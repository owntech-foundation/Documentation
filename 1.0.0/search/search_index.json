{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Matlab/docs/closed_loop_buck/","title":"Closed loop buck","text":"<p>After the open-loop mode, the aim of this tutorial is to show you how you can implement a buck voltage control using simulink and owntech library.</p> <p>You can delete all the data store variable related to the duty_cycle that we have created in the open loop section. Enter inside the block closed_loop_task, and with the association of the block \u201cconstant\u201d, \u201csum\u201d and \u201cdiscrete PID controller\u201d from the simulink library, <code>set leg duty</code> and <code>get data</code> from owntech library you can create the following schema :</p> <p></p> <p>We are fixing the output voltage to 15 volt, as for the PI paramters you should have the same as below\u00a0:</p> <p> </p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code\u00a0:</p> <p></p> <p>When enabling the matlab_mode, the output voltage will be fixed to 15V.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/","title":"First compilation with matlab","text":""},{"location":"Matlab/docs/first_compilation_with_matlab/#owntech-blocksets","title":"Owntech blocksets","text":"<p>There is a set of simulinks blocks ready to be used, to install it first clone this repository and checkout to the branch Ownblock_library_V3. In a console use the commands : </p> <pre><code>git clone https://gitlab.laas.fr/owntech/owntech-matlab.git\ngit checkout Ownblock_library_V3\n</code></pre> <p></p> <p>In the folder where the repository is cloned, you will find a file with the extension .mtltbx which is a matlab toolbox. There are multiple toolbox, choose the one correspondings to your OS and open it with matlab (in matlab press <code>ctrl+o</code> then open the chosen file), and the toolbox will be installed automatically.</p> <p>After the installation you can check that the library has been correctly installed. In simuinks \"Library Brower\" you can see if Owntech Library is present.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#simulink-template","title":"Simulink template","text":"<p>Still in the folder where we cloned the repository checkout to the branch matlab_zephyrV3 :</p> <pre><code>git checkout matlab_zephyrV3\n</code></pre> Resulting folder file structure<pre><code>\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 matlab_file\n\u251c\u2500\u2500 owntech\n\u251c\u2500\u2500 platformio.ini\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 zephyr\n</code></pre> <p></p> <p>Make sure that your working directory in matlab is the folder <code>matlab_file</code>. Browse for the folder in matlab.</p> <p>In matlab_file, there is a simulink file (owntech_template.slx) already set to be used for code generation. Open it and let\u2019s take a look at what is inside :</p> <p></p> <p>Let's see how each of this blocks work, starting by the initialize block.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#initialize-block","title":"Initialize block","text":"<p>This block will generate the initialization step for the hardware and software configuration. You can choose the convention for the legs (buck, boost) and the version of the board.</p> <p></p> <p>You can left it as it is to continue with the default value. </p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#increasedecrease-functions-and-pwr_enable-state","title":"Increase/decrease functions and pwr_enable state","text":"The application task and the control loop  <p>Inside the simulink file, we can see two functions that you can use to increment or decrement variables that you have defined. We will see how to use them later in another section of this tutorial. You can also notice that there is a variable pwr_enable, the state of this variable is used to activate or deactivate the PWM command of the converters.</p> <p></p> <p>We have two blocks here, we will focus on them to generate our code. The first one is the application_loop_task which works at a period of 100ms. Currently it is empty, but it will allow us later to define voltage reference and duty cycle here. </p> <p></p> <p>On the other hand the control_loop_task is faster, and works at 10kHz. We will typically use this block for all the critical tasks (sending the pwm command, PID implementation..). For now, the control_loop blocks contains a block called Interleaved_ON and depending on the value of pwr_enable, this block is supposed to activate the converter drivers. This block is currently commented to not activate the converter, we will uncomment it later on this tutorial.  </p> <p>This concludes the presentation of the simulink template, before generating any code we will need to make some configuration with the serial monitor to visualize data and also send commands.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#serial-monitor-setting","title":"Serial monitor setting","text":"<p>If you check the main file (main.cpp) in the src folder, you will notice that we have essentially two modes :</p> <pre><code>enum serial_interface_menu_mode //LIST OF POSSIBLE MODES FOR THE OWNTECH CONVERTER\n{\n    IDLEMODE =0,\n    MATLABMODE\n};\n</code></pre> <p>The idle mode will turn off the PWM signal sent to the converters, while the matlab mode will execute the generated code. If you look at the loop_communication_task inside the main file, you will see all the commands needed to activate either the idle mode or the matlab mode, but also to use the increase <code>Up_function()</code> and decrease <code>Dwn_function()</code> functions defined in the simulink template. For example, if we send \u201cm\u201d to the serial monitor, we will switch to the matlab mode.</p> different modes and command to send<pre><code>void loop_communication_task()\n{\n    while(1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n            case 'h':\n                //----------SERIAL INTERFACE MENU-----------------------\n                printk(\" ________________________________________\\n\");\n                printk(\"|     Communication task Tutorial        |\\n\");\n                printk(\"|     ------- MENU ---------             |\\n\");\n                printk(\"|     press i : idle mode                |\\n\");\n                printk(\"|     press m : matlab generated code    |\\n\");\n                printk(\"|     press u : increment variable       |\\n\");\n                printk(\"|     press d : decrement variable       |\\n\");\n                printk(\"|________________________________________|\\n\\n\");\n                //------------------------------------------------------\n                break;\n            case 'i':\n                printk(\"idle mode\\n\");\n                mode = IDLEMODE;\n                break;\n            case 'm':\n                printk(\"Matlab generated code\\n\");\n                mode = MATLABMODE;\n                break;\n            case 'u':\n                printk(\"increase!\\n\");\n                Up_function();\n                break; \n            case 'd':\n                printk(\"decrease!\\n\");\n                Dwn_function();\n                break;    \n            default:\n                break;\n        }\n    }\n}\n</code></pre> <p>We will use ownplot as a serial monitor, go to this github page.</p> <p>Then click on release :</p> <p></p> <p>Depending on your OS, choose the correspondig binary file and download it : </p> <p></p> <p>Execute the binary file to launch ownplot, start it and open the \u201csend\u201d tab. First we will set the commands.</p> <p></p> <p>In (1) enter the command\u2019s name (eg: decrease), in (2) the data associated to this command that we will send and finally press (3) to save the command. Repeat this process three time for the other command (idle-i, matlab_mode-m and increase-i).</p> <p></p> <p>In the \u201csetting\u201d tab, check that you have the same parameters.</p> <p></p> <p>With the serial monitor we can visualize current and voltage from the sensor, in the \u201cchart\u201d tab rename the dataset to have the following names in exactly the same order</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#adding-platformio-command-to-the-system-path","title":"Adding platformIO command to the system path","text":"<p>This process depends on your OS: </p> WindowsLinux <p>It is necessary to add C:\\Users\\ user \\.platformio\\penv\\Scripts (user is your user name on the computer) to your system path. We recommend that you follow this guide.</p> <p>You can call this command from matlab command window: <code>setenv(\"PATH\",[getenv(\"PATH\"),':/home/username/.platformio/penv/bin'])</code> Where home is your home directory and username is your user name. If your platformio is installed somewhere else, please change this path.</p> <p>You are now all set to generate your first code !</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#how-to-generate","title":"How to generate","text":"<p>We can try to compile and flash the board with this empty template to make sure that embedded coder work. </p> <p>Go to the app tab and then select Embedded Coder :</p> <p> </p> <p></p> <p>After the code generation, matlab will automatically flash the code to the board. If everything went well, you should see this window appears :</p> <p>If not, make sure that your current working directory is matlab_files, that the board is turned on and connected to your computer or that you have added \u201cC:\\Users\\user.platformio\\penv\\Scripts\u201d to the system path.</p>"},{"location":"Matlab/docs/getting_started/","title":"Gettings started with matlab","text":"<p>Matlab with the Embedded Coder add-on, is employed in the embedded field to generate code directly from Simulink blocksets. By integrating Owntech APIs as blocksets, the Embedded Coder allows you to accelerate the code generation process from your Simulink designs.</p> <p> Image : Example of implementation of PID with Owntech Blockset in Simulink</p> <p>Owntech blocksets might be useful for you if:</p> <ul> <li>You work in fields like research and development, simulation, or other areas where Matlab/Simulink is used regularly.</li> <li>You are interested in quickly generating and deploying code using Simulink blocksets and the Embedded Coder add-on.</li> </ul> <p>Tip</p> <p>It is not required, but you can try to follow first this tutorial to become familiar with owntech hardware and software.</p> <p>Abstract</p> <ul> <li>A TWIST power board</li> <li>A 50V power supply</li> <li>A resistive load (like an electronic load, or a variable resistive load)</li> </ul> <p>Abstract</p> <ul> <li>Matlab-Simulink</li> <li>Embedded coder toolbox</li> <li>Visual Studio Code with PlatformIO</li> </ul>"},{"location":"Matlab/docs/open_loop_buck/","title":"Open loop buck control","text":"<p>This section of the tutorial will show you how you can generate a code to control the converter in open-loop mode with the simulink template.</p> <p></p> <p>First let\u2019s start by creating a variable which will represents the duty cycle. Take a \u201cdata store memory\u201d block from simulink, to the root (where pwr_enable is located).</p> <p></p> <p>Name this data store block duty_cycle, and in the signal attribute tab choose the initial value (0.5 here to have 50% duty cycle) and data type (double or float):</p> <p></p> <p></p> <p>Then enter inside the increase function block, take a \u201cdata store read\u201d and a \u201cdata store write\u201d from simulink library and link them with duty_cycle (name them duty_cycle). With the association of the \u201cconstant\u201d and \u201cadd\u201d block from simulink you can form the following schema.</p> <p></p> <p>You can do the same thing in the decrease function block, instead of an addition it will be a subtraction.</p> <p>You have now the possibility to control the duty_cycle either by increasing or decreasing it, the only thing missing is sending this value to the converters. Inside control_loop_task, we will first uncomment the <code>POWER_ON</code> to activate power : click on the block then press ctrl+shift+x. We will then place a \u201cdata store read\u201d block linked to duty_cycle and a <code>set leg duty</code> block connected together.</p> <p></p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code, use increase and decrease function to control the duty cycle\u00a0:</p> <p></p>"},{"location":"OwnModels/","title":"OwnModels","text":"<p>Repository that gathers all models of the OwnTech foundation.</p>"},{"location":"OwnModels/docs/first_example/","title":"First model example with PLECS","text":"<p>This page shows how to run your first example of a PLECS based OwnTech model.</p>"},{"location":"OwnModels/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> </ul>"},{"location":"OwnModels/docs/first_example/#running-the-open-loop-model-for-the-first-time","title":"Running the open loop model for the first time","text":"<p>We have developed a first model that you can run out-of-the-box. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Open loop folder. Choose the Twist_open_loop.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. At 1 milisecond, the Twist board starts to operate and voltage goes up to around half of the generator voltage, as expected for a 50% duty cycle setup.</p>"},{"location":"OwnModels/docs/first_example/#analyzing-the-model-a-little-further","title":"Analyzing the model a little further","text":"<p>The open loop model will allow you to explore how the twist board operates.</p> <p>The model input is a standard voltage source with an inductive impedence and a bus capacitor.</p> <p>The output is a 1 Ohm resistor.</p> <p>You are now able to run simulations. The next step is to run closed loop simulations using this model.</p>"},{"location":"OwnModels/docs/getting_started/","title":"Gettings started with PLECS","text":"<p>PLECS is a software tool for system-level simualtions of electrical circuits developed by Plexim. It is not open-source, but it remains very accessible, which is a reason why we adopted it as one of the solutions to model our power converters. In this section we will explain to you how to get started with PLECS and run your first simulation.</p>"},{"location":"OwnModels/docs/getting_started/#installing-plecs","title":"Installing PLECS","text":"<p>To install PLECS, go to their website and download the standalone package. Choose your platform and follow the instructions.</p> <p>PLECS LICENSE</p> <p>There are three ways where you can use PLECS. Choose the one of your convenience.</p> Trial licenseDemo modeJCGE 2024 special license <p>PLECS provides a 90 days trial license for its products. Follow their dedicated page to get yours.</p> <p>If you do not want to ask for a license, you can still use PLECS in its demo mode. You will still be able to run the simulations, but you will not be able to modify the model or save its data.</p> <p>During the JCGE 2024 conference we will provide you with a special license that you can get with by clicking here.</p> <p>This License will expire on June 23rd 2024.</p> <p>Once PLECS is installed, you will see its library browser. You are now ready to start working with OwnModels.</p> <p></p>"},{"location":"OwnModels/docs/getting_started/#getting-the-ownmodels-plecs-library","title":"Getting the OwnModels PLECS library","text":"<p>This section will show you how to add the OwnTech library to your PLECS instance.</p> <p>Step 1 - Go to the OwnModels repository of the owntech foundation github. Either clone it locally (if you know how to use git) or download the zip file.</p> <p></p> <p>Step 2 - Unzip the file if you use zip. Keep the path at hand.</p> <p>Step 3 - In PLECS Library Browser go to File-&gt;PLECS Preferences</p> <p></p> <p>Step 4 - In PLECS Preferences click on the Libraries tab. You will see two sub blocks, search path and user libraries.</p> <p></p> <p>Step 5 - In Libraries-&gt;Search path click on the + icon and navigate to the owntech-lib folder. Click on Choose.</p> <p></p> <p></p> <p>Step 7 - In Libraries-&gt;User libraries click on the + icon and navigate to the Owntech_lib.plecs file. Click on Open.</p> <p></p> <p></p> <p>Step 8 - Rename the library name from User Library 1 to OwnTech. Click on Apply and Ok to finish.</p> <p></p> <p></p> <p>Step 9 - Verify that the library is correctly added to the Library Browser.</p> <p></p> <p>You are now ready to run your first PLECS example.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/","title":"Voltage mode simulaton","text":"<p>This page shows how to run a closed loop voltage mode PLECS based OwnTech simulation.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> <li>Successfully Run an open-loop simulation.</li> </ul>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model","title":"Running the closed loop model","text":"<p>The closed loop model is much similar to its open-loop equivalent. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then steadly rises to track its reference of 15 volts.</p> <p>Speed</p> <p>You will notice that this simulation is significantly slower than the open-loop. This is normal as the model used was a switched one. These models are precise, requiring longer to run.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model-averaged-version","title":"Running the closed loop model - AVERAGED version","text":"<p>We will now run the averaged version of the closed loop voltage mode model. The idea here is to show you how a less precise model is much faster.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck_AVG.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then rises to track its reference of 15 volts.</p> <p>Speed</p> <p>Notice how much faster this model is. Using averaged models allows for much faster iteration and study of the system in steady-state conditions. It can also be used whenever the study is much more focused on system-level behavior rather than switching.</p> <p>You are now ready to start working on a droop control example.</p>"},{"location":"OwnPlot/","title":"OwnPlot","text":"<p>OwnPlot is a free and opensource data plotter software designed to work with OwnTech's dev board. </p> <p>However, everybody can use this software as a data plotter with any devboard.</p>"},{"location":"OwnPlot/#why-create-another-plotting-app-from-scratch","title":"Why create another plotting app from scratch","text":"<p>After testing the most popular plotting app, we realized that it was not an easy task to run the app on all systems without tweaking. We also want to add power electronics-specific features in the near future. We are glad to present an easy-to-use and painless installation app.</p> <p>And most of all, it's free! Happy plotting \ud83d\ude01</p>"},{"location":"OwnPlot/#how-to-use-it","title":"How to use it","text":"<p>Go to the settings tab to specify the data format that your devboard is sending. Then select the right port and open it. You can pause both chart and terminal with the top right button. Once you are done, you can close the port (it will close when you close the app anyway).</p> <p>You can custom the chart layout under chart tab. Click on a channel in the legend to change its layout.</p> <p>A record feature is also available. You have to click play under the record tab. Do not forget to download the file !</p> <p>Send command to your devboard through the command tab ! You can add buttons if you have to send the same data regularly.</p>"},{"location":"OwnPlot/#running-the-development-environment","title":"Running the development environment","text":"<p>First of all, open the terminal of your choice. If you are using Windows, we recommand the use of git bash https://www.git-scm.com/downloads</p> <ol> <li> <p>type: \\     <code>node --version</code></p> <ul> <li>If the command prompt tells you node isn't present on your computer, then download and install nodejs thru this website:     https://nodejs.org/en/download/</li> <li>If the version is inferior than version 14.x.x then you'll need to update nodejs. <code>nvm</code> is a great little piece of kit that will make your life a lot easier   https://github.com/nvm-sh/nvm</li> </ul> <p>Note: version <code>18.7.0</code> is recommanded</p> </li> <li> <p>Clone the repository:</p> <ul> <li> <p>If you have a gitlab accound and a ssh key linked to this one, clone with this command instead: \\ <code>git clone git@gitlab.laas.fr:owntech/ownplot.git</code></p> </li> <li> <p>Otherwise use this command: \\ <code>git clone https://gitlab.laas.fr/owntech/ownplot.git</code></p> </li> </ul> </li> <li> <p>Go the the newly created folder: \\ <code>cd ownplot</code></p> </li> <li> <p>Install the decencies: \\ <code>npm install</code></p> </li> <li> <p>Run the development environment: \\ <code>npm start</code></p> </li> </ol> <p>Congrats! \ud83e\udd73 \\ A window should be opened with OwnPlot.</p> <p>If you are experiencing problems during the install, please post an issue and report the problem. This will greatly help us improve the user experience.</p>"},{"location":"OwnPlot/#build-for-your-plateform","title":"Build for your plateform","text":"<p>Run  - <code>npm run pack-win</code> for the <code>.exe</code> installer - <code>npm run pack-linux</code> for the <code>.deb</code>, <code>.rpm</code> and <code>.AppImage</code> - <code>npm run pack-mac-uni</code> for the <code>.dmg</code></p> <p>Note: Only a mac can build all the plateforms.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [owntech@laas.fr]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"OwnPlot/CONTRIBUTE/","title":"Contribute to OwnPlot","text":"<p>Welcome ! Thank you for your interest in OwnPlot. We would greatly appreciate your involvement in the project if you wish.</p> <p>You will find in this file some informations to guide you through the contributing process.</p>"},{"location":"OwnPlot/CONTRIBUTE/#summary","title":"Summary","text":"<ul> <li>Community guidelines</li> <li>Bug Report</li> <li>Suggest Feature</li> <li>Contribute to the code base</li> <li>Contact for further questions</li> </ul>"},{"location":"OwnPlot/CONTRIBUTE/#community-guidelines","title":"Community guidelines","text":"<p>Always be nice to other contributors. Be constructive and understanding when interacting with someone. Read and then follow the Code of Conduct at all times.</p>"},{"location":"OwnPlot/CONTRIBUTE/#bug-report","title":"Bug Report","text":"<p>Please report bugs within the gitlab repository by creating a new issue. Use the bug issue template and try to be as descriptive as possible. Always check first if a similar issue already exists or has been closed.</p>"},{"location":"OwnPlot/CONTRIBUTE/#suggest-feature","title":"Suggest Feature","text":"<p>Feel free to make any suggestion that would improve the user experience. To do so, please use the feature issue template in the gitlab repository.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contribute-to-the-code-base","title":"Contribute to the code base","text":"<p>If you want to get involved further, you can write and modify the existing code base available at the gitlab OwnPlot repository. Your modifications should always be related to an issue. You can submit a feature/bug issue if no one answers your problematic. The code base is clearly not perfectly written so far. Code related improvements are welcomed if they make code easier to understand, more compact, faster to execute. A related issue template is available.</p>"},{"location":"OwnPlot/CONTRIBUTE/#coding-style","title":"Coding Style","text":"<p>Always try to make your code as readable as possible as other people will work on it. Names should be as descriptive as possible. Here is a guide that we try to follow when writing code, so please try to stick to it too. Do not worry if you do not achieve to write a perfect piece of code, just try to be clear about what you are trying to code. Comments are precious friends, but should not be redudant with explicit lines of code. Explicit naming should be your first concern. Other contributors can help you, do not hesitate to ask for help.</p>"},{"location":"OwnPlot/CONTRIBUTE/#submit-your-modifications","title":"Submit your modifications","text":"<p>Please begin with creating a branch, which name should be XXXX_nameOfTheBranch, considering XXXX as the number of the corresponding issue. Then add and commit changes everytime an improvement has been brought to the code, but always ensure that each commit is atomic (brings a full modification and is functionnal). Consider reading this page for a clear explanation of good practice in commits. Finally ask for a pull request that will be examined as soon as possible.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contact-for-further-questions","title":"Contact for further questions","text":"<p>OwnPlot is an open-source software created and maintained by the OwnTech Foundation. It is delivered with the GNU LGPL v2.1 Licence. An overview of our work is available at our website. Contact us at owntech@laas.fr, or join our Discord.</p> <p>Thank you for your involvement. See you soon !</p>"},{"location":"OwnPlot/LICENCE/","title":"Licence","text":"<p>OwnPlot, the OwnTech data plotter. Copyright (C) 2022 OwnTech Foundation.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p> <p>Contact the OwnTech Foundation by email at [owntech@laas.fr].</p> <p>Full licence is available at: https://opensource.org/licenses/LGPL-2.1.</p>"},{"location":"OwnPlot/docs/","title":"Index","text":""},{"location":"OwnPlot/docs/#welcome-to-ownplot","title":"Welcome to OwnPlot!","text":"<p>This documentation will help you use and develop for OwnPlot.</p> OwnPlot is a Free and OpenSource plotter written in Electron"},{"location":"OwnPlot/docs/#documentation","title":"Documentation","text":"<p>The documentation is split between the User Manual and the Developer Manual</p> <p> User Manual</p> <p> Dev Manual</p>"},{"location":"OwnPlot/docs/#user-manual","title":"User Manual","text":"<p>The User Manual will guide you through all of OwnPlot's features.</p>"},{"location":"OwnPlot/docs/#developer-manual","title":"Developer Manual","text":"<p>The Dev Manual will help you understand the architecture and will permit you to add features and contribute to OwnPlot's development.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/","title":"Files description","text":""},{"location":"OwnPlot/docs/dev-manual/arch/#main-files","title":"Main files","text":"<p>These files are located at the root of the repo. - main.js Program Starting Point. This file sets up the windows as well as default configurations.  This also loads user configuration. This file will render index.ejs - index.ejs The main skeleton of OwnPlot. This file includes other .ejs files present in the template folder</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files","title":"Template files","text":"<p>Files used to describe skeletons of the different parts of OwnPlot. - header.ejs This file includes stylesheets and some scripts. description needed - navBar.ejs The navigation hub of OwnPlot. This file permits to change the main view. screenshot of the navbar. - portBar.ejs description needed - tabs.ejs description needed - apps.ejs description needed - myTerminal.ejs description needed - footer.ejs Closing the HTML tag.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files_1","title":"Template files","text":""},{"location":"OwnPlot/docs/dev-manual/home/","title":"Development Manual","text":""},{"location":"OwnPlot/docs/dev-manual/home/#setting-up-a-dev-environment","title":"Setting up a dev environment","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#dev-board-demo-code","title":"Dev board demo code","text":"<p>In order to transmit data to OwnPlot, your device must send data through a serial port. This serial port on dev boards is in most cases USB based.</p> <p>This page will provide you with sample codes that will make those dev boards \"talk\" in the serial port.</p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#sawtooth-demo-code","title":"Sawtooth demo code","text":"<p>This code will generate sawteeth with ASCII formatting.</p> <p>You can change the number of datasets by modifying the <code>#define numberOfTriangles 3</code> statement. The default value is 3.</p>  SPIN Arduino <p>Info</p> <p>If you need to familiarize yourself with OwnTech's SDK, please start here</p> <pre><code>#include \"TaskAPI.h\"\n#include \"SpinAPI.h\"\n#include \"zephyr/console/console.h\"\n\nvoid setup_routine();\nvoid loop_communication_task();\nvoid initTriangles();\nint main();\n\n#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nuint8_t received_serial_char;\nuint8_t state = 1;\n\nvoid setup_routine() {\n    spin.version.setBoardVersion(SPIN_v_1_0);\n    uint32_t com_task_number = task.createBackground(loop_communication_task);\n    task.startBackground(com_task_number);\n}\n\nvoid loop_communication_task()\n{\n    while (1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n        case 's':\n            state ^= 1;\n            break;\n        default:\n            break;\n        }\n        k_msleep(100);\n    }\n}\n\nvoid initTriangles() {\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nint main() {\n    setup_routine();\n    initTriangles();\n    while (1) {\n        if (state) {\n            for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n                printk(\"%d:\", triangles[i]);\n            }\n            printk(\"%d\\n\", triangles[numberOfTriangles - 1]);\n            for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n                triangles[i] = triangles[i] + numberPoints;\n            }\n        }\n        k_msleep(50);\n    }\n    return 0;\n}\n</code></pre> <p>Here is the demo code. Tested on an Arduino Uno and Mega. <pre><code>#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nint incomingByte;\nuint8_t state = 1;\n\nvoid setup() {\n    Serial.begin(115200);\n    initTriangles();\n}\n\nvoid initTriangles() {\nfor (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n    triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nvoid loop() {\nincomingByte = Serial.read();\nif (incomingByte &gt; 0) {\n    if (incomingByte == 's') {\n        state ^= 1;\n    }\n}\nif (state) {\n    for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n        Serial.print(triangles[i]);\n        Serial.print(\":\");\n    }\n    Serial.println(triangles[numberOfTriangles - 1]);\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = triangles[i] + numberPoints;\n    }\n}\ndelay(100);\n}\n</code></pre></p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#result","title":"Result","text":"<p>In either case, you will get the same sawteeth in OwnPlot. To open the port, please refer to this page.</p>"},{"location":"OwnPlot/docs/user-manual/first-steps/","title":"My First Port","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#first-steps","title":"First Steps","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#open-a-port","title":"Open a port","text":"<ol> <li>Select the send tab (This will spawn the graph)</li> <li>Plug in a SPIN or an Arduino talking on the serial port. if you want to test this, sample programs will be available later.</li> <li> <p>Select the corresponding serial port in the port dropdown</p>  Windows macOS Linux <p>The port will start with COM TODO: PIC { width=\"300\" }</p> <p>The port will most likely start with /dev/tty.usbserial but your mileage may vary. </p> <p>The port will most likely start with /dev/tty.usb but your mileage may vary. TODO: PIC { width=\"300\" }</p> </li> <li> <p>Open the port by clicking the \"Open\" button</p> <p></p> </li> <li> <p>You should observe the data coming from the serial port in the terminal and data points should appear on the graph.</p> <p></p> </li> </ol> <p>Troubleshooting</p> <ul> <li>if you have trouble seeing the desired port, check out the troubleshooting guide</li> </ul>"},{"location":"OwnPlot/docs/user-manual/home/","title":"Home","text":""},{"location":"OwnPlot/docs/user-manual/home/#user-manual","title":"User Manual","text":"<p>Welcome to the OwnPlot's user manual. This documentation will help you familiarize yourself with OwnPlot and understand all its features. If you find a mistake or a malfunction of OwnPlot, please report the issue Here .</p>"},{"location":"OwnPlot/docs/user-manual/home/#start-here","title":"Start Here","text":"<p>If you are a new user of OwnPlot, please start here.</p>"},{"location":"OwnPlot/docs/user-manual/home/#download-setup","title":"Download &amp; Setup","text":""},{"location":"OwnPlot/docs/user-manual/home/#dev-board-demo-code","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/home/#my-first-port","title":"My first port","text":""},{"location":"OwnPlot/docs/user-manual/home/#components","title":"Components","text":""},{"location":"OwnPlot/docs/user-manual/home/#tabs","title":"Tabs","text":""},{"location":"OwnPlot/docs/user-manual/home/#terminal","title":"Terminal","text":""},{"location":"OwnPlot/docs/user-manual/home/#plotter","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/setup/","title":"Setup","text":""},{"location":"OwnPlot/docs/user-manual/setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"OwnPlot/docs/user-manual/setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p> <p>Great! Now that you have OwnPlot installed and all setup, we can proceed to your first steps with OwnPlot.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/","title":"Troubleshooting","text":""},{"location":"OwnPlot/docs/user-manual/troubleshooting/#port-finding","title":"Port finding","text":"<p>If you can't see the port you are looking for, try to unplug and plug in the dev board to another port. You can try to reflash the sample program.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#antivirus","title":"Antivirus","text":"<p>It has been reported that some antivirus like Norton Antivirus can cause problems while downloading OwnPlot. If you have trouble downloading OwnPlot, please disable or trust the executable file.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#empty-canvas","title":"Empty canvas","text":"<p>By default, no activities are loaded into OwnPlot (this might change in the future). Select any tab like the send tab to load the graph and terminal</p>"},{"location":"OwnPlot/docs/user-manual/Components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/Components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/Components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"OwnPlot/docs/user-manual/components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"bootloader/docs/getting_started/","title":"Bootloader","text":"<p>OwnTech use its own bootloader in order to be able to flash code using USB without the use of a dedicated debug tool.  It is based on MCUBoot an open source bootloader supported by the zephyr ecosystem. </p>"},{"location":"bootloader/docs/getting_started/#features","title":"Features","text":"<ul> <li>USB compatible</li> <li>Supports Over The Air (OTA) updates</li> <li>Image validation </li> <li>Encryption ready</li> </ul>"},{"location":"bootloader/docs/getting_started/#boot-sequence","title":"Boot sequence","text":"<p>When pressing reset button the following happens : </p> <ul> <li>Program initiates at 0x80000000, and bootloader is launched.</li> <li>Bootloader jumps at Image-0 address at 0x8010000.</li> </ul>"},{"location":"bootloader/docs/getting_started/#nomal-upload-sequence","title":"Nomal Upload sequence","text":"<p>When pressing upload button the following happens : </p> <p></p> <ul> <li>Image-1 is the memory bank where the program is uploaded using USB or via STLink</li> <li>When the USB transfer is complete, a reboot order is sent to the board. </li> </ul> <ul> <li>Image is marked for testing</li> <li>A memory swap is performed. Image-1 is sent to memory bank 0 at the address 0x8010000 and Image-0 is sent to memory bank 1 at the address 0x8047800. </li> <li>A boot test is performed.</li> <li>If the initialization is successful, the new program is marked as good and stays in image-0.</li> <li>Otherwise, the image is rejected and the swap action is reverted. </li> <li>After that, application code is executed normally from address 0x8010000</li> </ul> <p>Note</p> <p>This bootloading sequence is complex but has advantages. If your program has an issue during initialization, the bootloader will detect it and will reject the     image. </p> <p>After a Reset, the previous working program will be launched, recovering the board from a non functional program that would have otherwise bricked it.</p> <p>Warning</p> <p>Image swapping requires having a valid image at address 0x8010000. </p> <p>If no image-0 is present normal upload sequence will fail. </p> <p>If you observe serial messages using an STlink, you will receive a message like below </p> Serial Port<pre><code>*** Booting Zephyr OS build zephyr-v3.5.0 ***\nI: Starting bootloader\nI: Primary image: magic=good, swap_type=0x1, copy_done=0x3, image_ok=0x3\nI: Secondary image: magic=good, swap_type=0x1, copy_done=0x3, image_ok=0x3\nI: Boot source: none\nW: Failed reading image headers; Image=0\n</code></pre> <p>Tip</p> <p>In that case use Recovery Mode to upload a valid Image-0 and proceed again.</p>"},{"location":"bootloader/docs/getting_started/#recovery-mode","title":"Recovery Mode","text":"<p>The OwnTech bootloader has a recovery mode in order to flash directly the Image-0 without performing a swap action. This mode is really helpfull to recover the board when something went wrong.</p> <p>Tip</p> <p>To enter recovery mode, press BOOT button and RESET button simultaneously.  </p> <p>Success</p> <p>When entering recovery mode, the user LED should light up</p> <p>When pressing the upload button in recovery mode the following happens : </p> <p></p> <ul> <li>User program is written at the address 0x8010000 directly. </li> <li>A reboot is performed and the bootloader jumps to user code at address 0x8010000.</li> </ul> <p>Note</p> <p>Recovery mode is significantly slower than Normal Upload Sequence.</p>"},{"location":"bootloader/docs/getting_started/#how-it-works","title":"How it works","text":"<p>USB upload uses what is called a magic baudrate callback. When pressing the upload button:  </p> <ul> <li>The user code is compiled, creating a bin executable.</li> <li>A trailer containing meta-data is added to the bin file, and the executable is marked for testing.  </li> <li>The USB serial disconnects and reconnects using the magic 1200Baud baudrate. </li> <li>That baudrate is detected and it triggers a reboot order to switch in bootloader mode.</li> <li>On the computer side, a small program called MCUMgr is called to upload the user code image to the microcontroller (it is located in owntech/third_party/mcumgr - if it is not present, it will be downloaded automatically.)</li> <li>When upload is finished, a reboot order is sent</li> <li>Bootloader starts and detects the new image trailer marked for testing.</li> <li>Bootloader performs the swap action</li> <li>Bootloader jumps to user application at address 0x8010000 and USB serial is available again.</li> </ul>"},{"location":"controlLibrary/","title":"control_library","text":"<p>Control and dsp algorithms for owntech converters</p> <p>This library has been integrated and tested on TWIST converters using SPIN controller.</p> <p>The integration is based on the dedicated OwnTech Power API.</p> <p>Remarks: The library is currently not optimized to make it easier to read (we hope).</p>"},{"location":"controlLibrary/#features","title":"Features","text":"<p>The library provides the following functionalities mainly through C++ objects :  * <code>Pid()</code>: Standard form of the PID regulator.  * <code>Pr()</code>: Proportional Resonant regulator.  * <code>Rst()</code>: Discrete form of Polynomial regulator.  * <code>PllSinus()</code>: Software PLL (Phased Lock Loop)  * Digital filters: <code>LowPassFirstOrdreFilter()</code>, <code>NotchFilter()</code></p> <p><code>Pid()</code>, <code>Pr()</code> and <code>Rst()</code> inherit from the <code>Controller()</code> class which define the same interface.</p>"},{"location":"controlLibrary/#installation","title":"Installation","text":"<p>We describe here the process to use it with the Power API which has been designed to use PlatformIO.</p> <p>The installation here recall the procedure of using a library in PlatformIO.</p> <p>To use the library, you need to add the line above in the <code>platformio.ini</code> file.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>You can find various examples in the OwnTech examples library </p>"},{"location":"controlLibrary/#links","title":"Links:","text":"<p>Links which inspired this work:</p> <ul> <li>PID:</li> <li>K. Astrom et T. Hagglund, Advanced PID Control.</li> <li>PR:</li> <li>A. G\u00ef, \u00ab\u00a0Digital Resonant Current Controllers For Voltage Source Converters\u00a0\u00bb. Thesis</li> <li>RST:</li> <li>I. D. Landau, C. Cyrot, A. Voda, et D. Rey, \u00ab\u00a0Robust digital control of flexible structures using the combined pole placement/sensitivity function shaping method\u00a0\u00bb, in Proceedings of 1994 American Control Conference - ACC \u201994, Baltimore, MD, USA: IEEE, 1994, p. 283\u2011288. doi: 10.1109/ACC.1994.751743.</li> <li>I. D. Landau et G. Zito, \u00ab\u00a0Digital Control Systems - New edition (I. D. Landau &amp; G. Zito)\u00a0\u00bb, 2020, doi: 10.13140/RG.2.2.19321.49764.</li> <li>PLL:</li> <li>F. D. Freijedo, J. Doval-Gandoy, O. Lopez, et J. Cabaleiro, \u00ab\u00a0Robust phase locked loops optimized for DSP implementation in power quality applications\u00a0\u00bb, in 2008 34th Annual Conference of IEEE Industrial Electronics, Orlando, FL: IEEE, nov. 2008, p. 3052\u20113057. doi: 10.1109/IECON.2008.4758447.</li> </ul>"},{"location":"controlLibrary/#thanks","title":"Thanks","text":"<p>Thanks to the OwnTech contributors:</p> <ul> <li>Luiz</li> <li>Ayoub</li> <li>Guillaume</li> <li>Jean</li> <li>Clement</li> </ul>"},{"location":"controlLibrary/docs/controller/","title":"Controller","text":"<p><code>Controller</code> is an abstract class.</p> <p>The main idea is to fix the interface of a <code>controller</code>.</p> <p>Each type of controller like <code>Pid</code>, <code>RST</code> and <code>Pr</code> have then the same way of life.</p> <p>It has been thinking considering SISO (Single Input Single Output) and sample controller.</p> <p>If you want to implement a new controller type, you should consider to inherit from this class.</p>"},{"location":"controlLibrary/docs/getting-started/","title":"Getting started","text":"<p>Control library has been written in c++, the library is a set of object you can instanciate. </p> <p>Each <code>Controller</code> is in a different file (<code>pid.cpp, rst.cpp, pr.cpp</code>).</p> <p>It has mainly been developped to be used with  The OwnTech Power API based on Zephyr and integrated with PlatformIO.</p>"},{"location":"controlLibrary/docs/getting-started/#installation","title":"Installation","text":"<p>Control library has been designed to be integrated as a PlatformIO library.</p> <p>To use it, you need to add the line below in the <code>platformio.ini</code> file.</p> <p>platformio.ini</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"controlLibrary/docs/getting-started/#using-the-pid-controller","title":"Using the <code>Pid()</code> <code>Controller</code>.","text":"<p>To introduce the control library, we propose to implement a PID regulator.</p> <p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-filters/","title":"Filters module.","text":"<p>In the filters module <code>filters.h</code> there's multiple digital filter.</p> <ul> <li> <p>First Order Low Pass filter</p> <p></p> <p> LowPassFirstOrder</p> </li> <li> <p>Notch Filter</p> <p> </p> <p> Notch filter</p> </li> <li> <p>Phase Locked Loop</p> <p></p> <p> PllSinus</p> </li> </ul>"},{"location":"controlLibrary/docs/use-fir/","title":"Use <code>Fir</code> object.","text":""},{"location":"controlLibrary/docs/use-firstorder/","title":"Use First Order Low Pass Filter","text":""},{"location":"controlLibrary/docs/use-firstorder/#introduction","title":"Introduction.","text":""},{"location":"controlLibrary/docs/use-firstorder/#parameters","title":"Parameters","text":"<p>Here, the transfer function representation of the first order filter (where \\(s\\) is the Laplace variable) :  </p> \\[H(s) = \\dfrac{1}{1+\\tau.s}\\] <p>Where:</p> <ul> <li>\\(\\tau\\) is the constant time in [s].</li> </ul> <p>transfer function is sampled</p> <p>We show here the continuous transfer function of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-firstorder/#discretization","title":"Discretization","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_1.z^{-1}}{1+a_1.z^{-1}} \\\\ \\\\ H(z) = \\dfrac{b_1}{z + a_1} \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> <p>We give here the recurrence equation used to filter the \\(\\text{input}\\) signal.</p> \\[  out_k = b_1 . \\text{in}_k - a_1 . out_{k-1} \\] <p>where:</p> \\[ \\begin{align} a_1 &amp;= -exp\\left(-\\dfrac{Ts}{\\tau}\\right) \\\\ \\\\ b_1 &amp;= 1 + a_1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-firstorder/#use","title":"Use.","text":"<p>3 steps to use the first order filter</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t tau = 1e-3;               // constant time\n    const float32_t Ts = 100e-6;              // sampling time\n    myfilter = LowPassFirstOrderFilter(Ts, tau);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-notchfilter/","title":"Use Notch Filter","text":""},{"location":"controlLibrary/docs/use-notchfilter/#introduction","title":"Introduction.","text":"<p>The notch filter allow to remove a band of frequencies from an input signal.</p> <p> </p>"},{"location":"controlLibrary/docs/use-notchfilter/#parameters","title":"Parameters.","text":"<p>Here, the transfer function representation of the notch filter:</p> \\[H(s) = \\dfrac{s^2 + (2 \\pi f_0)^2}{s^2 + 2 \\pi \\Delta f .s + (2 \\pi f_0)^2}\\] <p>Where:</p> <ul> <li> <p>\\(f_0\\) is the notch frequency,</p> </li> <li> <p>\\(\\Delta f\\) is the bandwidth of the filter.</p> </li> </ul>"},{"location":"controlLibrary/docs/use-notchfilter/#discretization","title":"Discretization.","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_0 + b_1.z^{-1} + b_2.z^{-2}}{ a_0 + a_1.z^{-1}+ a_2.z^{-2}} \\\\ \\\\ H(z) = \\dfrac{b_0.z^2 + b_1.z^{1} + b_2}{ a_0.z^2 + a_1.z^{1}+ a_2} \\\\ \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[ out_k = b_0 . in_k + b_1 . in_{k-1} + b_2 . in_{k-2} - a_1 . out_{k-1} - a_2 . out_{k-2}. \\] <p>Where:</p> \\[ \\begin{align} b_0 &amp;= \\dfrac{1}{1+ \\pi . \\Delta f . T_s} \\\\ \\\\ b_1 &amp;= -2 . b_0 .\\cos(2\\pi.f_0.T_s)  \\\\ \\\\ b_2 &amp;= b_0 \\\\ \\\\ a_1 &amp;= b_1 \\\\ \\\\ a_2 &amp;= 2 b_0 - 1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-notchfilter/#use-of-the-notchfilter-object","title":"Use of the <code>NotchFilter</code> object.","text":"<p>3 steps to use the notchfilter.</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t f0 = 50.0;               // notch frequency [Hz]\n    const float32_t bandwidth = 5.0;         // notch bandwidth [Hz]\n    const float32_t Ts = 100e-6;              // sampling time [s]\n    myfilter = NotchFilter(Ts, f0, bandwidth);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pid/","title":"PID <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-pid/#introduction","title":"Introduction.","text":"<p>The PID  <code>Controller</code> is implemented here in a Standard form.</p> bloc diagram of standard form of a continuous PID with filtered derivative"},{"location":"controlLibrary/docs/use-pid/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the PID.</p> \\[command = K_p . \\left( \\varepsilon + \\dfrac{1}{T_i.s} .  \\varepsilon + \\dfrac{T_d.s}{1 + \\frac{T_d}{N}.s}.\\varepsilon \\right)\\] <p>where:</p> <ul> <li>\\(K_p\\) is the proportionnal gain</li> <li>\\(T_i\\) is the integration time</li> <li>\\(T_d\\) is derivative time</li> <li>\\(N\\) help to filter the derivative (typical values \\(\\in [2, 20]\\)).</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pid/#discretization","title":"Discretization:","text":"<p>This <code>Pid()</code> object is implemented using a backward euler integration method.</p> <p>We have the following discrete equation implemented:</p> \\[  \\begin{align} \\epsilon_k &amp;=  y_{ref_{k}} - y_{meas_{k}} \\\\ \\\\  i_k &amp;= i_{k-1}  + T_s . \\epsilon_k \\\\ \\\\ d_k &amp;= \\dfrac{\\epsilon_k - \\epsilon_{k-1}}{T_s} \\\\ \\\\ f_{d_k} &amp;= (1 - e^{-T_s/\\tau}) . d_k  + e^{-T_s/\\tau} . f_{d_{k-1}} \\end{align} \\] \\[ u_k = K_p .\\left( \\epsilon_k +  \\dfrac{1}{T_i} . i_k + T_d . f_{d_k}\\right) \\]"},{"location":"controlLibrary/docs/use-pid/#use-of-the-pid-controller","title":"Use of the PID <code>Controller</code>.","text":"<p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pid/#example","title":"Example","text":"<p>You can find a pid use with the buck voltage mode example which regulates a DC voltage.</p>"},{"location":"controlLibrary/docs/use-pll/","title":"Use the software Phase Locked Loop.","text":""},{"location":"controlLibrary/docs/use-pll/#introduction","title":"Introduction","text":"<p>The <code>PllSinus</code> is used to track sinusoid and extract angle and pulsation. It is included in the <code>filters.cpp</code> module.</p> <p> block diagram of software phase locked loop <p></p>"},{"location":"controlLibrary/docs/use-pll/#parameters","title":"Parameters:","text":"<ul> <li>We set \\(f_0\\) the frequency of the signal to track linked with \\(\\omega_0=2.\\pi.f_0\\). </li> <li>\\(\\Delta \\omega\\) has been arbitrarily fixed to be 20% of \\(\\omega_0\\).</li> <li>\\(K_p, T_i\\) parameters are computed using the <code>rise_time</code> of the closed loop, which   fix the dynamic of the PLL and we have also to take into account of the <code>amplitude</code> of   the signal.</li> </ul>"},{"location":"controlLibrary/docs/use-pll/#use-of-the-pllsinus-filter","title":"Use of the <code>PllSinus</code> filter.","text":"<p>The use of the `PllSinus is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters declaration.2. Initialization.3. Execution. <p>We define constants used to initialize the parameter structure. <pre><code>#include \"filters.h\"\n\nstatic float32_t amplitude = 16.0F; // amplitude of the voltage sinus to track.\nstatic float32_t f0 = 50.0;               // frequency assumed of the signal to track [Hz]\nstatic float32_t rise_time = 50.e-3F;     // dynamic of the loop [s].\nstatic float32_t Ts = 100.0e-6F;          // sampling time [s]\n</code></pre></p> <p>We define the variable <code>pll</code> which is an instance of <code>PllSinus</code> object. <pre><code>static PllSinus pll;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>PllSinus</code> with its parameters.</p> <pre><code>pll.init(Ts, amplitude, f0, rise_time);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code></p> <pre><code>pll_datas = pll.calculateWithReturn(signal_to_track);\n</code></pre> <p><code>pll_datas</code> is a structure which kept the results of the PllSinus calculation for one step.</p> <p>the PllData structure has 3 fields: <pre><code>struct PllDatas {\n    float32_t w;     // estimated pulsation [rad/s]\n    float32_t angle; // estimated angle [rad]\n    float32_t error; // angle error [rad]\n};\n</code></pre></p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pll/#example","title":"Example","text":"<p>You can find a pll use with the grid following example which requires a synchronisation to inject current in parallel with a voltage source.</p>"},{"location":"controlLibrary/docs/use-pr/","title":"Proportionnal Resonant <code>Controller</code>","text":""},{"location":"controlLibrary/docs/use-pr/#introduction","title":"Introduction.","text":"<p>The Proportionnal Resonant <code>Controller</code> is dedicated to follow a sinusoidal reference.</p> <p>It is design to minimized phase shift and amplitude error.</p> Block diagram of Proportionnal Resonant controller <p>The \\(\\phi'\\) variable is dedicated to reduce delay generated by the calculation and the PWM.</p> Block diagram of Proportionnal Resonant controller including delay compensation"},{"location":"controlLibrary/docs/use-pr/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the Proportionnal resonant.</p> \\[Pr(s)=K_p + K_r \\dfrac{s \\cos(\\phi')-\\omega_0.\\sin(\\phi')}{s^2+w_0^2}\\] <p>Where:</p> <ul> <li>\\(\\omega_0\\)  is the pulsation in [rad/s]</li> <li>\\(\\phi'\\) is the compensation delay in [rad]</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pr/#discretization","title":"Discretization:","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} Pr(z^{-1}) = \\left(K_p + K_r . \\dfrac{b_0 + b_1.z^{-1}}{a_0+a_1.z^{-1}+ a_2.z^{-2}}\\right) \\\\ \\\\ Pr(z) = \\left(K_p + K_r . \\dfrac{b_0 .z^2 + b_1.z^1}{a_0.z^{2}+a_1.z^{1}+ a_2}\\right) \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[  \\begin{align} res_k &amp;= b_0.\\epsilon_k + b_1.\\epsilon_{k-1} - a_1.res_{k-1} - a_2.res_{k-2} \\\\ \\\\ u_k &amp;= K_p . \\epsilon_k + K_r .res_k \\end{align} \\] <p>With:</p> \\[ \\begin{align} a_1 &amp;= -2.\\cos(T_s . \\omega_0)\\\\ a_2 &amp;= 1.0\\\\ b_0 &amp;= T_s . \\cos(\\phi')\\\\ b_1 &amp;= -T_s . \\cos(\\phi' - T_s . \\omega_0)\\\\ \\end{align} \\]"},{"location":"controlLibrary/docs/use-pr/#use-of-the-proportionnal-resonant-controller","title":"Use of the Proportionnal Resonant <code>Controller</code>.","text":"<p>The use of the <code>Pr</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pr.h\"\n\nstatic float32_t Kp = 0.001F;\nstatic float32_t Kr = 300.0F;\nstatic float32_t w0 = 2 * PI * 50.0F;\nstatic float32_t phase_shift = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static  PrParams params = PrParams(Ts, Kp, Kr, w0, phase_shift, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>prop_res</code> which is a <code>Pr</code> object. <pre><code>static Pr prop_res;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pr</code> with its parameters.</p> <pre><code>prop_res.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Remind that the <code>loop_critical_task()</code> is called every 100\u00b5s.</p> <pre><code>new_command = prop_res.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pr calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pr/#example","title":"Example","text":"<p>You can find the use with a grid forming example which generate an AC voltage source.</p>"},{"location":"controlLibrary/docs/use-rst/","title":"Polynomial RST <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-rst/#introduction","title":"Introduction.","text":"<p>The polynomial R-S-T <code>Controller</code> is a two degree of freedom digital controller (allowing to fix a regulation dynamic uncoupling from the setting point dynamic). </p> <p>It allows to implement various digital filters in the measurement part (\\(R\\)) or in the integration part (\\(\\frac{1}{S}\\)).</p> <p> </p>"},{"location":"controlLibrary/docs/use-rst/#parameters","title":"Parameters:","text":"<p>Here the equation of the RST controller.</p> \\[S(q^{-1}).u = T(q^{-1}).y_{ref} - R(q^{-1}).y\\] <p>where:</p> <ul> <li> <p>\\(S(q^{-1}),\\ T(q^{-1})\\ \\text{and}\\ R(q^{-1})\\) are polynomial of delay operator \\(q^{-1}\\)</p> </li> <li> <p>\\(S(q^{-1}) = s_0 + s_1.q^{-1} + ... + s_{ns}.q^{-ns}\\)</p> </li> <li>\\(R(q^{-1}) = r_0 + r_1.q^{-1} + ... + r_{nr}.q^{-nr}\\)</li> <li>\\(T(q^{-1}) = t_0 + t_1.q^{-1} + ... + t_{nt}.q^{-nt}\\)</li> </ul>"},{"location":"controlLibrary/docs/use-rst/#use-of-the-rst-controller","title":"Use of the RST <code>Controller</code>.","text":"<p>The use of the `RST is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"rst.h\"\n\nconst uint8_t nr = 3;\nconst float R[] = { 0.8914, -1.1521, 0.3732 };\n\nconst uint8_t ns = 6;\nconst float S[] = { 0.2, 0.0852, -0.0134, -0.0045, -0.1785, -0.0888 };\n\nconst uint8_t nt = 3;\nconst float T[] = { 1.0, -1.3741, 0.4867 };\n\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\n\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static RstParams params = RstParams(Ts, nr, R, ns, S, nt, T, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>my_rst</code> which is a <code>Rst</code> object. <pre><code>static RST my_rst;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Rst</code> with its parameters.</p> <pre><code>my_rst.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = my_rst.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the rst calculation for one step.</p>"},{"location":"controlLibrary/docs/use-sogi/","title":"Use the SOGI PLL.","text":""},{"location":"controlLibrary/docs/use-sogi/#introduction","title":"Introduction","text":"<p>The Second Order Generalized Integrator based PLL <code>SOGI-PLL</code> is a filter used to retrieve phase information from a mono phase or three phased system. It is included in the <code>filters.cpp</code> module.</p> <p>Digital implementation of the SOGI PLL is done using the <code>impulse invariant</code>  using \\(R_{1h}\\) discretization method.</p> <p></p> block diagram of SOGI PLL <ul> <li><code>SOGI QSG</code> stands for Quadrature Signal Generator. It takes an input signal and output the signal in \\(\\alpha\\beta\\) frame. This <code>QSG</code> is particularily useful for single phase systems where a simple Clark transform can not be used.</li> <li><code>SRF PLL</code> stands for Synchronous Reference Frame Phase Lock Loop. It takes an input signal in the \\(\\alpha\\beta\\) frame and retrieve the angle \\(\\theta\\) and the pulsation \\(\\omega\\)</li> </ul>"},{"location":"controlLibrary/docs/use-sogi/#parameters","title":"Parameters:","text":"<p>The SOGI PLL is discretized form is the following:</p> <p>\\(R_{1hd} = Kr \\times Ts \\left(. \\cos(\\phi') . \\dfrac{1- z^{-1}.cos(\\omega .T_s)}{1 - 2.z^{-1}cos(\\omega T_s)+z^{-2}} -sin(\\phi').\\dfrac{z^{-1}.sin(\\omega .T_s)}{1 - 2.z^{-1}cos(\\omega T_s)+z^{-2}}\\right)\\)</p> <p>Kr parameter augment SOGI PLL dynamic but decrease its selectivity.</p>"},{"location":"controlLibrary/docs/use-sogi/#retrieve-quadrature-signal","title":"Retrieve Quadrature signal","text":"<p>Following equations are expanded :</p> \\[cos(\\theta_k) = cos(\\theta_{k-1} +\\omega.Ts)\\] \\[sin(\\theta_k) = sin(\\theta_{k-1} +\\omega.Ts)\\] <p>Hence we derive the quadrature sinus term</p> \\[sin(\\theta_k) = -\\dfrac{cos(\\omega . Ts)}{sin(\\omega .Ts)}.cos(\\theta_k) + \\dfrac{1}{sin(\\omega . Ts)}.cos(\\theta_{k-1})\\]"},{"location":"controlLibrary/docs/use-sogi/#use-of-the-sogi-filter","title":"Use of the <code>SOGI</code> filter.","text":"<p>The use of the `Sogi is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters declaration.2. Initialization.3. Execution. <p>We define constants used to initialize the parameter structure. <pre><code>#include \"filters.h\"\n\nstatic float32_t kr = 500;                // Sogi filter gain defining dynamics\nstatic float32_t Ts = 100.0e-6F;          // sampling time of the control period [s]\n</code></pre></p> <p>We define the variable <code>sogi_filter</code> which is an instance of <code>Sogi</code> object. <pre><code>static Sogi sogi_filter;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>sogi_filter</code> with its parameters.</p> <pre><code>sogi_filter.init(Ts, kr);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code></p> <pre><code>sogi_data = sogi_filter.calculateWithReturn(signal_to_track);\n</code></pre> <p><code>sogi_data</code> is a structure which kept the results of the sogi_filter calculation for one step.</p> <p>the SogiData structure has 3 fields: <pre><code>struct SogiData {\n    float32_t theta;      // estimated angle [rad]\n    float32_t alpha;      // cosinus term\n    float32_t beta;       // sinus term\n};\n</code></pre></p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-sogi/#example","title":"Example","text":"<p>You can find a Sogi use with the grid following example which requires a synchronisation to inject current in parallel with a voltage source.</p>"},{"location":"core/","title":"OwnTech Power API","text":"<p>This is the OwnTech Power API Core repository.</p> <p>The Power API is designed to be used with VS Code and PlatformIO. Installing VS Code with PlatformIO.</p> <p>For information about Power API, check out its Documentation.</p>"},{"location":"core/#downloading-owntech-power-api-core","title":"Downloading OwnTech Power API Core","text":"<p>You fisrt need to download the Power API Core repository using the following command:</p> <p><code>git clone https://github.com/owntech-foundation/Core.git owntech_power_api</code></p> <p>Then, open VS Code and, if not already done, install the PlatformIO plugin.</p> <p>Finally, open the newly cloned folder <code>owntech_power_api</code> using menu <code>File &gt; Open Folder...</code></p>"},{"location":"core/#working-with-owntech-power-api","title":"Working with OwnTech Power API","text":"<p>While the project contains many folders and files, all your code goes to the <code>src</code> folder. In the this folder, the file <code>main.cpp</code> is the entry point of the application. Aditionally, some configuration can be done in the <code>platformio.ini</code> file.</p> <p>Other folders and files are used to configure the underlying Zephyr OS and PlatformIO, and are hidden by default.</p>"},{"location":"core/#accessing-owntech-source-code-in-vs-code-for-advanced-developers","title":"Accessing OwnTech source code in VS Code (for advanced developers)","text":"<p>The full hierarchy of the project is as follows:</p> <pre><code>owntech_power_api\n\u2514\u2500 owntech\n|  \u2514\u2500 boards\n|  \u2514\u2500 scripts\n|  \u2514\u2500&gt;pio_extra.ini\n\u2514\u2500 src\n|  \u2514\u2500&gt;main.cpp\n\u2514\u2500 zephyr\n|  \u2514\u2500 boards\n|  \u2514\u2500 dts\n|  \u2514\u2500 modules\n|  \u2514\u2500&gt;CMakeLists.txt\n|  \u2514\u2500&gt;prj.conf\n\u2514\u2500&gt;LICENSE\n\u2514\u2500&gt;platformio.ini\n\u2514\u2500&gt;README.md\n</code></pre> <p>The <code>owntech</code> folder contains scripts and board description for PlatformIO, while the <code>zephyr</code> folder contains board decription and OwnTech's Zephyr modules. By default, these folders (as well as VS Code and PlatformIO folders <code>.vscode</code> and <code>.pio</code>) are hidden when opening the project in VS Code.</p> <p>If you need to access these in VS Code, open the project using your file explorer, then in the <code>.vscode</code> folder, rename file <code>settings.json</code>, e.g. to <code>settings.json.old</code>.</p> <p>Advanced Zephyr configuration can be tweaked by editing <code>zephyr/prj.conf</code>.</p> <p>The OwnTech API source code is located in <code>zephyr/modules</code>. If you need to tailor it to your needs, please checkout the Zephyr documentation.</p>"},{"location":"core/docs/communication_introduction/","title":"Introduction","text":"<p>Communication API is used to interact with the Spin board and its shields communication peripherals.</p> <p>To work with Communication API, include the following file in your code:</p> <p>Note</p> <pre><code>#include &lt;CommunicationAPI.h&gt;\n</code></pre>"},{"location":"core/docs/communication_introduction/#detailed-documentation-on-available-classes","title":"Detailed documentation on available classes:","text":"<ul> <li>Analog communication</li> <li>RS485</li> <li>CAN</li> <li>Real-Time synch</li> </ul>"},{"location":"core/docs/communication_introduction/#api-reference","title":"API Reference","text":""},{"location":"core/docs/communication_introduction/#class-communicationapi","title":"Class CommunicationAPI","text":"<p>ClassList &gt; CommunicationAPI</p> <p>Main communication API interface. More...</p> <ul> <li><code>#include &lt;CommunicationAPI.h&gt;</code></li> </ul>"},{"location":"core/docs/communication_introduction/#public-attributes","title":"Public Attributes","text":"Type Name AnalogCommunication analog Contains all the functions for Analog communication. CanCommunication can Contains all the functions for CAN communication. Rs485Communication rs485 Contains all the functions for RS485 communication. SyncCommunication sync Contains all the functions for Real Time synchronization."},{"location":"core/docs/communication_introduction/#detailed-description","title":"Detailed Description","text":"<p>This class provides access to all supported communication interfaces, including analog, CAN, RS485, and real-time synchronization protocols.</p> <ul> <li><code>analog</code>: provides analog communication functions.</li> <li><code>can</code>: provides CAN bus communication functions.</li> <li><code>rs485</code>: provides RS485 serial communication functions.</li> <li><code>sync</code>: provides real-time synchronization functions. </li> </ul>"},{"location":"core/docs/communication_introduction/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"core/docs/communication_introduction/#variable-analog","title":"variable analog","text":"<p>Contains all the functions for Analog communication. <pre><code>AnalogCommunication CommunicationAPI::analog;\n</code></pre></p>"},{"location":"core/docs/communication_introduction/#variable-can","title":"variable can","text":"<p>Contains all the functions for CAN communication. <pre><code>CanCommunication CommunicationAPI::can;\n</code></pre></p>"},{"location":"core/docs/communication_introduction/#variable-rs485","title":"variable rs485","text":"<p>Contains all the functions for RS485 communication. <pre><code>Rs485Communication CommunicationAPI::rs485;\n</code></pre></p>"},{"location":"core/docs/communication_introduction/#variable-sync","title":"variable sync","text":"<p>Contains all the functions for Real Time synchronization. <pre><code>SyncCommunication CommunicationAPI::sync;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"core/docs/environment_setup/","title":"Environment Setup","text":"<p>If you use or wish to use Visual Studio Code, follow this tutorial to set up your work environment. It will use a \u201cBlinky\u201d (blinking LED) example which requires no other hardware than your OwnTech board.</p>"},{"location":"core/docs/environment_setup/#requirements","title":"Requirements","text":"<p>Before we start, make sure your machine meets all the requirements below.</p> <p>Required software</p> WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers<ul> <li>The pip package installer is needed. If using the system Python (<code>/usr/bin/python3</code>), <code>pip</code> may not be installed by default.   See Installing pip with Linux Package Managers.</li> <li>The venv module is needed.   Warning if using the system Python: although <code>venv</code> is part of the Python Standard Library, some Linux distributions such as Debian and Ubuntu don't install it by default.   In that case, make sure that the <code>python3-venv</code> package is installed.</li> </ul> </li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>64 bit Linux distribution</li> <li>Write permission for the serial port (<code>/dev/ttyACM0</code>): See PlatformIO documentation which provides a udev rules file</li> <li>Internet connection</li> </ul>"},{"location":"core/docs/environment_setup/#setup-your-work-environment","title":"Setup your work environment","text":"<p>To use OwnTech's system, we will use:</p> <ul> <li>Visual Studio Code - The platform or Integrated Development Environment we will use to write code.</li> <li>PlatformIO - A Visual Studio Code extension that is a toolbox for microcontrollers</li> </ul> <p>Required Disk Space</p> <p>Make sure that you have more than 2GB on your hard drive so that PlatformIO can download all the required files without issues.</p> <p>Here is how to set up this environment.</p>"},{"location":"core/docs/environment_setup/#step-1-empty-folder","title":"Step 1 - Empty folder","text":"<p>Create an empty folder in which you will work throughout the tutorials.</p> <p>Warning</p> Windows <ul> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not linked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> </ul>"},{"location":"core/docs/environment_setup/#step-2-install-visual-studio-code","title":"Step 2 - Install Visual Studio Code","text":"<p>Download  and install Visual Studio Code (\u201cVS Code\u201d for short).</p> <p>Warning</p> Windows <p>Make sure you have the System Version of VSCode installed in your computer, as shown in the image below. </p> <p>An overview of VS Code user interface is available in their official Get Started / User Interface documentation.</p>"},{"location":"core/docs/environment_setup/#step-3-install-platformio","title":"Step 3 - Install PlatformIO","text":"<p>Launch Visual Studio Code.</p> <p>In the \u201cActivity Bar\u201d, located on the far left-hand side, click on the Extensions icon (1) to open the VS Code Extensions manager in the Primary Side Bar.</p> <ol> <li>The VS Code Extensions manager icon looks like this: </li> </ol> <p>Using the search box in the Extensions Marketplace, search for the \u201cPlatformIO IDE\u201d extension and install it.</p> <p>Finally, restart Visual Studio Code when you are prompted to do so.</p> <p></p> <p>Once installed, you should see that PlatformIO has appended its \u201calien head\u201d icon (1) to the Activity Bar.</p> <ol> <li>The PlatformIO icon looks like this: </li> </ol> <p>Pro tip</p> <p>If the alien icon does not show up spontaneously, wait for a few more seconds, then press F1 key and type \"platformio home\".</p>"},{"location":"core/docs/environment_setup/#step-4-open-platformio-in-vs-code","title":"Step 4 - Open PlatformIO in VS Code","text":"<p>In VS Code Activity Bar, click on the newly added PlatformIO \u201calien head\u201d icon to open PlatformIO in the Primary Side Bar. It should contain:</p> <ul> <li>\u201cProject Tasks\u201d view, at the top (without any task list at that stage, since you haven\u2019t opened a PlatformIO project at this stage)</li> <li>\u201cQuick Access\u201d view, below</li> </ul>"},{"location":"core/docs/environment_setup/#step-5-clone-our-core-repository","title":"Step 5 - Clone our Core repository","text":"<p>In PlatformIO's \u201cQuick Access\u201d view, select the \u201cMiscelleanous / Clone Git Project\u201d action. This will open a field in which you should enter the following Git repository address:</p> <pre><code>https://github.com/owntech-foundation/Core\n</code></pre> <p>PlatformIO will then ask you in which folder the project should be cloned. Choose the folder you have created previously. This will start the cloning process (with a progress window popping up in the lower right corner).</p> <p>At the end of the cloning process, VS Code will ask you if you wish to open the cloned repository and you should answer yes (\"Open\" or \"Open in New Window\").</p> <p>Once the project folder is opened, a popup will appear asking if you trust the authors of the files in this folder. You can trust us. </p> <p></p> <p>Once the repository is cloned successfully, make sure you are on the <code>main</code> branch of the Git project. The name of the current branch is displayed on the left side of the Status Bar, at the bottom of the VS Code window, as highlighted in the following screenshot:</p> <p></p> <p>Now the project is successfully opened and you should see two tabs in the Editor area:</p> <ul> <li>the \u201cPIO Home\u201d tab that we will not use here   (remark: PIO Home\u2019s Devices tab can be used to check that your board is well detected once connected)</li> <li>the <code>platformio.ini</code> Project Configuration File,   which is already well configured for the present example</li> </ul> <p>This first example you have just opened implements a simple \u201cBlinky\u201d (blinking LED) demo. If you wish to understand how it is implemented, open and read through the main C++ code which is <code>main.cpp</code>, located in the <code>src</code> folder. VS Code file Explorer can be opened from the first icon at the top of the Activity Bar.</p>"},{"location":"core/docs/environment_setup/#step-6-build-our-core-code","title":"Step 6 - Build our Core code","text":"<p>In the Status Bar, at the bottom of the VS Code window, click on the Build (<code>\u2713</code>) icon. This will launch the code compilation process.</p> <p></p> <p>Coffee Time</p> <p>During your first build, PlatformIO will download all the necessary dependencies of our code. This may take several minutes depending on your machine and your internet connection.</p> <p>Do not hesitate to go get yourself a coffee.</p> <p>When the compilation is completed, you should see:</p> <p></p> <p>Note</p> <p>If you encounter an error during compilation, please refer to the troubleshooting section below.</p>"},{"location":"core/docs/environment_setup/#step-7-prepare-your-hardware","title":"Step 7 - Prepare your hardware","text":"<p>Before running the code, make sure that you meet the following requirements:</p> <p>Requirements for running the code on a board</p> <ul> <li>Have your VS Code Environment already set up</li> <li>Run your first compilation successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> </ul> <p></p> <ul> <li>Connect the SPIN board to your computer via the USB.</li> <li>Notice that the LED PWR must turn on.</li> <li>Here you see the connection of a SPIN board embedded onto a TWIST board.</li> </ul>"},{"location":"core/docs/environment_setup/#step-8-upload-our-core-code-in-your-spin-board","title":"Step 8 - Upload our Core code in your SPIN board","text":"<p>Now it is time to run a Blinky (i.e. blinking LED) example on the board.</p> <p>This requires uploading (or flashing) the compiled code to the SPIN controller board. To do so, press the Upload icon (<code>\u2192</code>, just to the right of the Build icon <code>\u2713</code>).</p> <p>Pro tip</p> <p>The Build and Upload action buttons are also available in the top right corner of the Editor area</p> <p>Coffee time 2</p> <p>During your first upload, PlatformIO will automatically download the necessary dependencies to send data to the SPIN board. Depending on your machine and your internet connection, this might take some time.</p> <p>Time to pour another coffee.</p> Known bug - mcumgr macOS <p>The upload requires a software called mcumgr.</p> <p>As of the time of writing, we have experienced issues with some macOS devices in finding it.</p> <p>Please refer to the ongoing issue to handle it if you have the error below.</p> <p></p> <p>If everything goes well, you will get a success as in the image below.</p> <p></p> <p>Finally, allowing a few extra seconds for the board to reboot, you will see the <code>LED</code> LED blink.</p> <p>  Success</p> <p>Congratulations! You have uploaded your first code!</p> <p>If you want to make sure you really master this first example, you can change the blinking frequency. The blinking period is set at the last line of the <code>loop_background_task()</code> routine in the <code>main.cpp</code> file (<code>1000</code> by default, expressed in ms). After saving the modified code, you will need to redo the Build and Upload steps.</p>"},{"location":"core/docs/environment_setup/#troubleshooting","title":"Troubleshooting","text":"<p>From our experience, there are multiple types of errors that can block your compilation.</p> <p>Check the list below of possible issues</p> Troubleshooting WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not liked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> <li>If you have a problem with <code>mcumgr</code>, please refer to the ongoing issue to handle it.</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Check that your Linux is 64 bits</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> </ul> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.07.11: Pierre Haessig</li> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/first_example/","title":"First Example","text":"<p>The best way \"to owntech\" is to use our examples.</p> <p>In this section we will show you how to use our example interface.</p>"},{"location":"core/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Run your first compilation successfully.</li> <li>Run your first upload successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/first_example/#using-the-example-interface","title":"Using the example interface","text":"<p>We have developed an automatic method to use the examples available in our github example repository within our environment.</p> <p>Here are the steps to use it.</p>"},{"location":"core/docs/first_example/#step-1-open-project-tasks","title":"Step 1 - Open project tasks","text":"<p>Click on the PlatformIO alien icon. (1)</p> <ol> <li>The alien icon looks like this </li> </ol> <p>There are three group of tasks:</p> <ul> <li>Default:</li> <li>STLink:</li> <li>USB: These are the tasks we will work with</li> </ul> <p>Environments</p> <p>These three groups of tasks are called \"environments\" in PlatformIO.</p> <ul> <li>Default is given by PlatformIO itself and we do not use it.</li> <li>STLink is the environment that supports using an STLink when interacting to the SPIN board.</li> <li>USB is the default environment which uses an USB cable to interact with the SPIN board.</li> </ul> <p>We will work with different environments in later more advanced examples.</p>"},{"location":"core/docs/first_example/#step-2-open-the-usb-tasks","title":"Step 2 - Open the USB tasks","text":"<p>There are multiple folders on the USB tasks.</p> <ul> <li>From General to Msciellaneous are tasks by default that we don not use</li> <li>OwnTech: are tasks that can be used for more advanced users.</li> <li>Examples TWIST: are the examples dedicated to the TWIST board which we will see later.</li> <li>Examples SPIN: groups all the examples related to the SPIN board.</li> </ul>"},{"location":"core/docs/first_example/#step-3-open-the-examples-spin-folder","title":"Step 3 - Open the Examples SPIN folder","text":"<p>Click on the Examples SPIN folder.</p> <p>You will see multiple examples on this folder.</p> <ul> <li>Blinky LED: Your trusted companion.</li> <li>Setting PWM: An example to create a single PWM signal</li> <li>Setting multiple PWM: An example for creating multiple PWM signals</li> <li>Setting PWM phase shift: An example for shifting two PWM signals</li> <li>DAC signal: An example for generating an analog signal from digital data</li> <li>Software triggered ADC: An example to activate</li> <li>HRTIM triggered ADC: An example to active an ADC measuremente using a hardware trigger</li> <li>Incremental encoder: An example on how to interface an incremental encoder to the SPIN board</li> </ul>"},{"location":"core/docs/first_example/#step-4-get-your-example","title":"Step 4 - Get your example","text":"<p>Click on the Setting PWM duty cycle example.</p> <p>The file will be automatically downloaded and replace your <code>main.cpp</code>.</p>"},{"location":"core/docs/first_example/#step-5-build-the-example","title":"Step 5 - Build the example","text":"<p>Go back to your VSCode Explorer tab.(1)</p> <ol> <li>The explorer tab icon looks like this: </li> </ol> <p>Notice that an <code>old/old0/src</code> folder has been created.  You will find your previous <code>main.cpp</code> in this folder.  This way you can access your old code anytime.</p> <p>In the <code>src</code> folder, notice that an <code>Image</code> folder has been created and that the <code>readme.md</code> of the example was downloaded.</p> <p>You can click on the new <code>main.cpp</code> file to explore the newly downloaded example.</p> <p>When you are ready to build, click on the build icon. (1)</p> <ol> <li>The build icon looks like this: </li> </ol>"},{"location":"core/docs/first_example/#step-6-upload-the-example","title":"Step 6 - Upload the example","text":"<p>If the build is successful, connect your SPIN board and click on the flash icon. (1)</p> <ol> <li>The flash icon looks like this: </li> </ol> <p>Connect your SPIN board</p> <p>Remember to connect your SPIN board to your computer to allow you to upload the new example.</p> <p></p> <p>Once the upload is completed, the LED will stop blinking.</p> <p>You can connect to the serial port by cliking on its icon. (1)</p> <ol> <li>The serial icon looks like this: </li> </ol> <p>VSCode will open a <code>TERMINAL</code> window and show what the SPIN board is writing on the console.</p> <p>You should see a <code>0.300000</code> which represents a duty cycle of 30%.</p> <p>If you click on the terminal and push the <code>d</code> key on your keyboard, the value will go <code>DOWN</code> and decrease to <code>0.250000</code>.</p> <p>If you push the <code>u</code> key on your key board, the value will go <code>UP</code> and increase back to <code>0.300000</code>.</p> <p>Congratulations! you have uploaded your fist example. Do not hesitate to explore more examples either via our interface or our repository.</p> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/ownplot_setup/","title":"OwnPlot Setup","text":"<p>OwnPlot is the software we have developed to easily visualize data. Here we will show you how to install and use it.</p>"},{"location":"core/docs/ownplot_setup/#requirements","title":"Requirements","text":"<p>Before you start, make sure you meet the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Have your first PWM example uploaded.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready and connected to your computer (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/ownplot_setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"core/docs/ownplot_setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"core/docs/ownplot_setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"core/docs/ownplot_setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p>"},{"location":"core/docs/powerAPI/","title":"Home","text":"<p>PowerAPI is a comprehensive software API for demanding applications.</p> <ul> <li> <p> Blazing Fast</p> <p>Get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Application oriented</p> <p>Focus on your application and generate your real time control</p> <p> Examples</p> </li> </ul>"},{"location":"core/docs/powerAPI/#browse-the-documentation","title":"Browse the documentation","text":"<ul> <li> <p> Real time tasks</p> <p>Generate accurate periodic actions and handle background tasks</p> <p> API Reference</p> </li> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> HAL Reference</p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> API Reference</p> </li> <li> <p> Analog accelerated control loops</p> <p>Use internal analog hardware to control your application</p> <p> HAL Reference</p> </li> <li> <p> Real time synchronization</p> <p>Synchronize multiple SPIN boards down to 10 of ns</p> <p> API Reference</p> </li> <li> <p> Real time communication</p> <p>Send critical data, at real time pace.</p> <p> Digital communication API</p> <p> Analog communication API</p> </li> </ul>"},{"location":"core/docs/safety_introduction/","title":"Introduction","text":"<p>Safety API is designed to provide safety features when working with the Spin board.</p> <p>To work with Spin API, include the following file in your code:</p> <p>Note</p> <pre><code>#include &lt;SafetyAPI.h&gt;\n</code></pre>"},{"location":"core/docs/safety_introduction/#api-reference","title":"API Reference","text":""},{"location":"core/docs/safety_introduction/#class-safetyapi","title":"Class SafetyAPI","text":"<p>ClassList &gt; SafetyAPI</p>"},{"location":"core/docs/safety_introduction/#public-functions","title":"Public Functions","text":"Type Name void disableSafetyApi () Disables the safety API fault detection task. void enableSafetyApi () Enables the safety API fault detection task. bool getChannelError (sensor_t sensors_error) Check if the sensor faced an error (went over/under threshold) safety_reaction_t getChannelReaction () returns the reaction to do when encountering an error. float32_t getChannelThresholdMax (sensor_t sensors_threshold) Get the maximum threshold of the selected sensor. float32_t getChannelThresholdMin (sensor_t sensors_threshold) Get the minimum threshold of the selected sensor. bool getChannelWatch (sensor_t sensors_watch) check if a sensor is being monitored or not. void initShield () Initializes thresholds min/max with the default value from the device tree. void initShield (sensor_t * sensors_watch, uint8_t sensors_watch_number) Initializes thresholds min/max with the default value from the device tree. int8_t retrieveThreshold (sensor_t sensor_threshold_retrieve) Retrieves the current minimum and maximum threshold stored in the flash (non volatile memory) void setChannelReaction (safety_reaction_t sensors_reaction) Set the reaction to do if an error has been detected. int8_t setChannelThresholdMax (sensor_t * sensors_threshold, float32_t * threshold_max, uint8_t sensors_threshold_number) Set the maximum threshold for the sensors present in the list safety_sensors. int8_t setChannelThresholdMin (sensor_t * sensors_threshold, float32_t * threshold_min, uint8_t sensors_threshold_number) Set the minimum threshold for the sensors present in the list safety_sensors. int8_t setChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Enables the monitoring of the selected sensors for safety. int8_t storeThreshold (sensor_t sensor_threshold_store) Store the current minimum and maximum threshold in the flash (non volatile memory) int8_t unsetChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Disables the monitoring of the selected sensors for safety."},{"location":"core/docs/safety_introduction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/safety_introduction/#function-disablesafetyapi","title":"function disableSafetyApi","text":"<p>Disables the safety API fault detection task. <pre><code>void SafetyAPI::disableSafetyApi () \n</code></pre></p>"},{"location":"core/docs/safety_introduction/#function-enablesafetyapi","title":"function enableSafetyApi","text":"<p>Enables the safety API fault detection task. <pre><code>void SafetyAPI::enableSafetyApi () \n</code></pre></p>"},{"location":"core/docs/safety_introduction/#function-getchannelerror","title":"function getChannelError","text":"<p>Check if the sensor faced an error (went over/under threshold) <pre><code>bool SafetyAPI::getChannelError (\n    sensor_t sensors_error\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_error</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>True if the sensor faced an error, false if not </p>"},{"location":"core/docs/safety_introduction/#function-getchannelreaction","title":"function getChannelReaction","text":"<p>returns the reaction to do when encountering an error. <pre><code>safety_reaction_t SafetyAPI::getChannelReaction () \n</code></pre></p> <p>Returns:</p> <p>Open_Circuit or Short_Circuit </p>"},{"location":"core/docs/safety_introduction/#function-getchannelthresholdmax","title":"function getChannelThresholdMax","text":"<p>Get the maximum threshold of the selected sensor. <pre><code>float32_t SafetyAPI::getChannelThresholdMax (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>the maximum threshold </p>"},{"location":"core/docs/safety_introduction/#function-getchannelthresholdmin","title":"function getChannelThresholdMin","text":"<p>Get the minimum threshold of the selected sensor. <pre><code>float32_t SafetyAPI::getChannelThresholdMin (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>The minimum threshold </p>"},{"location":"core/docs/safety_introduction/#function-getchannelwatch","title":"function getChannelWatch","text":"<p>check if a sensor is being monitored or not. <pre><code>bool SafetyAPI::getChannelWatch (\n    sensor_t sensors_watch\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p><code>true</code> if the sensor is being monitored, <code>false</code> if not </p>"},{"location":"core/docs/safety_introduction/#function-initshield-12","title":"function initShield [1/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree. <pre><code>void SafetyAPI::initShield () \n</code></pre></p> <p>If values were stored and found in the flash they will be used instead.</p> <p>All the sensors will be monitored to detect potential faults in voltage/current. </p>"},{"location":"core/docs/safety_introduction/#function-initshield-22","title":"function initShield [2/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree. <pre><code>void SafetyAPI::initShield (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>If values were stored and found in the flash they will be used instead.</p> <p>All the sensors will be monitored to detect potential faults in voltage/current.</p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch. </li> </ul>"},{"location":"core/docs/safety_introduction/#function-retrievethreshold","title":"function retrieveThreshold","text":"<p>Retrieves the current minimum and maximum threshold stored in the flash (non volatile memory) <pre><code>int8_t SafetyAPI::retrieveThreshold (\n    sensor_t sensor_threshold_retrieve\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_retrieve</code> the sensor to retrieve the threshold stored in the NVS within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved, negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested sensor </li> </ul>"},{"location":"core/docs/safety_introduction/#function-setchannelreaction","title":"function setChannelReaction","text":"<p>Set the reaction to do if an error has been detected. <pre><code>void SafetyAPI::setChannelReaction (\n    safety_reaction_t sensors_reaction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>sensors_reaction</code> the reaction to do:</p> </li> <li> <p><code>Open_Circuit</code>: both switches are opened and no power flows to the output</p> </li> <li><code>Short_Circuit</code>: high-side switch is opened, and low-side is closed maintaining the output in short-circuit. Useful in motor control. </li> </ul>"},{"location":"core/docs/safety_introduction/#function-setchannelthresholdmax","title":"function setChannelThresholdMax","text":"<p>Set the maximum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t SafetyAPI::setChannelThresholdMax (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_max,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>threshold_max</code> A list of the maximum threshold to apply to the sensors in safety_sensors.</li> <li><code>sensors_threshold_number</code> the number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if not. </p>"},{"location":"core/docs/safety_introduction/#function-setchannelthresholdmin","title":"function setChannelThresholdMin","text":"<p>Set the minimum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t SafetyAPI::setChannelThresholdMin (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_min,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>threshold_min</code> A list of the minimum threshold to apply to the sensors in safety_sensors.</li> <li><code>sensors_threshold_number</code> The number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if not. </p>"},{"location":"core/docs/safety_introduction/#function-setchannelwatch","title":"function setChannelWatch","text":"<p>Enables the monitoring of the selected sensors for safety. <pre><code>int8_t SafetyAPI::setChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if there was an error </p>"},{"location":"core/docs/safety_introduction/#function-storethreshold","title":"function storeThreshold","text":"<p>Store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t SafetyAPI::storeThreshold (\n    sensor_t sensor_threshold_store\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_store</code> the sensor to store the threshold in the NVS within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_store</code> The sensor for which we store the threshold in the NVS</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly stored, <code>-1</code> if there was an error. </p>"},{"location":"core/docs/safety_introduction/#function-unsetchannelwatch","title":"function unsetChannelWatch","text":"<p>Disables the monitoring of the selected sensors for safety. <pre><code>int8_t SafetyAPI::unsetChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if there was an error </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"core/docs/shield_introduction/","title":"Introduction","text":"<p>This API is designed to work with Spin shields hardware, providing a set of functions to manage and control the shields.</p> <p>To work with Shield API, include the following file in your code:</p> <p>Note</p> <pre><code>#include &lt;ShieldAPI.h&gt;\n</code></pre>"},{"location":"core/docs/shield_introduction/#features","title":"Features","text":"<p> - Versatile Control Modes: The API supports both voltage and peak current control modes, allowing you to choose the best option for your specific application. - Independent Leg Operation: Each of the two legs can operate independently with different topologies, such as boost or buck, offering greater flexibility in power management. - Configure different paramaters for power electronics (dead time, phase shift) - Simplified ADC value retrieval - Refer to TWIST hardware specifications for more detail on TWIST board.</p>"},{"location":"core/docs/shield_introduction/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <p>1. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>shield.power.initBuck(ALL)</code>, <code>shield.power.initBoost(ALL)</code></p> <p>Optional steps 2. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>shield.power.setAdcDecim(ALL, decim)</code> 3. Set the dead time <code>shield.power.setDeadTime(ALL, rise_deadTime_ns, fall_deadTime_ns)</code> 4. Set the phase shift in degree <code>shield.power.setPhaseShift(ALL, ps_degree)</code> </p> <p>5. Enable the ADC acquisition for twist to get voltage and current measures <code>shield.sensors.enableDefaultTwistSensors()</code> 6. Set the duty cycle to control output voltage <code>shield.power.setDutyCycle(ALL, duty_cycle)</code> 7. Then start the converters <code>shield.power.start(ALL)</code></p> <p>1. Choose the wished topology : buck, boost <code>shield.power.initBuck(LEG1/LEG2)</code>, <code>shield.power.initBoost(LEG1/LEG2)</code></p> <p>Optional steps 2. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>shield.power.setAdcDecim(LEG1/LEG2, decim)</code> 3. Set the dead time <code>shield.power.setDeadTime(LEG1/LEG2, rise_deadTime_ns, fall_deadTime_ns)</code> 4. Set the phase shift in degree <code>shield.power.setPhaseShift(LEG1/LEG2, ps_degree)</code> </p> <p>5. Enable the ADC acquisition for twist to get voltage and current measures <code>shield.sensors.enableDefaultTwistSensors()</code> 6. Set the duty cycle to control output voltage <code>shield.power.setDutyCycle(LEG1/LEG2, duty_cycle)</code> 7. Then start the converters <code>shield.power.start(ALL)</code></p> <p>1. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>shield.power.initBuck(ALL, CURRENT_MODE)</code>, <code>shield.power.initBoost(ALL)</code></p> <p>Optional steps 2. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>shield.power.setAdcDecim(ALL, decim)</code> 3. Set the dead time <code>shield.power.setDeadTime(ALL, rise_deadTime_ns, fall_deadTime_ns)</code> 4. Set the phase shift in degree <code>shield.power.setPhaseShift(ALL, ps_degree)</code> </p> <p>5. Enable the ADC acquisition for twist to get voltage and current measures [<code>shield.sensors.enableDefaultTwistSensors()</code>]#function-enabledefaulttwistsensors) 6. Set the slope compensation to control the output current<code>shield.power.setSlopeCompensation(ALL, 1.4, 1.0)</code> 7. Then start the converters <code>shield.power.start(ALL)</code></p> <p>Warning</p> <p>Only buck topology is currently supported for current mode control.</p> <p>Example</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <pre><code>shield.power.initBuck(ALL);\nshield.power.setAdcDecim(ALL, 1);\nshield.power.setDeadTime(ALL, 200, 200);\nshield.power.setPhaseShift(ALL, 180);\nshield.sensors.enableDefaultTwistSensors();\nshield.power.setDutyCycle(ALL, 0.5);\nshield.power.start(ALL);\n</code></pre> <pre><code>shield.power.initBuck(LEG1);\nshield.power.setAdcDecim(LEG1, 1);\nshield.power.setDeadTime(LEG1, 200,200);\nshield.power.setPhaseShift(LEG1, 180);\nshield.sensors.enableDefaultTwistSensors();\nshield.power.setDutyCycle(LEG1, 0.5);\nshield.power.start(LEG1);\n</code></pre> <pre><code>shield.power.initBuck(ALL, CURRENT_MODE);\nshield.power.setAdcDecim(ALL, 1);\nshield.power.setDeadTime(ALL, 200, 200);\nshield.power.setPhaseShift(ALL, 180);\nshield.sensors.enableDefaultTwistSensors();\nshield.power.setSlopeCompensation(ALL, 1.4, 1.0);\nshield.power.start(ALL);\n</code></pre>"},{"location":"core/docs/shield_introduction/#voltage-mode-and-current-mode","title":"Voltage mode and Current mode","text":"<p>There is two different way to control the power delivered by TWIST : voltage and current mode.</p>"},{"location":"core/docs/shield_introduction/#voltage-mode","title":"Voltage mode","text":"<p>Voltage mode is a traditional and widely-used approach in power electronics, where the output voltage is regulated by controlling the duty cycle. The duty cycle is a crucial parameter that determines the proportion of time a switch (such as a transistor) is active during a complete switching period. By adjusting the duty cycle, you can effectively manage the power delivered to a load.</p> <p>A higher duty cycle indicates that the switch remains on for a more extended period, resulting in increased power delivery to the load. Conversely, a lower duty cycle means the switch is on for a shorter duration, thereby reducing the power supplied. Consequently, the average power and voltage applied to the load can be precisely controlled by fine-tuning the duty cycle.</p>  Voltage mode PWM schematic  Voltage mode PWM waveform  <p></p> <p></p>"},{"location":"core/docs/shield_introduction/#current-mode","title":"Current mode","text":"<p>In peak current mode control,  we monitors the current flowing through the power switch. Once the current reaches a predetermined peak value, we promptly turns off the power switch. This mechanism helps maintain a constant output voltage by regulating the current flow.</p> <p>In this setup, a clock signal determines the switching frequency and triggers the switch to close. The controller then sends a reference peak current value. When the inductor's current reaches this reference value, the switch opens.</p>  Current mode schematic  Current mode waveform  <p></p> <p></p> <p>However, using a constant peak current reference can lead to subharmonic oscillations. To prevent this issue, we employ a technique called slope compensation. Instead of a constant value, the peak current reference is a sawtooth waveform. The final schematic with slope compensation is shown below:</p>  Final current mode schematic Final current mode waveform  <p></p> <p></p> <p>The sawtooth signal <code>Slope compensation</code> is generated with the function <code>shield.power.setSlopeCompensation</code>. This function sets the slope compensation based on the input parameters.  for example <code>shield.power.setSlopeCompensation(ALL, 1.4, 1.0)</code> generates a sawtooth signal ranging from 1.4V to 1.0V. You can create a sawtooth signal between 2.048V and 0V as well.</p> <p>This sawtooth signal is then compared with the ADC's current value. When selecting the sawtooth parameters, it's essential to consider the conversion of current to voltage.</p> <p>On the TWIST board, a voltage value of 1.024V on the ADC corresponds to a current of 0A. The system has a gain of 100mV per ampere, meaning that for each ampere increase in current, the voltage value increases by 100 millivolts.</p>"},{"location":"core/docs/shield_introduction/#snippets-examples","title":"Snippets examples","text":""},{"location":"core/docs/shield_introduction/#buck-topology","title":"Buck topology","text":""},{"location":"core/docs/shield_introduction/#2-legs-with-the-same-configuration","title":"2 legs with the same configuration","text":"Connection  Schematic  <pre><code>    shield.power.initBuck(ALL);\n    shield.power.setDutyCycle(ALL, 0.5);\n    shield.power.start(ALL);\n</code></pre>"},{"location":"core/docs/shield_introduction/#2-independant-leg-operations","title":"2 independant leg operations","text":"Connection  Schematic  <pre><code>    shield.power.initBuck(LEG1);\n    shield.power.initBuck(LEG2);\n    shield.power.setDutyCycle(LEG1, 0.3);\n    shield.power.setDutyCycle(LEG2, 0.5);\n    shield.power.start(ALL);\n</code></pre>"},{"location":"core/docs/shield_introduction/#boost-topology","title":"Boost topology","text":"Connection  Schematic  <pre><code>    shield.power.initBoost(ALL);\n    shield.power.setDutyCycle(ALL, 0.5);\n    shield.power.start(ALL);\n</code></pre>"},{"location":"core/docs/shield_introduction/#inverter-topology","title":"Inverter topology","text":"Connection  Schematic  <pre><code>    shield.power.initBuck(LEG1);\n    shield.power.initBoost(LEG2);\n    shield.power.setDutyCycle(ALL, 0.5);\n    shield.power.start(ALL);\n</code></pre> <p>Example</p> <p>Check the following examples for an application :     - Voltage mode buck     - Current mode buck     - Voltage mode boost</p>"},{"location":"core/docs/shield_introduction/#detailed-documentation-on-available-apis-classes","title":"Detailed documentation on available APIs classes:","text":"<ul> <li>Power API</li> <li>Sensors API</li> </ul>"},{"location":"core/docs/shield_introduction/#detailed-documentation-on-hardware-abstraction-layer-classes","title":"Detailed documentation on Hardware Abstraction Layer classes:","text":"<ul> <li>NGND HAL</li> </ul>"},{"location":"core/docs/shield_introduction/#api-reference","title":"API Reference","text":""},{"location":"core/docs/shield_introduction/#class-shieldapi","title":"Class ShieldAPI","text":"<p>ClassList &gt; ShieldAPI</p>"},{"location":"core/docs/shield_introduction/#public-static-attributes","title":"Public Static Attributes","text":"Type Name NgndHAL ngnd Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. PowerAPI power Contains all the functions to drive shield power capabilities. SensorsAPI sensors Contains all the functions to interact with shield sensors."},{"location":"core/docs/shield_introduction/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"core/docs/shield_introduction/#variable-ngnd","title":"variable ngnd","text":"<p>Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. <pre><code>NgndHAL ShieldAPI::ngnd;\n</code></pre></p>"},{"location":"core/docs/shield_introduction/#variable-power","title":"variable power","text":"<p>Contains all the functions to drive shield power capabilities. <pre><code>PowerAPI ShieldAPI::power;\n</code></pre></p>"},{"location":"core/docs/shield_introduction/#variable-sensors","title":"variable sensors","text":"<p>Contains all the functions to interact with shield sensors. <pre><code>SensorsAPI ShieldAPI::sensors;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.h</code></p>"},{"location":"core/docs/shield_sensors/","title":"Sensors","text":"<p>Shield sensors is an API that allows to access sensors from a Spin shield easily. Acquiring data without a shield is done using Data API, but Shield sensors API builds on Data API to provide access to sensors by name as well as automatically configuring the parameters for the raw data conversion.</p>"},{"location":"core/docs/shield_sensors/#quick-start-with-shield-sensor-api","title":"Quick start with Shield sensor API","text":"<p>To enable the Twist Shield channels, indicate which shield you are using by editing the file <code>platformio.ini</code> to define the <code>board_shield=</code> and <code>board_shield_version=</code> commands. From there, the Shield sensors API will be available simply by including <code>ShieldAPI.h</code> in your code.</p> <p>Using shield sensor API is done quite similarly to the Data API. The difference is that you do not have to know which pin a sensor is connected to.</p> <p>For example, if you want to access the V1_LOW sensor from the Twist shield using Data API, you would have to consult the pinout of the shield and identify that it is connected to pin 29 of the Spin, then write: <pre><code>spin.data.enableAcquisition(29);\n</code></pre> However, using Shield sensor API, you just have to write: <pre><code>shield.sensors.enableAcquisition(V1_LOW);\n</code></pre></p> <p>Everything else should be used similarly as Data API, just replace <code>spin.data</code> by <code>shield.sensors</code> in your code, then use the sensor name instead of the pin number as a parameter for the functions.</p>"},{"location":"core/docs/shield_sensors/#auto-configuration-of-the-api","title":"Auto-configuration of the API","text":"<p>Moreover, as Shield sensor API is aware of what sensors are available on the shield you use, it provides an auto-configuration that enables acquisition for all the sensors from the shield.</p> <p>The function is named <code>shield.sensors.enableDefault***Sensors()</code>. For example, for the Twist shield, the function is named <code>shield.sensors.enableDefaultTwistSensors()</code>. Just call this function then start the API, and you're ready to go!</p>"},{"location":"core/docs/shield_sensors/#api-reference","title":"API Reference","text":""},{"location":"core/docs/shield_sensors/#class-sensorsapi","title":"Class SensorsAPI","text":"<p>ClassList &gt; SensorsAPI</p>"},{"location":"core/docs/shield_sensors/#public-functions","title":"Public Functions","text":"Type Name float32_t convertRawValue (sensor_t sensor_name, uint16_t raw_value) Use this function to convert values obtained using matching spin.data.get*RawValues() function. void enableDefaultOwnverterSensors () This function is used to enable acquisition of all voltage/current sensors on the OwnVerter shield. void enableDefaultTwistSensors () This function is used to enable acquisition of all voltage/current sensors on the Twist shield. int8_t enableSensor (sensor_t sensor_name, adc_t adc_number) This function is used to enable a shield sensor for acquisition by a given ADC. float32_t getLatestValue (sensor_t sensor_name, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the sensor: Volts, Amperes, or Degree Celsius. uint16_t * getRawValues (sensor_t sensor_name, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified sensor. float32_t * getValues (sensor_t sensor_name, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t peekLatestValue (sensor_t sensor_name) Function to access the latest value available from the sensor. int8_t retrieveParametersFromMemory (sensor_t sensor_name) Use this function to read the gain and offset parameters of the board to is non-volatile memory. conversion_type_t retrieveStoredConversionType (sensor_t sensor_name) Use this function to get the current conversion type for the chosen sensor. float32_t retrieveStoredParameterValue (sensor_t sensor_name, parameter_t parameter_name) Use this function to get the current conversion parameters for the chosen sensor. void setConversionParametersLinear (sensor_t sensor_name, float32_t gain, float32_t offset) Use this function to tweak the conversion values for any linear sensor if default values are not accurate enough. void setConversionParametersNtcThermistor (sensor_t sensor_name, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. void setOwnverterTempMeas (ownverter_temp_sensor_t temperature_sensor) This function sets the GPIOs attached to the MUX to control which temperature sensor will be measured. void setTwistSensorsUserCalibrationFactors () Manually set parameters values using console. You will be directed via console to input the parameters of each sensor of the Twist board. int8_t storeParametersInMemory (sensor_t sensor_name) Use this function to write the gain and offset parameters of the board to is non-volatile memory. void triggerTwistTempMeas (sensor_t temperature_sensor) Manually triggers the temperature measurement of the Twist board."},{"location":"core/docs/shield_sensors/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/shield_sensors/#function-convertrawvalue","title":"function convertRawValue","text":"<p>Use this function to convert values obtained using matching spin.data.get*RawValues() function. <pre><code>float32_t SensorsAPI::convertRawValue (\n    sensor_t sensor_name,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Conversion will be done to relevant unit for the data: Volts, Amperes, or Degree Celsius.</p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which the value originates </li> <li><code>raw_value</code> Raw value obtained from which the value originates</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit.</p> <p>Returns <code>ERROR_CHANNEL_NOT_FOUND</code> if the sensor is not active. </p>"},{"location":"core/docs/shield_sensors/#function-enabledefaultownvertersensors","title":"function enableDefaultOwnverterSensors","text":"<p>This function is used to enable acquisition of all voltage/current sensors on the OwnVerter shield. <pre><code>void SensorsAPI::enableDefaultOwnverterSensors () \n</code></pre></p> <p>Note:</p> <p>ADCs are triggered simultaneously.</p> <p>Note:</p> <p>Sensors are attributed to ADC1 and ADC2 as follows:</p> <ul> <li> <p><code>ADC1_LIST[5]</code>: [<code>V1_LOW</code>,<code>V2_LOW</code>, <code>I3_LOW</code>, <code>V_HIGH</code>, <code>V_NEUTR</code> ] </p> </li> <li> <p><code>ADC2_LIST[5]</code>: [<code>I1_LOW</code>,<code>I2_LOW</code>, <code>V3_LOW</code>, <code>I_HIGH</code>, <code>TEMP_SENSOR</code>]</p> </li> </ul> <p>This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events.</p> <p>All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> <p>It also configures the gpios that control the MUX that chooses which temperature will be measured.</p> <p>Note:</p> <p>This function must be called before ADC is started. </p>"},{"location":"core/docs/shield_sensors/#function-enabledefaulttwistsensors","title":"function enableDefaultTwistSensors","text":"<p>This function is used to enable acquisition of all voltage/current sensors on the Twist shield. <pre><code>void SensorsAPI::enableDefaultTwistSensors () \n</code></pre></p> <p>Note:</p> <p>ADCs are triggered simultaneously.</p> <p>Note:</p> <p>Sensors are attributed to ADC1 and ADC2 as follows:</p> <ul> <li> <p><code>ADC1_LIST[3]</code>: [<code>V1_LOW</code>,<code>V2_LOW</code>,<code>V_HIGH</code>] </p> </li> <li> <p><code>ADC2_LIST[3]</code>: [<code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>]This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events.All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> </li> </ul> <p>Warning:</p> <p>This function must be called <code>before</code> ADC is started. </p>"},{"location":"core/docs/shield_sensors/#function-enablesensor","title":"function enableSensor","text":"<p>This function is used to enable a shield sensor for acquisition by a given ADC. <pre><code>int8_t SensorsAPI::enableSensor (\n    sensor_t sensor_name,\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function requires the presence of an \"shield-sensor\" node in the shield device-tree.</p> <p>Note:</p> <p>This function must be called <code>before</code> ADC is started.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the sensor using enumeration sensor_t. </li> <li><code>adc_number</code> The ADC which should be used for acquisition.</li> </ul> <p>Returns:</p> <p>0 if the sensor was correctly enabled, negative value if there was an error.</p> <p>Public functions accessible only when using a power shield </p>"},{"location":"core/docs/shield_sensors/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the sensor: Volts, Amperes, or Degree Celsius. <pre><code>float32_t SensorsAPI::getLatestValue (\n    sensor_t sensor_name,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using spin.data.get*RawValues() function for the matching sensor, as spin.data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain value. </li> <li><code>dataValid</code> Pointer to an <code>uint8_t</code> variable.</li> </ul> <p>This parameter is optional.</p> <p>If this parameter is provided, it will be updated to indicate information about spin.data.</p> <p>Possible values for this parameter will be:</p> <ul> <li><code>DATA_IS_OK</code> if returned data is a newly acquired data,</li> <li><code>DATA_IS_OLD</code> if returned data has already been provided before (no new data available since latest time this function was called),</li> <li><code>DATA_IS_MISSING</code> if returned data is <code>NO_VALUE</code>.</li> </ul> <p>Returns:</p> <p>Latest measure acquired by the sensor.</p> <p>If no value was acquired by this sensor yet, return value is <code>NO_VALUE</code>. </p>"},{"location":"core/docs/shield_sensors/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified sensor. <pre><code>uint16_t * SensorsAPI::getRawValues (\n    sensor_t sensor_name,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function.</p> <p>However, different sensors buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion.</p> <p>Use matching spin.data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same sensor as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an <code>uint32_t</code> variable. </li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"core/docs/shield_sensors/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>float32_t * SensorsAPI::getValues (\n    sensor_t sensor_name,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an <code>uint32_t</code> variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored.  </p>"},{"location":"core/docs/shield_sensors/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from the sensor. <pre><code>float32_t SensorsAPI::peekLatestValue (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain value.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given sensor. If there was no value acquired by this sensor yet, return value is <code>NO_VALUE</code>. </p>"},{"location":"core/docs/shield_sensors/#function-retrieveparametersfrommemory","title":"function retrieveParametersFromMemory","text":"<p>Use this function to read the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t SensorsAPI::retrieveParametersFromMemory (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to save the values. </li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved,negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested channel </li> </ul>"},{"location":"core/docs/shield_sensors/#function-retrievestoredconversiontype","title":"function retrieveStoredConversionType","text":"<p>Use this function to get the current conversion type for the chosen sensor. <pre><code>conversion_type_t SensorsAPI::retrieveStoredConversionType (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to get a conversion parameter. </li> </ul>"},{"location":"core/docs/shield_sensors/#function-retrievestoredparametervalue","title":"function retrieveStoredParameterValue","text":"<p>Use this function to get the current conversion parameters for the chosen sensor. <pre><code>float32_t SensorsAPI::retrieveStoredParameterValue (\n    sensor_t sensor_name,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retrieved: <code>gain</code> or <code>offset</code>. </li> </ul>"},{"location":"core/docs/shield_sensors/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for any linear sensor if default values are not accurate enough. <pre><code>void SensorsAPI::setConversionParametersLinear (\n    sensor_t sensor_name,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. </p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to set conversion values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the sensor raw value. </li> <li><code>offset</code> Offset to be applied (added) to the sensor value after gain has been applied. </li> </ul>"},{"location":"core/docs/shield_sensors/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void SensorsAPI::setConversionParametersNtcThermistor (\n    sensor_t sensor_name,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. </p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to set conversion values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge divider resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"core/docs/shield_sensors/#function-setownvertertempmeas","title":"function setOwnverterTempMeas","text":"<p>This function sets the GPIOs attached to the MUX to control which temperature sensor will be measured. <pre><code>void SensorsAPI::setOwnverterTempMeas (\n    ownverter_temp_sensor_t temperature_sensor\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>temperature_sensor</code> Name of the temperature sensor to trigger: <code>TEMP_1</code>, <code>TEMP_2</code>, <code>TEMP_3</code></li> </ul> <p>Note:</p> <p>This function will decide which value will be read automatically by the ADC2 to which the temperature of the Ownverter is linked.</p> <p>The logic is:</p> <ul> <li><code>TEMP_1: IN1 = T IN2 = F</code></li> <li><code>TEMP_2: IN1 = F IN2 = T</code></li> <li><code>TEMP_3: IN1 = T IN2 = T</code></li> </ul> <p>Please refer to the OwnVerter documentation and repository for more details </p>"},{"location":"core/docs/shield_sensors/#function-settwistsensorsusercalibrationfactors","title":"function setTwistSensorsUserCalibrationFactors","text":"<p>Manually set parameters values using console. You will be directed via console to input the parameters of each sensor of the Twist board. <pre><code>void SensorsAPI::setTwistSensorsUserCalibrationFactors () \n</code></pre></p> <p>After the parameters have been set, they will be stored in Spin Non-Volatile memory so that they are automatically applied on subsequent boots.</p> <p>Note:</p> <p>This function requires a console to interact with the user. </p> <p>Note:</p> <p>This function can NOT be called before all Twist sensors have been enabled (you can use enableDefaultTwistSensors() for that purpose).</p> <p>The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task. </p>"},{"location":"core/docs/shield_sensors/#function-storeparametersinmemory","title":"function storeParametersInMemory","text":"<p>Use this function to write the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t SensorsAPI::storeParametersInMemory (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function should be called after updating the parameters using setParameters.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to save the values. </li> </ul>"},{"location":"core/docs/shield_sensors/#function-triggertwisttempmeas","title":"function triggerTwistTempMeas","text":"<p>Manually triggers the temperature measurement of the Twist board. <pre><code>void SensorsAPI::triggerTwistTempMeas (\n    sensor_t temperature_sensor\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>temperature_sensor</code> Name of the temperature sensor to trigger: <code>TEMP_SENSOR_1</code>, <code>TEMP_SENSOR_2</code></li> </ul> <p>Note:</p> <p>This function must be called to trigger a conversion of the ADC to which the sensor is linked.</p> <p>It must be called <code>BEFORE</code> reading a new measurement.</p> <p>Account for delays in the measurement. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"core/docs/spin_dac/","title":"DAC","text":"<p>A Digital-to-Analog Converter (DAC) transforms digital signals into analog signals by mapping digital values to specific voltages. This process effectively creates continuous analog waveforms from discrete digital data. DACs play a vital role in electronic systems by enabling the generation of diverse waveforms.</p>"},{"location":"core/docs/spin_dac/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>1. First start by calling the initialization function of the DAC <code>spin.dac.initConsValue(DAC_NUM)</code>.  2. Second enter the integer value to send to the DAC <code>spin.dac.setConstValue(DAC_NUM, DAC_CHAN, DAC_VALUE)</code> </p> <p>Example</p> <pre><code>spin.dac.initConstValue(2); // DAC 2 initialization\nspin.dac.setConstValue(2, 1, 2048);\n</code></pre>"},{"location":"core/docs/spin_dac/#conversion-from-numerical-to-analog-value","title":"Conversion from numerical to analog value","text":"<p>The value we can send to the DAC is an integer between 0 and 4096, this value is then converted to voltage between 0 and 2.048V. For example : </p> <p><pre><code>spin.dac.setConstValue(2, 1, 2048);\n</code></pre> Generate a 1.024V signal.</p> <p></p> <p>Example</p> <p>For a pratical example of the DAC see the example :      - Signal generation</p>"},{"location":"core/docs/spin_dac/#api-reference","title":"API Reference","text":""},{"location":"core/docs/spin_dac/#class-dachal","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"core/docs/spin_dac/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src) Update slope compensation settings on a DAC using voltage values. void initConstValue (uint8_t dac_number) Initialize a DAC device in constant output mode. void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value) Set a constant analog output value on a DAC channel. void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage) Configure a DAC to operate in sawtooth waveform mode for current-mode control."},{"location":"core/docs/spin_dac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/spin_dac/#function-currentmodeinit","title":"function currentModeInit","text":"<p>Update slope compensation settings on a DAC using voltage values. <pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre></p> <p>Converts the given voltage values into digital DAC values and sets the DAC's sawtooth waveform reset and step parameters accordingly.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1 or 3). </li> <li><code>peak_voltage</code> The peak voltage value for the sawtooth ramp (reset level). </li> <li><code>low_voltage</code> The valley (starting) voltage of the ramp. </li> </ul>"},{"location":"core/docs/spin_dac/#function-initconstvalue","title":"function initConstValue","text":"<p>Initialize a DAC device in constant output mode. <pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre></p> <p>Configures the specified DAC (1, 2, or 3) to output a constant analog value.</p> <p>This includes setting the value to 0, enabling external output, and starting the DAC.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1, 2, or 3). </li> </ul>"},{"location":"core/docs/spin_dac/#function-setconstvalue","title":"function setConstValue","text":"<p>Set a constant analog output value on a DAC channel. <pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre></p> <p>Writes a raw 12-bit value to the selected DAC channel, provided the DAC is ready.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1, 2, or 3). </li> <li><code>channel</code> The DAC output channel index (usually 1). </li> <li><code>const_value</code> The constant value to set (0\u20134095). </li> </ul>"},{"location":"core/docs/spin_dac/#function-slopecompensation","title":"function slopeCompensation","text":"<p>Configure a DAC to operate in sawtooth waveform mode for current-mode control. <pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre></p> <p>Initializes the DAC to produce a decrementing sawtooth waveform.</p> <p>The DAC is triggered by the selected HRTIM timer unit to synchronize waveform generation with the PWM cycle.</p> <p>Reset and step triggers are selected based on the <code>tu_src</code>.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1 or 3). </li> <li><code>tu_src</code> The HRTIM timer unit (TIMB to TIMF) used for synchronization. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"core/docs/spin_dataAPI/","title":"Data API","text":"<p>Data acquisition is the process of sampling signals that measure real-world physical conditions and converting the resulting samples into digital numeric values that can be manipulated by a computer.</p> <p>In the PowerAPI context, the DataAPI helps the user to easily configure the ADC and retrieve the acquired values.</p> <p>The Data API configures the DMAs to store the ADCs acquisitions for the Spin board, and dispatches them in per-channel buffers that can be read by the user. The module also provides functions to convert the raw values acquired by the sensors into values in the adequate unit.</p> <p>If using a shield such as Twist, a dedicated interface for sensors configuration is made available by the Shield sensors API.</p>"},{"location":"core/docs/spin_dataAPI/#quick-start-with-spin-data-api","title":"Quick start with Spin Data API","text":"<p>Note that if you use a shield on the Spin board, you can use the functions provided by the shield API : <code>shield.sensors</code>, which provides the an API similar as this one, but with also more specialized functions that take into consideration shield specificities: sensors accessible by name rather than by using the pin number, initial conversions factors for raw values adapted depending on the sensors, etc.</p> <p>The Data API is for use only if you do not use a shield, or want to access to a pin that is not connected to a sensor of the shield.</p>"},{"location":"core/docs/spin_dataAPI/#include","title":"Include","text":"<p>Data API is part of Spin API: it is made available by including the <code>SpinAPI.h</code> header. From there, a <code>spin.data</code> object is available to interact with the API.</p> <p>Note</p> <pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#setup-phase","title":"Setup phase","text":"<p>To use Data API, the first stage is to indicate on which pin of the Spin board you want to acquire data. Not all pins can be used for that purpose: the pin must be linked to an ADC. Here is the list of pins that provide ADC capabilities:</p> SPIN v1.1.0SPIN v1.0.0 <p> </p> <p> </p> <p>To indicate that the value of a pin should be acquired, the acquisition must be enabled on this pin in the setup phase. This can be done using the <code>enableAcquisition()</code> function:</p> <p>Note</p> <pre><code>// Pins connected to a single ADC:\nspin.data.enableAcquisition(35); // Enable acquisition on pin 35 (will use ADC 2)\nspin.data.enableAcquisition(12); // Enable acquisition on pin 12 (will use ADC 5)\n// Pins connected to multiple ADCs:\nspin.data.enableAcquisition(5, ADC_4); // Acquisition on pin 5 using ADC 4\nspin.data.enableAcquisition(31); // Acquisition on pin 31 (will use ADC 1 by default)\n</code></pre> <p>Note that providing the ADC number is not required. For pins connected to multiples ADC, the ADC with the lowest number will be used if no ADC is specified. Specifying an ADC number that is not available on the pin will result in an error.</p> <p>By default, the acquisitions are software-triggered, which means that when your program will want to acquire a measure, you'll have to trigger the acquisition. Other means of triggering the measure exists, notably periodic acquisitions, see detailed information. If you need to change the trigger source, this must be done at this point.</p> <p>At the end of all the hardware configuration (including other modules), the Data API must be started using the <code>start()</code> function. Note that in case you use an uninterruptible task, you do not need to start the Data API manually, this will be done automatically when the uninterruptible task is started.</p>"},{"location":"core/docs/spin_dataAPI/#obtaining-data","title":"Obtaining data","text":"<p>After the Data API has been started, it becomes possible to get data obtained from the enabled pins. Depending on the trigger source (see detailed section below), you'll have to trigger the acquisition then read the value, or directly read the value.</p> <p>If software-trigged is used for an ADC (default configuration), the acquisition must first be triggered, then the value read. If the acquisition is configured to be periodic for ann ADC, directly read the value.</p> <p>Note</p> Sofware-triggered acquisitionPeriodic acquisition <pre><code>spin.data.triggerAcquisition(ADC_2); // Trigger acquisitions of all pins linked to ADC 2\nspin.data.getLatestValue(35); // Get value read on pin 35\n</code></pre> <pre><code>spin.data.getLatestValue(35); // Get value read on pin 35\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#advanced-usage","title":"Advanced usage","text":"<p>The above procedure is only for basic usage. Data API has other capabilities that can be configured.</p>"},{"location":"core/docs/spin_dataAPI/#controlling-the-conversion","title":"Controlling the conversion","text":"<p>By default, the raw acquired values are provided, except if the board was calibrated.</p> <p>Raw ADC values</p> <ul> <li>ADC resolution is 12 bit: the value ranges from 0 to 4096</li> <li>Sensing full scale: 0 V to 2.048 V</li> <li>The returned value is then linear, from 0 for 0 V to 4096 for 2.048 V</li> </ul> <p>You can edit the conversion factors by calling one of the <code>spin.data.setConversionParameters***()</code> functions. E.g. <code>setConversionParametersLinear(35, 2, -0.1);</code> will set the conversion parameters for pin 35 to <code>Linear</code>, with a gain of <code>2</code> and an offset of <code>-0.1</code>.</p>"},{"location":"core/docs/spin_dataAPI/#obtaining-all-the-acquired-data","title":"Obtaining all the acquired data","text":"<p>When using <code>getLatestValue()</code>, only the latest acquired value for the pin is returned, already converted using conversion parameters set for the pin (if any has been configured).</p> <p>If you need more precision, you can get all values acquired on a pin since the previous call to a <code>get</code> function. To do so, use <code>getRawValues()</code>, to obtain all values without any conversion or <code>getValues()</code> to obtain values after conversion. Warning: using the <code>getValues()</code> function will convert values on-the-fly. This can be long depending on the number of values to be converted and the type of conversion.</p> <p>These function act similarly, except for the conversion part: they are called with two parameters, the first one is an input parameter indicating which pin you want data from, and the second is an output parameter, a uint32_t whose value will be updated by the function to indicate how many values are available. The function returns an array that has to be stored in a pointer variable.</p> <p>Note</p> Using the converted valuesUsing the raw values <pre><code>// Declare a variable for the output parameter:\nuint32_t valuesCount;\n// Get the values: array of float32_t for converted values\nfloat32_t* array = spin.data.getValues(35, valuesCount);\n\n// Access the values:\nfor (int i = 0 ; i &lt; valuesCount ; i++)\n{\n    // Do something with array[i]\n}\n</code></pre> <pre><code>// Declare a variable for the output parameter:\nuint32_t valuesCount;\n// Get the values: array of float32_t for converted values\nuint16_t* array = spin.data.getRawValues(35, valuesCount);\n\n// Access the values:\nfor (int i = 0 ; i &lt; valuesCount ; i++)\n{\n    // Do something with array[i]\n    // E.g. you can use the conversion function\n    float32_t convertedValue = spin.data.convertValue(35, array[i]);\n}\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#channel-sequence","title":"Channel sequence","text":"<p>Each ADC unit can measure multiple analog signal. This works by defining an acquisition sequence.</p> <p>Tip</p> <p>By default the aquisition sequence is in continuous mode. It means than one trigger will trigger all the sequence of acquisition. This can be changed using Discontinuous Mode</p> <p>Example</p> 3 channels on ADC1 <p><pre><code>spin.adc.enableAcquisition(2, ADC_1)\nspin.adc.enableAcquisition(3, ADC_1)\nspin.adc.enableAcquisition(1, ADC_1)\n</code></pre> In this example, for each trigger action, the ADC1 will measure channel 2, then channel 3, then channel 1.</p> Single channel <p><code>spin.adc.enableChannel(1, ADC_1)</code></p> <p>In this example, for each trigger, the ADC1 will measure channel 1.</p> <p>Note</p> <p>The sequence order is given by the order in which the <code>spin.adc.enableChannel()</code> function is called. E.g., in the above case, the acquisition order would be pin 2, then 3, then 1.</p>"},{"location":"core/docs/spin_dataAPI/#continuous-discontinuous-sequence","title":"Continuous / Discontinuous sequence","text":"<p>Note</p> <p>This is relevant if more than one measurement is taken with the same ADC.</p> Continuous sequenceDiscontinuous sequence  <p> All enabled pins for the ADC are acquired at each trigger</p> <pre><code>    spin.data.configureDiscontinuousMode(ADC_1, 0);\n</code></pre> <p> Only acquire one pin in the sequence at each trigger. The next trigger will acquire the next pin in the sequence, etc.</p> <pre><code>    spin.data.configureDiscontinuousMode(ADC_1, 1);\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#triggering-the-acquisition","title":"Triggering the acquisition","text":"<p>The data acquisition can be triggered by two sources: - software trigger: you will have to explicitely call <code>spin.data.triggerAcquisition()</code> to trigger an acquisition. - event-based: the trigger is automatically done in sync with the PWM generation.</p>"},{"location":"core/docs/spin_dataAPI/#software-triggered","title":"Software triggered","text":"<p>A software trigger for an ADC is a command or signal generated by the software to start the ADC conversion process. Instead of using a hardware signal or event to initiate the conversion, the ADC is triggered by software instructions, allowing for precise control and synchronization with other software processes or events. For example this trigger command can be generated from a high speed control task.</p> <pre><code>spin.data.configureTriggerSource(ADC_2, TRIG_SOFTWARE); // ADC 2 configured in software mode\nsing.data.triggerAcquisition(ADC_2); // Send an adc trigger to ADC2 to start conversion\nadc_value = data.getLatest(35); // Get the acquired data\n</code></pre> <p>Example</p> <p>See the following example for an application :</p> <ul> <li>Software trigerred ADC</li> </ul>"},{"location":"core/docs/spin_dataAPI/#synchronous-with-pwms","title":"Synchronous with PWMs","text":"<p>Software triggers is generally speaking not suitable for applications that requires precise timing. Sometimes measurement have to be taken at a specific time, in interaction with the control signal.</p> <p>Info</p> <p>This kind of acquisition have a side benefit. It operates in the background and does not interfer with software. It means that periodical sampling will not interrupt code execution.</p> <p>The trigger is the PWM peripheral, the ADC performs the conversion and place the result in an output buffer, the output buffer is directly placed in memory by a DMA. A rather complex software mechanics execute periodically and serve each measurement in a dedicated memory space. The periodical routine is executed at the beggining of the controlTask.</p> <p>Info</p> <p>Synchronous measurement require having a controlTask running.</p> <p>The section below explain how to synchronize measurements with control signals.</p>"},{"location":"core/docs/spin_dataAPI/#advanced-usage-of-pwm-triggered-acquisition","title":"Advanced usage of PWM-triggered acquisition","text":"<p>The PWM-triggered acquisition can be further configured.</p>"},{"location":"core/docs/spin_dataAPI/#the-different-event-and-trigger-of-adchrtim","title":"The different event and trigger of ADC/HRTIM","text":"<p>Configuring PWM as the source trigger for ADC conversion is done in two steps: - Indicating to Data API that the PWM will be the trigger source, - Setting which timing unit will trigger the conversion.</p> <pre><code>spin.data.configureTriggerSource(ADC_1, TRIG_PWM);\nspin.pwm.setAdcTrigger(PWMA, ADC_1);\n</code></pre> <p>The PWM is produced by a carrier (see here) by using a comparator to compare a specific constant value with the carrier. We can generate an event when enabling a trigger on the PWM. For instance :</p> <pre><code>spin.pwm.setAdcTrigger(PWMA, ADC_1);\nspin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p>We are enabling and linking ADC_1 to PWMA. That means that when the comparator value and the carrier value of the PWMA are equal, we can generate an event that can be used to start an ADC conversion :</p> <p></p> <p>The comparator value can be adjusted using the function <code>spin.pwm.setAdcTriggerInstant(PWMA, 0.5)</code>. For example, setting it to 0.5 means triggering an event halfway through the switching period, initiating an ADC conversion.</p>"},{"location":"core/docs/spin_dataAPI/#source-adc-and-pwm-channel","title":"Source ADC and PWM channel","text":"<p>ADC1 and ADC2 can be associated with PWM channels at will.</p> ADC1 and PWMAADC1 and PWMC <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMC, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMC);\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#modulation-impact","title":"Modulation impact","text":"<p>Note</p> <p>Hardware trigger depends on PWM modulation.</p> Left Aligned ModulationCenter aligned modulation <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#rising-edge-falling-edge","title":"Rising Edge / Falling edge","text":"<p>Note</p> <p>This only applies to center aligned modulation.</p> Rising EdgeFalling Edge <p></p> <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\n    spin.pwm.setAdcTrigger(PWMA, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_down);\n    spin.pwm.setAdcTrigger(PWMA, ADC_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#measurment-trigger-instant","title":"Measurment trigger instant","text":"<p>Trigger timing can be defined or changed dynamically.</p> 20% Duty cycle80% Duty cycle <p></p> <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.2);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.8);\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#number-of-pwm-period-between-acquisition","title":"Number of PWM period between acquisition","text":"<p>Note</p> <p>This is relevant if more than one measurement is taken with the same ADC.</p> With 2 periodsWith 4 periodsWithout interuptions <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 2);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 4);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 1);\n</code></pre> <p>Example</p> <p>see the following example for an application :</p> <ul> <li>PWM trigerred ADC</li> </ul>"},{"location":"core/docs/spin_dataAPI/#deeper-understanding-of-data-api","title":"Deeper understanding of Data API","text":""},{"location":"core/docs/spin_dataAPI/#data-dispatching","title":"Data dispatching","text":"<p>When using the control task (critical task) data are dispatched at the start, which means there are ready to be retrieved by the <code>get***()</code> functions.</p> <p></p> <p>Data dispatching is an internal mechanism of Data API, that transfers Data from the internal buffers controlled by the DMA to user-level buffers that can be retreived by the <code>get***()</code> functions. If dispatching is not done, the user will not be able to retrive values, and the <code>get***()</code> functions will return no value.</p> <p>The dispatch is done automatically and the in most cases, the user does not have to worry about it. However, in some cases, the user may want to know when this is done.</p> <p>If you use an uninterruptible task to manage the converter on a fast loop, the dispatch is automatically done just before each call of the task.</p> <p>If you do not have an uninterruptible task however, then the dispatch will be done once all enabled acquisitions for an ADC have been done. This means that if you configure ADC 1 with one acquisition and ADC 3 with two acquisitions, the data for a pin controlled by the ADC 1 will be available at each acquisition, while the data for a pin controlled by the ADC 3 will only be available every time it has acquired two values.</p>"},{"location":"core/docs/spin_dataAPI/#api-start","title":"API start","text":"<p>The Data API must be started after all configuration has been carried out. However, in most common cases, this will happen automatically. If you use an uninterruptible task to manage the converter on a fast loop, the Data API is automatically started when the task is started.</p> <p>The cases where you have to manually start the Data API are the following: * No uninterruptible task defined in the program, * An uninterruptible task is defined, but its start function is called with a value <code>false</code> for its parameter.</p> <p>The second case is only used in advanced scenarios where the user want full control over Data API.</p> <p>If you use Data API in one of these cases, the Data API must be started using the <code>start()</code> function. This call must only be made at the end of all the hardware configuration (including other modules).</p>"},{"location":"core/docs/spin_dataAPI/#initialization-sequence","title":"Initialization sequence","text":"<p>If you want specific ADC behavior (trigger sources, discontinuous mode, etc.), you will want to configure set these configurations before starting the API.</p> <p>After channels have been enabled, the conversion parameters can be set so that raw values can be automatically converted to the relevant unit. This is done using the <code>spin.data.setParameters()</code> function.</p> <p>After channels have been enabled (and optionnally conversion parameters have been set), there are two ways of starting the API, depending on your use of other OwnTech APIs. If your code uses an uninterruptible task, nothing more is required, the Data API will be started automatically when task is started. However, if you do not have an uninterruptible task in your code, you need to manually start the API by calling <code>spin.data.start()</code>.</p> <p>Note</p> Software triggeredHardware triggered <ol> <li>Enable acquisition on the pins you want: <code>spin.data.enableAcquisition()</code></li> <li>Define acquisition conversion parameters, e.g. using <code>spin.data.setConversionParametersLinear()</code></li> <li>Start data dispatching <code>spin.data.start()</code></li> <li>Trigger an initial adc conversion <code>spin.data.triggerAcquisition(ADCx)</code></li> <li>Retrieve values : <code>spin.data.getLatestValue()</code> or <code>spin.data.getRawValues()</code></li> </ol> <ol> <li>Make sure PWM engine is initialized</li> <li>Enable acquisition on the pins you want: <code>spin.data.enableAcquisition()</code></li> <li>Define acquisition conversion parameters, e.g. using <code>spin.data.setConversionParametersLinear()</code></li> <li>Start data dispatching <code>spin.data.start()</code></li> <li>Retrieve values : <code>spin.data.getLatestValue()</code> or <code>spin.data.getRawValues()</code></li> </ol> <p>Example</p> Software triggered ADCHardware triggered ADC <pre><code>spin.data.enableAcquisition(5, ADC_1); // Enable acquisition on pin 5 using ADC 1\nspin.data.start();\nspin.data.triggerAcquisition(ADC_1); // Trigger acquisition for ADC 1\nfloat32_t adc_value = spin.data.getLatestValue(5); // Get latest value acquired for pin 5\n</code></pre> <pre><code>/* PWM unit initialization */\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n\n/* ADC initialization */\nspin.data.configureTriggerSource(ADC_1, TRIG_PWM); // ADC 1 ; HRTIM event 1\nspin.data.configureDiscontinuousMode(ADC_1, 1); // ADC 1 ; acquire 1 pin at each event\nspin.data.enableAcquisition(5, ADC_1); // Pin 5 using ADC 1\nspin.data.start();\nfloat32_t adc_value = data.getLatestValue(5); // Pin 5\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#retrieving-latest-value","title":"Retrieving latest value","text":"<p>Getting the latest measured value to feed the control algorithm is super simple.</p> <p>Example</p> Get latest value <p><pre><code>spin.data.getLatest(5)\n</code></pre> This will retrieve the latest sampled value of ADC 1 pin 5.</p>"},{"location":"core/docs/spin_dataAPI/#getting-values-with-the-right-unit","title":"Getting values with the right unit","text":"<p>DataAPI contains commodity functions to convert the raw binary measurement values in meaningful units.</p> <p>Example</p> Converting in volts <pre><code>spin.data.setParameters()\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#get-an-array-of-values","title":"Get an array of values","text":"<p>DataAPI contains commodity function to retrieve an array of raw values that can be fed to a post processing filter.</p> <p>Example</p> Retrieve 5 values <pre><code>spin.data.getRawValues()\n</code></pre>"},{"location":"core/docs/spin_dataAPI/#class-dataapi","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p> <p>More...</p> <ul> <li><code>#include &lt;DataAPI.h&gt;</code></li> </ul>"},{"location":"core/docs/spin_dataAPI/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (adc_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. void configureTriggerSource (adc_t adc_number, trigger_source_t trigger_source) Change the trigger source of an ADC. float32_t convertValue (uint8_t pin_number, uint16_t raw_value) Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data (Volts, Amperes, or Degree Celsius). int8_t enableAcquisition (uint8_t pin_number, adc_t adc_number=DEFAULT_ADC) This function is used to enable acquisition on a Spin PIN with a given ADC. conversion_type_t getConversionParameterType (uint8_t pin_number) Use this function to get the current conversion type for the chosen channel. float32_t getConversionParameterValue (uint8_t pin_number, parameter_t parameter_name) Use this function to get the current conversion parameters for the chosen channel . float32_t getLatestValue (uint8_t pin_number, uint8_t * dataValid=nullptr) This function returns the latest acquired measurement. uint16_t * getRawValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t * getValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t peekLatestValue (uint8_t pin_number) Function to access the latest value available from a pin. int8_t retrieveConversionParametersFromMemory (uint8_t pin_number) Retrieved previously configured conversion parameters from persistent memory. void setConversionParametersLinear (uint8_t pin_number, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setConversionParametersNtcThermistor (uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t stop () Stops the module if it is started. int8_t storeConversionParametersInMemory (uint8_t pin_number) Store the currently configured conversion parameters of a given channel in persistent memory. void triggerAcquisition (adc_t adc_number) Triggers an acquisition on a given ADC."},{"location":"core/docs/spin_dataAPI/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"core/docs/spin_dataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/spin_dataAPI/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. <pre><code>void DataAPI::configureDiscontinuousMode (\n    adc_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Note:</p> <p>This is an advanced function that requires to understand the way the ADC work.</p> <p>Only for use if you explicitly requires it.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. <pre><code>void DataAPI::configureTriggerSource (\n    adc_t adc_number,\n    trigger_source_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-convertvalue","title":"function convertValue","text":"<p>Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data (Volts, Amperes, or Degree Celsius). <pre><code>float32_t DataAPI::convertValue (\n    uint8_t pin_number,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit.  </p>"},{"location":"core/docs/spin_dataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t pin_number,\n    adc_t adc_number=DEFAULT_ADC\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisition: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before Data API is started.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the Spin pin on which to enable acquisition. </li> <li> <p><code>adc_number</code> Number of the ADC on which acquisition is to be done.   This parameter can be omitted, in which case:</p> </li> <li> <p>If only one ADC is linked to the given pin, it will be selected.</p> </li> <li>If two ADCs are available for acquisition on the given pin, the ADC with the lowest number will be selected.</li> </ul> <p>Returns:</p> <p><code>0</code> if acquisition was correctly enabled, <code>-1</code> if there was an error.</p> <p>Errors generally indicate that the given pin is not linked to and ADC, and thus can not be used for acquisition.</p> <p>If the adc_number parameter was explicitly provided, it can also indicate that the given ADC is not available for acquisition on the provided pin.</p> <p>Public functions accessible only when using a power shield </p>"},{"location":"core/docs/spin_dataAPI/#function-getconversionparametertype","title":"function getConversionParameterType","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::getConversionParameterType (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Returns the type of conversion of the given pin.  </p>"},{"location":"core/docs/spin_dataAPI/#function-getconversionparametervalue","title":"function getConversionParameterValue","text":"<p>Use this function to get the current conversion parameters for the chosen channel . <pre><code>float32_t DataAPI::getConversionParameterValue (\n    uint8_t pin_number,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>parameter_name</code> Paramater to be retrieved: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter.  </p>"},{"location":"core/docs/spin_dataAPI/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measurement. <pre><code>float32_t DataAPI::getLatestValue (\n    uint8_t pin_number,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.getRawValues() function for the matching channel, as data.getLatestValue() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. </li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel.  </p>"},{"location":"core/docs/spin_dataAPI/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>The count of these values is returned as an output parameter. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use data.convertValue() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored.  </p>"},{"location":"core/docs/spin_dataAPI/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>float32_t * DataAPI::getValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored.  </p>"},{"location":"core/docs/spin_dataAPI/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from a pin. <pre><code>float32_t DataAPI::peekLatestValue (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel.  </p>"},{"location":"core/docs/spin_dataAPI/#function-retrieveconversionparametersfrommemory","title":"function retrieveConversionParametersFromMemory","text":"<p>Retrieved previously configured conversion parameters from persistent memory. <pre><code>int8_t DataAPI::retrieveConversionParametersFromMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved,   negative value if there was an error:</p> <ul> <li><code>-1</code>: persistent memory is empty</li> <li><code>-2</code>: persistent memory contains data, but its version doesn't match current version</li> <li><code>-3</code>: data in persistent memory is corrupted</li> <li><code>-4</code>: persistent memory contains data, but not for the requested pin</li> <li><code>-5000</code>: pin not found. </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersLinear (\n    uint8_t pin_number,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersNtcThermistor (\n    uint8_t pin_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge divider resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually:</p> <p>It will instead start automatically at the same time as the task as their internal behavior is intrinsically linked.</p> <p>If, for some reason, you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task.</p> <p>In that case, Data Acquisition must be manually started using this function.</p> <p>Note that in that case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out.</p> <p>No ADC configuration change is allowed after module has been started.</p> <p>If you're using a power shield and are not sure how to initialize ADCs, you can use data.enableShieldDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function.</p> <p>Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error Error is triggered when dispatch method is set to be external, but the repetition value has not provided.</p> <p>Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"core/docs/spin_dataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"core/docs/spin_dataAPI/#function-stop","title":"function stop","text":"<p>Stops the module if it is started. <pre><code>int8_t DataAPI::stop () \n</code></pre></p> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error.  </p>"},{"location":"core/docs/spin_dataAPI/#function-storeconversionparametersinmemory","title":"function storeConversionParametersInMemory","text":"<p>Store the currently configured conversion parameters of a given channel in persistent memory. <pre><code>int8_t DataAPI::storeConversionParametersInMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly stored, negative value if there was an error:</p> <ul> <li><code>-1</code>: There was an error,</li> <li><code>-5000</code>: pin not found. </li> </ul>"},{"location":"core/docs/spin_dataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. <pre><code>void DataAPI::triggerAcquisition (\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before: </p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"core/docs/spin_gpio/","title":"GPIO","text":"<p>A GPIO, or General Purpose Input/Output, is a pin on a microcontroller or processor that can be programmed to function either as an input or an output. As an input, it can read the state of an external electrical signal, such as a switch or a sensor. As an output, it can send an electrical signal, such as a high or low logic level, to an external component, such as an LED.</p>"},{"location":"core/docs/spin_gpio/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Set the output pinReset the output pinRead the input pin <p>1. Configure the pin in output mode. 2. Set the pin.  </p> <p>1. Configure the pin in output mode. 2. Reset the pin  </p> <p>1. Configure the pin in input mode. 2. Read the pin input.  </p> <p>Example</p> Set the output pinReset the output pinRead the input pin <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.setPin(9);  </p> <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.resetPin(9);  </p> <p>spin.gpio.configurePin(9, INPUT); uint8_t return_gpio = spin.gpio.readPin(9);  </p>"},{"location":"core/docs/spin_gpio/#api-reference","title":"API Reference","text":""},{"location":"core/docs/spin_gpio/#class-gpiohal","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p> <p>More...</p> <ul> <li><code>#include &lt;GpioHAL.h&gt;</code></li> </ul>"},{"location":"core/docs/spin_gpio/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"core/docs/spin_gpio/#detailed-description","title":"Detailed Description","text":"<p>Class definition </p>"},{"location":"core/docs/spin_gpio/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/spin_gpio/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code></li> </ul> <p>Parameters:</p> <ul> <li><code>flags</code> Pin configuration flags. Authorized values: <code>INPUT</code>, <code>INPUT_PULLUP</code>, <code>OUTPUT</code> </li> </ul>"},{"location":"core/docs/spin_gpio/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"core/docs/spin_gpio/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"core/docs/spin_gpio/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"core/docs/spin_gpio/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"core/docs/spin_gpio/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code></li> </ul> <p>Parameters:</p> <ul> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"core/docs/spin_introduction/","title":"Introduction","text":"<p>Spin API is an entry point to access APIs and peripheral HALs dedicated for interaction with the Spin board</p> <p>To work with Spin API, include the following file in your code:</p> <p>Note</p> <pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre>"},{"location":"core/docs/spin_introduction/#detailed-documentation-on-available-api-classes","title":"Detailed documentation on available API classes:","text":"<ul> <li>Data API</li> </ul>"},{"location":"core/docs/spin_introduction/#detailed-documentation-on-hardware-abstraction-layer-classes","title":"Detailed documentation on Hardware Abstraction Layer classes:","text":"<ul> <li>Comparator HAL</li> <li>Digital Analog converter HAL</li> <li>General-Purpose Input Output HAL</li> <li>LEDs HAL</li> <li>PWM HAL</li> <li>Timer HAL</li> <li>UART HAL</li> </ul>"},{"location":"core/docs/spin_introduction/#api-reference","title":"API Reference","text":""},{"location":"core/docs/spin_introduction/#class-spinapi","title":"Class SpinAPI","text":"<p>ClassList &gt; SpinAPI</p> <p>Contains all the elements linked to peripherals of the spin board. </p> <ul> <li><code>#include &lt;SpinAPI.h&gt;</code></li> </ul>"},{"location":"core/docs/spin_introduction/#public-static-attributes","title":"Public Static Attributes","text":"Type Name CompHAL comp Contains all the function of the STM32 comparator used with the current mode. DacHAL dac Contains all the function of the STM32 DAC used to generate signals and handle the current mode. DataAPI data Data acquisition from SPIN ADCs. GpioHAL gpio Contains all the functions for the spin gpio. LedHAL led Contains all the function of the embedded LED. PwmHAL pwm Contains all the function of the STM32 hrtim PWM generator. TimerHAL timer Contains all the function of the STM32 Timer4 functions that handle the encoder. UartHAL uart Contains all the function of the STM32 Usart1 functions."},{"location":"core/docs/spin_introduction/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"core/docs/spin_introduction/#variable-comp","title":"variable comp","text":"<p>Contains all the function of the STM32 comparator used with the current mode. <pre><code>CompHAL SpinAPI::comp;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-dac","title":"variable dac","text":"<p>Contains all the function of the STM32 DAC used to generate signals and handle the current mode. <pre><code>DacHAL SpinAPI::dac;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-data","title":"variable data","text":"<p>Data acquisition from SPIN ADCs. <pre><code>DataAPI SpinAPI::data;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-gpio","title":"variable gpio","text":"<p>Contains all the functions for the spin gpio. <pre><code>GpioHAL SpinAPI::gpio;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-led","title":"variable led","text":"<p>Contains all the function of the embedded LED. <pre><code>LedHAL SpinAPI::led;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-pwm","title":"variable pwm","text":"<p>Contains all the function of the STM32 hrtim PWM generator. <pre><code>PwmHAL SpinAPI::pwm;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-timer","title":"variable timer","text":"<p>Contains all the function of the STM32 Timer4 functions that handle the encoder. <pre><code>TimerHAL SpinAPI::timer;\n</code></pre></p>"},{"location":"core/docs/spin_introduction/#variable-uart","title":"variable uart","text":"<p>Contains all the function of the STM32 Usart1 functions. <pre><code>UartHAL SpinAPI::uart;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"core/docs/spin_pwm/","title":"PWM","text":"<p>PWM, or Pulse Width Modulation, is a method used in electronics to control the power supplied to devices like motors, LEDs, and heaters. Instead of changing the voltage or current level, PWM changes the amount of time the power is on (the pulse width) compared to the time it's off.</p> <p>In power electronics, PWM is super important because it allows us to control the average power delivered to a load by varying the duty cycle of the pulse. This means we can regulate the speed of motors or the brightness of LEDs.</p>"},{"location":"core/docs/spin_pwm/#features","title":"Features","text":"<ul> <li>Up to 5 pairs of PWMs possible (PWMA, PWC, PWMD, PWME, PWMF)</li> <li>Each PWM unit has a miminum resolution of 184ps.</li> </ul> <p>Note</p> <p>The resolution of a PWM signal defines the maximum number of steps that can be present in a single PWM period. In other words, it determines how finely you can adjust the pulse width of the signal. A higher resolution means you can make smaller and more precise adjustments to the pulse width.</p> <ul> <li>Frequencies in the range of 650Hz to 1Ghz theorically possible. Tests were made from 2kHz up to 10MHz.</li> </ul> <p>Warning</p> <p>Only 200Khz was tested with TWIST</p> <ul> <li>Two different modulation mode possible : left aligned, and center aligned</li> <li>Two ADC linkable to two differents PWM unit for precise measurement instant</li> <li>Compatible for peak current control with the internal analog comparator</li> <li>Positive and negative dead time set via software</li> <li>Phase shift possible for interleaved operations</li> </ul>"},{"location":"core/docs/spin_pwm/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre> Make sure that SPIN API is included to use PwmHAL</p>"},{"location":"core/docs/spin_pwm/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>Function to call before initializing the PWM unit.</p> Software triggeredHardware triggered <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set wich output (1 or 2) will be controlled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 3.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 4.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code></p> <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set ow which edge (up/down) to trigger adc conversion <code>spin.pwm.setAdcEdgeTrigger(PWMx, edgeTrigUp/edgeTrigDwn)</code> 3. Set the division of the number of trigger in a fixed period <code>spin.pwm.setAdcDecimation(PWMx, DecimValue)</code> 4. Set wich output (1 or 2) will be constrolled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 5.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 6.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code></p> <p>Note</p> <p>Function to call after initializing PWM unit.</p> Software triggeredHardware triggered <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code></li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code></li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code></li> <li>if ADC hardware triggered : follow ADC init sequence</li> </ol> <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code></li> <li>Set wich ADC trigger to link to PWM unit <code>spin.pwm.setAdcTrigger(PWMx, ADCtrig)</code></li> <li>Enable the adc trigger <code>spin.pwm.enableAdcTrigger</code></li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code></li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code></li> <li>if ADC hardware triggered : follow ADC init sequence</li> </ol> <p>Example</p> Software triggeredHardware triggered <pre><code>spin.pwm.initFixedFrequency(frequency);\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre> <pre><code>spin.pwm.initFixedFrequency(frequency);\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/spin_pwm/#how-it-works","title":"How it works","text":"<p>To generate a PWM you need two signals, a variable high frequency signals called the carrier and a constant signal called the duty cycle.</p>"},{"location":"core/docs/spin_pwm/#carrier-signal-and-pwm-resolution","title":"Carrier signal and PWM resolution","text":"<p>The carrier signal is usually a counter in the form of a sawtooth or triangle wave. The frequency of the PWM is given by the max value of that counter. It means that the minimal duty cycle step of phase step, is proportional to the frequency of the signal.</p> <p>Example</p> <p>Here is a counter incrementing from 0 to 27200. </p> <p>The increment between each step is made at the PWM resolution which is here 184ps, so the carrier gets from 0 to 27200 in 5\u00b5s so a frequency of 200kHz. In other words the smallest step is 1/27200 or 0.0037% of the period.</p>"},{"location":"core/docs/spin_pwm/#duty-cycle","title":"Duty cycle","text":"<p>The duty cycle is a constant value compared to the carrier.</p> <p></p> <p>When the carrier is superior to the duty cycle, the logic output is at high level. On the contrary, when the carrier is inferior to the duty cycle the the output logic is low level. A PWM signal is thus a sqarewave signal with a frequency (the switching frequency) being fixed by the carrier.</p> <p>Varying the duty cycle is how to vary the output of the PWM.</p>"},{"location":"core/docs/spin_pwm/#snippet-examples","title":"Snippet examples","text":""},{"location":"core/docs/spin_pwm/#frequency","title":"Frequency","text":"200kHz frequency400kHz frequency <pre><code>    spin.pwm.setFixedFrequency(200000);\n</code></pre> <pre><code>    spin.pwm.setFixedFrequency(400000);\n</code></pre>"},{"location":"core/docs/spin_pwm/#singledual-output","title":"Single/Dual Output","text":"Single OutputSingle Output PWMx2Dual Output <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT1);\n</code></pre> <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT2);\n</code></pre> <pre><code>    spin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/spin_pwm/#duty-cycle_1","title":"Duty Cycle","text":"20% Duty cycle80% Duty cycleHow it works <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.2);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre>"},{"location":"core/docs/spin_pwm/#phase-shift","title":"Phase Shift","text":"<p>Tip</p> <p>PWMA is defined as the phase reference. It can not be phase shifted. If you are not using PWMA, you can define any PWM channel as the reference by setting its phase shift to 0\u00b0 NB: Phase reference is 0\u00b0.</p> 20% Phase Shift80% Phase ShiftHow it works <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  72);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  288);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMA,  288);\n</code></pre>"},{"location":"core/docs/spin_pwm/#dead-time","title":"Dead Time","text":"2% Dead Time8% Dead TimeAsymetric Dead Time leading edgeAsymetric Dead Time trailing edge <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  100);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  100);\n</code></pre>"},{"location":"core/docs/spin_pwm/#modulation-type","title":"Modulation Type","text":"Left AlignedCenter Aligned <pre><code>    spin.pwm.setModulation(PWMA, Lft_aligned);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <pre><code>    spin.pwm.setModulation(PWMA, UpDwn);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <p>Example</p> <p>See this examples for more details :</p> <ul> <li> <p>How to control duty cycle of a PWM unit</p> </li> <li> <p>How to set the trigger instant by linking adc trigger to PWM unit</p> </li> <li> <p>Managing phase shift between two PWM units</p> </li> </ul>"},{"location":"core/docs/spin_pwm/#api-reference","title":"API Reference","text":""},{"location":"core/docs/spin_pwm/#class-pwmhal","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"core/docs/spin_pwm/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void deInitBurstMode () This function deinit burst mode. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. adc_t getAdcTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. uint32_t getFrequencyMax (hrtim_tu_number_t pwmX) This function returns the maximum frequency of the selected timer in Hz. uint32_t getFrequencyMin (hrtim_tu_number_t pwmX) This function returns the minimum frequency of the selected timer in Hz. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint16_t getPeriodMax (hrtim_tu_number_t pwmX) This function returns the maximum period of the selected timing unit. uint16_t getPeriodMin (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. uint32_t getResolutionPs (hrtim_tu_number_t pwmX) This function returns the resolution of the timing unit in picoseconds. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initBurstMode () This function initialize burst mode. void initFixedFrequency (uint32_t fixed_frequency) This function initialize the PWM for fixed frequency applications. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void initVariableFrequency (uint32_t initial_frequency, uint32_t minimal_frequency) This functions initializes the PWM for variable frequency applications. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events.ie. you divide the number of trigger in a fixed period. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, adc_t adc) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setBurstMode (int bm_cmp, int bm_per) This function sets burst mode parameters. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setDutyCycleRaw (hrtim_tu_number_t pwmX, uint16_t duty_cycle) Sets the duty cycle for the selected timing unit using an unsigned integer. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startBurstMode () This function starts burst mode. void startDualOutput (hrtim_tu_number_t pwmX) This function starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopBurstMode () This function stops burst mode. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"core/docs/spin_pwm/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"core/docs/spin_pwm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/spin_pwm/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> <li><code>repetition</code> Number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> Function to call each interupt </li> </ul>"},{"location":"core/docs/spin_pwm/#function-deinitburstmode","title":"function deInitBurstMode","text":"<p>This function deinit burst mode. <pre><code>void PwmHAL::deInitBurstMode () \n</code></pre></p>"},{"location":"core/docs/spin_pwm/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Warning:</p> <p>Call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"core/docs/spin_pwm/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>Rollover mode: <code>EdgeTrigger_up</code>, <code>EdgeTrigger_down</code>, <code>EdgeTrigger_Both</code> </p>"},{"location":"core/docs/spin_pwm/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>adc_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>ADC number: <code>ADC_1</code>,<code>ADC_2</code>,<code>ADC_3</code>,<code>ADC_4</code>,<code>ADC_5</code> or</p> <p><code>UNKNOWN_ADC</code> if the ADC trigger was not configured for this timing unit. </p>"},{"location":"core/docs/spin_pwm/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>eev</code> external event trigger:   <code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getfrequencymax","title":"function getFrequencyMax","text":"<p>This function returns the maximum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getfrequencymin","title":"function getFrequencyMin","text":"<p>This function returns the minimum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>PWM mode: <code>VOLTAGE_MODE</code> or <code>CURRENT_MODE</code> </p> <p>Warning:</p> <p>This function must be called before initializing a timing unit </p>"},{"location":"core/docs/spin_pwm/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>The type of modulation <code>Lft_aligned</code> or <code>UpDwn</code> (center aligned) </p>"},{"location":"core/docs/spin_pwm/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/spin_pwm/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"core/docs/spin_pwm/#function-getperiodmax","title":"function getPeriodMax","text":"<p>This function returns the maximum period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/spin_pwm/#function-getperiodmin","title":"function getPeriodMin","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/spin_pwm/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getresolutionps","title":"function getResolutionPs","text":"<p>This function returns the resolution of the timing unit in picoseconds. <pre><code>uint32_t PwmHAL::getResolutionPs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Note:</p> <p>The resolution of the PWM depends on the prescaler that is automatically calculated when the master unit is initialized.</p> <p>For an HRTIM frequency of =170MHz:</p> <ul> <li><code>PRSCL = 0</code>: <code>fHRTIM x 32 = 4.608 GHz</code> - <code>Res:00184 ps - Min PWM f: 83.00 kHz</code></li> <li><code>PRSCL = 1</code>: <code>fHRTIM x 16 = 2.304 GHz</code> - <code>Res:00368 ps - Min PWM f: 41.50 kHz</code></li> <li><code>PRSCL = 2</code>: <code>fHRTIM x 08 = 1.152 GHz</code> - <code>Res:00735 ps - Min PWM f: 20.80 kHz</code></li> <li><code>PRSCL = 3</code>: <code>fHRTIM x 04 = 0.576 GHz</code> - <code>Res:01470 ps - Min PWM f: 10.40 kHz</code></li> <li><code>PRSCL = 4</code>: <code>fHRTIM x 02 = 0.288 GHz</code> - <code>Res:02940 ps - Min PWM f: 05.20 kHz</code></li> <li><code>PRSCL = 5</code>: <code>fHRTIM x 01 = 0.144 GHz</code> - <code>Res:05880 ps - Min PWM f: 02.60 kHz</code></li> <li><code>PRSCL = 6</code>: <code>fHRTIM / 02 = 0.072 GHz</code> - <code>Res:11760 ps - Min PWM f: 01.30 kHz</code></li> <li><code>PRSCL = 7</code>: <code>fHRTIM / 04 = 0.036 GHz</code> - <code>Res:23530 ps - Min PWM f: 00.65 kHz</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>Returns the switch convention :</p> <ul> <li><code>PWMx1</code>: <code>BUCK</code> convention, switch HIGH</li> <li><code>PWMx2</code>: <code>BOOST</code> convention, switch LOW </li> </ul>"},{"location":"core/docs/spin_pwm/#function-initburstmode","title":"function initBurstMode","text":"<p>This function initialize burst mode. <pre><code>void PwmHAL::initBurstMode () \n</code></pre></p>"},{"location":"core/docs/spin_pwm/#function-initfixedfrequency","title":"function initFixedFrequency","text":"<p>This function initialize the PWM for fixed frequency applications. <pre><code>void PwmHAL::initFixedFrequency (\n    uint32_t fixed_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fixed_frequency</code> frequency to be fixed in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing any timing unit.</p> <p>The frequency will not vary during the operation of the power device.</p> <p>Use it for fixed frequencies only. </p>"},{"location":"core/docs/spin_pwm/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-initvariablefrequency","title":"function initVariableFrequency","text":"<p>This functions initializes the PWM for variable frequency applications. <pre><code>void PwmHAL::initVariableFrequency (\n    uint32_t initial_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>initial_frequency</code> The initial value of the frequency in Hz </li> <li><code>minimal_frequency</code> The minimal value of the frequency in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing any timing unit.</p> <p>The user can vary the frequency during the operation of the power device.</p> <p>This may compromise the resolution of the PWM.</p> <p>You can check your resolution with the getResolutionPS function. </p>"},{"location":"core/docs/spin_pwm/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events.ie. you divide the number of trigger in a fixed period. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>For example if :</p> <ul> <li><code>decimation = 1</code>, nothing changes but with</li> <li><code>decimation = 2</code>, you have twice less adc trigger</li> </ul> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>decimation</code> decimation/post-scaler: a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"core/docs/spin_pwm/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>adc_edge_trigger</code> Rollover mode: <code>EdgeTrigger_up</code>, <code>EdgeTrigger_down</code>, <code>EdgeTrigger_Both</code></li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"core/docs/spin_pwm/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    adc_t adc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>adc</code> ADC number: <code>ADC_1</code>,<code>ADC_2</code>,<code>ADC_3</code>,<code>ADC_4</code>,<code>ADC_5</code> </li> </ul> <p>Warning:</p> <p>Call this function:  </p>"},{"location":"core/docs/spin_pwm/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>trig_val</code> a float value between 0 and 1 </li> </ul>"},{"location":"core/docs/spin_pwm/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>This function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"core/docs/spin_pwm/#function-setburstmode","title":"function setBurstMode","text":"<p>This function sets burst mode parameters. <pre><code>void PwmHAL::setBurstMode (\n    int bm_cmp,\n    int bm_per\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>bm_cmp</code> Number of period of PWM off </li> <li><code>bm_per</code> Total number of PWM period </li> </ul>"},{"location":"core/docs/spin_pwm/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"core/docs/spin_pwm/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"core/docs/spin_pwm/#function-setdutycycleraw","title":"function setDutyCycleRaw","text":"<p>Sets the duty cycle for the selected timing unit using an unsigned integer. <pre><code>void PwmHAL::setDutyCycleRaw (\n    hrtim_tu_number_t pwmX,\n    uint16_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>value</code> duty cycle value as an unsigned integer </li> </ul>"},{"location":"core/docs/spin_pwm/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>eev</code> external event trigger:   <code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </li> </ul> <p>Warning:</p> <p>this function must be called before initializing a timing unit </p>"},{"location":"core/docs/spin_pwm/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step.</p> <p>Use it AFTER the initialization of the timing unit. </p>"},{"location":"core/docs/spin_pwm/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>mode</code> PWM mode: <code>VOLTAGE_MODE</code> or <code>CURRENT_MODE</code></li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing the selected timing unit </p>"},{"location":"core/docs/spin_pwm/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>modulation</code> PWM Modulation: <code>Lft_aligned</code> or <code>UpDwn</code></li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"core/docs/spin_pwm/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> <li><code>repetition</code> Number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"core/docs/spin_pwm/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>shift</code> phase shift value in DEGREES (between <code>-360</code> and <code>360</code>)</li> </ul> <p>Warning:</p> <p>Use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"core/docs/spin_pwm/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li> <p><code>convention</code> PWM Switch to be driven by the duty cycle: </p> </li> <li> <p><code>PWMx1</code>: <code>BUCK</code> convention, switch HIGH</p> </li> <li><code>PWMx2</code>: <code>BOOST</code> convention, switch LOW</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"core/docs/spin_pwm/#function-startburstmode","title":"function startBurstMode","text":"<p>This function starts burst mode. <pre><code>void PwmHAL::startBurstMode () \n</code></pre></p>"},{"location":"core/docs/spin_pwm/#function-startdualoutput","title":"function startDualOutput","text":"<p>This function starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>output</code> output to disable: <code>TIMING_OUTPUT1</code>,<code>TIMING_OUTPUT2</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-stopburstmode","title":"function stopBurstMode","text":"<p>This function stops burst mode. <pre><code>void PwmHAL::stopBurstMode () \n</code></pre></p>"},{"location":"core/docs/spin_pwm/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"core/docs/spin_pwm/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>output</code> output to disable: <code>TIMING_OUTPUT1</code>,<code>TIMING_OUTPUT2</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"core/docs/task_introduction/","title":"Introduction","text":"<p>PowerAPI is meant to deploy easily Real-time programs that must guarantee response within specified time constraints. In that context, scheduling is the action of asigning computing ressources to perform tasks.</p>"},{"location":"core/docs/task_introduction/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;TaskAPI.h&gt;\n</code></pre> Make sure that Task API is included</p>"},{"location":"core/docs/task_introduction/#deploying-a-real-time-control-task","title":"Deploying a real time control task","text":"<p>Having a periodical code execution is key to real time applications. It is easy to spawn one using the TaskAPI.</p>"},{"location":"core/docs/task_introduction/#the-control-task-sources","title":"The control task sources","text":"<p>You can have different source calling the control task.</p> <p>The control task is synchronous, it means that it is called at fixed period. So we need some kind of timer calling the control, this timer is considered as the source. There are two sources : - The PWM carrier - An independant timer</p>"},{"location":"core/docs/task_introduction/#the-pwm-carrier","title":"The PWM carrier","text":"<p>The carrier has a period called the switching period, we can use it to call the control task after a fixed number of switching period.</p> <p></p> <p>On the figure above, the switching period is 5\u00b5s (200Khz) and we call the control every 10 switching cycle so 50\u00b5s (20Khz).</p> <p>Warning</p> <p>There are limitations when using this method :     - You need to start the a PWM to start the control task     - You can only have control period which are multiple of the switching period     - You can not have a control period inferior to the switching period</p> <p>Tip</p> <p>Synchronizing the control task period with PWM period can be usefull when you try to synchronize PWM between several SPIN or TWIST, in that case the control task is also synchronized between the board.</p>"},{"location":"core/docs/task_introduction/#independant-timer","title":"Independant timer","text":"<p>A simple timer not related to the PWM can be used to compute the control task period. We choose one of the MCU timer (the <code>timer 6</code>), to which we give our control period and this timer will call the control task each period.</p> <p></p> <p>Tip</p> <p>With an independant timer you can choose any value in \u00b5s as the control period, there is not the same limitation as the PWM source.</p> <p>Warning</p> <p>The disavantage of such method is that since it is independant from the PWM you can't have synchronization between several control task modules.</p>"},{"location":"core/docs/task_introduction/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Periodic task based on PWM sourcePeriodic task based on Timer6 <p>1. Create the critical task and link it to the function to be called and choose hrtim as the source source. <code>task.createCritical(critical_function, control_period, source_hrtim);</code> 2. Start the critical function.  <code>task.startCritical()</code></p> <p>1. Create the critical task and link it to the function to be called and choose tim6 as the source.  <code>task.createCritical(critical_function, control_period, source_tim6);</code> 2. Start the critical function.  <code>task.startCritical()</code></p> <p>Example</p> 20kHz Periodic task based on PWM10kHz Periodic task based on Timer6 <pre><code>    task.createCritical(my_critical_function, 50, source_hrtim);\n    task.startCritical();\n</code></pre> <pre><code>    task.createCritical(my_critical_function, 100, source_tim6);\n    task.startCritical();\n</code></pre> <p>Tip</p> <p>Having a control Task is required for synchronous measurements to work correctly.</p>"},{"location":"core/docs/task_introduction/#non-time-critical-tasks","title":"Non time critical tasks","text":"<p>In the powerAPI, non time critical tasks are refered as background tasks.</p>"},{"location":"core/docs/task_introduction/#priority-between-critical-and-non-critical-task","title":"Priority between critical and non-critical task","text":"<p>The control task has priority over any other task. It will preempts any background task. The control task can not be preempted. That is why it is also refered as an uninteruptible task.</p> <p></p>"},{"location":"core/docs/task_introduction/#pseudo-periodicity-of-non-critical-task","title":"Pseudo periodicity of non-critical task","text":"<p>Non-critical tasks aren't synchronous, meaning they're not recurring at regular intervals. Instead, they operate in a pseudo-periodic manner: we can temporarily halt them for a specific duration, during which they remain inactive.  Below, in the illustration we suspend the background task for a period of 500ms. After 500ms we can execute again the background task, but we need to end the control task to do that (the critical task is uninteruptible).</p> <p></p>"},{"location":"core/docs/task_introduction/#initialization-sequence_1","title":"Initialization sequence","text":"<p>Note</p> <p>1. Create the background task and link it to the function to be called. <code>task.createBackground(function)</code> 2. Start the background function. <code>task.startCritical()</code></p> <p>Example</p> Spawning a background taskMaking it pseudo periodic <p><pre><code>    void my_background_function(){\n        do_stuff();\n    }\n    task.createBackground(my_background_function);\n</code></pre> In that case <code>do_stuff()</code> will execute continuously each time the processor is not occupied by the critical task.</p> <p><pre><code>    void my_background_function(){\n        do_stuff();\n        suspendBackgroundUs(500);\n    }\n</code></pre> In that case after executing <code>do_stuff();</code> the task will be suspended for 500us and resumed after. It creates a pseudo periodical task, runs every 500us + the time taken to execute <code>do_stuff()</code>.</p>"},{"location":"core/docs/task_introduction/#class-taskapi","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p> <p>More...</p> <ul> <li><code>#include &lt;TaskAPI.h&gt;</code></li> </ul>"},{"location":"core/docs/task_introduction/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critical task. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"core/docs/task_introduction/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"core/docs/task_introduction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/task_introduction/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"core/docs/task_introduction/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critical task. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Note:</p> <p>If the <code>HRTIM</code> is used to trigger the task (which is the default behavior), then the <code>HRTIM</code> must have been configured before calling this function.</p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically.</li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is <code>HRTIM</code>, this value must be an integer multiple of the <code>HRTIM</code> period.</li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the <code>HRTIM</code> is the source, but this optional parameter can be provided to set TIM6 as the source in case the <code>HRTIM</code> is not used or if the task can't be correlated to an <code>HRTIM</code> event. Allowed values are source_hrtim and source_tim6.</li> </ul> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error defining the task.</p> <p>An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"core/docs/task_introduction/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/task_introduction/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"core/docs/task_introduction/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/task_introduction/#function-stopcritical","title":"function stopCritical","text":"<p>Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task. The task can be then resumed by calling startCritical() again. <pre><code>void TaskAPI::stopCritical () \n</code></pre></p>"},{"location":"core/docs/task_introduction/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"core/docs/task_introduction/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"core/owntech/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board for PlatformIO.</p> <p>The <code>boards_dir</code> variable is defined in <code>platformio.ini</code>, making this the board directory for PlatformIO, which will use its file <code>spin.json</code>.</p> <p>Help link: - PlatformIO Custom Boards</p>"},{"location":"core/zephyr/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board and Twist shield for Zephyr.</p> <p>As per location (within <code>Zephyr</code> folder), this is the default board directory for Zephyr OS, which will use its sub-directories <code>arm/spin</code> and <code>shields/twist</code>.</p> <p>Help links: - Zephyr OS Board Porting Guide - Zephyr OS Application Development Custom Board</p>"},{"location":"examples/","title":"Index","text":"<p>Welcome to the owntech examples repository.</p> <p>Here you can find ready to be used example for spin and twist.</p>"},{"location":"examples/#example-for-twist","title":"Example for TWIST","text":"<ul> <li> <p>DC DC topology examples</p> <ul> <li>Buck voltage mode</li> <li>Buck current mode</li> <li>Boost voltage mode</li> <li>Interleaved Buck</li> </ul> </li> <li> <p>Microgrid examples</p> <ul> <li>AC client server</li> <li>AC peer to peer</li> <li>DC client server</li> <li>DC droop</li> </ul> </li> <li> <p>DC AC topology examples</p> <ul> <li>Grid forming</li> <li>Grid following</li> </ul> </li> </ul>"},{"location":"examples/#example-for-spin","title":"Example for SPIN","text":"<ul> <li> <p>ADC use examples</p> <ul> <li>Software trigerred ADC</li> <li>HRTIM trigerred ADC</li> </ul> </li> <li> <p>DAC use examples</p> <ul> <li>Signal generation</li> </ul> </li> <li> <p>LED use examples</p> <ul> <li>Blinky</li> </ul> </li> <li> <p>PWM use examples</p> <ul> <li>PWM duty cycle control</li> <li>PWM phase shift control</li> <li>Multiple PWM operation</li> </ul> </li> <li> <p>TIMER</p> <ul> <li>Incremental encoder</li> </ul> </li> </ul>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/","title":"Triggering measure from ADC via HRTIM trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>The spin uses the stm32G4 MCU, which has a high resolution timer (HRTIM) which can produce high resolution PWM. This example will show you how to use the HRTIM in order to trigger the measures. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#software-setup","title":"Software setup","text":"<p>The HRTIM has 6 differents timer (A,B,C,D,E,F) but you can choose up to two of them to trigger the measures. In this example we'll show you how you can use one of them the timer A.</p> <p>On the picture below, you can see the waveform of the timer A pwm, the carrier, the duty cycle and the colored zone represents the timing where the measures is trigerred. </p> <p> figure 2</p> <p>The measure is triggered with the same frequency as the switching frequency, the measure is done around the trough of the carrier on the positive slope. We will explain here which functions to call to setup the ADC trigger. </p> <p>First of all, we start by initializing the PWMA : </p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMA, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> The function <code>setAdcEdgeTrigger</code> allows us to choose where we want to trigger the measures : on the positive slope (EdgeTrigger_up) of the carrier like in fig.2, or the negative slope (EdgeTrigger_down) of the carrier.</p> <p>After the initialization of the PWM, we can link it to a trigger : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMA, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMA); // enable the trigger\n</code></pre> We are linking PWMA to a trigger, here ADCTRIG_1. There is a total of 4 trigger possible ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4. However, there is only two that works for data acquisition currently : ADCTRIG_1 and ADCTRIG_3.</p> <p><code>setAdcTriggerInstant</code> will set the moment when we trigger a measure with a parameter between 0 (corresponding to the trough of the carrier)and 1 (corresponding to the crest of the carrier). Here we took 0.06, so we'll get the data around the trough of the carrier (as we have seen on fig.2)</p> <p>And finally, we set the ADC2 to be set by the ADCTRIG_1, hrtim_ev1 means hrtim external event 1 which is ADCTRIG_1. </p> <p><pre><code>    spin.adc.configureTriggerSource(2, hrtim_ev1); // ADC 2 configured to be triggered by the PWM\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can also use ADCTRIG_3 to have PWMC trigger another ADC and get another measure. Below, we reproduce the same step but by using the ADC1 channel 2 localized on PA1 (pin number 30).</p> <p>start PWMC :</p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMC, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMC, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMC); // timer initialization\n</code></pre> link ADCTRIG_3 to PWMC : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMC, ADCTRIG_3); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMC, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMC); // enable the trigger\n</code></pre> then set ADC1 channel 5 to be trigerred by ADCTRIG_3 : </p> <pre><code>    spin.adc.configureTriggerSource(1, hrtim_ev3); // ADC 2 configured to be triggered by the PWM\n    data.enableAcquisition(1, 30); // ADC 2 enabled\n</code></pre> <p>Finally you can retrieve data from the ADC : </p> <pre><code>    data.triggerAcquisition(1);\n    adc_value = data.getLatest(1, 30);\n</code></pre>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/","title":"Triggering measure from ADC via software trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>This example will show you how to get measures from the ADC by calling a function that will trigger the measures : this is what we call a software trigger.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#software-setup","title":"Software setup","text":"<p>The ADC 2 is used here, it is initialized like this : </p> <p><pre><code>    spin.adc.configureTriggerSource(2, software); // ADC 2 configured in software mode\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can configure any of the above ADC with same steps.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/DAC/signal_generation/","title":"Generating waveform with DAC","text":"<p>A DAC, or Digital-to-Analog Converter, converts digital signals into corresponding analog signals. It achieves this by assigning digital values to specific voltage, effectively generating continuous analog waveforms from discrete digital data. This functionality makes DACs essential for generating various waveforms in electronic systems.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>An oscilloscope to watch the DAC output</li> </ul> <p>Connect the oscilloscope to gpio PA6 (the DAC output).</p>"},{"location":"examples/SPIN/DAC/signal_generation/#software-setup","title":"Software setup","text":"<p>In this example we will use DAC 2 channel 1 to output a sawtooth signal. </p> <p>We start by initializing the DAC :</p> <pre><code>    spin.dac.initConstValue(2); // DAC 2 initialization\n    spin.dac.setConstValue(2, 1, 0); // Setting DAC 2 channel 1 to 0\n</code></pre> <p>The function <code>setConstValue</code> will convert numerical value (from 0 to 4096) to a voltage (between 0 and 2.048) with the DAC. </p> <p>In the background task (called every 100ms), is increasing the value send to the DAC : </p> <pre><code>    dac_value = (dac_value + 100)%4096;\n    spin.dac.setConstValue(2, 1, dac_value);\n</code></pre> <p>You can also reproduce the same step to use DAC1 channel 1 localized in gpio PA4.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#expected-result","title":"Expected result","text":"<p>You should see a sawtooth on the DAC output.</p>"},{"location":"examples/SPIN/LED/blinky/","title":"Blinking a led","text":"<p>Here is a simple example to start with SPIN : making a led blink.</p>"},{"location":"examples/SPIN/LED/blinky/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> </ul>"},{"location":"examples/SPIN/LED/blinky/#software-setup","title":"Software setup","text":"<p>The led is toggled in the background task called each 1s, which means the leed will blink at the rate of 1s : </p> <pre><code>    spin.led.toggle();\n</code></pre>"},{"location":"examples/SPIN/LED/blinky/#expected-result","title":"Expected result","text":"<p>Visual result : the led should turn on and off. </p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/","title":"Setting the duty cycle","text":"<p>In the context of Pulse Width Modulation (PWM), the duty cycle refers to the proportion of time that a signal is in the \"on\" state compared to the total period of the signal. It represents the percentage of time during which the signal is at its maximum level.</p> <p>In power electronics, such as motor control, power supplies, and voltage regulation, PWM is a widely used technique for controlling the amount of power delivered to a load. The duty cycle of the PWM signal determines the average power delivered to the load. By adjusting the duty cycle, engineers can control the speed of motors, regulate voltage levels, and efficiently manage power consumption.</p> <p>In this example we'll see how to generate a PWM, an control the duty cycle.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with one of them : PWMA.</p> <p> Figure 1</p> <p>PWMA has two complementary channels :</p> <ul> <li>PWMA1 on gpio A8</li> <li>PWMA2 on gpio A9</li> </ul> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#software-setup","title":"Software setup","text":"<p>First we start by initializing the PWMA :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n</code></pre> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe two complementary PWM and their evolution when you increase/decrease the duty cycle.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/","title":"Working with multiple PWM","text":"<p>The spin has a total of 5 PWM channels with 2 complementary output each. In this example, we'll detail how to use each of them.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch :</p> <p>-PWMA1 on gpio A8 -PWMC1 on gpio B12 -PWMD1 on gpio B14 -PWME1 on gpio C8 -PWMF1 on gpio C6</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#software-setup","title":"Software setup","text":"<p>This example is initializing every PWM, and making a phase shift 77\u00b0 (= 360/5\u00b0) as if we working in interleaved mode. See the  phase shift  example for more details.</p> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#expected-result","title":"Expected result","text":"<p>You should observe 5 PWM with a phaseshift of 77\u00b0 between them.</p>"},{"location":"examples/SPIN/PWM/phase_shift/","title":"Phase shifting PWM","text":"<p>Phase shift in Pulse Width Modulation (PWM) refers to the intentional offset of the timing between multiple PWM signals. This offset alters the switching instants of the signals, affecting the distribution of power delivery and minimizing ripple in power electronic systems.</p> <p>Phase shifting PWM is used in interleaved topology for power electronics. In this example we'll show you how setup a phase shift for a 2 leg interleaved configuration for example.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with two of them in phase shifted mode : PWMA and PWMB.</p> <p> Figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch PWMA1 on gpio A8 and PWMC1 on gpio B12.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#software-setup","title":"Software setup","text":"<p>We start by initializing PWMA and PWMC :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    /* PWM A initialization */\n    spin.pwm.initUnit(PWMA); // timer initialization\n    spin.pwm.startDualOutput(PWMA); // Start PWM\n\n    /* PWM C initialization */\n    spin.pwm.initUnit(PWMC); // timer initialization\n    spin.pwm.setPhaseShift(PWMC, 180); // Phase shift of 180\u00b0 for 2 legs interleaved configuration\n    spin.pwm.startDualOutput(PWMC); // Start PWM\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>PWMC is shifted of 180\u00b0 from PWMA.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n    spin.pwm.setDutyCycle(PWMC, duty_cycle);\n</code></pre> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe that PWMC1 is phase shifted of 180\u00b0 from PWMA1 (which means they are complementary).</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/","title":"Using the spin with an incremental encoder","text":"<p>An incremental encoder is a device that converts mechanical motion into digital signals. It typically consists of a rotating disk with evenly spaced slots and a sensor that detects these slots as the disk turns. The sensor generates electrical pulses corresponding to the motion, which can be used to track position, speed, or direction.</p> <p>in this example we'll see how to use an incremental encoder with spin.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>A rotary incremental encoder</li> </ul> <p>Connect output A (clk) to gpio B6 and output B (dt) to gpio B7.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#software-setup","title":"Software setup","text":"<p>We initialize the incremental encoder :</p> <p><pre><code>    spin.timer.startLogTimer4IncrementalEncoder();\n</code></pre> The value from the incremental encoder is updated in the background task (called every 100ms). This value is displayed in the serial monitor.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#expected-result","title":"Expected result","text":"<p>You should see the value in the serial monitor either increasing or decresing depending on how you turning the rotary incremental encoder (clokc-wise or not).</p>"},{"location":"examples/TWIST/DC_AC/grid_following/","title":"Ac current source follower","text":"<p>In this example you need to have a first Twist with the Grid Forming example.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 15 \\Omega\\).</li> </ul> <p>In the second Twist we use a software phase locked loop ( \"PLL\" ). By this way we are synchronised with the grid voltage and we can then inject current with a power factor of one. The current is regulated using a proportional resonant (\"PR\") regulator.</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_following/#import-a-library","title":"Import a library","text":"<p>the \"pll\" and \"pr\" are provided by the OwnTech control library which must be included  in the file <code>platfomio.ini</code>.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#define-a-regulator","title":"Define a regulator","text":"<p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.2F;\nstatic float32_t Kr = 3000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#configure-the-pll","title":"Configure the PLL","text":"<p>You have to define a PLL: <pre><code>static PllSinus pll;\nstatic PllDatas pll_datas;\n</code></pre></p> <p>Then initialize it: <pre><code>float32_t rise_time = 50e-3;\npll.init(Ts, Vgrid_amplitude, f0, rise_time);\n</code></pre></p> <p>and use it: <pre><code>pll_datas = pll.calculateWithReturn(V1_low_value - V2_low_value);\n</code></pre></p> <p>The calculation return a structure with 3 fields:</p> <ol> <li>the pulsation <code>w</code> in [rad/s]</li> <li>the angle <code>angle</code> in [rad]</li> <li>the angle error <code>error</code> in [rad/s]</li> </ol>"},{"location":"examples/TWIST/DC_AC/grid_following/#link-between-voltage-output-and-duty-cycle","title":"Link between voltage output and duty cycle","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#retrieve-recorded-datas","title":"Retrieve recorded datas","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/","title":"Ac Voltage Source","text":"<p>In this example we build an AC voltage source using a Twist and supply a resistor.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 30 \\Omega\\).</li> </ul>"},{"location":"examples/TWIST/DC_AC/grid_forming/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_forming/#import-libraries","title":"Import libraries","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#define-a-regulator","title":"Define a regulator","text":"<p>The voltage regulation will be done by a proportional resonant regulator. This component is provided by the OwnTech control library <code>control_lib</code>.</p> <p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.02F;\nstatic float32_t Kr = 4000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\nstatic float32_t Udc = 40.0F;\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_forming/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#link-between-voltage-reference-and-duty-cycles","title":"Link between voltage reference and duty cycles.","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/","title":"Boost with PID controlled output voltage","text":"<p>A voltage mode boost converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps up voltage levels, making it useful in various electronic devices such as converting photovoltaic panel voltage.</p> <p>This example will implement a voltage mode boost converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (max 10V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import the OwnTech control library with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static Pid pid; // define a pid controller\n\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/","title":"Buck current mode","text":""},{"location":"examples/TWIST/DC_DC/buck_current_mode/#overview","title":"Overview","text":"<p>A buck converter is a type of DC-DC converter used to efficiently regulate voltage levels. It works by converting a higher input voltage to a lower output voltage.</p> <p>Peak current control mode is a technique used in DC-DC converters to regulate the output voltage. In this mode, the converter controls the output voltage by monitoring the peak current flowing through the inductor. During each switching period when the peak current reaches a set limit, the converter switches off. This mode helps maintain stable output voltage by adjusting the duty cycle of the switching signal based on the peak current level, ensuring efficient and reliable power conversion.</p> <p>Currently only buck configuration is supported for current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#control-diagram","title":"Control diagram","text":"<p>The general implementation of the current mode follow this model.</p> <p> Source : STM32 AN5497</p> <p>check stm32 application note for more informations about current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#requirement-and-schematic","title":"Requirement and schematic","text":"<p>You will need :</p> <ul> <li>1 twist</li> <li>A DC power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#code-overview","title":"Code overview","text":"<p>We initialize the leg control in buck current mode with the lines above: </p> <pre><code> /* Initialize buck with current mode*/\n    twist.initAllBuck(CURRENT_MODE);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#important-functions","title":"Important functions","text":"<p>For current mode, there are two specific functions to control the current of both legs.</p> <pre><code>twist.setLegSlopeCompensation(LEG1, 1.4, 1.0);\ntwist.setLegSlopeCompensation(LEG2, 1.4, 1.0);\n</code></pre> <p>It sets in volt the higher and lower point of the sawtooth used for the slope compensation.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/","title":"Buck with PID controlled output voltage","text":"<p>A voltage mode buck converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps down voltage levels, making it useful in various electronic devices like phone battery charger.</p> <p>This example will implement a voltage mode buck converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (20-60V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import control_pid library with src/owntech.ini via the line :</p> <pre><code>lib_deps=\n    control_pid = https://gitlab.laas.fr/owntech/power-api/opalib-control-pid.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>opalib_control_init_interleaved_pid(kp, ki, kd, control_task_period);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static float32_t kp = 0.000215;\nstatic float32_t ki = 2.86;\nstatic float32_t kd = 0.0;\nstatic uint32_t control_task_period = 100;\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/","title":"Interleaved operation","text":""},{"location":"examples/TWIST/DC_DC/interleaved/#overview","title":"Overview","text":"<p>In the case of a two-phase interleaved buck converter, the term \"interleaved\" implies that there are two power stages operating, and they are out of phase by 180 degrees. This means that while one power stage is in its on-state (conducting), the other is in its off-state (non-conducting), and vice versa.</p> <p>The 180-degree phase shift ensures that there is always at least one power stage active, reducing the overall ripple and improving the efficiency of the buck converter. The interleaved operation helps distribute the load more evenly, minimizing the stress on individual components and resulting in a more efficient power conversion process.</p> <p></p> <p></p> <p>This example will implement interleaved operation using the two legs of the TWIST.</p>"},{"location":"examples/TWIST/DC_DC/interleaved/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need :</p> <ul> <li>1 TWIST</li> <li>A DC voltage power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/interleaved/#expected-results","title":"Expected results","text":"<p>The voltage reference is initially 15V, but you can increase/decrease it with the serial monitor with 'u' and 'd' on you keyboard.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/","title":"Client/Server control AC/DC","text":""},{"location":"examples/TWIST/Microgrid/AC_client_server/#overview","title":"Overview","text":"<p>In a dual inverter setup with one inverter designated as the \"SERVER\" and the other as the \"CLIENT,\" the SERVER inverter is responsible for sending a current reference and frequency signal to the CLIENT inverter. The CLIENT inverter, in turn, has the task of tracking the current reference from the SERVER and generating an output current that is in phase with the SERVER.</p> <p>SERVER Inverter Operation:</p> <p>The SERVER inverter is considered the primary control unit in the system. The SERVER inverter sets the output voltage, then it generates a reference signal for both the desired current magnitude (amplitude) and frequency to send to the CLIENT.</p> <p>CLIENT Inverter Operation:</p> <p>The CLIENT inverter receives the current reference and frequency signals from the SERVER. It compares the received current reference with the actual output current it is producing. The CLIENT inverter then adjusts its output voltage and frequency to match the reference signal provided by the SERVER. The goal is to ensure that the current generated by the CLIENT is in sync (in phase) with the current produced by the SERVER.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>you will need :</p> <ul> <li>Two Twist</li> <li>A 40V DC power supply</li> <li>A 30\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#instruction-to-flash-the-code-and-use-python-script","title":"Instruction to flash the code, and use python script","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the server or the client.</p> <p>To flash the server, choose :</p> <pre><code>#define server\n</code></pre> <p>To flash the client, choose :</p> <pre><code>#define client\n</code></pre> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p> <p>There is also a current gain to control the current reference sent to the CLIENT :</p> <pre><code>tx_data.consigne.Iref_fromSERVER = k_gain*I1_low_value;\n</code></pre> <p>This allows you to increase or deacrese the current of the CLIENT. To increase the current gain, in the serial monitor press <code>l</code> to decrease it press <code>m</code>.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#expected-result","title":"Expected result","text":"<p>If you set up correctly the project, you should have server and client output current in phase together.</p> <p></p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/","title":"Peer to peer AC control with an inverter and a synchronous rectifier","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#overview","title":"Overview","text":"<p>Peer-to-peer communication in power electronics involves two converters, a DC/AC converter producing a certain power and informing an AC/DC converter that it can consume this reference power.</p> <p></p> <p>DC/AC Converter (single phase inverter): This converter is responsible for converting direct current (DC) power into alternating current (AC) power. It may be connected to renewable energy sources (such as solar panels or wind turbines) or batteries, which produce DC power. The DC/AC converter's task is to generate AC power for use in the electrical network.</p> <p>AC/DC Converter (single phase synchronous rectifier): This converter performs the opposite function. It converts AC power back into DC power. This conversion is necessary when the electrical network requires DC power for various applications, such as charging batteries or powering DC devices.</p> <p>In a peer-to-peer communication system, these converters communicate with each other to optimize power exchange. The DC/AC converter informs the AC/DC converter of the available power it can deliver. This information includes details like the power's magnitude and frequency.</p> <p>An important aspect of this exchange is that the DC/AC converter must maintain an alternating current in phase opposition (180 degrees phase shift) with the input alternating voltage. This phase opposition ensures that power is effectively delivered to the load.</p> <p>A proportional resonant is used to keep the input alternative current in phase opposition with the Vac, a PI is used to control the output voltage Vdc.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>You will need :</p> <ul> <li>Two Twist</li> <li>A 50V DC power supply (input voltage for the inverter)</li> <li>A 6V DC power supply (external sensors/drivers suply for the synchronous rectifier)</li> <li>A 115\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul> <p>It is important to check that the boards you are using have the correct voltage and current measures since they'll be used to compute the duty cycle.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#instruction-to-flash-the-code-and-view-some-results","title":"Instruction to flash the code, and view some results","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-flash-the-code","title":"To flash the code","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the inverter or the synchronous rectifier.</p> <p>To flash the inverter, choose :</p> <pre><code>#define SERVER\n</code></pre> <p>To flash the synchronous rectifier, choose :</p> <pre><code>#define CLIENT\n</code></pre> <p>Here P_ref = 19W to have a 47V output DC voltage. You can change this value in line 87 of src/main.cpp file.</p> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#expected-results","title":"Expected results","text":"<p>If everything goes well you'll have 47V delivered to the resistor.</p> <p>Here are some results for Vdc and Idc : </p> <p>And for Vac and Iac : </p> <p>By using the python script you can also watch MCU internal variables :</p> <p></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/","title":"Current Control Experiment with Analog Communication - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#overview","title":"Overview","text":"<p>This code example demonstrates a current control experiment utilizing analog communication between a master board and multiple slave boards. The master board operates in voltage control mode and sends current references to the slave boards, which work in current control mode. The goal is to regulate and synchronize current injection into an electrical network.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Two boards are used: a master board and one or more slave boards.</li> <li>The master board generates current references and communicates them to the slave boards via analog communication. Communication Current Mode</li> <li>Synchronization modules ensure coordination of PWM signals between master and slave boards.</li> <li>Compensation control is utilized to equilibrate current between different legs of the system. compensation control</li> </ul> Connexion diagram Microgrid structure <p>To run this example you would need: 1. a Voltage Source fixed at ~30V  2. 2 Twist boards  3. 1 RJ45 cable to make the communication link between boards. 4. A variable resistive load between approximatively 6 and 12 Ohm.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#communication-modules","title":"Communication Modules","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#1-analog-communication","title":"1. Analog Communication","text":"<p>Analog communication facilitates the exchange of peak current references from the master board to the slave boards. This communication allows for current regulation and control within the system.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#2-synchronization","title":"2. Synchronization","text":"<p>Synchronization modules ensure that PWM signals are aligned and coordinated between the master and slave boards. This synchronization is crucial for maintaining accurate current control and injection.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#code-usage","title":"Code Usage","text":"<ol> <li>Upload <code>src/main.cpp</code> to the master board and each slave board.</li> <li>In the <code>main.cpp</code> file, navigate to line 114 to find the macro definition:</li> </ol> <pre><code>#define MASTER\n</code></pre> <p>Replace this macro with one of the following options based on the board you are flashing:</p> <p>For a slave board:    <pre><code>#define SLAVE\n</code></pre></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#example-workflow","title":"Example Workflow","text":"<ol> <li>Master Board Operation:</li> <li>The master board operates in voltage control mode.</li> <li>It generates current references within the 0-4000 range.</li> <li> <p>Using analog communication, it sends these references to the slave board(s).</p> </li> <li> <p>Slave Board Operation:</p> </li> <li>Each slave board operates in current control mode.</li> <li>It continuously monitors the analog communication from the master board.</li> <li>The slave board extracts the current reference and injects it into the electrical network.</li> <li> <p>Compensation control ensures balanced current distribution among the system's legs.</p> </li> <li> <p>Synchronization:</p> </li> <li>The synchronization modules guarantee that PWM signals are coordinated between the master and slave boards.</li> <li>This synchronization is vital for maintaining accurate and synchronized current injection.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#conclusion","title":"Conclusion","text":"<p>This code example showcases a current control experiment that employs analog communication between a master board and multiple slave boards. By following the provided instructions and flashing the appropriate code, you can simulate and observe the regulation and synchronization of current injection into an electrical network. The combination of voltage control, current control, analog communication, and synchronization modules results in an efficient and coordinated system for current regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/","title":"Parallel Power Conversion Experiment - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_droop/#overview","title":"Overview","text":"<p>This code example demonstrates an experiment involving three power converters connected in parallel to power a DC bus without communication. Each converter performs power conversion in buck mode and is programmed with a distinct droop factor (1.2, 1.1, and 1.6 respectively). The experiment aims to explore the behavior of parallel power conversion and observe the impact of different droop factors on the voltage regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Three power converters are connected in parallel to the DC bus.</li> <li>Each power converter operates in voltage control mode and performs power conversion in buck mode.</li> <li>Individual droop factors of 1.2, 1.1, and 1.6 are programmed for the respective cards.</li> </ul> Connexion diagram Microgrid structure"},{"location":"examples/TWIST/Microgrid/DC_droop/#code-usage","title":"Code Usage","text":"<ol> <li>Flash <code>src/main.cpp</code> to each of the power converters.</li> <li>In the <code>main.cpp</code> file, go to line 80 to find the macro definition:</li> </ol> <pre><code>#define DROOP\n</code></pre> <p>Replace this macro with the relevant option for the board you are flashing:</p> <p>For a different board:    <pre><code>#define DROOP1\n</code></pre></p> <p>or</p> <pre><code>#define DROOP2\n</code></pre>"},{"location":"examples/TWIST/Microgrid/DC_droop/#example-workflow","title":"Example Workflow","text":"<ol> <li>Parallel Power Conversion:</li> <li>Three power converters are interconnected in parallel to supply power to the DC bus.</li> <li>Each converter performs power conversion using a buck mode.</li> <li> <p>Individual droop factors (1.2, 1.1, and 1.6) are applied to each converter.</p> </li> <li> <p>Voltage Regulation:</p> </li> <li>Monitor the behavior of the parallel power conversion system and observe how it manages voltage regulation under different conditions.</li> <li>Analyze the role of each card's droop factor in distributing the load and regulating the voltage on the DC bus.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_droop/#conclusion","title":"Conclusion","text":"<p>By following the provided guidelines and uploading the code to the power cards, you can emulate and study the dynamics of parallel power conversion in buck mode. This experiment allows you to investigate the impact of varied droop factors on voltage regulation and observe how the power cards work together in parallel to provide power to the DC bus. The combination of voltage control, buck mode operation, and unique droop factors contributes to an efficient and synchronized power conversion system.</p>"},{"location":"examples/docs/home/","title":"Home","text":"<p>Opening a fully featured example is often the best way to get started.</p> <p>Tip</p> <p>Need help to launch an example ? Here it is !</p>"},{"location":"examples/docs/home/#browse-spin-examples","title":"Browse SPIN examples","text":"<p>Get on track using featured examples : </p> <ul> <li> <p> Blinky</p> <p>Get up and running in minutes</p> <p> Blinky</p> </li> <li> <p> Multiple PWM</p> <p>Lets play, lets do PWMs !</p> <p> Examples</p> </li> </ul> <ul> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> Duty Cycle control  Phase Shift control </p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> Software Triggered Measures  Real Time Measurments</p> </li> </ul>"},{"location":"examples/docs/home/#browse-twist-examples","title":"Browse TWIST examples","text":""},{"location":"examples/docs/home/#dc-to-dc-applications","title":"DC to DC applications","text":"<ul> <li> <p> Buck</p> <p>Good starting point to deploy your first power application. </p> <p> Buck voltage mode </p> <p>Leverage embedded analog hardware, go for current mode !</p> <p> Buck current mode </p> <p>Interleaving, made easy</p> <p> Interleaved Buck </p> </li> <li> <p> Boost</p> <p>Need a boost ? Here you go !</p> <p> Boost voltage mode.</p> </li> </ul>"},{"location":"examples/docs/home/#dc-to-ac-applications","title":"DC to AC applications","text":"<ul> <li> <p> Grid forming Inverter</p> <p>Good starting point to discover AC world. </p> <p> Grid Forming Inverter  </p> </li> <li> <p> Grid Following Inverter</p> <p>Get in sync with the grid !</p> <p> Grid Following Inverter </p> </li> </ul>"},{"location":"examples/docs/home/#microgrid-applications","title":"Microgrid Applications","text":"<ul> <li> <p> DC Droop</p> <p>Sometimes, a simple droop is enough </p> <p> DC Droop  </p> </li> <li> <p> DC with communication</p> <p>Introduction to communication based DC microgrid</p> <p> Client - Server DC </p> </li> <li> <p> AC Client/Server</p> <p>Sharing the load is caring ! </p> <p> AC Client/Server  </p> </li> <li> <p> AC Peer2Peer</p> <p>Doing.. Legal Peer2Peer !</p> <p> AC Peer2Peer </p> </li> </ul>"},{"location":"ownverter/1.0.0/getting_started/","title":"OwnVerter Board Datasheet v1.0.0","text":""},{"location":"ownverter/1.0.0/getting_started/#overview","title":"Overview","text":"<p>The OwnVerter Board is a reprogrammable, 1.3kW three-phase power converter designed primarily for motor control applications. It can interface with Sin-Cos encoders, optical speed sensors, and Hall effect sensors, providing precise feedback control.</p> <p>The OwnVerter Board is fully open-source, compatible with either the SPIN board or other programming systems. It supports communication via CAN-bus or RS-485.</p> <p>Check</p> <ul> <li>Rated Power: 1.3kW</li> <li>Number of Low-Side Channels: <ul> <li>Three Low side </li> <li>Single High side</li> </ul> </li> <li>Current ratings: <ul> <li>20Apk per channel</li> <li>16A in parallel</li> </ul> </li> <li>Voltage Ratings: <ul> <li>12V to 72V low-side</li> <li>12V to 100V high-side</li> </ul> </li> </ul> <p>Attention</p> <ul> <li>3-phase design</li> <li>Tripe, Dual or Single power channel configuration</li> <li>Up to 97% efficiency</li> <li>Standard size: 100mm x 160mm x 35mm</li> <li>Wide voltage operating range</li> <li>Motor control optimized</li> <li>CAN-bus and RS-485 communication compatible</li> <li>Fully open-source</li> <li>BLDC and FOC examples and control library available</li> <li>GitLab Source Code</li> </ul>"},{"location":"ownverter/1.0.0/getting_started/#converter-pinout","title":"Converter Pinout","text":"<p>The OWNVERTER converter pinout is shown in the image below.</p> <p></p> <p>Info</p> <p>Danger</p> <ul> <li>Vhigh is the high side voltage</li> <li>A+/B+/C+ are the low side voltages. They are connected to the motor phases.</li> <li>GND is the power GND </li> <li>Feeder 6V is the 6V output of the embedded feeder</li> <li>D6V is the input of the digital 6V. You can feed it from an outside source.</li> <li>DGND is the digital ground</li> </ul> <p>Success</p> <ul> <li>CAN1 and CAN2 the two pins of the CANBus</li> <li>RS485 +/- the two pins of the RS485 bus.</li> <li>Analog +/- the two pins of the analog bus. </li> <li>Sync I/0 the pin through which boards synchronize. It is the same pin for both master and slave operation.</li> <li>DGND is the digital ground</li> </ul>"},{"location":"ownverter/1.0.0/getting_started/#electrical-specifications","title":"Electrical Specifications","text":""},{"location":"ownverter/1.0.0/getting_started/#absolute-maximum-ratings","title":"Absolute Maximum Ratings","text":"<p>Warning</p> Parameter Min Typ Max Unit Low-Side peak Voltage - - 92 VDC Low-Side RMS Voltage - - 65 VDC High-Side Voltage 8 - 100 VDC Low-Side Peak Current per Channel - - 20 A Low-Side RMS Current per Channel - - 14.14 A Power Output - - 1.3 kW"},{"location":"ownverter/1.0.0/getting_started/#low-side-ratings","title":"Low-Side Ratings","text":"Parameter Min Typ Max Unit Number of Power Channels - - 3 - Voltage Range 12 - 92 VDC (Max Low-Side Peak Current per Channel) - - 20 A"},{"location":"ownverter/1.0.0/getting_started/#high-side-ratings","title":"High-Side Ratings","text":"Parameter Min Typ Max Unit Number of Power Channels - - 1 - Voltage Range 12 - 100 VDC"},{"location":"ownverter/1.0.0/getting_started/#switching-characteristics","title":"Switching Characteristics","text":"Parameter Min Typ Max Unit Switching Frequency - 200 - kHz Selectable Deadtime (20k\u03a9 resistor) - 200 - ns Maximum Gate Current - 4 - A"},{"location":"ownverter/1.0.0/getting_started/#temperature-and-dimensions","title":"Temperature and Dimensions","text":"Parameter Min Typ Max Unit Operating Temperature -20 - +60 \u00b0C Cooling Principle - Natural Convection - - Dimensions (L x W x H) 100 x 100 x 35 - - mm"},{"location":"ownverter/1.0.0/getting_started/#protection-features","title":"Protection Features","text":"Parameter Min Typ Max Unit High-Side Fuse (Tamb = 25\u00b0C) - 25 - A Low-Side Fuse (Tamb = 25\u00b0C) - 25 - A"},{"location":"ownverter/1.0.0/getting_started/#communication-specifications","title":"Communication Specifications","text":""},{"location":"ownverter/1.0.0/getting_started/#can-fd","title":"CAN-FD","text":"Type Parameter Min Typ Max Unit CAN-FD Baudrate 500 500 - kBauds Halh Duplex RS485 Baudrate 10 20 - MBauds SPI Baudrate 0.5 - 20 MBauds USART Baudrate - 115200 - Bauds"},{"location":"ownverter/1.0.0/getting_started/#synchronization","title":"Synchronization","text":"<p>Two OWNVERTER Boards can be synchronized via PWM sinc IN/OUT. Using a 15cm RJ45 cable, the delay and jitter between the server and the client PWM are measured as follows:</p> Parameter Symbol Min Typ Max Unit PWM Slew Rate - 660 - - mV/ns Delay Between Server and Client td - 24.2 - ns Jitter of PWM Client tj - 4.8 - ns <p></p>"},{"location":"ownverter/1.0.0/getting_started/#analog-communication","title":"Analog Communication","text":"<p>Analog communication between boards allows voltage and current measurement with high accuracy.</p> <p>Example Measurement: - A 16-bit value of 2000 is transmitted by a server board. - Step response from 1V to 1.25V measured with a 500 MHz oscilloscope.</p> Parameter Symbol Min Typ Max Unit Step Response Time to \u00b15% \u0394t5% - 1.7 - \u00b5s Steady-State Value Vfinal - 1.25 - V \u00b15% Steady-State Interval \u0394V - 0.125 - V Bandwidth \\(\\(fc = \\dfrac{3}{2\\cdot \\pi \\cdot \\Delta t_{5\\%}}\\)\\) - 281 - kHz <p></p> <p>Statistical Distribution of 10235 data samples </p> Parameter Symbol Min Typ Max Unit Mean \\(\\mu\\) - 2032.65 - Variance \\(\\sigma^2\\) 0.795 - <p></p>"},{"location":"ownverter/1.0.0/getting_started/#measurement-chains","title":"Measurement Chains","text":"<p>The Twist Board implements full observability on all low-side and high-side power channels using isolated measurements.</p>"},{"location":"ownverter/1.0.0/getting_started/#adc-specifications","title":"ADC Specifications","text":"Parameter Value ADC Technology Successive Approximation (SAR) Independent ADC Peripherals 5 Number of Channels per ADC 1 to 6 Sampling Time 530 ns Hardware ADC Trigger Programmable trigger instant on PWM period Number of PWM synchronized ADCs 2 Software ADC Trigger All ADC peripherals Trigger Event Typical Frequency 200 kHz"},{"location":"ownverter/1.0.0/getting_started/#measurement-points","title":"Measurement Points","text":"Measurement Description Sensor Technology Bandwidth (kHz) Signal Side Amplitude Full Scale Range Unit VILow1 Phase A Low-side voltage Voltage divider &amp; isolation amplifier 60 \u00b1250 mV \u00b180 V iILow1 Phase A Low-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b120 A VILow2 Phase B Low-side voltage Voltage divider &amp; isolation amplifier 60 \u00b1250 mV \u00b180 V iILow2 Phase B Low-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b120 A VILow2 Phase C Low-side voltage Voltage divider &amp; isolation amplifier 60 \u00b1250 mV \u00b180 V iILow2 Phase C Low-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b120 A VIHigh High-side voltage Voltage divider &amp; isolation amplifier 100 +2 V 120 V iIHigh High-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b120 A Temp1 LEG1 Temperature NTC Thermistor -40 to +110 \\(\\degree C\\) Temp2 LEG2 Temperature NTC Thermistor -40 to +110 \\(\\degree C\\) Temp3 LEG2 Temperature NTC Thermistor -40 to +110 \\(\\degree C\\) <p>Schematic showing where the measurements are performed on the circuit.</p> <p></p> <p>Info</p> <ul> <li>Voltage sensors - they measure phase voltage of the motor.</li> <li>Low-side Current sensors - they measure phase current of the motor.      Their output is positive when the inverter is in Source mode (current going OUT of the low side). </li> <li>High-side Current sensor - it is connected right after the high-side connector.     Its output is negative when the converter is in BUCK mode (current going IN the high side). </li> </ul> <p>Image showing where the measurements can be accessed on the board. </p> <p></p> <p>Note</p> <p>All measurements have pins which can be easily accessed with a probe (oscilloscope or multimeter) as shown below.</p> <p>Warning</p> <p></p>"},{"location":"ownverter/1.0.0/getting_started/#standard-deviation-of-measurements","title":"Standard Deviation of Measurements","text":"Parameter Not Averaged Avg of 2 Measures Avg of 3 Measures Avg of 5 Measures Avg of 10 Measures VILow1 85 mV 61 mV 50 mV 39 mV 28 mV VILow2 82 mV 58 mV 47 mV 37 mV 27 mV VILow2 82 mV 58 mV 47 mV 37 mV 27 mV VIHigh 150 mV 108 mV 88 mV 68 mV 48 mV IILow1 34 mA 24 mA 20 mA 16 mA 11 mA IILow2 34 mA 24 mA 20 mA 15 mA 11 mA IILow2 34 mA 24 mA 20 mA 15 mA 11 mA IIHigh 14 mA 10 mA 8 mA 6 mA 4 mA"},{"location":"ownverter/1.0.0/getting_started/#relative-accuracy-of-voltage-and-current-measurements","title":"Relative accuracy of voltage and current measurements","text":"<p>The following graphs give the accuracy of the voltage and current measurements for different levels of current and voltage for the TWIST board for reference only. Measurements for the OWNVERTER board are ongoing.</p> <p></p>"},{"location":"ownverter/1.0.0/getting_started/#theoretical-calibration-parameters","title":"Theoretical Calibration Parameters","text":"<p>By default all OWNVERTER boards can be calibrated using the following parameters.</p> Variable Name Gain Offset Unit VLow1 0.05134 -97.868 V VLow2 0.05134 -97.868 V VLow3 0.05134 -97.868 V VHigh 0.029964 0 V ILow1 0.01 -20 A ILow2 0.01 -20 A ILow3 0.01 -20 A IHigh 0.01 20 A"},{"location":"ownverter/1.0.0/getting_started/#typical-applications","title":"Typical Applications","text":"Mode Name High Side Low Side Sensor type Typical Application 3 phase inverter Input Output HAL BLDC Motor"},{"location":"ownverter/1.0.0/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-buck-mode","title":"Example wiring diagram and schematic of the Twist board in Buck mode","text":""},{"location":"ownverter/1.0.0/getting_started/#revision-history","title":"Revision History","text":"Date Revision Changes 07-Fev-2025 1 Initial Release <p>License: Documentation licensed under Creative Commons SA-BY</p>"},{"location":"spin/1.0.0/getting_started/","title":"SPIN V1.0 Documentation","text":"<p>Note</p> <p>This page is version specific. Make sure that your board version matches prior reader further.</p>"},{"location":"spin/1.1.0/getting_started/","title":"SPIN V1.1 Documentation","text":"<p>Note</p> <p>This page is version specific. Make sure that your board version matches prior reader further.</p>"},{"location":"spin/1.2.0/getting_started/","title":"SPIN V1.2 Documentation","text":"<p>Note</p> <p>This page is version specific. Make sure that your board version matches prior reader further.</p>"},{"location":"twist/1.2.0/getting_started/","title":"TWIST V1.2 Documentation","text":"<p>Note</p> <p>This page is version specific. Make sure that your board version matches prior reader further.</p>"},{"location":"twist/1.3.0/getting_started/","title":"TWIST V1.3 Documentation","text":"<p>Note</p> <p>This page is version specific. Make sure that your board version matches prior reader further.</p>"},{"location":"twist/1.4.1/getting_started/","title":"Twist Board Datasheet v1.4.1","text":""},{"location":"twist/1.4.1/getting_started/#overview","title":"Overview","text":"<p>The Twist Board is a reprogrammable, bi-directional 300W power converter. It features a dual 12V to 72V low side and a single 10V to 110V high side. The maximum current per power channel is 8A. The power channels can be used independently, providing two output voltages, or combined to double the current capacity.</p> <p>The Twist Board is fully open-source, compatible with either the SPIN board or other programming systems. It supports communication via CAN-bus or RS-485.</p> <p>Check</p> <ul> <li>Rated Power: 300W</li> <li>Number of Low-Side Channels: <ul> <li>Dual Low side</li> <li>Single High side</li> </ul> </li> <li>Current ratings: <ul> <li>8A per channel</li> <li>16A in parallel</li> </ul> </li> <li>Voltage Ratings: <ul> <li>12V to 72V low-side</li> <li>12V to 100V high-side</li> </ul> </li> </ul> <p>Attention</p> <ul> <li>2-phase design</li> <li>Dual or Single power channel configuration</li> <li>Up to 97% efficiency</li> <li>Standard size: 100mm x 160mm x 35mm</li> <li>Wide voltage operating range</li> <li>DC or AC operation</li> <li>Parallel connection for higher power</li> <li>CAN-bus and RS-485 communication compatible</li> <li>Fully open-source</li> <li>Voltage and current mode libraries available</li> <li>Github Repository</li> </ul>"},{"location":"twist/1.4.1/getting_started/#converter-pinout","title":"Converter Pinout","text":"<p>The TWIST converter pinout is shown in the image below.</p> <p></p> <p>Converter pins</p> <p>Power Pins or feeder pins</p> <ul> <li>Vhigh is the high side voltage</li> <li>Vlow is the low side voltage. There are two channels 1 and 2.</li> <li>GND is the power GND </li> <li>Feeder 6V is the 6V output of the embedded feeder</li> <li>D6V is the input of the digital +6V. You can feed it from an outside source.</li> <li>DGND When feeding from an outside source, connect your ground on the pin next to D6V</li> </ul> <p>Data Pins</p> <ul> <li>CAN1 and CAN2 the two pins of the CANBus</li> <li>RS485 +/- the two pins of the RS485 bus.</li> <li>Analog +/- the two pins of the analog bus. </li> <li>Sync I/0 the pin through which boards synchronize. It is the same pin for both master and slave operation.</li> <li>DGND is the digital ground</li> </ul>"},{"location":"twist/1.4.1/getting_started/#electrical-specifications","title":"Electrical Specifications","text":""},{"location":"twist/1.4.1/getting_started/#absolute-maximum-ratings","title":"Absolute Maximum Ratings","text":"<p>Absolute Maximum Ratings</p> Parameter Min Typ Max Unit Low-Side Voltage - - 90 VDC High-Side Voltage 8 - 110 VDC Low-Side Peak Current per Channel - - 10 A Power Output - - 300 W"},{"location":"twist/1.4.1/getting_started/#low-side-ratings","title":"Low-Side Ratings","text":"Parameter Min Typ Max Unit Number of Power Channels - - 2 - Voltage Range 12 - 72 VDC (Max Low-Side Peak Current per Channel) - - 8 A Voltage Ripple - - 0.3 VDC"},{"location":"twist/1.4.1/getting_started/#high-side-ratings","title":"High-Side Ratings","text":"Parameter Min Typ Max Unit Number of Power Channels - - 1 - Voltage Range 12 - 100 VDC Voltage Ripple - - 0.3 VDC"},{"location":"twist/1.4.1/getting_started/#switching-characteristics","title":"Switching Characteristics","text":"Parameter Min Typ Max Unit Switching Frequency - 200 - kHz Selectable Deadtime (20k\u03a9 resistor) - 200 - ns Maximum Gate Current - 4 - A"},{"location":"twist/1.4.1/getting_started/#temperature-and-dimensions","title":"Temperature and Dimensions","text":"Parameter Min Typ Max Unit Operating Temperature -20 - +60 \u00b0C Cooling Principle - Natural Convection - - Dimensions (L x W x H) 100 x 100 x 35 - - mm"},{"location":"twist/1.4.1/getting_started/#protection-features","title":"Protection Features","text":"Parameter Min Typ Max Unit High-Side Fuse (Tamb = 25\u00b0C) - 8 - A Low-Side Fuse (Tamb = 25\u00b0C) - 8 - A"},{"location":"twist/1.4.1/getting_started/#communication-specifications","title":"Communication Specifications","text":""},{"location":"twist/1.4.1/getting_started/#can-fd","title":"CAN-FD","text":"Type Parameter Min Typ Max Unit CAN-FD Baudrate 500 500 - kBauds Halh Duplex RS485 Baudrate 10 20 - MBauds SPI Baudrate 0.5 - 20 MBauds USART Baudrate - 115200 - Bauds"},{"location":"twist/1.4.1/getting_started/#synchronization","title":"Synchronization","text":"<p>Two Twist Boards can be synchronized via PWM sinc IN/OUT. Using a 15cm RJ45 cable, the delay and jitter between the server and the client PWM are measured as follows:</p> Parameter Symbol Min Typ Max Unit PWM Slew Rate - 660 - - mV/ns Delay Between Server and Client td - 24.2 - ns Jitter of PWM Client tj - 4.8 - ns <p></p>"},{"location":"twist/1.4.1/getting_started/#analog-communication","title":"Analog Communication","text":"<p>Analog communication between boards allows voltage and current measurement with high accuracy.</p> <p>Example Measurement: - A 16-bit value of 2000 is transmitted by a server board. - Step response from 1V to 1.25V measured with a 500 MHz oscilloscope.</p> Parameter Symbol Min Typ Max Unit Step Response Time to \u00b15% \u0394t5% - 1.7 - \u00b5s Steady-State Value Vfinal - 1.25 - V \u00b15% Steady-State Interval \u0394V - 0.125 - V Bandwidth \\(\\(fc = \\dfrac{3}{2\\cdot \\pi \\cdot \\Delta t_{5\\%}}\\)\\) - 281 - kHz <p></p> <p>Statistical Distribution of 10235 data samples </p> Parameter Symbol Min Typ Max Unit Mean \\(\\mu\\) - 2032.65 - Variance \\(\\sigma^2\\) 0.795 - <p></p>"},{"location":"twist/1.4.1/getting_started/#measurement-chains","title":"Measurement Chains","text":"<p>The Twist Board implements full observability on all low-side and high-side power channels using isolated measurements.</p>"},{"location":"twist/1.4.1/getting_started/#adc-specifications","title":"ADC Specifications","text":"Parameter Value ADC Technology Successive Approximation (SAR) Independent ADC Peripherals 5 Number of Channels per ADC 1 to 6 Sampling Time 530 ns Hardware ADC Trigger Programmable trigger instant on PWM period Number of PWM synchronized ADCs 2 Software ADC Trigger All ADC peripherals Trigger Event Typical Frequency 200 kHz"},{"location":"twist/1.4.1/getting_started/#measurement-points","title":"Measurement Points","text":"Measurement Description Sensor Technology Bandwidth (kHz) Signal Side Amplitude Full Scale Range Unit VILow1 Low-side voltage Voltage divider &amp; isolation amplifier 60 \u00b1250 mV \u00b180 V iILow1 Low-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b110 A VILow2 Low-side voltage Voltage divider &amp; isolation amplifier 60 \u00b1250 mV \u00b180 V iILow2 Low-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b110 A VIHigh High-side voltage Voltage divider &amp; isolation amplifier 100 +2 V 120 V iIHigh High-side current Isolated Hall effect sensor 1000 \u00b120 A \u00b120 A Temp1 LEG1 Temperature NTC Thermistor -40 to +110 \\(\\degree C\\) Temp2 LEG2 Temperature NTC Thermistor -40 to +110 \\(\\degree C\\) <p>Schematic showing where the measurements are performed on the circuit.</p> <p></p> <p>Measurements location and output convention</p> <ul> <li>Voltage sensors - they are connected at the input/output of the TWIST board</li> <li>Low-side Current sensors - they are connected right next to the inductor and measure inductor current.      Their output is positive when the converter is in BUCK mode (current going OUT of the low side). </li> <li>High-side Current sensor - it is connected right next to the high side connector.     Its output is positive when the converter is in BUCK mode (current going IN of the high side). </li> </ul> <p>Image showing where the measurements can be accessed on the board. </p> <p></p> <p>Measurement pins</p> <p>All measurements have pins which can be easily accessed with a probe (oscilloscope or multimeter) as shown below.</p> <p>Warning</p> <p></p>"},{"location":"twist/1.4.1/getting_started/#standard-deviation-of-measurements","title":"Standard Deviation of Measurements","text":"Parameter Not Averaged Avg of 2 Measures Avg of 3 Measures Avg of 5 Measures Avg of 10 Measures VILow1 85 mV 61 mV 50 mV 39 mV 28 mV VILow2 82 mV 58 mV 47 mV 37 mV 27 mV VIHigh 150 mV 108 mV 88 mV 68 mV 48 mV IILow1 34 mA 24 mA 20 mA 16 mA 11 mA IILow2 34 mA 24 mA 20 mA 15 mA 11 mA IIHigh 14 mA 10 mA 8 mA 6 mA 4 mA"},{"location":"twist/1.4.1/getting_started/#relative-accuracy-of-voltage-and-current-measurements","title":"Relative accuracy of voltage and current measurements","text":"<p>The following graphs give the accuracy of the voltage and current measurements for different levels of current and voltage.</p> <p></p>"},{"location":"twist/1.4.1/getting_started/#theoretical-calibration-parameters","title":"Theoretical Calibration Parameters","text":"<p>By default all TWIST boards can be calibrated using the following parameters.</p> Variable Name Gain Offset Unit VLow1 0.045 -94.364 V VLow2 0.045 -94.364 V VHigh 0.029964 0 V ILow1 0.005 -10 A ILow2 0.005 -10 A IHigh 0.005 -10 A"},{"location":"twist/1.4.1/getting_started/#typical-applications","title":"Typical Applications","text":"Mode Name High Side Low Side Electrolytic Capacitor Typical Application DC-DC Buck Input Output ON Battery Charger DC-DC Independent Input Output ON Reprogrammable Power Supply DC-DC Boost Output Input ON Fuel-Cell Converter 1-Phase DC-AC Buck Inverter Input Output OFF AC Micro-Grids 1-Phase DC-AC Buck PFC Input Output OFF AC Micro-Grids"},{"location":"twist/1.4.1/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-buck-mode","title":"Example wiring diagram and schematic of the Twist board in Buck mode","text":""},{"location":"twist/1.4.1/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-independent-mode","title":"Example wiring diagram and schematic of the Twist board in Independent mode","text":""},{"location":"twist/1.4.1/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-boost-mode","title":"Example wiring diagram and schematic of the Twist board in Boost mode","text":""},{"location":"twist/1.4.1/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-boost-mode_1","title":"Example wiring diagram and schematic of the Twist board in Boost mode","text":""},{"location":"twist/1.4.1/getting_started/#example-wiring-diagram-and-schematic-of-the-twist-board-in-pfc-mode","title":"Example wiring diagram and schematic of the Twist board in PFC mode","text":"<p>!!!warning The AC source shown below must be low-voltage (below 90V peak)</p> <p> </p>"},{"location":"twist/1.4.1/getting_started/#mechanical-specifications","title":"Mechanical Specifications","text":"<p>Below is the Twist converter assembly view.</p> <p></p>"},{"location":"twist/1.4.1/getting_started/#revision-history","title":"Revision History","text":"Date Revision Changes 07-Fev-2025 1 Initial Release <p>License: Documentation licensed under Creative Commons SA-BY</p>"},{"location":"powerAPI/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI Main communication API interface. </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class NgndHAL </li> <li>class PowerAPI </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class SafetyAPI </li> <li>class SensorsAPI </li> <li>union int2float </li> <li>struct sensor_dt_data_t </li> <li>class ShieldAPI </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class UartHAL Handles USART1 for the SPIN board. </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct can_control_work_data </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t Defines the DAC configuration structure. </li> <li>struct dma_user_data_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>struct sensor_info_t </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t Timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder: set to 1 for timer to act as an incremental coder counter. </li> <li>struct timer_driver_api Driver API structure for timer devices. </li> <li>struct timer_hrtim_t Timing unit configuration that aggregates all the structures: </li> </ul>"},{"location":"powerAPI/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir core <ul> <li>dir zephyr <ul> <li>dir modules <ul> <li>dir owntech_adc_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file adc.c </li> <li>file adc.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_communication <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file CommunicationAPI.cpp </li> <li>file CommunicationAPI.h </li> </ul> </li> <li>dir src <ul> <li>file AnalogCommunication.cpp </li> <li>file AnalogCommunication.h </li> <li>file CanCommunication.cpp </li> <li>file CanCommunication.h </li> <li>file Rs485.cpp </li> <li>file Rs485.h </li> <li>file Rs485Communication.cpp </li> <li>file Rs485Communication.h </li> <li>file SyncCommunication.cpp </li> <li>file SyncCommunication.h </li> <li>file data_objects.h Handling of ThingSet data objects. </li> <li>file thingset_can.c </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_comparator_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file comparator.c </li> <li>file comparator.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_dac_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file dac.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_flash_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file nvs_storage.c </li> <li>file nvs_storage.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_hrtim_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file hrtim.h </li> <li>file hrtim_enum.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_ngnd_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file ngnd.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_safety_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SafetyAPI.cpp </li> <li>file SafetyAPI.h </li> <li>file safety_internal.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_shield_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file ShieldAPI.cpp </li> <li>file ShieldAPI.h </li> </ul> </li> <li>dir src <ul> <li>file NgndHAL.cpp </li> <li>file NgndHAL.h </li> <li>file Power.cpp </li> <li>file Power.h </li> <li>file Sensors.cpp </li> <li>file Sensors.h </li> <li>file power_init.cpp </li> <li>file power_init.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_spin_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SpinAPI.cpp </li> <li>file SpinAPI.h </li> </ul> </li> <li>dir src <ul> <li>file CompHAL.cpp </li> <li>file CompHAL.h </li> <li>file DacHAL.cpp </li> <li>file DacHAL.h </li> <li>file DataAPI.cpp </li> <li>file DataAPI.h </li> <li>file GpioHAL.cpp </li> <li>file GpioHAL.h </li> <li>file LedHAL.cpp </li> <li>file LedHAL.h </li> <li>file PwmHAL.cpp </li> <li>file PwmHAL.h </li> <li>file TimerHAL.cpp </li> <li>file TimerHAL.h </li> <li>file UartHAL.cpp </li> <li>file UartHAL.h </li> <li>dir data <ul> <li>file data_conversion.cpp </li> <li>file data_conversion.h </li> <li>file data_dispatch.cpp </li> <li>file data_dispatch.h </li> <li>file dma.cpp </li> <li>file dma.h </li> </ul> </li> <li>file hardware_auto_configuration.cpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_task_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file TaskAPI.cpp </li> <li>file TaskAPI.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_timer_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file timer.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"powerAPI/classAnalogCommunication/","title":"Class AnalogCommunication","text":"<p>ClassList &gt; AnalogCommunication</p>"},{"location":"powerAPI/classAnalogCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name float32_t getAnalogCommValue () Get the analog value. void init () Initializing analog communication ( <code>ADC</code> and<code>DAC</code> ) void setAnalogCommValue (uint32_t analog_bus_value) Set the analog value, the <code>DAC</code> output."},{"location":"powerAPI/classAnalogCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classAnalogCommunication/#function-getanalogcommvalue","title":"function getAnalogCommValue","text":"<p>Get the analog value. <pre><code>static float32_t AnalogCommunication::getAnalogCommValue () \n</code></pre></p> <p>Returns:</p> <p>Analog value (A value between <code>0</code> and <code>4096</code>) </p>"},{"location":"powerAPI/classAnalogCommunication/#function-init","title":"function init","text":"<p>Initializing analog communication ( <code>ADC</code> and<code>DAC</code> ) <pre><code>static void AnalogCommunication::init () \n</code></pre></p>"},{"location":"powerAPI/classAnalogCommunication/#function-setanalogcommvalue","title":"function setAnalogCommValue","text":"<p>Set the analog value, the <code>DAC</code> output. <pre><code>static void AnalogCommunication::setAnalogCommValue (\n    uint32_t analog_bus_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>analog_bus_value</code> A value between <code>0</code> and <code>4096</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/classCanCommunication/","title":"Class CanCommunication","text":"<p>ClassList &gt; CanCommunication</p>"},{"location":"powerAPI/classCanCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name bool getBroadcastEnable () Get the Broadcasting enable status. uint16_t getBroadcastPeriod () Get the broadcast period. uint16_t getCanNodeAddr () Get the CAN node address. uint16_t getControlPeriod () Get the control period. bool getCtrlEnable () Get the control enable status. float32_t getCtrlReference () Get the control reference value. float32_t getStartStopState () Get the start - stop current order. void setBroadcastEnable (bool enable) Set the Broadcasting enable status. void setBroadcastPeriod (uint16_t time_s) Set the broadcast period. void setCanNodeAddr (uint16_t addr) Set the CAN node address. void setControlPeriod (uint16_t time_ms) Set the control period. void setCtrlEnable (bool enable) Set the control enable status. void setCtrlReference (float32_t reference) Set the control reference value. void startSlaveDevice () Set the order to start slave devices. void stopSlaveDevice () Set the order to stop slave devices."},{"location":"powerAPI/classCanCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classCanCommunication/#function-getbroadcastenable","title":"function getBroadcastEnable","text":"<p>Get the Broadcasting enable status. <pre><code>static bool CanCommunication::getBroadcastEnable () \n</code></pre></p> <p>Returns:</p> <p>True if broadcasting is enabled, false otherwise. </p>"},{"location":"powerAPI/classCanCommunication/#function-getbroadcastperiod","title":"function getBroadcastPeriod","text":"<p>Get the broadcast period. <pre><code>static uint16_t CanCommunication::getBroadcastPeriod () \n</code></pre></p> <p>Returns:</p> <p>The broadcast period in seconds (s). </p>"},{"location":"powerAPI/classCanCommunication/#function-getcannodeaddr","title":"function getCanNodeAddr","text":"<p>Get the CAN node address. <pre><code>static uint16_t CanCommunication::getCanNodeAddr () \n</code></pre></p> <p>Returns:</p> <p>The CAN node address. </p>"},{"location":"powerAPI/classCanCommunication/#function-getcontrolperiod","title":"function getControlPeriod","text":"<p>Get the control period. <pre><code>static uint16_t CanCommunication::getControlPeriod () \n</code></pre></p> <p>Returns:</p> <p>The control period in milli seconds (ms). </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlenable","title":"function getCtrlEnable","text":"<p>Get the control enable status. <pre><code>static bool CanCommunication::getCtrlEnable () \n</code></pre></p> <p>Returns:</p> <p>True if control is enabled, false otherwise. </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlreference","title":"function getCtrlReference","text":"<p>Get the control reference value. <pre><code>static float32_t CanCommunication::getCtrlReference () \n</code></pre></p> <p>Returns:</p> <p>The control reference value. </p>"},{"location":"powerAPI/classCanCommunication/#function-getstartstopstate","title":"function getStartStopState","text":"<p>Get the start - stop current order. <pre><code>static float32_t CanCommunication::getStartStopState () \n</code></pre></p> <p>Returns:</p> <p>A boolean that is 1 is current order is start, 0 if stop. </p>"},{"location":"powerAPI/classCanCommunication/#function-setbroadcastenable","title":"function setBroadcastEnable","text":"<p>Set the Broadcasting enable status. <pre><code>static void CanCommunication::setBroadcastEnable (\n    bool enable\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> True to enable broadcasting, false to disable it. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setbroadcastperiod","title":"function setBroadcastPeriod","text":"<p>Set the broadcast period. <pre><code>static void CanCommunication::setBroadcastPeriod (\n    uint16_t time_s\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_s</code> The broadcast period in seconds (s). </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcannodeaddr","title":"function setCanNodeAddr","text":"<p>Set the CAN node address. <pre><code>static void CanCommunication::setCanNodeAddr (\n    uint16_t addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> The CAN node address to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcontrolperiod","title":"function setControlPeriod","text":"<p>Set the control period. <pre><code>static void CanCommunication::setControlPeriod (\n    uint16_t time_ms\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_ms</code> The control period in milli seconds (ms). </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlenable","title":"function setCtrlEnable","text":"<p>Set the control enable status. <pre><code>static void CanCommunication::setCtrlEnable (\n    bool enable\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> True to enable control, false to disable it. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlreference","title":"function setCtrlReference","text":"<p>Set the control reference value. <pre><code>static void CanCommunication::setCtrlReference (\n    float32_t reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> The control reference value to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-startslavedevice","title":"function startSlaveDevice","text":"<p>Set the order to start slave devices. <pre><code>static void CanCommunication::startSlaveDevice () \n</code></pre></p>"},{"location":"powerAPI/classCanCommunication/#function-stopslavedevice","title":"function stopSlaveDevice","text":"<p>Set the order to stop slave devices. <pre><code>static void CanCommunication::stopSlaveDevice () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/classCommunicationAPI/","title":"Class CommunicationAPI","text":"<p>ClassList &gt; CommunicationAPI</p> <p>Main communication API interface. More...</p> <ul> <li><code>#include &lt;CommunicationAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classCommunicationAPI/#public-attributes","title":"Public Attributes","text":"Type Name AnalogCommunication analog Contains all the functions for Analog communication. CanCommunication can Contains all the functions for CAN communication. Rs485Communication rs485 Contains all the functions for RS485 communication. SyncCommunication sync Contains all the functions for Real Time synchronization."},{"location":"powerAPI/classCommunicationAPI/#detailed-description","title":"Detailed Description","text":"<p>This class provides access to all supported communication interfaces, including analog, CAN, RS485, and real-time synchronization protocols.</p> <ul> <li><code>analog</code>: provides analog communication functions.</li> <li><code>can</code>: provides CAN bus communication functions.</li> <li><code>rs485</code>: provides RS485 serial communication functions.</li> <li><code>sync</code>: provides real-time synchronization functions. </li> </ul>"},{"location":"powerAPI/classCommunicationAPI/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/classCommunicationAPI/#variable-analog","title":"variable analog","text":"<p>Contains all the functions for Analog communication. <pre><code>AnalogCommunication CommunicationAPI::analog;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-can","title":"variable can","text":"<p>Contains all the functions for CAN communication. <pre><code>CanCommunication CommunicationAPI::can;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-rs485","title":"variable rs485","text":"<p>Contains all the functions for RS485 communication. <pre><code>Rs485Communication CommunicationAPI::rs485;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-sync","title":"variable sync","text":"<p>Contains all the functions for Real Time synchronization. <pre><code>SyncCommunication CommunicationAPI::sync;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/classCompHAL/","title":"Class CompHAL","text":"<p>ClassList &gt; CompHAL</p> <p>Handles comparator 1 and 3 of the SPIN board. More...</p> <ul> <li><code>#include &lt;CompHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classCompHAL/#public-functions","title":"Public Functions","text":"Type Name void initialize (uint8_t comparator_number) Initializes a comparator for the current mode control."},{"location":"powerAPI/classCompHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call the initialization function of either comparator </p>"},{"location":"powerAPI/classCompHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classCompHAL/#function-initialize","title":"function initialize","text":"<p>Initializes a comparator for the current mode control. <pre><code>void CompHAL::initialize (\n    uint8_t comparator_number\n) \n</code></pre></p> <p>Note:</p> <p>Current mode control deploys a comparator together with a DAC. </p> <p>Parameters:</p> <ul> <li><code>comparator_number</code> can be either 1 or 3 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/classDacHAL/","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"powerAPI/classDacHAL/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src) Update slope compensation settings on a DAC using voltage values. void initConstValue (uint8_t dac_number) Initialize a DAC device in constant output mode. void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value) Set a constant analog output value on a DAC channel. void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage) Configure a DAC to operate in sawtooth waveform mode for current-mode control."},{"location":"powerAPI/classDacHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDacHAL/#function-currentmodeinit","title":"function currentModeInit","text":"<p>Update slope compensation settings on a DAC using voltage values. <pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre></p> <p>Converts the given voltage values into digital DAC values and sets the DAC's sawtooth waveform reset and step parameters accordingly.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1 or 3). </li> <li><code>peak_voltage</code> The peak voltage value for the sawtooth ramp (reset level). </li> <li><code>low_voltage</code> The valley (starting) voltage of the ramp. </li> </ul>"},{"location":"powerAPI/classDacHAL/#function-initconstvalue","title":"function initConstValue","text":"<p>Initialize a DAC device in constant output mode. <pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre></p> <p>Configures the specified DAC (1, 2, or 3) to output a constant analog value.</p> <p>This includes setting the value to 0, enabling external output, and starting the DAC.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1, 2, or 3). </li> </ul>"},{"location":"powerAPI/classDacHAL/#function-setconstvalue","title":"function setConstValue","text":"<p>Set a constant analog output value on a DAC channel. <pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre></p> <p>Writes a raw 12-bit value to the selected DAC channel, provided the DAC is ready.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1, 2, or 3). </li> <li><code>channel</code> The DAC output channel index (usually 1). </li> <li><code>const_value</code> The constant value to set (0\u20134095). </li> </ul>"},{"location":"powerAPI/classDacHAL/#function-slopecompensation","title":"function slopeCompensation","text":"<p>Configure a DAC to operate in sawtooth waveform mode for current-mode control. <pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre></p> <p>Initializes the DAC to produce a decrementing sawtooth waveform.</p> <p>The DAC is triggered by the selected HRTIM timer unit to synchronize waveform generation with the PWM cycle.</p> <p>Reset and step triggers are selected based on the <code>tu_src</code>.</p> <p>Parameters:</p> <ul> <li><code>dac_number</code> The DAC number (1 or 3). </li> <li><code>tu_src</code> The HRTIM timer unit (TIMB to TIMF) used for synchronization. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/classDataAPI/","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p> <p>More...</p> <ul> <li><code>#include &lt;DataAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classDataAPI/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (adc_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. void configureTriggerSource (adc_t adc_number, trigger_source_t trigger_source) Change the trigger source of an ADC. float32_t convertValue (uint8_t pin_number, uint16_t raw_value) Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data (Volts, Amperes, or Degree Celsius). int8_t enableAcquisition (uint8_t pin_number, adc_t adc_number=DEFAULT_ADC) This function is used to enable acquisition on a Spin PIN with a given ADC. conversion_type_t getConversionParameterType (uint8_t pin_number) Use this function to get the current conversion type for the chosen channel. float32_t getConversionParameterValue (uint8_t pin_number, parameter_t parameter_name) Use this function to get the current conversion parameters for the chosen channel . float32_t getLatestValue (uint8_t pin_number, uint8_t * dataValid=nullptr) This function returns the latest acquired measurement. uint16_t * getRawValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t * getValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t peekLatestValue (uint8_t pin_number) Function to access the latest value available from a pin. int8_t retrieveConversionParametersFromMemory (uint8_t pin_number) Retrieved previously configured conversion parameters from persistent memory. void setConversionParametersLinear (uint8_t pin_number, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setConversionParametersNtcThermistor (uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t stop () Stops the module if it is started. int8_t storeConversionParametersInMemory (uint8_t pin_number) Store the currently configured conversion parameters of a given channel in persistent memory. void triggerAcquisition (adc_t adc_number) Triggers an acquisition on a given ADC."},{"location":"powerAPI/classDataAPI/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"powerAPI/classDataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDataAPI/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. <pre><code>void DataAPI::configureDiscontinuousMode (\n    adc_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Note:</p> <p>This is an advanced function that requires to understand the way the ADC work.</p> <p>Only for use if you explicitly requires it.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. <pre><code>void DataAPI::configureTriggerSource (\n    adc_t adc_number,\n    trigger_source_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-convertvalue","title":"function convertValue","text":"<p>Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data (Volts, Amperes, or Degree Celsius). <pre><code>float32_t DataAPI::convertValue (\n    uint8_t pin_number,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit.  </p>"},{"location":"powerAPI/classDataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t pin_number,\n    adc_t adc_number=DEFAULT_ADC\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisition: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before Data API is started.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the Spin pin on which to enable acquisition. </li> <li> <p><code>adc_number</code> Number of the ADC on which acquisition is to be done.   This parameter can be omitted, in which case:</p> </li> <li> <p>If only one ADC is linked to the given pin, it will be selected.</p> </li> <li>If two ADCs are available for acquisition on the given pin, the ADC with the lowest number will be selected.</li> </ul> <p>Returns:</p> <p><code>0</code> if acquisition was correctly enabled, <code>-1</code> if there was an error.</p> <p>Errors generally indicate that the given pin is not linked to and ADC, and thus can not be used for acquisition.</p> <p>If the adc_number parameter was explicitly provided, it can also indicate that the given ADC is not available for acquisition on the provided pin.</p> <p>Public functions accessible only when using a power shield </p>"},{"location":"powerAPI/classDataAPI/#function-getconversionparametertype","title":"function getConversionParameterType","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::getConversionParameterType (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Returns the type of conversion of the given pin.  </p>"},{"location":"powerAPI/classDataAPI/#function-getconversionparametervalue","title":"function getConversionParameterValue","text":"<p>Use this function to get the current conversion parameters for the chosen channel . <pre><code>float32_t DataAPI::getConversionParameterValue (\n    uint8_t pin_number,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>parameter_name</code> Paramater to be retrieved: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter.  </p>"},{"location":"powerAPI/classDataAPI/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measurement. <pre><code>float32_t DataAPI::getLatestValue (\n    uint8_t pin_number,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.getRawValues() function for the matching channel, as data.getLatestValue() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. </li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel.  </p>"},{"location":"powerAPI/classDataAPI/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>The count of these values is returned as an output parameter. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use data.convertValue() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored.  </p>"},{"location":"powerAPI/classDataAPI/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>float32_t * DataAPI::getValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored.  </p>"},{"location":"powerAPI/classDataAPI/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from a pin. <pre><code>float32_t DataAPI::peekLatestValue (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel.  </p>"},{"location":"powerAPI/classDataAPI/#function-retrieveconversionparametersfrommemory","title":"function retrieveConversionParametersFromMemory","text":"<p>Retrieved previously configured conversion parameters from persistent memory. <pre><code>int8_t DataAPI::retrieveConversionParametersFromMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved,   negative value if there was an error:</p> <ul> <li><code>-1</code>: persistent memory is empty</li> <li><code>-2</code>: persistent memory contains data, but its version doesn't match current version</li> <li><code>-3</code>: data in persistent memory is corrupted</li> <li><code>-4</code>: persistent memory contains data, but not for the requested pin</li> <li><code>-5000</code>: pin not found. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersLinear (\n    uint8_t pin_number,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersNtcThermistor (\n    uint8_t pin_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge divider resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually:</p> <p>It will instead start automatically at the same time as the task as their internal behavior is intrinsically linked.</p> <p>If, for some reason, you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task.</p> <p>In that case, Data Acquisition must be manually started using this function.</p> <p>Note that in that case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out.</p> <p>No ADC configuration change is allowed after module has been started.</p> <p>If you're using a power shield and are not sure how to initialize ADCs, you can use data.enableShieldDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function.</p> <p>Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error Error is triggered when dispatch method is set to be external, but the repetition value has not provided.</p> <p>Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"powerAPI/classDataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"powerAPI/classDataAPI/#function-stop","title":"function stop","text":"<p>Stops the module if it is started. <pre><code>int8_t DataAPI::stop () \n</code></pre></p> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error.  </p>"},{"location":"powerAPI/classDataAPI/#function-storeconversionparametersinmemory","title":"function storeConversionParametersInMemory","text":"<p>Store the currently configured conversion parameters of a given channel in persistent memory. <pre><code>int8_t DataAPI::storeConversionParametersInMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly stored, negative value if there was an error:</p> <ul> <li><code>-1</code>: There was an error,</li> <li><code>-5000</code>: pin not found. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. <pre><code>void DataAPI::triggerAcquisition (\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before: </p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"powerAPI/classGpioHAL/","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p> <p>More...</p> <ul> <li><code>#include &lt;GpioHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classGpioHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"powerAPI/classGpioHAL/#detailed-description","title":"Detailed Description","text":"<p>Class definition </p>"},{"location":"powerAPI/classGpioHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classGpioHAL/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code></li> </ul> <p>Parameters:</p> <ul> <li><code>flags</code> Pin configuration flags. Authorized values: <code>INPUT</code>, <code>INPUT_PULLUP</code>, <code>OUTPUT</code> </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"powerAPI/classGpioHAL/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code> </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>pin</code> Number of pin. Format allowed:</p> </li> <li> <p>the Spin pin number from 1 to 58</p> </li> <li>STM32-style pin name from <code>PA1</code> to <code>PA15</code>, <code>PB1</code> to <code>PB15</code>, <code>PC1</code> to <code>PC15</code> and <code>PD1</code> to <code>PD3</code></li> </ul> <p>Parameters:</p> <ul> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/classLedHAL/","title":"Class LedHAL","text":"<p>ClassList &gt; LedHAL</p>"},{"location":"powerAPI/classLedHAL/#public-functions","title":"Public Functions","text":"Type Name void toggle () Toggle the LED state. void turnOff () Turn the LED off. void turnOn () Turn the LED on."},{"location":"powerAPI/classLedHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classLedHAL/#function-toggle","title":"function toggle","text":"<p>Toggle the LED state. <pre><code>void LedHAL::toggle () \n</code></pre></p> <p>Changes the LED state from on to off or vice versa.</p> <p>Performs lazy initialization if not already done. </p>"},{"location":"powerAPI/classLedHAL/#function-turnoff","title":"function turnOff","text":"<p>Turn the LED off. <pre><code>void LedHAL::turnOff () \n</code></pre></p> <p>Ensures the LED is initialized, then sets the output state to inactive. </p>"},{"location":"powerAPI/classLedHAL/#function-turnon","title":"function turnOn","text":"<p>Turn the LED on. <pre><code>void LedHAL::turnOn () \n</code></pre></p> <p>Ensures the LED is initialized, then sets the output state to active. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/classNgndHAL/","title":"Class NgndHAL","text":"<p>ClassList &gt; NgndHAL</p>"},{"location":"powerAPI/classNgndHAL/#public-functions","title":"Public Functions","text":"Type Name void turnOff () Turns the NGND switch OFF. void turnOn () Turns the NGND switch ON."},{"location":"powerAPI/classNgndHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classNgndHAL/#function-turnoff","title":"function turnOff","text":"<p>Turns the NGND switch OFF. <pre><code>void NgndHAL::turnOff () \n</code></pre></p>"},{"location":"powerAPI/classNgndHAL/#function-turnon","title":"function turnOn","text":"<p>Turns the NGND switch ON. <pre><code>void NgndHAL::turnOn () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/NgndHAL.h</code></p>"},{"location":"powerAPI/classPowerAPI/","title":"Class PowerAPI","text":"<p>ClassList &gt; PowerAPI</p>"},{"location":"powerAPI/classPowerAPI/#public-functions","title":"Public Functions","text":"Type Name void connectCapacitor (leg_t leg) Connect the electrolytic capacitor. void connectDriver (leg_t leg) Turns the driver of the leg ON. This enables control over the power switches. void disconnectCapacitor (leg_t leg) Disconnect the electrolytic capacitor. void disconnectDriver (leg_t leg) Turns the driver of the leg OFF. float32_t getDutyCycleMax (leg_t leg) gets the Maximum Duty Cycle Limit as a float uint16_t getDutyCycleMaxRaw (leg_t leg) gets the Maximum Duty Cycle Limit as an unsigned integer. float32_t getDutyCycleMin (leg_t leg) gets the Minimum Duty Cycle Limit as a float uint16_t getDutyCycleMinRaw (leg_t leg) gets the Minimum Duty Cycle Limit as an unsigned integer. uint16_t getPeriod (leg_t leg) returns the value of the leg period as an unsigned integer void initBoost (leg_t leg) Initialise all the legs for boost topology, current mode is not supported for boost. void initBuck (leg_t leg, hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE) Initialise a leg for buck topology. void initMode (leg_t leg, hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode) Initialize the power mode for a given leg. void setAdcDecim (leg_t leg, uint16_t adc_decim) Sets ADC decimator for a leg. void setDeadTime (leg_t leg, uint16_t ns_rising_dt, uint16_t ns_falling_dt) set the dead time value for a leg void setDutyCycle (leg_t leg, float32_t duty_value) Set the duty cycle for a specific leg's power control. void setDutyCycleMax (leg_t leg, float32_t duty_cycle) sets the Maximum Duty Cycle Limit void setDutyCycleMaxRaw (leg_t leg, uint16_t duty_cycle) sets the Maximum Duty Cycle Limit as an unsigned int void setDutyCycleMin (leg_t leg, float32_t duty_cycle) sets the Minimum Duty Cycle Limit void setDutyCycleMinRaw (leg_t leg, uint16_t duty_cycle) sets the Minimum Duty Cycle Limit as an unsigned int void setDutyCycleRaw (leg_t leg, uint16_t duty_value) Set the duty cycle for a specific leg's power control. void setPhaseShift (leg_t leg, int16_t phase_shift) Set the phase shift value for a specific leg's power control. void setSlopeCompensation (leg_t leg, float32_t set_voltage, float32_t reset_voltage) Set the slope compensation in current mode for a leg. void setTriggerValue (leg_t leg, float32_t trigger_value) Set the trigger value for a specific leg's ADC trigger. void start (leg_t leg) Start power output for a specific leg. void stop (leg_t leg) Stop power output for a specific leg."},{"location":"powerAPI/classPowerAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classPowerAPI/#function-connectcapacitor","title":"function connectCapacitor","text":"<p>Connect the electrolytic capacitor. <pre><code>void PowerAPI::connectCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which the capacitor will be connected: <code>LEG1</code> to <code>ALL</code></li> </ul> <p>Warning:</p> <p>This function can only be called AFTER initializing the <code>LEG</code>. </p>"},{"location":"powerAPI/classPowerAPI/#function-connectdriver","title":"function connectDriver","text":"<p>Turns the driver of the leg ON. This enables control over the power switches. <pre><code>void PowerAPI::connectDriver (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which the driver will be turned on: <code>LEG1</code> to <code>ALL</code></li> </ul> <p>Warning:</p> <p>This function can only be called AFTER initializing the LEG. </p>"},{"location":"powerAPI/classPowerAPI/#function-disconnectcapacitor","title":"function disconnectCapacitor","text":"<p>Disconnect the electrolytic capacitor. <pre><code>void PowerAPI::disconnectCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which the capacitor will be disconnected: <code>LEG1</code> to <code>ALL</code></li> </ul> <p>Warning:</p> <p>This function can only be called AFTER initializing the <code>LEG</code>. </p>"},{"location":"powerAPI/classPowerAPI/#function-disconnectdriver","title":"function disconnectDriver","text":"<p>Turns the driver of the leg OFF. <pre><code>void PowerAPI::disconnectDriver (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which the driver will be turned off: <code>LEG1</code> to <code>ALL</code></li> </ul> <p>Warning:</p> <p>This function can only be called AFTER initializing the LEG. </p>"},{"location":"powerAPI/classPowerAPI/#function-getdutycyclemax","title":"function getDutyCycleMax","text":"<p>gets the Maximum Duty Cycle Limit as a float <pre><code>float32_t PowerAPI::getDutyCycleMax (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>LEG5</code>. </li> </ul> <p>Warning:</p> <p><code>ALL</code> is NOT supported ! </p>"},{"location":"powerAPI/classPowerAPI/#function-getdutycyclemaxraw","title":"function getDutyCycleMaxRaw","text":"<p>gets the Maximum Duty Cycle Limit as an unsigned integer. <pre><code>uint16_t PowerAPI::getDutyCycleMaxRaw (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>LEG5</code>. </li> </ul> <p>Warning:</p> <p><code>ALL</code> is NOT supported ! </p>"},{"location":"powerAPI/classPowerAPI/#function-getdutycyclemin","title":"function getDutyCycleMin","text":"<p>gets the Minimum Duty Cycle Limit as a float <pre><code>float32_t PowerAPI::getDutyCycleMin (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>LEG5</code>. </li> </ul> <p>Warning:</p> <p><code>ALL</code> is NOT supported ! </p>"},{"location":"powerAPI/classPowerAPI/#function-getdutycycleminraw","title":"function getDutyCycleMinRaw","text":"<p>gets the Minimum Duty Cycle Limit as an unsigned integer. <pre><code>uint16_t PowerAPI::getDutyCycleMinRaw (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>LEG5</code>. </li> </ul> <p>Warning:</p> <p><code>ALL</code> is NOT supported ! </p>"},{"location":"powerAPI/classPowerAPI/#function-getperiod","title":"function getPeriod","text":"<p>returns the value of the leg period as an unsigned integer <pre><code>uint16_t PowerAPI::getPeriod (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>LEG5</code>. </li> </ul> <p>Warning:</p> <p><code>ALL</code> is NOT supported ! </p>"},{"location":"powerAPI/classPowerAPI/#function-initboost","title":"function initBoost","text":"<p>Initialise all the legs for boost topology, current mode is not supported for boost. <pre><code>void PowerAPI::initBoost (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize: <code>LEG1</code> to <code>ALL</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-initbuck","title":"function initBuck","text":"<p>Initialise a leg for buck topology. <pre><code>void PowerAPI::initBuck (\n    leg_t leg,\n    hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize: <code>LEG1</code> to <code>ALL</code> </li> <li><code>leg_mode</code> PWM mode - <code>VOLTAGE_MODE</code> or <code>CURRENT_MODE</code></li> </ul> <p>Note:</p> <p><code>CURRENT_MODE</code> only available to <code>LEG1</code> and <code>LEG2</code> for the Twist board </p>"},{"location":"powerAPI/classPowerAPI/#function-initmode","title":"function initMode","text":"<p>Initialize the power mode for a given leg. <pre><code>void PowerAPI::initMode (\n    leg_t leg,\n    hrtim_switch_convention_t leg_convention,\n    hrtim_pwm_mode_t leg_mode\n) \n</code></pre></p> <p>This function configures modulation, frequency, phase shift, dead time, and other parameters for power control of a specified leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize:<code>LEG1</code> to <code>ALL</code> </li> <li><code>leg_convention</code> PWM Switch to be driven by the duty cycle: <code>PWMx1</code>, <code>PWMx2</code> </li> <li><code>leg_mode</code> PWM mode: <code>VOLTAGE_MODE</code>, <code>CURRENT_MODE</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setadcdecim","title":"function setAdcDecim","text":"<p>Sets ADC decimator for a leg. <pre><code>void PowerAPI::setAdcDecim (\n    leg_t leg,\n    uint16_t adc_decim\n) \n</code></pre></p> <p>This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period.</p> <p>For example if adc_decim = 1, nothing changes but with adc_decims = 2 you have twice less adc trigger.</p> <p>Parameters:</p> <ul> <li><code>leg</code> leg for which to set adc decimator value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>adc_decim</code> adc decimator, a number between 1 and 32 </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdeadtime","title":"function setDeadTime","text":"<p>set the dead time value for a leg <pre><code>void PowerAPI::setDeadTime (\n    leg_t leg,\n    uint16_t ns_rising_dt,\n    uint16_t ns_falling_dt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>ns_rising_dt</code> rising dead time value in nanoseconds </li> <li><code>ns_falling_dt</code> falling dead time value in nanoseconds </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycycle","title":"function setDutyCycle","text":"<p>Set the duty cycle for a specific leg's power control. <pre><code>void PowerAPI::setDutyCycle (\n    leg_t leg,\n    float32_t duty_value\n) \n</code></pre></p> <p>This function sets the duty cycle for the power control of a specified leg.</p> <p>The duty cycle determines the ON/OFF ratio of the power signal for the leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the duty cycle: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_value</code> The duty cycle value to set (a floating-point number between <code>0.1</code> and <code>0.9</code>). </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycyclemax","title":"function setDutyCycleMax","text":"<p>sets the Maximum Duty Cycle Limit <pre><code>void PowerAPI::setDutyCycleMax (\n    leg_t leg,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_cycle</code> - new maximum duty cycle value between 0.0 and 1.0 </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycyclemaxraw","title":"function setDutyCycleMaxRaw","text":"<p>sets the Maximum Duty Cycle Limit as an unsigned int <pre><code>void PowerAPI::setDutyCycleMaxRaw (\n    leg_t leg,\n    uint16_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_cycle</code> - new minimum duty cycle value between <code>0</code> and <code>period</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycyclemin","title":"function setDutyCycleMin","text":"<p>sets the Minimum Duty Cycle Limit <pre><code>void PowerAPI::setDutyCycleMin (\n    leg_t leg,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_cycle</code> - new minimum duty cycle value between 0.0 and 1.0 </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycycleminraw","title":"function setDutyCycleMinRaw","text":"<p>sets the Minimum Duty Cycle Limit as an unsigned int <pre><code>void PowerAPI::setDutyCycleMinRaw (\n    leg_t leg,\n    uint16_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> the leg for which to set dead time value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_cycle</code> - new minimum duty cycle value between <code>0</code> and <code>period</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setdutycycleraw","title":"function setDutyCycleRaw","text":"<p>Set the duty cycle for a specific leg's power control. <pre><code>void PowerAPI::setDutyCycleRaw (\n    leg_t leg,\n    uint16_t duty_value\n) \n</code></pre></p> <p>This function sets the duty cycle for the power control of a specified leg.</p> <p>The duty cycle determines the ON/OFF time ratio of the power signal for the leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the duty cycle: <code>LEG1</code> to <code>ALL</code> </li> <li><code>duty_value</code> The duty cycle value to set an unsigned integer number between <code>duty_cycle_min_raw</code> and <code>duty_cycle_max_raw</code>. </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setphaseshift","title":"function setPhaseShift","text":"<p>Set the phase shift value for a specific leg's power control. <pre><code>void PowerAPI::setPhaseShift (\n    leg_t leg,\n    int16_t phase_shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the phase shift value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>phase_shift</code> phase shift value in degrees between <code>-360</code> and <code>360</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-setslopecompensation","title":"function setSlopeCompensation","text":"<p>Set the slope compensation in current mode for a leg. <pre><code>void PowerAPI::setSlopeCompensation (\n    leg_t leg,\n    float32_t set_voltage,\n    float32_t reset_voltage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize: <code>LEG1</code> to <code>ALL</code> </li> <li><code>set_voltage</code> in volt, the DAC peak voltage for slope compensation (value between <code>0</code> and <code>2.048</code>) </li> <li><code>reset_voltage</code> in volt, the DAC lowest voltage for slope compensation (value between <code>0</code> and <code>2.048</code>)</li> </ul> <p>Warning:</p> <p>Be sure that <code>set_voltage &gt; reset_voltage</code> </p>"},{"location":"powerAPI/classPowerAPI/#function-settriggervalue","title":"function setTriggerValue","text":"<p>Set the trigger value for a specific leg's ADC trigger. <pre><code>void PowerAPI::setTriggerValue (\n    leg_t leg,\n    float32_t trigger_value\n) \n</code></pre></p> <p>This function sets the trigger value for the ADC trigger of a specified leg.</p> <p>The trigger value determines the level at which the ADC trigger is activated.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the ADC trigger value: <code>LEG1</code> to <code>ALL</code> </li> <li><code>trigger_value</code> The trigger value to set between 0.05 and 0.95. </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-start","title":"function start","text":"<p>Start power output for a specific leg. <pre><code>void PowerAPI::start (\n    leg_t leg\n) \n</code></pre></p> <p>This function initiates the power output for a specified leg by starting the PWM subunits associated with the leg's output pins.</p> <p>If the leg's output pins are not declared inactive in the device tree, the corresponding subunits are started. eg.</p> <p>If output1 is declared inactive in the device tree, PWMA1 will not start.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to start the power output: <code>LEG1</code> to <code>ALL</code> </li> </ul>"},{"location":"powerAPI/classPowerAPI/#function-stop","title":"function stop","text":"<p>Stop power output for a specific leg. <pre><code>void PowerAPI::stop (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to stop the power output: <code>LEG1</code> to <code>ALL</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Power.h</code></p>"},{"location":"powerAPI/classPwmHAL/","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classPwmHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void deInitBurstMode () This function deinit burst mode. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. adc_t getAdcTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. uint32_t getFrequencyMax (hrtim_tu_number_t pwmX) This function returns the maximum frequency of the selected timer in Hz. uint32_t getFrequencyMin (hrtim_tu_number_t pwmX) This function returns the minimum frequency of the selected timer in Hz. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint16_t getPeriodMax (hrtim_tu_number_t pwmX) This function returns the maximum period of the selected timing unit. uint16_t getPeriodMin (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. uint32_t getResolutionPs (hrtim_tu_number_t pwmX) This function returns the resolution of the timing unit in picoseconds. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initBurstMode () This function initialize burst mode. void initFixedFrequency (uint32_t fixed_frequency) This function initialize the PWM for fixed frequency applications. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void initVariableFrequency (uint32_t initial_frequency, uint32_t minimal_frequency) This functions initializes the PWM for variable frequency applications. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events.ie. you divide the number of trigger in a fixed period. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, adc_t adc) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setBurstMode (int bm_cmp, int bm_per) This function sets burst mode parameters. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setDutyCycleRaw (hrtim_tu_number_t pwmX, uint16_t duty_cycle) Sets the duty cycle for the selected timing unit using an unsigned integer. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startBurstMode () This function starts burst mode. void startDualOutput (hrtim_tu_number_t pwmX) This function starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopBurstMode () This function stops burst mode. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"powerAPI/classPwmHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"powerAPI/classPwmHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classPwmHAL/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> <li><code>repetition</code> Number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> Function to call each interupt </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-deinitburstmode","title":"function deInitBurstMode","text":"<p>This function deinit burst mode. <pre><code>void PwmHAL::deInitBurstMode () \n</code></pre></p>"},{"location":"powerAPI/classPwmHAL/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Warning:</p> <p>Call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>Rollover mode: <code>EdgeTrigger_up</code>, <code>EdgeTrigger_down</code>, <code>EdgeTrigger_Both</code> </p>"},{"location":"powerAPI/classPwmHAL/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>adc_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>ADC number: <code>ADC_1</code>,<code>ADC_2</code>,<code>ADC_3</code>,<code>ADC_4</code>,<code>ADC_5</code> or</p> <p><code>UNKNOWN_ADC</code> if the ADC trigger was not configured for this timing unit. </p>"},{"location":"powerAPI/classPwmHAL/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>eev</code> external event trigger:   <code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getfrequencymax","title":"function getFrequencyMax","text":"<p>This function returns the maximum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getfrequencymin","title":"function getFrequencyMin","text":"<p>This function returns the minimum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>PWM mode: <code>VOLTAGE_MODE</code> or <code>CURRENT_MODE</code> </p> <p>Warning:</p> <p>This function must be called before initializing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Returns:</p> <p>The type of modulation <code>Lft_aligned</code> or <code>UpDwn</code> (center aligned) </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodmax","title":"function getPeriodMax","text":"<p>This function returns the maximum period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodmin","title":"function getPeriodMin","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getresolutionps","title":"function getResolutionPs","text":"<p>This function returns the resolution of the timing unit in picoseconds. <pre><code>uint32_t PwmHAL::getResolutionPs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> </ul> <p>Note:</p> <p>The resolution of the PWM depends on the prescaler that is automatically calculated when the master unit is initialized.</p> <p>For an HRTIM frequency of =170MHz:</p> <ul> <li><code>PRSCL = 0</code>: <code>fHRTIM x 32 = 4.608 GHz</code> - <code>Res:00184 ps - Min PWM f: 83.00 kHz</code></li> <li><code>PRSCL = 1</code>: <code>fHRTIM x 16 = 2.304 GHz</code> - <code>Res:00368 ps - Min PWM f: 41.50 kHz</code></li> <li><code>PRSCL = 2</code>: <code>fHRTIM x 08 = 1.152 GHz</code> - <code>Res:00735 ps - Min PWM f: 20.80 kHz</code></li> <li><code>PRSCL = 3</code>: <code>fHRTIM x 04 = 0.576 GHz</code> - <code>Res:01470 ps - Min PWM f: 10.40 kHz</code></li> <li><code>PRSCL = 4</code>: <code>fHRTIM x 02 = 0.288 GHz</code> - <code>Res:02940 ps - Min PWM f: 05.20 kHz</code></li> <li><code>PRSCL = 5</code>: <code>fHRTIM x 01 = 0.144 GHz</code> - <code>Res:05880 ps - Min PWM f: 02.60 kHz</code></li> <li><code>PRSCL = 6</code>: <code>fHRTIM / 02 = 0.072 GHz</code> - <code>Res:11760 ps - Min PWM f: 01.30 kHz</code></li> <li><code>PRSCL = 7</code>: <code>fHRTIM / 04 = 0.036 GHz</code> - <code>Res:23530 ps - Min PWM f: 00.65 kHz</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul> <p>Returns:</p> <p>Returns the switch convention :</p> <ul> <li><code>PWMx1</code>: <code>BUCK</code> convention, switch HIGH</li> <li><code>PWMx2</code>: <code>BOOST</code> convention, switch LOW </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-initburstmode","title":"function initBurstMode","text":"<p>This function initialize burst mode. <pre><code>void PwmHAL::initBurstMode () \n</code></pre></p>"},{"location":"powerAPI/classPwmHAL/#function-initfixedfrequency","title":"function initFixedFrequency","text":"<p>This function initialize the PWM for fixed frequency applications. <pre><code>void PwmHAL::initFixedFrequency (\n    uint32_t fixed_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fixed_frequency</code> frequency to be fixed in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing any timing unit.</p> <p>The frequency will not vary during the operation of the power device.</p> <p>Use it for fixed frequencies only. </p>"},{"location":"powerAPI/classPwmHAL/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-initvariablefrequency","title":"function initVariableFrequency","text":"<p>This functions initializes the PWM for variable frequency applications. <pre><code>void PwmHAL::initVariableFrequency (\n    uint32_t initial_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>initial_frequency</code> The initial value of the frequency in Hz </li> <li><code>minimal_frequency</code> The minimal value of the frequency in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing any timing unit.</p> <p>The user can vary the frequency during the operation of the power device.</p> <p>This may compromise the resolution of the PWM.</p> <p>You can check your resolution with the getResolutionPS function. </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events.ie. you divide the number of trigger in a fixed period. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>For example if :</p> <ul> <li><code>decimation = 1</code>, nothing changes but with</li> <li><code>decimation = 2</code>, you have twice less adc trigger</li> </ul> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>decimation</code> decimation/post-scaler: a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>adc_edge_trigger</code> Rollover mode: <code>EdgeTrigger_up</code>, <code>EdgeTrigger_down</code>, <code>EdgeTrigger_Both</code></li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    adc_t adc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>adc</code> ADC number: <code>ADC_1</code>,<code>ADC_2</code>,<code>ADC_3</code>,<code>ADC_4</code>,<code>ADC_5</code> </li> </ul> <p>Warning:</p> <p>Call this function:  </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>trig_val</code> a float value between 0 and 1 </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>This function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"powerAPI/classPwmHAL/#function-setburstmode","title":"function setBurstMode","text":"<p>This function sets burst mode parameters. <pre><code>void PwmHAL::setBurstMode (\n    int bm_cmp,\n    int bm_per\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>bm_cmp</code> Number of period of PWM off </li> <li><code>bm_per</code> Total number of PWM period </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setdutycycleraw","title":"function setDutyCycleRaw","text":"<p>Sets the duty cycle for the selected timing unit using an unsigned integer. <pre><code>void PwmHAL::setDutyCycleRaw (\n    hrtim_tu_number_t pwmX,\n    uint16_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>value</code> duty cycle value as an unsigned integer </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>eev</code> external event trigger:   <code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </li> </ul> <p>Warning:</p> <p>this function must be called before initializing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step.</p> <p>Use it AFTER the initialization of the timing unit. </p>"},{"location":"powerAPI/classPwmHAL/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>mode</code> PWM mode: <code>VOLTAGE_MODE</code> or <code>CURRENT_MODE</code></li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initializing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>modulation</code> PWM Modulation: <code>Lft_aligned</code> or <code>UpDwn</code></li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit:<code>TIMA</code>,<code>TIMB</code>,<code>TIMC</code>,<code>TIMD</code>,<code>TIME</code>,<code>TIMF</code></li> <li><code>repetition</code> Number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code></li> <li><code>shift</code> phase shift value in DEGREES (between <code>-360</code> and <code>360</code>)</li> </ul> <p>Warning:</p> <p>Use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li> <p><code>convention</code> PWM Switch to be driven by the duty cycle: </p> </li> <li> <p><code>PWMx1</code>: <code>BUCK</code> convention, switch HIGH</p> </li> <li><code>PWMx2</code>: <code>BOOST</code> convention, switch LOW</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"powerAPI/classPwmHAL/#function-startburstmode","title":"function startBurstMode","text":"<p>This function starts burst mode. <pre><code>void PwmHAL::startBurstMode () \n</code></pre></p>"},{"location":"powerAPI/classPwmHAL/#function-startdualoutput","title":"function startDualOutput","text":"<p>This function starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>output</code> output to disable: <code>TIMING_OUTPUT1</code>,<code>TIMING_OUTPUT2</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopburstmode","title":"function stopBurstMode","text":"<p>This function stops burst mode. <pre><code>void PwmHAL::stopBurstMode () \n</code></pre></p>"},{"location":"powerAPI/classPwmHAL/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit: <code>PWMA</code>,<code>PWMB</code>,<code>PWMC</code>,<code>PWMD</code>,<code>PWME</code>,<code>PWMF</code> </li> <li><code>output</code> output to disable: <code>TIMING_OUTPUT1</code>,<code>TIMING_OUTPUT2</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/classRs485Communication/","title":"Class Rs485Communication","text":"<p>ClassList &gt; Rs485Communication</p> <p>More...</p> <ul> <li><code>#include &lt;Rs485Communication.h&gt;</code></li> </ul>"},{"location":"powerAPI/classRs485Communication/#public-functions","title":"Public Functions","text":"Type Name void configure (uint8_t * transmission_buffer, uint8_t * reception_buffer, uint16_t data_size, void(*)() user_function, rs485_speed_t data_speed=SPEED_10M) Configuration for RS485 communication using a 10Mbit/s speed. void configureCustom (uint8_t * transmission_buffer, uint8_t * reception_buffer, uint16_t data_size, void(*)(void) user_function, uint32_t baudrate, bool oversampling_8) Custom configuration for RS485 communication to choose the communication speed. void startTransmission () Start a transmission i.e. you send what is contained in the transmission buffer. void turnOffCommunication () Turn off the RS485. void turnOnCommunication () Turn on the RS485 communication."},{"location":"powerAPI/classRs485Communication/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"powerAPI/classRs485Communication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classRs485Communication/#function-configure","title":"function configure","text":"<p>Configuration for RS485 communication using a 10Mbit/s speed. <pre><code>void Rs485Communication::configure (\n    uint8_t * transmission_buffer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)() user_function,\n    rs485_speed_t data_speed=SPEED_10M\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the received buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>data_speed</code> Transmission speed (by default to 10Mbits/s) <code>SPEED_2M</code>,<code>SPEED_5M</code>,<code>SPEED_10M</code>,<code>SPEED_20M</code></li> </ul> <p>Warning:</p> <p>The size of transmission_buffer and reception_buffer must be the same </p>"},{"location":"powerAPI/classRs485Communication/#function-configurecustom","title":"function configureCustom","text":"<p>Custom configuration for RS485 communication to choose the communication speed. <pre><code>void Rs485Communication::configureCustom (\n    uint8_t * transmission_buffer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)(void) user_function,\n    uint32_t baudrate,\n    bool oversampling_8\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the received buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>baudrate</code> Communication speed in bit/s </li> <li><code>oversampling_8</code> True for oversampling (and multiply communication speed by 2), False if you want to keep the normal speed communication</li> </ul> <p>Warning:</p> <p>The size of transmission_buffer and reception_buffer must be the same </p>"},{"location":"powerAPI/classRs485Communication/#function-starttransmission","title":"function startTransmission","text":"<p>Start a transmission i.e. you send what is contained in the transmission buffer. <pre><code>void Rs485Communication::startTransmission () \n</code></pre></p>"},{"location":"powerAPI/classRs485Communication/#function-turnoffcommunication","title":"function turnOffCommunication","text":"<p>Turn off the RS485. <pre><code>void Rs485Communication::turnOffCommunication () \n</code></pre></p>"},{"location":"powerAPI/classRs485Communication/#function-turnoncommunication","title":"function turnOnCommunication","text":"<p>Turn on the RS485 communication. <pre><code>void Rs485Communication::turnOnCommunication () \n</code></pre></p> <p>Warning:</p> <p>The RS485 is automatically turned on when initializing with configureDefault or configure, no need to call this function </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/classSafetyAPI/","title":"Class SafetyAPI","text":"<p>ClassList &gt; SafetyAPI</p>"},{"location":"powerAPI/classSafetyAPI/#public-functions","title":"Public Functions","text":"Type Name void disableSafetyApi () Disables the safety API fault detection task. void enableSafetyApi () Enables the safety API fault detection task. bool getChannelError (sensor_t sensors_error) Check if the sensor faced an error (went over/under threshold) safety_reaction_t getChannelReaction () returns the reaction to do when encountering an error. float32_t getChannelThresholdMax (sensor_t sensors_threshold) Get the maximum threshold of the selected sensor. float32_t getChannelThresholdMin (sensor_t sensors_threshold) Get the minimum threshold of the selected sensor. bool getChannelWatch (sensor_t sensors_watch) check if a sensor is being monitored or not. void initShield () Initializes thresholds min/max with the default value from the device tree. void initShield (sensor_t * sensors_watch, uint8_t sensors_watch_number) Initializes thresholds min/max with the default value from the device tree. int8_t retrieveThreshold (sensor_t sensor_threshold_retrieve) Retrieves the current minimum and maximum threshold stored in the flash (non volatile memory) void setChannelReaction (safety_reaction_t sensors_reaction) Set the reaction to do if an error has been detected. int8_t setChannelThresholdMax (sensor_t * sensors_threshold, float32_t * threshold_max, uint8_t sensors_threshold_number) Set the maximum threshold for the sensors present in the list safety_sensors. int8_t setChannelThresholdMin (sensor_t * sensors_threshold, float32_t * threshold_min, uint8_t sensors_threshold_number) Set the minimum threshold for the sensors present in the list safety_sensors. int8_t setChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Enables the monitoring of the selected sensors for safety. int8_t storeThreshold (sensor_t sensor_threshold_store) Store the current minimum and maximum threshold in the flash (non volatile memory) int8_t unsetChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Disables the monitoring of the selected sensors for safety."},{"location":"powerAPI/classSafetyAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classSafetyAPI/#function-disablesafetyapi","title":"function disableSafetyApi","text":"<p>Disables the safety API fault detection task. <pre><code>void SafetyAPI::disableSafetyApi () \n</code></pre></p>"},{"location":"powerAPI/classSafetyAPI/#function-enablesafetyapi","title":"function enableSafetyApi","text":"<p>Enables the safety API fault detection task. <pre><code>void SafetyAPI::enableSafetyApi () \n</code></pre></p>"},{"location":"powerAPI/classSafetyAPI/#function-getchannelerror","title":"function getChannelError","text":"<p>Check if the sensor faced an error (went over/under threshold) <pre><code>bool SafetyAPI::getChannelError (\n    sensor_t sensors_error\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_error</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>True if the sensor faced an error, false if not </p>"},{"location":"powerAPI/classSafetyAPI/#function-getchannelreaction","title":"function getChannelReaction","text":"<p>returns the reaction to do when encountering an error. <pre><code>safety_reaction_t SafetyAPI::getChannelReaction () \n</code></pre></p> <p>Returns:</p> <p>Open_Circuit or Short_Circuit </p>"},{"location":"powerAPI/classSafetyAPI/#function-getchannelthresholdmax","title":"function getChannelThresholdMax","text":"<p>Get the maximum threshold of the selected sensor. <pre><code>float32_t SafetyAPI::getChannelThresholdMax (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>the maximum threshold </p>"},{"location":"powerAPI/classSafetyAPI/#function-getchannelthresholdmin","title":"function getChannelThresholdMin","text":"<p>Get the minimum threshold of the selected sensor. <pre><code>float32_t SafetyAPI::getChannelThresholdMin (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p>The minimum threshold </p>"},{"location":"powerAPI/classSafetyAPI/#function-getchannelwatch","title":"function getChannelWatch","text":"<p>check if a sensor is being monitored or not. <pre><code>bool SafetyAPI::getChannelWatch (\n    sensor_t sensors_watch\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> the sensor to check within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p><code>true</code> if the sensor is being monitored, <code>false</code> if not </p>"},{"location":"powerAPI/classSafetyAPI/#function-initshield-12","title":"function initShield [1/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree. <pre><code>void SafetyAPI::initShield () \n</code></pre></p> <p>If values were stored and found in the flash they will be used instead.</p> <p>All the sensors will be monitored to detect potential faults in voltage/current. </p>"},{"location":"powerAPI/classSafetyAPI/#function-initshield-22","title":"function initShield [2/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree. <pre><code>void SafetyAPI::initShield (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>If values were stored and found in the flash they will be used instead.</p> <p>All the sensors will be monitored to detect potential faults in voltage/current.</p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch. </li> </ul>"},{"location":"powerAPI/classSafetyAPI/#function-retrievethreshold","title":"function retrieveThreshold","text":"<p>Retrieves the current minimum and maximum threshold stored in the flash (non volatile memory) <pre><code>int8_t SafetyAPI::retrieveThreshold (\n    sensor_t sensor_threshold_retrieve\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_retrieve</code> the sensor to retrieve the threshold stored in the NVS within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved, negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested sensor </li> </ul>"},{"location":"powerAPI/classSafetyAPI/#function-setchannelreaction","title":"function setChannelReaction","text":"<p>Set the reaction to do if an error has been detected. <pre><code>void SafetyAPI::setChannelReaction (\n    safety_reaction_t sensors_reaction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li> <p><code>sensors_reaction</code> the reaction to do:</p> </li> <li> <p><code>Open_Circuit</code>: both switches are opened and no power flows to the output</p> </li> <li><code>Short_Circuit</code>: high-side switch is opened, and low-side is closed maintaining the output in short-circuit. Useful in motor control. </li> </ul>"},{"location":"powerAPI/classSafetyAPI/#function-setchannelthresholdmax","title":"function setChannelThresholdMax","text":"<p>Set the maximum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t SafetyAPI::setChannelThresholdMax (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_max,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>threshold_max</code> A list of the maximum threshold to apply to the sensors in safety_sensors.</li> <li><code>sensors_threshold_number</code> the number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if not. </p>"},{"location":"powerAPI/classSafetyAPI/#function-setchannelthresholdmin","title":"function setChannelThresholdMin","text":"<p>Set the minimum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t SafetyAPI::setChannelThresholdMin (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_min,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>threshold_min</code> A list of the minimum threshold to apply to the sensors in safety_sensors.</li> <li><code>sensors_threshold_number</code> The number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if not. </p>"},{"location":"powerAPI/classSafetyAPI/#function-setchannelwatch","title":"function setChannelWatch","text":"<p>Enables the monitoring of the selected sensors for safety. <pre><code>int8_t SafetyAPI::setChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if there was an error </p>"},{"location":"powerAPI/classSafetyAPI/#function-storethreshold","title":"function storeThreshold","text":"<p>Store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t SafetyAPI::storeThreshold (\n    sensor_t sensor_threshold_store\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_store</code> the sensor to store the threshold in the NVS within the possible names:</li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_store</code> The sensor for which we store the threshold in the NVS</li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly stored, <code>-1</code> if there was an error. </p>"},{"location":"powerAPI/classSafetyAPI/#function-unsetchannelwatch","title":"function unsetChannelWatch","text":"<p>Disables the monitoring of the selected sensors for safety. <pre><code>int8_t SafetyAPI::unsetChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables names can be: </li> </ul> <p><code>V1_LOW</code>,<code>V2_LOW</code>, <code>V_HIGH</code>, <code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>, <code>TEMP_SENSOR</code>, <code>EXTRA_MEAS</code>, <code>ANALOG_COMM</code></p> <p>Parameters:</p> <ul> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p><code>0</code> if successful, or <code>-1</code> if there was an error </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/classSensorsAPI/","title":"Class SensorsAPI","text":"<p>ClassList &gt; SensorsAPI</p>"},{"location":"powerAPI/classSensorsAPI/#public-functions","title":"Public Functions","text":"Type Name float32_t convertRawValue (sensor_t sensor_name, uint16_t raw_value) Use this function to convert values obtained using matching spin.data.get*RawValues() function. void enableDefaultOwnverterSensors () This function is used to enable acquisition of all voltage/current sensors on the OwnVerter shield. void enableDefaultTwistSensors () This function is used to enable acquisition of all voltage/current sensors on the Twist shield. int8_t enableSensor (sensor_t sensor_name, adc_t adc_number) This function is used to enable a shield sensor for acquisition by a given ADC. float32_t getLatestValue (sensor_t sensor_name, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the sensor: Volts, Amperes, or Degree Celsius. uint16_t * getRawValues (sensor_t sensor_name, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified sensor. float32_t * getValues (sensor_t sensor_name, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. float32_t peekLatestValue (sensor_t sensor_name) Function to access the latest value available from the sensor. int8_t retrieveParametersFromMemory (sensor_t sensor_name) Use this function to read the gain and offset parameters of the board to is non-volatile memory. conversion_type_t retrieveStoredConversionType (sensor_t sensor_name) Use this function to get the current conversion type for the chosen sensor. float32_t retrieveStoredParameterValue (sensor_t sensor_name, parameter_t parameter_name) Use this function to get the current conversion parameters for the chosen sensor. void setConversionParametersLinear (sensor_t sensor_name, float32_t gain, float32_t offset) Use this function to tweak the conversion values for any linear sensor if default values are not accurate enough. void setConversionParametersNtcThermistor (sensor_t sensor_name, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. void setOwnverterTempMeas (ownverter_temp_sensor_t temperature_sensor) This function sets the GPIOs attached to the MUX to control which temperature sensor will be measured. void setTwistSensorsUserCalibrationFactors () Manually set parameters values using console. You will be directed via console to input the parameters of each sensor of the Twist board. int8_t storeParametersInMemory (sensor_t sensor_name) Use this function to write the gain and offset parameters of the board to is non-volatile memory. void triggerTwistTempMeas (sensor_t temperature_sensor) Manually triggers the temperature measurement of the Twist board."},{"location":"powerAPI/classSensorsAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classSensorsAPI/#function-convertrawvalue","title":"function convertRawValue","text":"<p>Use this function to convert values obtained using matching spin.data.get*RawValues() function. <pre><code>float32_t SensorsAPI::convertRawValue (\n    sensor_t sensor_name,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Conversion will be done to relevant unit for the data: Volts, Amperes, or Degree Celsius.</p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which the value originates </li> <li><code>raw_value</code> Raw value obtained from which the value originates</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit.</p> <p>Returns <code>ERROR_CHANNEL_NOT_FOUND</code> if the sensor is not active. </p>"},{"location":"powerAPI/classSensorsAPI/#function-enabledefaultownvertersensors","title":"function enableDefaultOwnverterSensors","text":"<p>This function is used to enable acquisition of all voltage/current sensors on the OwnVerter shield. <pre><code>void SensorsAPI::enableDefaultOwnverterSensors () \n</code></pre></p> <p>Note:</p> <p>ADCs are triggered simultaneously.</p> <p>Note:</p> <p>Sensors are attributed to ADC1 and ADC2 as follows:</p> <ul> <li> <p><code>ADC1_LIST[5]</code>: [<code>V1_LOW</code>,<code>V2_LOW</code>, <code>I3_LOW</code>, <code>V_HIGH</code>, <code>V_NEUTR</code> ] </p> </li> <li> <p><code>ADC2_LIST[5]</code>: [<code>I1_LOW</code>,<code>I2_LOW</code>, <code>V3_LOW</code>, <code>I_HIGH</code>, <code>TEMP_SENSOR</code>]</p> </li> </ul> <p>This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events.</p> <p>All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> <p>It also configures the gpios that control the MUX that chooses which temperature will be measured.</p> <p>Note:</p> <p>This function must be called before ADC is started. </p>"},{"location":"powerAPI/classSensorsAPI/#function-enabledefaulttwistsensors","title":"function enableDefaultTwistSensors","text":"<p>This function is used to enable acquisition of all voltage/current sensors on the Twist shield. <pre><code>void SensorsAPI::enableDefaultTwistSensors () \n</code></pre></p> <p>Note:</p> <p>ADCs are triggered simultaneously.</p> <p>Note:</p> <p>Sensors are attributed to ADC1 and ADC2 as follows:</p> <ul> <li> <p><code>ADC1_LIST[3]</code>: [<code>V1_LOW</code>,<code>V2_LOW</code>,<code>V_HIGH</code>] </p> </li> <li> <p><code>ADC2_LIST[3]</code>: [<code>I1_LOW</code>,<code>I2_LOW</code>,<code>I_HIGH</code>]This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events.All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> </li> </ul> <p>Warning:</p> <p>This function must be called <code>before</code> ADC is started. </p>"},{"location":"powerAPI/classSensorsAPI/#function-enablesensor","title":"function enableSensor","text":"<p>This function is used to enable a shield sensor for acquisition by a given ADC. <pre><code>int8_t SensorsAPI::enableSensor (\n    sensor_t sensor_name,\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function requires the presence of an \"shield-sensor\" node in the shield device-tree.</p> <p>Note:</p> <p>This function must be called <code>before</code> ADC is started.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the sensor using enumeration sensor_t. </li> <li><code>adc_number</code> The ADC which should be used for acquisition.</li> </ul> <p>Returns:</p> <p>0 if the sensor was correctly enabled, negative value if there was an error.</p> <p>Public functions accessible only when using a power shield </p>"},{"location":"powerAPI/classSensorsAPI/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the sensor: Volts, Amperes, or Degree Celsius. <pre><code>float32_t SensorsAPI::getLatestValue (\n    sensor_t sensor_name,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using spin.data.get*RawValues() function for the matching sensor, as spin.data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain value. </li> <li><code>dataValid</code> Pointer to an <code>uint8_t</code> variable.</li> </ul> <p>This parameter is optional.</p> <p>If this parameter is provided, it will be updated to indicate information about spin.data.</p> <p>Possible values for this parameter will be:</p> <ul> <li><code>DATA_IS_OK</code> if returned data is a newly acquired data,</li> <li><code>DATA_IS_OLD</code> if returned data has already been provided before (no new data available since latest time this function was called),</li> <li><code>DATA_IS_MISSING</code> if returned data is <code>NO_VALUE</code>.</li> </ul> <p>Returns:</p> <p>Latest measure acquired by the sensor.</p> <p>If no value was acquired by this sensor yet, return value is <code>NO_VALUE</code>. </p>"},{"location":"powerAPI/classSensorsAPI/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified sensor. <pre><code>uint16_t * SensorsAPI::getRawValues (\n    sensor_t sensor_name,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function.</p> <p>However, different sensors buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion.</p> <p>Use matching spin.data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same sensor as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an <code>uint32_t</code> variable. </li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"powerAPI/classSensorsAPI/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. <pre><code>float32_t * SensorsAPI::getValues (\n    sensor_t sensor_name,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. </p> <p>Note:</p> <p>This function can NOT be called before the pin is enabled. </p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function.</p> <p>However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an <code>uint32_t</code> variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored.  </p>"},{"location":"powerAPI/classSensorsAPI/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from the sensor. <pre><code>float32_t SensorsAPI::peekLatestValue (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor from which to obtain value.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given sensor. If there was no value acquired by this sensor yet, return value is <code>NO_VALUE</code>. </p>"},{"location":"powerAPI/classSensorsAPI/#function-retrieveparametersfrommemory","title":"function retrieveParametersFromMemory","text":"<p>Use this function to read the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t SensorsAPI::retrieveParametersFromMemory (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to save the values. </li> </ul> <p>Returns:</p> <p><code>0</code> if parameters were correctly retrieved,negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested channel </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-retrievestoredconversiontype","title":"function retrieveStoredConversionType","text":"<p>Use this function to get the current conversion type for the chosen sensor. <pre><code>conversion_type_t SensorsAPI::retrieveStoredConversionType (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to get a conversion parameter. </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-retrievestoredparametervalue","title":"function retrieveStoredParameterValue","text":"<p>Use this function to get the current conversion parameters for the chosen sensor. <pre><code>float32_t SensorsAPI::retrieveStoredParameterValue (\n    sensor_t sensor_name,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retrieved: <code>gain</code> or <code>offset</code>. </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for any linear sensor if default values are not accurate enough. <pre><code>void SensorsAPI::setConversionParametersLinear (\n    sensor_t sensor_name,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. </p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to set conversion values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the sensor raw value. </li> <li><code>offset</code> Offset to be applied (added) to the sensor value after gain has been applied. </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void SensorsAPI::setConversionParametersNtcThermistor (\n    sensor_t sensor_name,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can NOT be called before the sensor is enabled. </p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to set conversion values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge divider resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-setownvertertempmeas","title":"function setOwnverterTempMeas","text":"<p>This function sets the GPIOs attached to the MUX to control which temperature sensor will be measured. <pre><code>void SensorsAPI::setOwnverterTempMeas (\n    ownverter_temp_sensor_t temperature_sensor\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>temperature_sensor</code> Name of the temperature sensor to trigger: <code>TEMP_1</code>, <code>TEMP_2</code>, <code>TEMP_3</code></li> </ul> <p>Note:</p> <p>This function will decide which value will be read automatically by the ADC2 to which the temperature of the Ownverter is linked.</p> <p>The logic is:</p> <ul> <li><code>TEMP_1: IN1 = T IN2 = F</code></li> <li><code>TEMP_2: IN1 = F IN2 = T</code></li> <li><code>TEMP_3: IN1 = T IN2 = T</code></li> </ul> <p>Please refer to the OwnVerter documentation and repository for more details </p>"},{"location":"powerAPI/classSensorsAPI/#function-settwistsensorsusercalibrationfactors","title":"function setTwistSensorsUserCalibrationFactors","text":"<p>Manually set parameters values using console. You will be directed via console to input the parameters of each sensor of the Twist board. <pre><code>void SensorsAPI::setTwistSensorsUserCalibrationFactors () \n</code></pre></p> <p>After the parameters have been set, they will be stored in Spin Non-Volatile memory so that they are automatically applied on subsequent boots.</p> <p>Note:</p> <p>This function requires a console to interact with the user. </p> <p>Note:</p> <p>This function can NOT be called before all Twist sensors have been enabled (you can use enableDefaultTwistSensors() for that purpose).</p> <p>The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task. </p>"},{"location":"powerAPI/classSensorsAPI/#function-storeparametersinmemory","title":"function storeParametersInMemory","text":"<p>Use this function to write the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t SensorsAPI::storeParametersInMemory (\n    sensor_t sensor_name\n) \n</code></pre></p> <p>Note:</p> <p>This function should be called after updating the parameters using setParameters.</p> <p>Parameters:</p> <ul> <li><code>sensor_name</code> Name of the shield sensor to save the values. </li> </ul>"},{"location":"powerAPI/classSensorsAPI/#function-triggertwisttempmeas","title":"function triggerTwistTempMeas","text":"<p>Manually triggers the temperature measurement of the Twist board. <pre><code>void SensorsAPI::triggerTwistTempMeas (\n    sensor_t temperature_sensor\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>temperature_sensor</code> Name of the temperature sensor to trigger: <code>TEMP_SENSOR_1</code>, <code>TEMP_SENSOR_2</code></li> </ul> <p>Note:</p> <p>This function must be called to trigger a conversion of the ADC to which the sensor is linked.</p> <p>It must be called <code>BEFORE</code> reading a new measurement.</p> <p>Account for delays in the measurement. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"powerAPI/unionSensorsAPI_1_1int2float/","title":"Union SensorsAPI::int2float","text":"<p>ClassList &gt; int2float</p> <p>More...</p>"},{"location":"powerAPI/unionSensorsAPI_1_1int2float/#public-attributes","title":"Public Attributes","text":"Type Name float32_t float_value uint32_t raw_value"},{"location":"powerAPI/unionSensorsAPI_1_1int2float/#detailed-description","title":"Detailed Description","text":"<p>Private types definitions </p>"},{"location":"powerAPI/unionSensorsAPI_1_1int2float/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/unionSensorsAPI_1_1int2float/#variable-float_value","title":"variable float_value","text":"<pre><code>float32_t SensorsAPI::int2float::float_value;\n</code></pre>"},{"location":"powerAPI/unionSensorsAPI_1_1int2float/#variable-raw_value","title":"variable raw_value","text":"<pre><code>uint32_t SensorsAPI::int2float::raw_value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/","title":"Struct SensorsAPI::sensor_dt_data_t","text":"<p>ClassList &gt; sensor_dt_data_t</p>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t adc_number uint32_t adc_reg_addr uint8_t channel_number conv_type_string_t conversion_type int2float default_b int2float default_gain int2float default_offset int2float default_r0 int2float default_rdiv int2float default_t0 bool is_differential sensor_t name uint8_t pin_number"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-adc_number","title":"variable adc_number","text":"<pre><code>uint8_t SensorsAPI::sensor_dt_data_t::adc_number;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-adc_reg_addr","title":"variable adc_reg_addr","text":"<pre><code>uint32_t SensorsAPI::sensor_dt_data_t::adc_reg_addr;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-channel_number","title":"variable channel_number","text":"<pre><code>uint8_t SensorsAPI::sensor_dt_data_t::channel_number;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-conversion_type","title":"variable conversion_type","text":"<pre><code>conv_type_string_t SensorsAPI::sensor_dt_data_t::conversion_type;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_b","title":"variable default_b","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_b;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_gain","title":"variable default_gain","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_gain;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_offset","title":"variable default_offset","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_offset;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_r0","title":"variable default_r0","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_r0;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_rdiv","title":"variable default_rdiv","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_rdiv;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-default_t0","title":"variable default_t0","text":"<pre><code>int2float SensorsAPI::sensor_dt_data_t::default_t0;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-is_differential","title":"variable is_differential","text":"<pre><code>bool SensorsAPI::sensor_dt_data_t::is_differential;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-name","title":"variable name","text":"<pre><code>sensor_t SensorsAPI::sensor_dt_data_t::name;\n</code></pre>"},{"location":"powerAPI/structSensorsAPI_1_1sensor__dt__data__t/#variable-pin_number","title":"variable pin_number","text":"<pre><code>uint8_t SensorsAPI::sensor_dt_data_t::pin_number;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"powerAPI/classShieldAPI/","title":"Class ShieldAPI","text":"<p>ClassList &gt; ShieldAPI</p>"},{"location":"powerAPI/classShieldAPI/#public-static-attributes","title":"Public Static Attributes","text":"Type Name NgndHAL ngnd Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. PowerAPI power Contains all the functions to drive shield power capabilities. SensorsAPI sensors Contains all the functions to interact with shield sensors."},{"location":"powerAPI/classShieldAPI/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/classShieldAPI/#variable-ngnd","title":"variable ngnd","text":"<p>Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. <pre><code>NgndHAL ShieldAPI::ngnd;\n</code></pre></p>"},{"location":"powerAPI/classShieldAPI/#variable-power","title":"variable power","text":"<p>Contains all the functions to drive shield power capabilities. <pre><code>PowerAPI ShieldAPI::power;\n</code></pre></p>"},{"location":"powerAPI/classShieldAPI/#variable-sensors","title":"variable sensors","text":"<p>Contains all the functions to interact with shield sensors. <pre><code>SensorsAPI ShieldAPI::sensors;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.h</code></p>"},{"location":"powerAPI/classSpinAPI/","title":"Class SpinAPI","text":"<p>ClassList &gt; SpinAPI</p> <p>Contains all the elements linked to peripherals of the spin board. </p> <ul> <li><code>#include &lt;SpinAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classSpinAPI/#public-static-attributes","title":"Public Static Attributes","text":"Type Name CompHAL comp Contains all the function of the STM32 comparator used with the current mode. DacHAL dac Contains all the function of the STM32 DAC used to generate signals and handle the current mode. DataAPI data Data acquisition from SPIN ADCs. GpioHAL gpio Contains all the functions for the spin gpio. LedHAL led Contains all the function of the embedded LED. PwmHAL pwm Contains all the function of the STM32 hrtim PWM generator. TimerHAL timer Contains all the function of the STM32 Timer4 functions that handle the encoder. UartHAL uart Contains all the function of the STM32 Usart1 functions."},{"location":"powerAPI/classSpinAPI/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/classSpinAPI/#variable-comp","title":"variable comp","text":"<p>Contains all the function of the STM32 comparator used with the current mode. <pre><code>CompHAL SpinAPI::comp;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-dac","title":"variable dac","text":"<p>Contains all the function of the STM32 DAC used to generate signals and handle the current mode. <pre><code>DacHAL SpinAPI::dac;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-data","title":"variable data","text":"<p>Data acquisition from SPIN ADCs. <pre><code>DataAPI SpinAPI::data;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-gpio","title":"variable gpio","text":"<p>Contains all the functions for the spin gpio. <pre><code>GpioHAL SpinAPI::gpio;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-led","title":"variable led","text":"<p>Contains all the function of the embedded LED. <pre><code>LedHAL SpinAPI::led;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-pwm","title":"variable pwm","text":"<p>Contains all the function of the STM32 hrtim PWM generator. <pre><code>PwmHAL SpinAPI::pwm;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-timer","title":"variable timer","text":"<p>Contains all the function of the STM32 Timer4 functions that handle the encoder. <pre><code>TimerHAL SpinAPI::timer;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-uart","title":"variable uart","text":"<p>Contains all the function of the STM32 Usart1 functions. <pre><code>UartHAL SpinAPI::uart;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/classSyncCommunication/","title":"Class SyncCommunication","text":"<p>ClassList &gt; SyncCommunication</p> <p>More...</p> <ul> <li><code>#include &lt;SyncCommunication.h&gt;</code></li> </ul>"},{"location":"powerAPI/classSyncCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name void initMaster () Initialization synchronization as <code>MASTER</code> , the master send the synchronization pulse. void initSlave () Initialization synchronization as <code>SLAVE</code> , the slave receive the synchronization pulse."},{"location":"powerAPI/classSyncCommunication/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"powerAPI/classSyncCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classSyncCommunication/#function-initmaster","title":"function initMaster","text":"<p>Initialization synchronization as <code>MASTER</code> , the master send the synchronization pulse. <pre><code>static void SyncCommunication::initMaster () \n</code></pre></p>"},{"location":"powerAPI/classSyncCommunication/#function-initslave","title":"function initSlave","text":"<p>Initialization synchronization as <code>SLAVE</code> , the slave receive the synchronization pulse. <pre><code>static void SyncCommunication::initSlave () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/classTaskAPI/","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p> <p>More...</p> <ul> <li><code>#include &lt;TaskAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classTaskAPI/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critical task. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"powerAPI/classTaskAPI/#detailed-description","title":"Detailed Description","text":"<p>Static class definition </p>"},{"location":"powerAPI/classTaskAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTaskAPI/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"powerAPI/classTaskAPI/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critical task. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Note:</p> <p>If the <code>HRTIM</code> is used to trigger the task (which is the default behavior), then the <code>HRTIM</code> must have been configured before calling this function.</p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically.</li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is <code>HRTIM</code>, this value must be an integer multiple of the <code>HRTIM</code> period.</li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the <code>HRTIM</code> is the source, but this optional parameter can be provided to set TIM6 as the source in case the <code>HRTIM</code> is not used or if the task can't be correlated to an <code>HRTIM</code> event. Allowed values are source_hrtim and source_tim6.</li> </ul> <p>Returns:</p> <p><code>0</code> if everything went well, <code>-1</code> if there was an error defining the task.</p> <p>An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"powerAPI/classTaskAPI/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopcritical","title":"function stopCritical","text":"<p>Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptable user task. The task can be then resumed by calling startCritical() again. <pre><code>void TaskAPI::stopCritical () \n</code></pre></p>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/classTimerHAL/","title":"Class TimerHAL","text":"<p>ClassList &gt; TimerHAL</p> <p>Handles timer 4 for the SPIN board. More...</p> <ul> <li><code>#include &lt;TimerHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classTimerHAL/#public-functions","title":"Public Functions","text":"Type Name uint32_t getIncrementalEncoderValue (timernumber_t timer_number) Gets the encoder step value. void startLogIncrementalEncoder (timernumber_t timer_number) Launches the timer4 which is adapted for reading an encoder."},{"location":"powerAPI/classTimerHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize timer 4 and use it with an incremental encoder </p>"},{"location":"powerAPI/classTimerHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTimerHAL/#function-getincrementalencodervalue","title":"function getIncrementalEncoderValue","text":"<p>Gets the encoder step value. <pre><code>uint32_t TimerHAL::getIncrementalEncoderValue (\n    timernumber_t timer_number\n) \n</code></pre></p> <p>Returns:</p> <p>An uint32 value of the counter which corresponds to the step of the system. </p>"},{"location":"powerAPI/classTimerHAL/#function-startlogincrementalencoder","title":"function startLogIncrementalEncoder","text":"<p>Launches the timer4 which is adapted for reading an encoder. <pre><code>void TimerHAL::startLogIncrementalEncoder (\n    timernumber_t timer_number\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/classUartHAL/","title":"Class UartHAL","text":"<p>ClassList &gt; UartHAL</p> <p>Handles USART1 for the SPIN board. More...</p> <ul> <li><code>#include &lt;UartHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classUartHAL/#public-functions","title":"Public Functions","text":"Type Name void usart1Init () Library initialization function for the USART communication. This function is declared on the private section of the .c file. char usart1ReadChar () This function sends back a single character waiting to be treated from the USART1. void usart1SwapRxTx () This function swaps the USART RX and TX pins. It should be called in conjunction with a board version setup. void usart1WriteChar (char data) This function transmits a single character through the USART1."},{"location":"powerAPI/classUartHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize and send messages via USART1 </p>"},{"location":"powerAPI/classUartHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classUartHAL/#function-usart1init","title":"function usart1Init","text":"<p>Library initialization function for the USART communication. This function is declared on the private section of the .c file. <pre><code>void UartHAL::usart1Init () \n</code></pre></p> <p>USART 1 public functions </p>"},{"location":"powerAPI/classUartHAL/#function-usart1readchar","title":"function usart1ReadChar","text":"<p>This function sends back a single character waiting to be treated from the USART1. <pre><code>char UartHAL::usart1ReadChar () \n</code></pre></p> <p>Returns:</p> <p>This function returns a single char which is waiting to be treated if no char is waiting it returns an 'x' which should be treated as an error </p>"},{"location":"powerAPI/classUartHAL/#function-usart1swaprxtx","title":"function usart1SwapRxTx","text":"<p>This function swaps the USART RX and TX pins. It should be called in conjunction with a board version setup. <pre><code>void UartHAL::usart1SwapRxTx () \n</code></pre></p>"},{"location":"powerAPI/classUartHAL/#function-usart1writechar","title":"function usart1WriteChar","text":"<p>This function transmits a single character through the USART1. <pre><code>void UartHAL::usart1WriteChar (\n    char data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> single char to be sent out </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/structadc__hrtim__conf__t/","title":"Struct adc_hrtim_conf_t","text":"<p>ClassList &gt; adc_hrtim_conf_t</p> <p>Structure containing information to setup adc events, adc source links and adc triggers. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_adc_event_t adc_event hrtim_adc_edgetrigger_t adc_rollover hrtim_adc_source_t adc_source hrtim_adc_trigger_t adc_trigger"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_event","title":"variable adc_event","text":"<pre><code>hrtim_adc_event_t adc_hrtim_conf_t::adc_event;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_rollover","title":"variable adc_rollover","text":"<pre><code>hrtim_adc_edgetrigger_t adc_hrtim_conf_t::adc_rollover;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_source","title":"variable adc_source","text":"<pre><code>hrtim_adc_source_t adc_hrtim_conf_t::adc_source;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_trigger","title":"variable adc_trigger","text":"<pre><code>hrtim_adc_trigger_t adc_hrtim_conf_t::adc_trigger;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structcan__control__work__data/","title":"Struct can_control_work_data","text":"<p>ClassList &gt; can_control_work_data</p>"},{"location":"powerAPI/structcan__control__work__data/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t buf size_t buf_len struct k_work work"},{"location":"powerAPI/structcan__control__work__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structcan__control__work__data/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t can_control_work_data::buf[4+CAN_MAX_DLEN];\n</code></pre>"},{"location":"powerAPI/structcan__control__work__data/#variable-buf_len","title":"variable buf_len","text":"<pre><code>size_t can_control_work_data::buf_len;\n</code></pre>"},{"location":"powerAPI/structcan__control__work__data/#variable-work","title":"variable work","text":"<pre><code>struct k_work can_control_work_data::work;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_can.c</code></p>"},{"location":"powerAPI/structcomp__usage__conf__t/","title":"Struct comp_usage_conf_t","text":"<p>ClassList &gt; comp_usage_conf_t</p> <p>Structure containing the status of the usage of comparators and their values. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_comp_usage_t cmp1 uint16_t cmp1_value hrtim_comp_usage_t cmp2 uint16_t cmp2_value hrtim_comp_usage_t cmp3 uint16_t cmp3_value hrtim_comp_usage_t cmp4 uint16_t cmp4_value"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1","title":"variable cmp1","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp1;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1_value","title":"variable cmp1_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp1_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2","title":"variable cmp2","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp2;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2_value","title":"variable cmp2_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp2_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3","title":"variable cmp3","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp3;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3_value","title":"variable cmp3_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp3_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4","title":"variable cmp4","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp4;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4_value","title":"variable cmp4_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp4_value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structdac__driver__api/","title":"Struct dac_driver_api","text":"<p>ClassList &gt; dac_driver_api</p>"},{"location":"powerAPI/structdac__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name dac_api_fn_upd_reset fn_upd_reset dac_api_fn_upd_step fn_upd_step dac_api_pinconfigure pinconfigure dac_api_setconstvalue setconstvalue dac_api_setfunction setfunction dac_api_start start dac_api_stop stop"},{"location":"powerAPI/structdac__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_reset","title":"variable fn_upd_reset","text":"<pre><code>dac_api_fn_upd_reset dac_driver_api::fn_upd_reset;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_step","title":"variable fn_upd_step","text":"<pre><code>dac_api_fn_upd_step dac_driver_api::fn_upd_step;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-pinconfigure","title":"variable pinconfigure","text":"<pre><code>dac_api_pinconfigure dac_driver_api::pinconfigure;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setconstvalue","title":"variable setconstvalue","text":"<pre><code>dac_api_setconstvalue dac_driver_api::setconstvalue;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setfunction","title":"variable setfunction","text":"<pre><code>dac_api_setfunction dac_driver_api::setfunction;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-start","title":"variable start","text":"<pre><code>dac_api_start dac_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>dac_api_stop dac_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structdac__function__config__t/","title":"Struct dac_function_config_t","text":"<p>ClassList &gt; dac_function_config_t</p> <p>Defines the DAC configuration structure. </p> <ul> <li><code>#include &lt;dac.h&gt;</code></li> </ul>"},{"location":"powerAPI/structdac__function__config__t/#public-attributes","title":"Public Attributes","text":"Type Name dac_function_t dac_function dac_polarity_t polarity uint32_t reset_data dac_trigger_t reset_trigger_source uint32_t step_data dac_trigger_t step_trigger_source"},{"location":"powerAPI/structdac__function__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__function__config__t/#variable-dac_function","title":"variable dac_function","text":"<pre><code>dac_function_t dac_function_config_t::dac_function;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-polarity","title":"variable polarity","text":"<pre><code>dac_polarity_t dac_function_config_t::polarity;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_data","title":"variable reset_data","text":"<pre><code>uint32_t dac_function_config_t::reset_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_trigger_source","title":"variable reset_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::reset_trigger_source;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_data","title":"variable step_data","text":"<pre><code>uint32_t dac_function_config_t::step_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_trigger_source","title":"variable step_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::step_trigger_source;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structdma__user__data__t/","title":"Struct dma_user_data_t","text":"<p>ClassList &gt; dma_user_data_t</p>"},{"location":"powerAPI/structdma__user__data__t/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t channel uint32_t dst bool has_interrupt size_t size uint32_t src"},{"location":"powerAPI/structdma__user__data__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdma__user__data__t/#variable-channel","title":"variable channel","text":"<pre><code>uint32_t dma_user_data_t::channel;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-dst","title":"variable dst","text":"<pre><code>uint32_t dma_user_data_t::dst;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-has_interrupt","title":"variable has_interrupt","text":"<pre><code>bool dma_user_data_t::has_interrupt;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-size","title":"variable size","text":"<pre><code>size_t dma_user_data_t::size;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-src","title":"variable src","text":"<pre><code>uint32_t dma_user_data_t::src;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.cpp</code></p>"},{"location":"powerAPI/structgpio__conf__t/","title":"Struct gpio_conf_t","text":"<p>ClassList &gt; gpio_conf_t</p> <p>Structure containing all the information of the gpio linked to a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structgpio__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_output_units_t OUT_H hrtim_output_units_t OUT_L LL_GPIO_InitTypeDef switch_H LL_GPIO_InitTypeDef switch_L hrtim_gpio_clock_number_t tu_gpio_CLK GPIO_TypeDef * unit"},{"location":"powerAPI/structgpio__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structgpio__conf__t/#variable-out_h","title":"variable OUT_H","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-out_l","title":"variable OUT_L","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_h","title":"variable switch_H","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_l","title":"variable switch_L","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-tu_gpio_clk","title":"variable tu_gpio_CLK","text":"<pre><code>hrtim_gpio_clock_number_t gpio_conf_t::tu_gpio_CLK;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-unit","title":"variable unit","text":"<pre><code>GPIO_TypeDef* gpio_conf_t::unit;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structphase__shift__conf__t/","title":"Struct phase_shift_conf_t","text":"<p>ClassList &gt; phase_shift_conf_t</p> <p>Structure containing all the data regarding phase shifting for a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_tu_t compare_tu hrtim_reset_trig_t reset_trig uint16_t value"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structphase__shift__conf__t/#variable-compare_tu","title":"variable compare_tu","text":"<pre><code>hrtim_tu_t phase_shift_conf_t::compare_tu;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-reset_trig","title":"variable reset_trig","text":"<pre><code>hrtim_reset_trig_t phase_shift_conf_t::reset_trig;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-value","title":"variable value","text":"<pre><code>uint16_t phase_shift_conf_t::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structpwm__conf__t/","title":"Struct pwm_conf_t","text":"<p>ClassList &gt; pwm_conf_t</p> <p>Structure containing all the data regarding the pwm of a given timing unit. More...</p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structpwm__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_burst_clk_t burst_clk uint8_t ckpsc uint16_t duty_cycle uint16_t duty_max uint16_t duty_max_user float32_t duty_max_user_float uint16_t duty_min uint16_t duty_min_user float32_t duty_min_user_float uint8_t duty_swap hrtim_external_trigger_t external_trigger uint16_t fall_dead_time uint32_t frequency uint32_t max_frequency uint16_t max_period uint32_t min_frequency uint16_t min_period hrtim_cnt_t modulation uint16_t period hrtim_pwm_mode_t pwm_mode hrtim_tu_t pwm_tu uint32_t resolution uint16_t rise_dead_time hrtim_tu_ON_OFF_t unit_on"},{"location":"powerAPI/structpwm__conf__t/#detailed-description","title":"Detailed Description","text":"<p>Structs </p>"},{"location":"powerAPI/structpwm__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structpwm__conf__t/#variable-burst_clk","title":"variable burst_clk","text":"<pre><code>hrtim_burst_clk_t pwm_conf_t::burst_clk;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-ckpsc","title":"variable ckpsc","text":"<pre><code>uint8_t pwm_conf_t::ckpsc;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_cycle","title":"variable duty_cycle","text":"<pre><code>uint16_t pwm_conf_t::duty_cycle;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_max","title":"variable duty_max","text":"<pre><code>uint16_t pwm_conf_t::duty_max;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_max_user","title":"variable duty_max_user","text":"<pre><code>uint16_t pwm_conf_t::duty_max_user;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_max_user_float","title":"variable duty_max_user_float","text":"<pre><code>float32_t pwm_conf_t::duty_max_user_float;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_min","title":"variable duty_min","text":"<pre><code>uint16_t pwm_conf_t::duty_min;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_min_user","title":"variable duty_min_user","text":"<pre><code>uint16_t pwm_conf_t::duty_min_user;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_min_user_float","title":"variable duty_min_user_float","text":"<pre><code>float32_t pwm_conf_t::duty_min_user_float;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_swap","title":"variable duty_swap","text":"<pre><code>uint8_t pwm_conf_t::duty_swap;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-external_trigger","title":"variable external_trigger","text":"<pre><code>hrtim_external_trigger_t pwm_conf_t::external_trigger;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-fall_dead_time","title":"variable fall_dead_time","text":"<pre><code>uint16_t pwm_conf_t::fall_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-frequency","title":"variable frequency","text":"<pre><code>uint32_t pwm_conf_t::frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-max_frequency","title":"variable max_frequency","text":"<pre><code>uint32_t pwm_conf_t::max_frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-max_period","title":"variable max_period","text":"<pre><code>uint16_t pwm_conf_t::max_period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-min_frequency","title":"variable min_frequency","text":"<pre><code>uint32_t pwm_conf_t::min_frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-min_period","title":"variable min_period","text":"<pre><code>uint16_t pwm_conf_t::min_period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-modulation","title":"variable modulation","text":"<pre><code>hrtim_cnt_t pwm_conf_t::modulation;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-period","title":"variable period","text":"<pre><code>uint16_t pwm_conf_t::period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_mode","title":"variable pwm_mode","text":"<pre><code>hrtim_pwm_mode_t pwm_conf_t::pwm_mode;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_tu","title":"variable pwm_tu","text":"<pre><code>hrtim_tu_t pwm_conf_t::pwm_tu;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-resolution","title":"variable resolution","text":"<pre><code>uint32_t pwm_conf_t::resolution;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-rise_dead_time","title":"variable rise_dead_time","text":"<pre><code>uint16_t pwm_conf_t::rise_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-unit_on","title":"variable unit_on","text":"<pre><code>hrtim_tu_ON_OFF_t pwm_conf_t::unit_on;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structsensor__info__t/","title":"Struct sensor_info_t","text":"<p>ClassList &gt; sensor_info_t</p>"},{"location":"powerAPI/structsensor__info__t/#public-attributes","title":"Public Attributes","text":"Type Name adc_t adc_num uint8_t channel_num uint8_t pin_num"},{"location":"powerAPI/structsensor__info__t/#public-functions","title":"Public Functions","text":"Type Name sensor_info_t (adc_t adc_num, uint8_t channel_num, uint8_t pin_num)"},{"location":"powerAPI/structsensor__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structsensor__info__t/#variable-adc_num","title":"variable adc_num","text":"<pre><code>adc_t sensor_info_t::adc_num;\n</code></pre>"},{"location":"powerAPI/structsensor__info__t/#variable-channel_num","title":"variable channel_num","text":"<pre><code>uint8_t sensor_info_t::channel_num;\n</code></pre>"},{"location":"powerAPI/structsensor__info__t/#variable-pin_num","title":"variable pin_num","text":"<pre><code>uint8_t sensor_info_t::pin_num;\n</code></pre>"},{"location":"powerAPI/structsensor__info__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/structsensor__info__t/#function-sensor_info_t","title":"function sensor_info_t","text":"<pre><code>inline sensor_info_t::sensor_info_t (\n    adc_t adc_num,\n    uint8_t channel_num,\n    uint8_t pin_num\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"powerAPI/structswitch__conv__conf__t/","title":"Struct switch_conv_conf_t","text":"<p>ClassList &gt; switch_conv_conf_t</p> <p>Structure describing the switching convention of a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_switch_convention_t convention uint32_t reset_H uint32_t reset_L uint32_t set_H uint32_t set_L"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structswitch__conv__conf__t/#variable-convention","title":"variable convention","text":"<pre><code>hrtim_switch_convention_t switch_conv_conf_t::convention;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_h","title":"variable reset_H","text":"<pre><code>uint32_t switch_conv_conf_t::reset_H;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_l","title":"variable reset_L","text":"<pre><code>uint32_t switch_conv_conf_t::reset_L;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_h","title":"variable set_H","text":"<pre><code>uint32_t switch_conv_conf_t::set_H;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_l","title":"variable set_L","text":"<pre><code>uint32_t switch_conv_conf_t::set_L;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structtimer__config__t/","title":"Struct timer_config_t","text":"<p>ClassList &gt; timer_config_t</p> <p>Timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder: set to 1 for timer to act as an incremental coder counter. More...</p> <ul> <li><code>#include &lt;timer.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__config__t/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t timer_enable_encoder uint32_t timer_enable_irq pin_mode_t timer_enc_pin_mode timer_callback_t timer_irq_callback uint32_t timer_irq_t_usec uint32_t timer_use_zero_latency"},{"location":"powerAPI/structtimer__config__t/#detailed-description","title":"Detailed Description","text":"<p>*** IRQ mode (ignored if timer_enable_irq=0) *** * timer_irq_callback : pointer to a void(void) function that will be called on timer overflow. * timer_irq_t_usec : period of the interrupt in microsecond (2 to 6553 \u00b5s) * timer_use_zero_latency: for tasks, use zero-latency interrupts. Only used by Task API, end-user should set this one to false.</p> <p>*** Incremental encoder mode (ignored if timer_enable_encoder=0) *** * timer_pin_mode : Pin mode for incremental coder interface.</p> <p>Note:</p> <p>At this time, only irq mode is supported on TIM6/TIM7, and only incremental coder mode is supported on TIM4.</p> <p>This limitation makes this configuration structure almost pointless (except for callback definition).</p> <p>However, it is built this way with future evolutions of the driver in mind. </p>"},{"location":"powerAPI/structtimer__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_encoder","title":"variable timer_enable_encoder","text":"<pre><code>uint32_t timer_config_t::timer_enable_encoder;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_irq","title":"variable timer_enable_irq","text":"<pre><code>uint32_t timer_config_t::timer_enable_irq;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enc_pin_mode","title":"variable timer_enc_pin_mode","text":"<pre><code>pin_mode_t timer_config_t::timer_enc_pin_mode;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_callback","title":"variable timer_irq_callback","text":"<pre><code>timer_callback_t timer_config_t::timer_irq_callback;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_t_usec","title":"variable timer_irq_t_usec","text":"<pre><code>uint32_t timer_config_t::timer_irq_t_usec;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_use_zero_latency","title":"variable timer_use_zero_latency","text":"<pre><code>uint32_t timer_config_t::timer_use_zero_latency;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__driver__api/","title":"Struct timer_driver_api","text":"<p>ClassList &gt; timer_driver_api</p> <p>Driver API structure for timer devices. More...</p> <ul> <li><code>#include &lt;timer.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name timer_api_config config timer_api_get_count get_count timer_api_start start timer_api_stop stop"},{"location":"powerAPI/structtimer__driver__api/#detailed-description","title":"Detailed Description","text":"<p>This structure defines the interface that a timer driver must implement to integrate with the OwnTech timer subsystem.</p> <ul> <li><code>config</code> is the function used to configure the timer.</li> <li><code>start</code> starts the timer operation.</li> <li><code>stop</code> stops the timer operation.</li> <li><code>get_count</code> retrieves the current timer counter value.</li> </ul> <p>This structure is registered as a Zephyr subsystem using the <code>__subsystem</code> keyword. </p>"},{"location":"powerAPI/structtimer__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__driver__api/#variable-config","title":"variable config","text":"<pre><code>timer_api_config timer_driver_api::config;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-get_count","title":"variable get_count","text":"<pre><code>timer_api_get_count timer_driver_api::get_count;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-start","title":"variable start","text":"<pre><code>timer_api_start timer_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>timer_api_stop timer_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__hrtim__t/","title":"Struct timer_hrtim_t","text":"<p>ClassList &gt; timer_hrtim_t</p> <p>Timing unit configuration that aggregates all the structures: More...</p> <ul> <li><code>#include &lt;hrtim.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes","title":"Public Attributes","text":"Type Name adc_hrtim_conf_t adc_hrtim comp_usage_conf_t comp_usage gpio_conf_t gpio_conf phase_shift_conf_t phase_shift pwm_conf_t pwm_conf switch_conv_conf_t switch_conv"},{"location":"powerAPI/structtimer__hrtim__t/#detailed-description","title":"Detailed Description","text":"<ul> <li><code>pwm_conf</code> = Pulse Width Modulation Configuration</li> <li> <p><code>phase_shift</code> = Phase shift configuration </p> </li> <li> <p><code>gpio_conf</code> = Configuration of the gpio </p> </li> <li> <p><code>switch_conv</code> = Switch Convention </p> </li> <li> <p><code>adc_hrtim</code> = ADC - HRTIM setup </p> </li> <li> <p><code>comp_usage</code> = Usage of comp1 to comp4 </p> </li> </ul>"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__hrtim__t/#variable-adc_hrtim","title":"variable adc_hrtim","text":"<pre><code>adc_hrtim_conf_t timer_hrtim_t::adc_hrtim;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-comp_usage","title":"variable comp_usage","text":"<pre><code>comp_usage_conf_t timer_hrtim_t::comp_usage;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-gpio_conf","title":"variable gpio_conf","text":"<pre><code>gpio_conf_t timer_hrtim_t::gpio_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-phase_shift","title":"variable phase_shift","text":"<pre><code>phase_shift_conf_t timer_hrtim_t::phase_shift;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-pwm_conf","title":"variable pwm_conf","text":"<pre><code>pwm_conf_t timer_hrtim_t::pwm_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-switch_conv","title":"variable switch_conv","text":"<pre><code>switch_conv_conf_t timer_hrtim_t::switch_conv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/","title":"Dir docs/core","text":"<p>FileList &gt; core</p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/</code></p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/","title":"Dir docs/core/zephyr","text":"<p>FileList &gt; core &gt; zephyr</p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/#directories","title":"Directories","text":"Type Name dir modules <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/</code></p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/","title":"Dir docs/core/zephyr/modules","text":"<p>FileList &gt; core &gt; zephyr &gt; modules</p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/#directories","title":"Directories","text":"Type Name dir owntech_adc_driver dir owntech_communication dir owntech_comparator_driver dir owntech_dac_driver dir owntech_flash_driver dir owntech_hrtim_driver dir owntech_ngnd_driver dir owntech_safety_api dir owntech_shield_api dir owntech_spin_api dir owntech_task_api dir owntech_timer_driver <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/</code></p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver</p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/</code></p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/#files","title":"Files","text":"Type Name file adc.c file adc.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/adc_8c/","title":"File adc.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t adc_discontinuous_mode   = <code>{0}</code> adc_ev_src_t adc_trigger_sources   = <code>{0}</code> bool enable_dma   = <code>{0}</code> uint32_t enabled_channels   = <code>{0}</code> uint32_t enabled_channels_count   = <code>{0}</code>"},{"location":"powerAPI/adc_8c/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the trigger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurrence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/adc_8c/#variable-adc_discontinuous_mode","title":"variable adc_discontinuous_mode","text":"<pre><code>uint32_t adc_discontinuous_mode[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-adc_trigger_sources","title":"variable adc_trigger_sources","text":"<pre><code>adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS];\n</code></pre> <p>Local variables </p>"},{"location":"powerAPI/adc_8c/#variable-enable_dma","title":"variable enable_dma","text":"<pre><code>bool enable_dma[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels","title":"variable enabled_channels","text":"<pre><code>uint32_t enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels_count","title":"variable enabled_channels_count","text":"<pre><code>uint32_t enabled_channels_count[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8c/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the trigger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>trigger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8c/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurrence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_start","title":"function adc_start","text":"<p>Starts all configured ADCs. <pre><code>void adc_start () \n</code></pre></p>"},{"location":"powerAPI/adc_8c/#function-adc_stop","title":"function adc_stop","text":"<p>Stops all configured ADCs. <pre><code>void adc_stop () \n</code></pre></p>"},{"location":"powerAPI/adc_8c/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.c</code></p>"},{"location":"powerAPI/adc_8c_source/","title":"File adc.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* STM32 LL */\n#include &lt;stm32_ll_adc.h&gt;\n\n/* Current module private functions */\n#include \"../src/adc_core.h\"\n\n/* Current file header */\n#include \"adc.h\"\n\n\n#define NUMBER_OF_ADCS 5\n#define NUMBER_OF_CHANNELS_PER_ADC 16\n\n\n\nstatic adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS]    = {0};\nstatic uint32_t     adc_discontinuous_mode[NUMBER_OF_ADCS] = {0};\nstatic uint32_t     enabled_channels_count[NUMBER_OF_ADCS] = {0};\nstatic bool         enable_dma[NUMBER_OF_ADCS]             = {0};\n\nstatic uint32_t\n        enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC] = {0};\n\n\n/* Public API */\n\nvoid adc_configure_trigger_source(uint8_t adc_number,\n                                  adc_ev_src_t trigger_source)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_trigger_sources[adc_number-1] = trigger_source;\n\n}\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number,\n                                      uint32_t discontinuous_count)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_discontinuous_mode[adc_number-1] = discontinuous_count;\n}\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    if (enabled_channels_count[adc_index] == NUMBER_OF_CHANNELS_PER_ADC)\n        return;\n\n    enabled_channels[adc_index][enabled_channels_count[adc_index]] = channel;\n    enabled_channels_count[adc_index]++;\n}\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    for (int i = 0 ; i &lt; NUMBER_OF_CHANNELS_PER_ADC ; i++)\n    {\n        if (enabled_channels[adc_index][i] == channel)\n        {\n            for (int j = i ; j &lt; NUMBER_OF_CHANNELS_PER_ADC-1 ; j++)\n            {\n                enabled_channels[adc_index][i] = enabled_channels[adc_index][i+1];\n            }\n            enabled_channels[adc_index][NUMBER_OF_CHANNELS_PER_ADC-1] = 0;\n\n            enabled_channels_count[adc_index]--;\n\n            break;\n        }\n    }\n}\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return 0;\n\n    uint8_t adc_index = adc_number-1;\n\n    return enabled_channels_count[adc_index];\n}\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    enable_dma[adc_number-1] = use_dma;\n}\n\nvoid adc_start()\n{\n    /* Initialize ADCs */\n\n    adc_core_init();\n\n\n    /* Enable ADCs */\n\n    for (int adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        adc_core_enable(adc_num);\n    }\n\n    /* Post-enable configuration */\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            for (int channel_index = 0;\n                channel_index &lt; NUMBER_OF_CHANNELS_PER_ADC;\n                channel_index++)\n            {\n                if (enabled_channels[adc_index][channel_index] == 0)\n                    break;\n\n                adc_core_configure_channel(\n                    adc_num,\n                    enabled_channels[adc_index][channel_index],\n                    channel_index+1);\n            }\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_dma_mode(adc_num, enable_dma[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_discontinuous_mode(\n                adc_num,\n                adc_discontinuous_mode[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            /* Convert to LL constants */\n            uint32_t trig;\n            switch (adc_trigger_sources[adc_index])\n            {\n            case hrtim_ev1:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG1;\n                break;\n            case hrtim_ev2:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG2;\n                break;\n            case hrtim_ev3:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG3;\n                break;\n            case hrtim_ev4:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG4;\n                break;\n            case hrtim_ev5:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG5;\n                break;\n            case hrtim_ev6:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG6;\n                break;\n            case hrtim_ev7:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG7;\n                break;\n            case hrtim_ev8:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG8;\n                break;\n            case hrtim_ev9:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG9;\n                break;\n            case software:\n            default:\n                trig = LL_ADC_REG_TRIG_SOFTWARE;\n                break;\n            }\n\n            adc_core_configure_trigger_source(adc_num,\n                                              LL_ADC_REG_TRIG_EXT_RISING,\n                                              trig);\n        }\n    }\n\n    /* Start ADCs */\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp;\n             (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_start(adc_num, enabled_channels_count[adc_index]);\n        }\n    }\n}\n\nvoid adc_stop()\n{\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp;\n             (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_stop(adc_num);\n        }\n    }\n}\n\nvoid adc_trigger_software_conversion(uint8_t adc_number,\n                                     uint8_t number_of_acquisitions)\n{\n    adc_core_start(adc_number, number_of_acquisitions);\n}\n</code></pre>"},{"location":"powerAPI/adc_8h/","title":"File adc.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8h/#public-types","title":"Public Types","text":"Type Name enum adc_ev_src_t Defines types of hrtim events to which the ADC connects:"},{"location":"powerAPI/adc_8h/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the trigger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurrence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/adc_8h/#enum-adc_ev_src_t","title":"enum adc_ev_src_t","text":"<p>Defines types of hrtim events to which the ADC connects: <pre><code>enum adc_ev_src_t {\n    software = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4,\n    hrtim_ev5 = 5,\n    hrtim_ev6 = 6,\n    hrtim_ev7 = 7,\n    hrtim_ev8 = 8,\n    hrtim_ev9 = 9\n};\n</code></pre></p> <p>Public enums </p> <ul> <li>software - software events</li> <li><code>hrtim_ev1</code> to <code>hrtim_ev9</code> - hrtim driven events </li> </ul>"},{"location":"powerAPI/adc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8h/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the trigger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>trigger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8h/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurrence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_start","title":"function adc_start","text":"<p>Starts all configured ADCs. <pre><code>void adc_start () \n</code></pre></p>"},{"location":"powerAPI/adc_8h/#function-adc_stop","title":"function adc_stop","text":"<p>Stops all configured ADCs. <pre><code>void adc_stop () \n</code></pre></p>"},{"location":"powerAPI/adc_8h/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.h</code></p>"},{"location":"powerAPI/adc_8h_source/","title":"File adc.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief  This is an ad-hoc ADC driver for OwnTech's\n * application. It supports differential channel setup\n * unlike Zephyr's STM32 driver.\n * It configures ADC 1 and ADC 2, using a common clock\n * which is AHB clock with a prescaler division by 4.\n * ADC 3 is also enabled independently.\n *\n * To use this driver, first call adc_init(), then call\n * required configuration functions, then call adc_start().\n */\n\n\n#ifndef ADC_H_\n#define ADC_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\ntypedef enum\n{\n    software  = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4,\n    hrtim_ev5 = 5,\n    hrtim_ev6 = 6,\n    hrtim_ev7 = 7,\n    hrtim_ev8 = 8,\n    hrtim_ev9 = 9\n} adc_ev_src_t;\n\n\n/* Public API */\n\nvoid adc_configure_trigger_source(uint8_t adc_number,\n                                  adc_ev_src_t trigger_source);\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number,\n                                      uint32_t discontinuous_count);\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel);\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel);\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number);\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma);\n\n\nvoid adc_start();\n\nvoid adc_stop();\n\nvoid adc_trigger_software_conversion(uint8_t adc_number,\n                                     uint8_t number_of_acquisitions);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ADC_H_ */\n</code></pre>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/","title":"Dir docs/core/zephyr/modules/owntech_communication","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication</p>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/</code></p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr</p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/</code></p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/#files","title":"Files","text":"Type Name file CommunicationAPI.cpp file CommunicationAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp/","title":"File CommunicationAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8cpp/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.cpp</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp_source/","title":"File CommunicationAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#include \"CommunicationAPI.h\"\n\nCommunicationAPI communication;\n</code></pre>"},{"location":"powerAPI/CommunicationAPI_8h/","title":"File CommunicationAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8h/#classes","title":"Classes","text":"Type Name class CommunicationAPI Main communication API interface."},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8h/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/CommunicationAPI_8h_source/","title":"File CommunicationAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef COMMUNICATIONAPI_H\n#define COMMUNICATIONAPI_H\n\n#include \"../src/AnalogCommunication.h\"\n#include \"../src/CanCommunication.h\"\n#include \"../src/Rs485Communication.h\"\n#include \"../src/SyncCommunication.h\"\n\nclass CommunicationAPI\n{\n    public :\n        AnalogCommunication analog;\n\n        CanCommunication can;\n\n        Rs485Communication rs485;\n\n        SyncCommunication sync;\n\n};\n\nextern CommunicationAPI communication;\n\n#endif /* COMMUNICATIONAPI_H */\n</code></pre>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/#files","title":"Files","text":"Type Name file AnalogCommunication.cpp file AnalogCommunication.h file CanCommunication.cpp file CanCommunication.h file Rs485.cpp file Rs485.h file Rs485Communication.cpp file Rs485Communication.h file SyncCommunication.cpp file SyncCommunication.h file data_objects.h Handling of ThingSet data objects. file thingset_can.c <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp/","title":"File AnalogCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.cpp</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp_source/","title":"File AnalogCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n\n/* Header */\n#include \"AnalogCommunication.h\"\n\n/* OwnTech Power API */\n#include \"ShieldAPI.h\"\n#include \"SpinAPI.h\"\n\n/* LL drivers */\n#include \"stm32_ll_gpio.h\"\n\n#define ADC_NUM ADC_2\n#define DAC_NUM 2\n#define DAC_CHAN 1\n\nvoid AnalogCommunication::init()\n{\n    /* Initialize the GPIO PC4 (pin number 35) to analog mode\n       to use the ADC */\n    LL_GPIO_SetPinMode      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_MODE_ANALOG);\n    LL_GPIO_SetPinSpeed     (GPIOC, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_PULL_NO);\n\n    shield.sensors.enableSensor(ANALOG_COMM, ADC_NUM);\n\n    /* Initialize the DAC */\n    spin.dac.initConstValue(ADC_NUM);\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, 0);\n}\n\nfloat32_t AnalogCommunication::getAnalogCommValue()\n{\n    float32_t ret =  shield.sensors.getLatestValue(ANALOG_COMM);\n    return ret;\n}\n\nvoid AnalogCommunication::setAnalogCommValue(uint32_t analog_bus_value)\n{\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, analog_bus_value);\n}\n</code></pre>"},{"location":"powerAPI/AnalogCommunication_8h/","title":"File AnalogCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/AnalogCommunication_8h/#classes","title":"Classes","text":"Type Name class AnalogCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/AnalogCommunication_8h_source/","title":"File AnalogCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef ANALOGCOMMUNICATION_H_\n#define ANALOGCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n\n/* Static class definition */\n\nclass AnalogCommunication\n{\n\npublic:\n    static void init();\n\n    static float32_t getAnalogCommValue();\n\n    static void setAnalogCommValue(uint32_t analog_bus_value);\n};\n\n#endif /* CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG */\n\n#endif /* ANALOGCOMMUNICATION_H_ */\n</code></pre>"},{"location":"powerAPI/CanCommunication_8cpp/","title":"File CanCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name bool live_reporting_enable uint32_t live_reporting_period float32_t reference_value bool start_stop"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CanCommunication_8cpp/#variable-live_reporting_enable","title":"variable live_reporting_enable","text":"<pre><code>bool live_reporting_enable;\n</code></pre> <p>Extern variables coming from sdk.c Boolean to set or unset CAN broadcasting </p>"},{"location":"powerAPI/CanCommunication_8cpp/#variable-live_reporting_period","title":"variable live_reporting_period","text":"<pre><code>uint32_t live_reporting_period;\n</code></pre> <p>Integer used to set broadcasting period </p>"},{"location":"powerAPI/CanCommunication_8cpp/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/CanCommunication_8cpp/#variable-start_stop","title":"variable start_stop","text":"<pre><code>bool start_stop;\n</code></pre> <p>Extern variable defined in this module </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.cpp</code></p>"},{"location":"powerAPI/CanCommunication_8cpp_source/","title":"File CanCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n\n/* Header */\n#include \"CanCommunication.h\"\n#include \"data_objects.h\"\n#include &lt;thingset.h&gt;\n#include &lt;thingset/can.h&gt;\n#include &lt;thingset/sdk.h&gt;\n\nstruct thingset_can *CanCommunication::ts_can_inst = thingset_can_get_inst();\n\n\n#ifdef CONFIG_THINGSET_SUBSET_LIVE_METRICS\nextern bool live_reporting_enable;\nextern uint32_t live_reporting_period;\n#endif\n\n#ifdef CONFIG_THINGSET_CAN_CONTROL_REPORTING\n\nextern bool      start_stop;\nextern float32_t reference_value;\n\nbool CanCommunication::getCtrlEnable()\n{\n    return ts_can_inst-&gt;control_enable;\n}\n\nfloat32_t CanCommunication::getCtrlReference()\n{\n    return reference_value;\n}\n\nfloat32_t CanCommunication::getStartStopState()\n{\n    return start_stop;\n}\n\nuint16_t CanCommunication::getControlPeriod()\n{\n    return ts_can_inst-&gt;control_period;\n}\n\nvoid CanCommunication::setCtrlEnable(bool enable)\n{\n    ts_can_inst-&gt;control_enable = enable;\n}\n\nvoid CanCommunication::setCtrlReference(float32_t reference)\n{\n    reference_value = reference;\n}\n\nvoid CanCommunication::stopSlaveDevice()\n{\n    start_stop = 0;\n}\n\nvoid CanCommunication::startSlaveDevice()\n{\n    start_stop = 1;\n}\n\nvoid CanCommunication::setControlPeriod(uint16_t time_ms)\n{\n    ts_can_inst-&gt;control_period = time_ms;\n}\n\n#endif /* CONFIG_THINGSET_CAN_CONTROL_REPORTING */\n\nuint16_t CanCommunication::getCanNodeAddr()\n{\n    return ts_can_inst-&gt;node_addr;\n}\n\nvoid CanCommunication::setCanNodeAddr(uint16_t addr)\n{\n    ts_can_inst-&gt;node_addr = addr;\n}\n\n#ifdef CONFIG_THINGSET_SUBSET_LIVE_METRICS\n\nbool CanCommunication::getBroadcastEnable()\n{\n    return live_reporting_enable;\n}\n\nuint16_t CanCommunication::getBroadcastPeriod()\n{\n    return live_reporting_period;\n}\n\nvoid CanCommunication::setBroadcastEnable(bool enable)\n{\n    live_reporting_enable = enable;\n}\n\nvoid CanCommunication::setBroadcastPeriod(uint16_t time_s)\n{\n    live_reporting_period = time_s;\n}\n\n#endif /* CONFIG_THINGSET_SUBSET_LIVE_METRICS */\n</code></pre>"},{"location":"powerAPI/CanCommunication_8h/","title":"File CanCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8h/#classes","title":"Classes","text":"Type Name class CanCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/CanCommunication_8h_source/","title":"File CanCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n\n#ifndef CANCOMMUNICATION_H_\n#define CANCOMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n/* Static class definition */\n\nclass CanCommunication\n{\n\npublic:\n    static uint16_t getCanNodeAddr();\n\n    static void setCanNodeAddr(uint16_t addr);\n\n#ifdef CONFIG_THINGSET_CAN_CONTROL_REPORTING\n\n    static bool getCtrlEnable();\n\n    static float32_t getCtrlReference();\n\n    static float32_t getStartStopState();\n    static uint16_t getControlPeriod();\n\n    static void setCtrlEnable(bool enable);\n\n    static void setCtrlReference(float32_t reference);\n\n    static void startSlaveDevice();\n\n    static void stopSlaveDevice();\n\n    static void setControlPeriod(uint16_t time_ms);\n\n#endif\n\n#ifdef CONFIG_THINGSET_SUBSET_LIVE_METRICS\n\n    static bool getBroadcastEnable();\n\n    static uint16_t getBroadcastPeriod();\n\n    static void setBroadcastEnable(bool enable);\n\n    static void setBroadcastPeriod(uint16_t time_s);\n\n#endif\n\nprivate:\n    static struct thingset_can *ts_can_inst;\n};\n\n#endif /* CANCOMMUNICATION_H_ */\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/","title":"File Rs485.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name struct uart_event evt struct uart_config uart_cfg"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t baud   = <code>21250000 / (2)</code> const struct device * dma1   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(dma1))</code> uint16_t dma_buffer_size uint8_t * rx_usart_val uint8_t * tx_usart_val const struct device * uart_dev   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(usart3))</code> dma_callbackRXfunc_t user_fnc   = <code>NULL</code>"},{"location":"powerAPI/Rs485_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () Initialize dma 1 channel 7 for receiving data in circular mode. void dma_channel_init_tx () Initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) Initialize Driver Enable mode for RS485 hardware flowcontrol. void init_usrBaudrate (uint32_t usr_baud) Initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) Initialize user transmission and reception buffer. void init_usrDataSize (uint16_t size) Initialize DMA data size to send and receive. void init_usrFunc (dma_callbackRXfunc_t fnc_callback) Initialize user function called every RX callback. void oversamp_set (usart_oversampling_t oversampling) Set oversampling which is by default oversampling_16. void serial_init (void) Initialize USART3. void serial_start () Enable USART. void serial_stop () Disable USART. void serial_tx_on () Reload dma buffer TX."},{"location":"powerAPI/Rs485_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _dma_callback_rx ()  void _dma_callback_tx (const struct device * dev, void * user_data, uint32_t channel, int status)"},{"location":"powerAPI/Rs485_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-evt","title":"variable evt","text":"<pre><code>struct uart_event evt;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_cfg","title":"variable uart_cfg","text":"<pre><code>struct uart_config uart_cfg;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-baud","title":"variable baud","text":"<pre><code>uint32_t baud;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma1","title":"variable dma1","text":"<pre><code>const struct device* dma1;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma_buffer_size","title":"variable dma_buffer_size","text":"<pre><code>uint16_t dma_buffer_size;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-rx_usart_val","title":"variable rx_usart_val","text":"<pre><code>uint8_t* rx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-tx_usart_val","title":"variable tx_usart_val","text":"<pre><code>uint8_t* tx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-user_fnc","title":"variable user_fnc","text":"<pre><code>dma_callbackRXfunc_t user_fnc;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>Initialize dma 1 channel 7 for receiving data in circular mode. <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>Initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_demode","title":"function init_DEmode","text":"<p>Initialize Driver Enable mode for RS485 hardware flowcontrol. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>Initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>Initialize user transmission and reception buffer. <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>Initialize DMA data size to send and receive. <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>Initialize user function called every RX callback. <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8cpp/#function-oversamp_set","title":"function oversamp_set","text":"<p>Set oversampling which is by default oversampling_16. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_init","title":"function serial_init","text":"<p>Initialize USART3. <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_start","title":"function serial_start","text":"<p>Enable USART. <pre><code>void serial_start () \n</code></pre></p> <p>To start or restart communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_stop","title":"function serial_stop","text":"<p>Disable USART. <pre><code>void serial_stop () \n</code></pre></p> <p>To stop communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>Reload dma buffer TX. <pre><code>void serial_tx_on () \n</code></pre></p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p>"},{"location":"powerAPI/Rs485_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_rx","title":"function _dma_callback_rx","text":"<pre><code>static void _dma_callback_rx () \n</code></pre> <p>DMA callback RX clear reception flag, then call user functions </p>"},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_tx","title":"function _dma_callback_tx","text":"<pre><code>static void _dma_callback_tx (\n    const struct device * dev,\n    void * user_data,\n    uint32_t channel,\n    int status\n) \n</code></pre> <p>DMA callback TX clear transmission flag, and disabled DMA channel TX. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.cpp</code></p>"},{"location":"powerAPI/Rs485_8cpp_source/","title":"File Rs485.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n/* LL drivers */\n#include &lt;stm32_ll_dma.h&gt;\n#include &lt;stm32_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n/* Zephyr drivers */\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/drivers/dma.h&gt;\n\n/* Header */\n#include \"Rs485.h\"\n\n#define DMA_USART DMA1 /* DMA used */\n\n#define STM32_DMA_HAL_OVERRIDE 0x7F\n\n\n/* Transmission DMA channel for zephyr driver */\n#define ZEPHYR_DMA_CHANNEL_TX 6\n/* Reception DMA channel for zephyr driver */\n#define ZEPHYR_DMA_CHANNEL_RX 7\n\n\n/* Transmission DMA channel for LL driver */\n#define LL_DMA_CHANNEL_TX LL_DMA_CHANNEL_6\n/* Reception DMA channel for LL driver */\n#define LL_DMA_CHANNEL_RX LL_DMA_CHANNEL_7\n\n/* DT definitions */\nstatic const struct device *dma1 = DEVICE_DT_GET(DT_NODELABEL(dma1));\nstatic const struct device *uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart3));\n\n/* USART initialization parameters */\n\n/* Initial baudrate to  10.625Mhz */\nstatic uint32_t baud = 21250000 / (2);\nstruct uart_config uart_cfg;\nstruct uart_event evt;\n\n/* DMA buffer for transmission and reception */\nstatic uint8_t* tx_usart_val;\nstatic uint8_t* rx_usart_val;\n\nstatic uint16_t dma_buffer_size;\n\n/* User function to call in RX callback */\nstatic dma_callbackRXfunc_t user_fnc = NULL;\n\n/* Private functions */\n\nstatic void _dma_callback_tx(const struct device *dev,\n                             void *user_data,\n                             uint32_t channel,\n                             int status)\n{\n    /* Disable DMA channel after sending datas */\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX);\n\n    LL_USART_ClearFlag_TXFE(USART3);\n    /* Clear transmission complete flag USART */\n    LL_USART_ClearFlag_TC(USART3);\n    /* Clear transmission complete dma channel TX */\n    LL_DMA_ClearFlag_TC6(DMA_USART);\n}\n\nstatic void _dma_callback_rx()\n{\n    /* Clear transmission complete flag */\n    LL_DMA_ClearFlag_TC7(DMA_USART);\n\n    if(user_fnc != NULL){\n        user_fnc();\n    }\n}\n\n/* Public functions */\n\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer)\n{\n    tx_usart_val = tx_buffer;\n    rx_usart_val = rx_buffer;\n}\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback)\n{\n    user_fnc = fnc_callback;\n}\n\nvoid init_usrBaudrate(uint32_t usr_baud)\n{\n    baud = usr_baud;\n}\n\nvoid init_usrDataSize(uint16_t size)\n{\n    dma_buffer_size = size;\n}\n\nvoid serial_init(void)\n{\n    uart_config_get(uart_dev, &amp;uart_cfg);\n    uart_cfg.baudrate = baud;\n    uart_cfg.flow_ctrl = UART_CFG_FLOW_CTRL_NONE;\n    uart_cfg.data_bits = UART_CFG_DATA_BITS_8;\n    uart_cfg.parity = UART_CFG_PARITY_NONE;\n    uart_cfg.stop_bits = UART_CFG_STOP_BITS_1;\n\n    uart_configure(uart_dev, &amp;uart_cfg);\n\n    LL_USART_ConfigAsyncMode(USART3);\n\n    /* Enable DMA request*/\n    LL_USART_EnableDMAReq_TX(USART3);\n    LL_USART_EnableDMAReq_RX(USART3);\n\n    /* Disable Interrupts for TX (not used for DMA) */\n\n    /* Disable Transmission Complete Interrupt */\n    LL_USART_DisableIT_TC(USART3);\n\n    /* Disable Transmission Data Register Empty Interrupt\n     * for DMA to provide data.\n     * Disable interrupts for RX (not used with DMA) */\n    LL_USART_DisableIT_TXE_TXFNF(USART3);\n    /* Disable Receiver Data Register\n     * Not Empty Interrupt for DMA to fetch data */\n    LL_USART_DisableIT_RXNE_RXFNE(USART3);\n\n    LL_USART_Enable(USART3);\n}\n\nvoid init_DEmode(void)\n{\n    LL_USART_Disable(USART3);\n\n    /* GPIO initialization and GPIO clock set-up */\n    LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n    /* Set GPIO_InitStruct */\n    GPIO_InitStruct.Pin = LL_GPIO_PIN_14;\n    GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\n    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\n    GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\n    GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\n    LL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);\n\n    /* Enable DE mode */\n    LL_USART_EnableDEMode(USART3);\n    /* Polarity is high ie. PB14 will be at high level when sending datas */\n    LL_USART_SetDESignalPolarity(USART3, LL_USART_DE_POLARITY_HIGH);\n\n    /* Assertion time is set to maximum */\n    LL_USART_SetDEAssertionTime(USART3, 31);\n    LL_USART_SetDEDeassertionTime(USART3, 31);\n\n    LL_USART_Enable(USART3);\n}\n\n\nvoid oversamp_set(usart_oversampling_t oversampling)\n{\n    LL_USART_Disable(USART3);\n    LL_USART_SetOverSampling(USART3, oversampling);\n    LL_USART_Enable(USART3);\n}\n\nvoid dma_channel_init_tx()\n{\n    /* Configure DMA */\n    struct dma_config dma_config_s = {0};\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    /* Callback function set-up */\n    dma_config_s.dma_callback = _dma_callback_tx;\n    /* HAL override */\n    dma_config_s.linked_channel = STM32_DMA_HAL_OVERRIDE;\n\n    /* DMA configuration with LL drivers */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;TDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(tx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_TX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    /* Indicates callback function to zephyr driver */\n    dma_config(dma1, ZEPHYR_DMA_CHANNEL_TX, &amp;dma_config_s);\n    /* Disabling channel for initial set-up */\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX);\n\n    /* Initialize DMA */\n\n    /* DMA data size */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size);\n    /* DMA channel priority */\n    LL_DMA_SetChannelPriorityLevel(DMA_USART,\n                                   LL_DMA_CHANNEL_TX,\n                                   LL_DMA_PRIORITY_VERYHIGH);\n\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_TX, &amp;DMA_InitStruct);\n\n    /* Clearing flags */\n    LL_DMA_ClearFlag_TC6(DMA_USART);\n    LL_DMA_ClearFlag_HT6(DMA_USART);\n\n    /* Enable transfer complete interruption */\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_TX);\n    /* Disable half-transfer interruption */\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_TX);\n}\n\n\nvoid dma_channel_init_rx()\n{\n    /* Configure DMA */\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    /* Initialization of DMA */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;RDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(rx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_RX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    IRQ_DIRECT_CONNECT(17, 0, _dma_callback_rx, IRQ_ZERO_LATENCY);\n    irq_enable(17);\n\n    /* Disabling channel for initial set-up */\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_RX);\n\n    /* Initialize DMA */\n\n    /* DMA data size */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_RX, dma_buffer_size);\n    /* DMA channel priority */\n    LL_DMA_SetChannelPriorityLevel(DMA_USART,\n                                   LL_DMA_CHANNEL_RX,\n                                   LL_DMA_PRIORITY_VERYHIGH);\n\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_RX, &amp;DMA_InitStruct);\n\n    /* Clearing flag */\n    LL_DMA_ClearFlag_TC7(DMA_USART);\n    LL_DMA_ClearFlag_HT7(DMA_USART);\n\n    /* Enabling channel */\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_RX);\n    /* Enable transfer complete interruption */\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_RX);\n    /* Disable half-transfer interruption */\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_RX);\n}\n\n\nvoid serial_tx_on()\n{\n    /* Making sure the flag is cleared before transmission */\n    LL_DMA_ClearFlag_TC6(DMA_USART);\n    /* Disable channel to reload TX buffer */\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX);\n    /* Reloading TX buffer */\n    LL_DMA_SetMemoryAddress(DMA_USART,\n                            LL_DMA_CHANNEL_TX,\n                            (uint32_t)(tx_usart_val));\n\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size);\n    /* Re-enable the channel */\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_TX);\n}\n\nvoid serial_stop()\n{\n    LL_USART_Disable(USART3);\n}\n\nvoid serial_start()\n{\n    LL_USART_Enable(USART3);\n}\n</code></pre>"},{"location":"powerAPI/Rs485_8h/","title":"File Rs485.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dma_callbackRXfunc_t enum usart_oversampling_t Defines the USART oversampling:"},{"location":"powerAPI/Rs485_8h/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () Initialize dma 1 channel 7 for receiving data in circular mode. void dma_channel_init_tx () Initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) Initialize Driver Enable mode for RS485 hardware flowcontrol. void init_usrBaudrate (uint32_t usr_baud) Initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) Initialize user transmission and reception buffer. void init_usrDataSize (uint16_t size) Initialize DMA data size to send and receive. void init_usrFunc (dma_callbackRXfunc_t fnc_callback) Initialize user function called every RX callback. void oversamp_set (usart_oversampling_t oversampling) Set oversampling which is by default oversampling_16. void serial_init (void) Initialize USART3. void serial_start () Enable USART. void serial_stop () Disable USART. void serial_tx_on () Reload dma buffer TX."},{"location":"powerAPI/Rs485_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485_8h/#typedef-dma_callbackrxfunc_t","title":"typedef dma_callbackRXfunc_t","text":"<pre><code>typedef void(* dma_callbackRXfunc_t) ();\n</code></pre>"},{"location":"powerAPI/Rs485_8h/#enum-usart_oversampling_t","title":"enum usart_oversampling_t","text":"<p>Defines the USART oversampling: <pre><code>enum usart_oversampling_t {\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n};\n</code></pre></p> <ul> <li><code>OVER8</code> - Oversampling of 8</li> <li><code>OVER16</code> - Oversampling of 16 </li> </ul>"},{"location":"powerAPI/Rs485_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>Initialize dma 1 channel 7 for receiving data in circular mode. <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>Initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_demode","title":"function init_DEmode","text":"<p>Initialize Driver Enable mode for RS485 hardware flowcontrol. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>Initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>usr_baud</code> Baud in bits per second</li> </ul> <p>Note:</p> <p>Baudrate is initialized by default to 10Mbps, if this function is not used</p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>Initialize user transmission and reception buffer. <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tx_buffer</code> Transmission buffer </li> <li><code>rx_buffer</code> Reception buffer</li> </ul> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>Initialize DMA data size to send and receive. <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> Size of the data in byte (max 65535)</li> </ul> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>Initialize user function called every RX callback. <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fnc_callback</code> Void function with no parameters, use NULL if there is no function to call</li> </ul> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8h/#function-oversamp_set","title":"function oversamp_set","text":"<p>Set oversampling which is by default oversampling_16. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>oversampling</code> choice of oversampling </li> <li>OVER8 oversampling_8 </li> <li>OVER16 oversampling_16</li> </ul> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_init","title":"function serial_init","text":"<p>Initialize USART3. <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_start","title":"function serial_start","text":"<p>Enable USART. <pre><code>void serial_start () \n</code></pre></p> <p>To start or restart communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_stop","title":"function serial_stop","text":"<p>Disable USART. <pre><code>void serial_stop () \n</code></pre></p> <p>To stop communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>Reload dma buffer TX. <pre><code>void serial_tx_on () \n</code></pre></p> <p>Note:</p> <p>After reloading the buffer, USART will start sending datas</p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.h</code></p>"},{"location":"powerAPI/Rs485_8h_source/","title":"File Rs485.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n#ifndef RS485_H_\n#define RS485_H_\n\n#include &lt;zephyr/kernel.h&gt;\n\n#include &lt;stm32_ll_usart.h&gt;\n\ntypedef void (*dma_callbackRXfunc_t)();\n\ntypedef enum{\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n}usart_oversampling_t;\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer);\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback);\n\nvoid init_usrBaudrate(uint32_t usr_baud);\n\nvoid init_usrDataSize(uint16_t size);\n\nvoid serial_init(void);\n\nvoid init_DEmode(void);\n\nvoid oversamp_set(usart_oversampling_t oversampling);\n\nvoid dma_channel_init_tx();\n\nvoid dma_channel_init_rx();\n\nvoid serial_tx_on();\n\nvoid serial_stop();\n\nvoid serial_start();\n\n#endif /* RS485_H_ */\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8cpp/","title":"File Rs485Communication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.cpp</code></p>"},{"location":"powerAPI/Rs485Communication_8cpp_source/","title":"File Rs485Communication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#include \"Rs485.h\"\n#include \"Rs485Communication.h\"\n\nvoid Rs485Communication::configure(uint8_t *transmission_buffer,\n                                   uint8_t *reception_buffer,\n                                   uint16_t data_size, void (*user_function)(),\n                                   rs485_speed_t data_speed)\n{\n    init_usrBuffer(transmission_buffer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n\n    switch(data_speed)\n    {\n        case SPEED_2M:\n            init_usrBaudrate(2656250);\n            break;\n        case SPEED_5M:\n            init_usrBaudrate(5312500);\n            break;\n        case SPEED_10M:\n            init_usrBaudrate(10625000);\n            break;\n        default:\n            init_usrBaudrate(10625000);\n            break;\n    }\n    init_usrBaudrate(10625000);\n\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n\n    if(data_speed == SPEED_20M) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::configureCustom(uint8_t* transmission_buffer,\n                                         uint8_t* reception_buffer,\n                                         uint16_t data_size,\n                                         void (*user_function)(void),\n                                         uint32_t baudrate,\n                                         bool oversampling_8)\n{\n    init_usrBuffer(transmission_buffer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n    init_usrBaudrate(baudrate);\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n    if(oversampling_8 == true) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::startTransmission()\n{\n    serial_tx_on();\n}\n\nvoid Rs485Communication::turnOnCommunication()\n{\n    serial_start();\n}\n\nvoid Rs485Communication::turnOffCommunication()\n{\n    serial_stop();\n}\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8h/","title":"File Rs485Communication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485Communication_8h/#classes","title":"Classes","text":"Type Name class Rs485Communication"},{"location":"powerAPI/Rs485Communication_8h/#public-types","title":"Public Types","text":"Type Name enum rs485_speed_t Defines the possible speeds for the RS485:"},{"location":"powerAPI/Rs485Communication_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485Communication_8h/#enum-rs485_speed_t","title":"enum rs485_speed_t","text":"<p>Defines the possible speeds for the RS485: <pre><code>enum rs485_speed_t {\n    SPEED_2M,\n    SPEED_5M,\n    SPEED_10M,\n    SPEED_20M\n};\n</code></pre></p> <ul> <li><code>SPEED_2M</code>: 2Mbits/s speed communication</li> <li><code>SPEED_5M</code>: 5Mbits/s speed communication</li> <li><code>SPEED_10M</code>: 10Mbits/s speed communication</li> <li><code>SPEED_20M</code>: 20Mbits/s speed communication </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/Rs485Communication_8h_source/","title":"File Rs485Communication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef RS485COMMUNICATION_H_\n#define RS485COMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485\n\n\ntypedef enum {\n    SPEED_2M,  \n    SPEED_5M,  \n    SPEED_10M, \n    SPEED_20M, \n}rs485_speed_t;\n\n\nclass Rs485Communication\n{\n    public :\n        void configure(uint8_t *transmission_buffer,\n                       uint8_t *reception_buffer,\n                       uint16_t data_size, void (*user_function)(),\n                       rs485_speed_t data_speed = SPEED_10M);\n\n        void configureCustom(uint8_t *transmission_buffer,\n                             uint8_t *reception_buffer,\n                             uint16_t data_size, void (*user_function)(void),\n                             uint32_t baudrate, bool oversampling_8);\n\n        void startTransmission();\n\n        void turnOnCommunication();\n\n        void turnOffCommunication();\n};\n\n#endif /* CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485 */\n\n#endif /* RS485COMMUNICATION_H_ */\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8cpp/","title":"File SyncCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.cpp</code></p>"},{"location":"powerAPI/SyncCommunication_8cpp_source/","title":"File SyncCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n/* LL drivers */\n#include \"stm32_ll_hrtim.h\"\n#include \"stm32_ll_gpio.h\"\n#include \"stm32g4xx_ll_bus.h\"\n\n/* Header */\n#include \"SyncCommunication.h\"\n\nvoid SyncCommunication::initMaster()\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_A);\n\n    /* SYNCOUT[1:0] and SYNCSRC[1:0] bitfield configuration in HRTIM_MCR */\n    LL_HRTIM_ConfigSyncOut(HRTIM1,\n                           LL_HRTIM_SYNCOUT_POSITIVE_PULSE,\n                           LL_HRTIM_SYNCOUT_SRC_TIMA_START);\n\n    /* HRTIM_SCOUT pin configuration */\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n    LL_GPIO_SetPinSpeed     (GPIOB,\n                             LL_GPIO_PIN_1,\n                             LL_GPIO_SPEED_FREQ_VERY_HIGH);\n\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_1, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_1, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_1, LL_GPIO_AF_13);\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_A);\n}\n\nvoid SyncCommunication::initSlave()\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    /* HRTIM synchronization input source */\n    LL_HRTIM_SetSyncInSrc(HRTIM1, LL_HRTIM_SYNCIN_SRC_EXTERNAL_EVENT);\n\n    /* Enable the master timer reset\n     * when receiving a synchronization input event */\n    LL_HRTIM_TIM_EnableResetOnSync(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    /* HRTIM_SCIN pin configuration */\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n#ifdef CONFIG_SHIELD_TWIST_V1_4_1\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB,\n                             LL_GPIO_PIN_2,\n                             LL_GPIO_SPEED_FREQ_VERY_HIGH);\n\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_2, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_2, LL_GPIO_AF_13);\n#else\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB,\n                             LL_GPIO_PIN_6,\n                             LL_GPIO_SPEED_FREQ_VERY_HIGH);\n\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_6, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_6, LL_GPIO_AF_12);\n#endif\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n}\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8h/","title":"File SyncCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SyncCommunication_8h/#classes","title":"Classes","text":"Type Name class SyncCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/SyncCommunication_8h_source/","title":"File SyncCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef SYNCCOMMUNICATION_H_\n#define SYNCCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC\n\n#include &lt;stdint.h&gt;\n\n/* OWNTECH API */\n#include \"SpinAPI.h\"\n\n\n\nclass SyncCommunication\n{\n\npublic:\n\n    static void initMaster();\n\n    static void initSlave();\n};\n\n#endif /* CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC */\n\n#endif /* SYNCCOMMUNICATION_H_ */\n</code></pre>"},{"location":"powerAPI/data__objects_8h/","title":"File data_objects.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the source code of this file</p> <p>Handling of ThingSet data objects. </p>"},{"location":"powerAPI/data__objects_8h/#public-attributes","title":"Public Attributes","text":"Type Name char device_type   = <code>HW\\_NAME</code> char firmware_version   = <code>\"1.0.0\"</code> char hardware_version   = <code>HW\\_VER</code> char manufacturer   = <code>CONFIG\\_USB\\_DEVICE\\_MANUFACTURER</code> float32_t reference_value   = <code>0</code> bool start_stop   = <code>false</code>"},{"location":"powerAPI/data__objects_8h/#public-functions","title":"Public Functions","text":"Type Name THINGSET_ADD_GROUP (ID_ROOT, 0x4, \"Device\", THINGSET_NO_CALLBACK)  THINGSET_ADD_GROUP (ID_ROOT, ID_CTRL, \"Control\", THINGSET_NO_CALLBACK)  THINGSET_ADD_ITEM_BOOL (ID_CTRL, ID_CTRL_ENABLE, \"zStartStop\", &amp; start_stop, THINGSET_ANY_RW, SUBSET_CTRL)  THINGSET_ADD_ITEM_FLOAT (ID_CTRL, ID_CTRL_REFERENCE, \"zCtrlReference\", &amp; reference_value, 1, THINGSET_ANY_RW, SUBSET_CTRL)  THINGSET_ADD_ITEM_STRING (ID_DEVICE, 0x40, \"cManufacturer\", manufacturer, 0, THINGSET_ANY_R, 0)  THINGSET_ADD_ITEM_STRING (ID_DEVICE, 0x41, \"cType\", device_type, 0, THINGSET_ANY_R, 0)  THINGSET_ADD_ITEM_STRING (ID_DEVICE, 0x42, \"cHardwareVersion\", hardware_version, 0, THINGSET_ANY_R, 0)  THINGSET_ADD_ITEM_STRING (ID_DEVICE, 0x43, \"cFirmwareVersion\", firmware_version, 0, THINGSET_ANY_R, 0)  THINGSET_ADD_SUBSET (ID_ROOT, 0x38, \"mCAN\", SUBSET_CAN, THINGSET_ANY_RW)"},{"location":"powerAPI/data__objects_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8h/#variable-device_type","title":"variable device_type","text":"<pre><code>char device_type[];\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-firmware_version","title":"variable firmware_version","text":"<pre><code>char firmware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-hardware_version","title":"variable hardware_version","text":"<pre><code>char hardware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-manufacturer","title":"variable manufacturer","text":"<pre><code>char manufacturer[];\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-start_stop","title":"variable start_stop","text":"<pre><code>bool start_stop;\n</code></pre> <p>Extern variable defined in this module </p>"},{"location":"powerAPI/data__objects_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__objects_8h/#function-thingset_add_group","title":"function THINGSET_ADD_GROUP","text":"<pre><code>THINGSET_ADD_GROUP (\n    ID_ROOT,\n    0x4,\n    \"Device\",\n    THINGSET_NO_CALLBACK\n) \n</code></pre> <p>Thingset Data Objects (see thingset.io for specification) </p>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_group_1","title":"function THINGSET_ADD_GROUP","text":"<pre><code>THINGSET_ADD_GROUP (\n    ID_ROOT,\n    ID_CTRL,\n    \"Control\",\n    THINGSET_NO_CALLBACK\n) \n</code></pre> <p>Control parameters (IDs &gt;= 0x8000) </p>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_bool","title":"function THINGSET_ADD_ITEM_BOOL","text":"<pre><code>THINGSET_ADD_ITEM_BOOL (\n    ID_CTRL,\n    ID_CTRL_ENABLE,\n    \"zStartStop\",\n    &amp; start_stop,\n    THINGSET_ANY_RW,\n    SUBSET_CTRL\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_float","title":"function THINGSET_ADD_ITEM_FLOAT","text":"<pre><code>THINGSET_ADD_ITEM_FLOAT (\n    ID_CTRL,\n    ID_CTRL_REFERENCE,\n    \"zCtrlReference\",\n    &amp; reference_value,\n    1,\n    THINGSET_ANY_RW,\n    SUBSET_CTRL\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_string","title":"function THINGSET_ADD_ITEM_STRING","text":"<pre><code>THINGSET_ADD_ITEM_STRING (\n    ID_DEVICE,\n    0x40,\n    \"cManufacturer\",\n    manufacturer,\n    0,\n    THINGSET_ANY_R,\n    0\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_string_1","title":"function THINGSET_ADD_ITEM_STRING","text":"<pre><code>THINGSET_ADD_ITEM_STRING (\n    ID_DEVICE,\n    0x41,\n    \"cType\",\n    device_type,\n    0,\n    THINGSET_ANY_R,\n    0\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_string_2","title":"function THINGSET_ADD_ITEM_STRING","text":"<pre><code>THINGSET_ADD_ITEM_STRING (\n    ID_DEVICE,\n    0x42,\n    \"cHardwareVersion\",\n    hardware_version,\n    0,\n    THINGSET_ANY_R,\n    0\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_item_string_3","title":"function THINGSET_ADD_ITEM_STRING","text":"<pre><code>THINGSET_ADD_ITEM_STRING (\n    ID_DEVICE,\n    0x43,\n    \"cFirmwareVersion\",\n    firmware_version,\n    0,\n    THINGSET_ANY_R,\n    0\n) \n</code></pre>"},{"location":"powerAPI/data__objects_8h/#function-thingset_add_subset","title":"function THINGSET_ADD_SUBSET","text":"<pre><code>THINGSET_ADD_SUBSET (\n    ID_ROOT,\n    0x38,\n    \"mCAN\",\n    SUBSET_CAN,\n    THINGSET_ANY_RW\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/data_objects.h</code></p>"},{"location":"powerAPI/data__objects_8h_source/","title":"File data_objects.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n#ifndef DATA_OBJECTS_H_\n#define DATA_OBJECTS_H_\n\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;arm_math.h&gt;\n#include \"thingset.h\"\n\n/*\n * Groups / first layer data object IDs\n */\n#define ID_ROOT         0x00\n#define ID_SUBSET_CAN   0x38\n\n/* Device */\n#define ID_DEVICE              0x4\n#define ID_DEVICE_MANUFACTURER 0x40\n#define ID_DEVICE_TYPE         0x41\n#define ID_DEVICE_HW_VERSION   0x42\n#define ID_DEVICE_FW_VERSION   0x43\n\n/* Control */\n#define ID_CTRL           0x8000\n#define ID_CTRL_REFERENCE 0x8001\n#define ID_CTRL_ENABLE    0x8002\n\n#define HW_VER DT_PROP(DT_NODELABEL(pcb), shield_version)\n#define HW_NAME DT_PROP(DT_NODELABEL(pcb), shield_name)\n\nchar manufacturer[] = CONFIG_USB_DEVICE_MANUFACTURER;\nchar device_type[] = HW_NAME;\nchar hardware_version[] = HW_VER;\nchar firmware_version[] = \"1.0.0\";\n\n/* Store value of reference (master-slave mode) */\nfloat32_t reference_value = 0;\nbool      start_stop = false;\n\n/*\n * Subset definitions for statements and publish/subscribe\n */\n\n/* UART serial */\n#define SUBSET_SER  (1U &lt;&lt; 0)\n/* CAN bus */\n#define SUBSET_CAN  (1U &lt;&lt; 1)\n/* Control data sent and received via CAN */\n#define SUBSET_CTRL (1U &lt;&lt; 3)\n\n\nTHINGSET_ADD_GROUP(ID_ROOT, 0x4, \"Device\", THINGSET_NO_CALLBACK);\n\nTHINGSET_ADD_ITEM_STRING(ID_DEVICE, 0x40, \"cManufacturer\",\n                         manufacturer, 0, THINGSET_ANY_R, 0);\n\nTHINGSET_ADD_ITEM_STRING(ID_DEVICE, 0x41, \"cType\", device_type, 0,\n                         THINGSET_ANY_R, 0);\n\nTHINGSET_ADD_ITEM_STRING(ID_DEVICE, 0x42, \"cHardwareVersion\",\n                         hardware_version, 0, THINGSET_ANY_R, 0);\n\nTHINGSET_ADD_ITEM_STRING(ID_DEVICE, 0x43, \"cFirmwareVersion\",\n                         firmware_version, 0, THINGSET_ANY_R, 0);\n\nTHINGSET_ADD_SUBSET(ID_ROOT, 0x38, \"mCAN\", SUBSET_CAN,\n                    THINGSET_ANY_RW);\n\n\nTHINGSET_ADD_GROUP(ID_ROOT, ID_CTRL, \"Control\", THINGSET_NO_CALLBACK);\n\nTHINGSET_ADD_ITEM_FLOAT(ID_CTRL, ID_CTRL_REFERENCE, \"zCtrlReference\",\n                        &amp;reference_value, 1, THINGSET_ANY_RW, SUBSET_CTRL);\n\nTHINGSET_ADD_ITEM_BOOL(ID_CTRL, ID_CTRL_ENABLE, \"zStartStop\", &amp;start_stop,\n                       THINGSET_ANY_RW, SUBSET_CTRL);\n\n#endif /* DATA_OBJECTS_H_ */\n</code></pre>"},{"location":"powerAPI/thingset__can_8c/","title":"File thingset_can.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_can.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/thingset__can_8c/#classes","title":"Classes","text":"Type Name struct can_control_work_data"},{"location":"powerAPI/thingset__can_8c/#public-attributes","title":"Public Attributes","text":"Type Name struct thingset_context ts"},{"location":"powerAPI/thingset__can_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name struct can_control_work_data can_work_data"},{"location":"powerAPI/thingset__can_8c/#public-functions","title":"Public Functions","text":"Type Name LOG_MODULE_REGISTER (ts_can, CONFIG_THINGSET_SDK_LOG_LEVEL)  SYS_INIT (can_control_init, APPLICATION, THINGSET_INIT_PRIORITY_DEFAULT)  void can_control_rx_handler (uint16_t data_id, const uint8_t * value, size_t value_len, uint8_t source_addr)"},{"location":"powerAPI/thingset__can_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name int can_control_init ()  void can_control_work_handler (struct k_work * item)"},{"location":"powerAPI/thingset__can_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/thingset__can_8c/#variable-ts","title":"variable ts","text":"<pre><code>struct thingset_context ts;\n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/thingset__can_8c/#variable-can_work_data","title":"variable can_work_data","text":"<pre><code>struct can_control_work_data can_work_data;\n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/thingset__can_8c/#function-log_module_register","title":"function LOG_MODULE_REGISTER","text":"<pre><code>LOG_MODULE_REGISTER (\n    ts_can,\n    CONFIG_THINGSET_SDK_LOG_LEVEL\n) \n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#function-sys_init","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    can_control_init,\n    APPLICATION,\n    THINGSET_INIT_PRIORITY_DEFAULT\n) \n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#function-can_control_rx_handler","title":"function can_control_rx_handler","text":"<pre><code>void can_control_rx_handler (\n    uint16_t data_id,\n    const uint8_t * value,\n    size_t value_len,\n    uint8_t source_addr\n) \n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/thingset__can_8c/#function-can_control_init","title":"function can_control_init","text":"<pre><code>static int can_control_init () \n</code></pre>"},{"location":"powerAPI/thingset__can_8c/#function-can_control_work_handler","title":"function can_control_work_handler","text":"<pre><code>static void can_control_work_handler (\n    struct k_work * item\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_can.c</code></p>"},{"location":"powerAPI/thingset__can_8c_source/","title":"File thingset_can.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_can.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n * @author Martin J\u00e4ger &lt;martin@libre.solar&gt;\n */\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/can.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n\n#include &lt;thingset.h&gt;\n#include &lt;thingset/can.h&gt;\n#include &lt;thingset/sdk.h&gt;\n\nLOG_MODULE_REGISTER(ts_can, CONFIG_THINGSET_SDK_LOG_LEVEL);\n\nextern struct thingset_context ts;\n\n/* Structure to hold the data to be processed by the workqueue */\nstruct can_control_work_data {\n    struct k_work work;\n    /* ThingSet bin headers + CAN frame payload */\n    uint8_t buf[4 + CAN_MAX_DLEN];\n    size_t buf_len;\n};\n\nstatic struct can_control_work_data can_work_data;\n\n/* Work handler function to be executed in workqueue context */\nstatic void can_control_work_handler(struct k_work *item)\n{\n    struct can_control_work_data *data =\n            CONTAINER_OF(item, struct can_control_work_data, work);\n\n    LOG_HEXDUMP_DBG(data-&gt;buf, data-&gt;buf_len, \"Thingset frame:\");\n\n    thingset_import_data(&amp;ts,\n                         data-&gt;buf,\n                         data-&gt;buf_len,\n                         THINGSET_WRITE_MASK,\n                         THINGSET_BIN_IDS_VALUES);\n}\n\nvoid can_control_rx_handler(uint16_t data_id,\n                            const uint8_t *value,\n                            size_t value_len,\n                            uint8_t source_addr)\n{\n    /* Control data items use IDs &gt;= 0x8000 */\n    if (data_id &gt;= 0x8000) {\n        /* CBOR: map with 1 element */\n        can_work_data.buf[0] = 0xA1;\n        /* CBOR: uint16 follows (object ID is 2 bytes) */\n        can_work_data.buf[1] = 0x19;\n        /* High byte of data ID */\n        can_work_data.buf[2] = data_id &gt;&gt; 8;\n        /* Low byte of data ID */\n        can_work_data.buf[3] = data_id;\n\n        memcpy(&amp;can_work_data.buf[4], value, value_len);\n\n        can_work_data.buf_len = 4 + value_len;\n\n        LOG_DBG(\"received control msg with id 0x%X from addr 0x%X\",\n                data_id,\n                source_addr);\n\n        /* Submit the work item to the system workqueue */\n        k_work_submit(&amp;can_work_data.work);\n    }\n}\n\nstatic int can_control_init()\n{\n    k_work_init(&amp;can_work_data.work, can_control_work_handler);\n    thingset_can_set_item_rx_callback(can_control_rx_handler);\n    return 0;\n}\n\nSYS_INIT(can_control_init, APPLICATION, THINGSET_INIT_PRIORITY_DEFAULT);\n</code></pre>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver</p>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/</code></p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/#files","title":"Files","text":"Type Name file comparator.c file comparator.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/comparator_8c/","title":"File comparator.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8c/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init () Initialize comparator <code>COMP1</code> with predefined settings. void comparator3_init () Initialize comparator <code>COMP3</code> with predefined settings."},{"location":"powerAPI/comparator_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8c/#function-comparator1_init","title":"function comparator1_init","text":"<p>Initialize comparator <code>COMP1</code> with predefined settings. <pre><code>void comparator1_init () \n</code></pre></p> <p>This function configures <code>GPIO</code> and comparator settings for <code>COMP1</code>:</p> <ul> <li>Sets <code>PA1</code> as the positive input (<code>COMP1_INP</code>) in analog mode.</li> <li>Routes <code>DAC3</code> Channel 1 as the negative input.</li> <li>Configures non-inverting output, no hysteresis, and no blanking source.</li> <li>Disables related EXTI line (line 21) events and interrupts.</li> <li>Applies voltage scaler stabilization delay.</li> <li>Enables the comparator. </li> </ul>"},{"location":"powerAPI/comparator_8c/#function-comparator3_init","title":"function comparator3_init","text":"<p>Initialize comparator <code>COMP3</code> with predefined settings. <pre><code>void comparator3_init () \n</code></pre></p> <p>This function configures <code>GPIO</code> and comparator settings for <code>COMP3</code>:</p> <ul> <li>Sets <code>PC1</code> as the positive input (<code>COMP3_INP</code>) in analog mode.</li> <li>Routes <code>DAC1</code> Channel 1 as the negative input.</li> <li>Configures non-inverting output, no hysteresis, and no blanking source.</li> <li>Disables related EXTI line (line 29) events and interrupts.</li> <li>Applies voltage scaler stabilization delay.</li> <li>Enables the comparator. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.c</code></p>"},{"location":"powerAPI/comparator_8c_source/","title":"File comparator.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2022\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n/* Current module private functions */\n#include \"../src/comparator_driver.h\"\n\n\nvoid comparator1_init()\n{\n    comparator_comp1_init();\n}\n\nvoid comparator3_init()\n{\n    comparator_comp3_init();\n}\n</code></pre>"},{"location":"powerAPI/comparator_8h/","title":"File comparator.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8h/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init () Initialize comparator <code>COMP1</code> with predefined settings. void comparator3_init () Initialize comparator <code>COMP3</code> with predefined settings."},{"location":"powerAPI/comparator_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8h/#function-comparator1_init","title":"function comparator1_init","text":"<p>Initialize comparator <code>COMP1</code> with predefined settings. <pre><code>void comparator1_init () \n</code></pre></p> <p>This function configures <code>GPIO</code> and comparator settings for <code>COMP1</code>:</p> <ul> <li>Sets <code>PA1</code> as the positive input (<code>COMP1_INP</code>) in analog mode.</li> <li>Routes <code>DAC3</code> Channel 1 as the negative input.</li> <li>Configures non-inverting output, no hysteresis, and no blanking source.</li> <li>Disables related EXTI line (line 21) events and interrupts.</li> <li>Applies voltage scaler stabilization delay.</li> <li>Enables the comparator. </li> </ul>"},{"location":"powerAPI/comparator_8h/#function-comparator3_init","title":"function comparator3_init","text":"<p>Initialize comparator <code>COMP3</code> with predefined settings. <pre><code>void comparator3_init () \n</code></pre></p> <p>This function configures <code>GPIO</code> and comparator settings for <code>COMP3</code>:</p> <ul> <li>Sets <code>PC1</code> as the positive input (<code>COMP3_INP</code>) in analog mode.</li> <li>Routes <code>DAC1</code> Channel 1 as the negative input.</li> <li>Configures non-inverting output, no hysteresis, and no blanking source.</li> <li>Disables related EXTI line (line 29) events and interrupts.</li> <li>Applies voltage scaler stabilization delay.</li> <li>Enables the comparator. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.h</code></p>"},{"location":"powerAPI/comparator_8h_source/","title":"File comparator.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @author  Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author  Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef COMPARATOR_H_\n#define COMPARATOR_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid comparator1_init();\n\nvoid comparator3_init();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* COMPARATOR_H_ */\n</code></pre>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver</p>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/</code></p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/#files","title":"Files","text":"Type Name file dac.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/dac_8h/","title":"File dac.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dac_8h/#classes","title":"Classes","text":"Type Name struct dac_driver_api struct dac_function_config_t Defines the DAC configuration structure."},{"location":"powerAPI/dac_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dac_api_fn_upd_reset typedef void(* dac_api_fn_upd_step typedef void(* dac_api_pinconfigure typedef void(* dac_api_setconstvalue typedef void(* dac_api_setfunction typedef void(* dac_api_start typedef void(* dac_api_stop enum dac_function_t Defines the possible speeds for the RS485: enum dac_pin_config_t Defines the types of pin configuration of the DAC: enum dac_polarity_t Defines the DAC polarity: enum dac_trigger_t Defines the triggers of the DAC:"},{"location":"powerAPI/dac_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void dac_function_update_reset (const struct device * dev, uint8_t channel, uint32_t reset_data)  void dac_function_update_step (const struct device * dev, uint8_t channel, uint32_t step_data)  void dac_pin_configure (const struct device * dev, uint8_t channel, dac_pin_config_t pin_config)  void dac_set_const_value (const struct device * dev, uint8_t channel, uint32_t value)  void dac_set_function (const struct device * dev, uint8_t channel, const dac_function_config_t * function_config)  void dac_start (const struct device * dev, uint8_t channel)  void dac_stop (const struct device * dev, uint8_t channel)"},{"location":"powerAPI/dac_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_reset","title":"typedef dac_api_fn_upd_reset","text":"<pre><code>typedef void(* dac_api_fn_upd_reset) (const struct device *dev, uint8_t channel, uint32_t reset_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_step","title":"typedef dac_api_fn_upd_step","text":"<pre><code>typedef void(* dac_api_fn_upd_step) (const struct device *dev, uint8_t channel, uint32_t step_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_pinconfigure","title":"typedef dac_api_pinconfigure","text":"<pre><code>typedef void(* dac_api_pinconfigure) (const struct device *dev, uint8_t channel, dac_pin_config_t config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setconstvalue","title":"typedef dac_api_setconstvalue","text":"<pre><code>typedef void(* dac_api_setconstvalue) (const struct device *dev, uint8_t channel, uint32_t value);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setfunction","title":"typedef dac_api_setfunction","text":"<pre><code>typedef void(* dac_api_setfunction) (const struct device *dev, uint8_t channel, const dac_function_config_t *config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_start","title":"typedef dac_api_start","text":"<pre><code>typedef void(* dac_api_start) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_stop","title":"typedef dac_api_stop","text":"<pre><code>typedef void(* dac_api_stop) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_function_t","title":"enum dac_function_t","text":"<p>Defines the possible speeds for the RS485: <pre><code>enum dac_function_t {\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n};\n</code></pre></p> <p>Configuration types </p> <ul> <li><code>dac_function_noise</code>: Creates noise on the DAC</li> <li><code>dac_function_triangle</code>: Creates a triangle waveform</li> <li><code>dac_function_sawtooth</code>: Creates a sawtooth waveform </li> </ul>"},{"location":"powerAPI/dac_8h/#enum-dac_pin_config_t","title":"enum dac_pin_config_t","text":"<p>Defines the types of pin configuration of the DAC: <pre><code>enum dac_pin_config_t {\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n};\n</code></pre></p> <ul> <li><code>dac_pin_internal</code></li> <li><code>dac_pin_external</code></li> <li><code>dac_pin_internal_and_external</code> </li> </ul>"},{"location":"powerAPI/dac_8h/#enum-dac_polarity_t","title":"enum dac_polarity_t","text":"<p>Defines the DAC polarity: <pre><code>enum dac_polarity_t {\n    dac_polarity_decrement,\n    dac_polarity_increment\n};\n</code></pre></p> <ul> <li><code>dac_polarity_decrement</code>: Decrements the DAC counter</li> <li><code>dac_polarity_increment</code>: Increments the DAC counter </li> </ul>"},{"location":"powerAPI/dac_8h/#enum-dac_trigger_t","title":"enum dac_trigger_t","text":"<p>Defines the triggers of the DAC: <pre><code>enum dac_trigger_t {\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n};\n</code></pre></p> <ul> <li><code>hrtim_trig1</code> to <code>hrtim_trig6</code>: HRTIM driven triggers </li> </ul>"},{"location":"powerAPI/dac_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/dac_8h/#function-dac_function_update_reset","title":"function dac_function_update_reset","text":"<pre><code>static inline void dac_function_update_reset (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t reset_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_function_update_step","title":"function dac_function_update_step","text":"<pre><code>static inline void dac_function_update_step (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t step_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_pin_configure","title":"function dac_pin_configure","text":"<pre><code>static inline void dac_pin_configure (\n    const struct device * dev,\n    uint8_t channel,\n    dac_pin_config_t pin_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_const_value","title":"function dac_set_const_value","text":"<pre><code>static inline void dac_set_const_value (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t value\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_function","title":"function dac_set_function","text":"<pre><code>static inline void dac_set_function (\n    const struct device * dev,\n    uint8_t channel,\n    const dac_function_config_t * function_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_start","title":"function dac_start","text":"<pre><code>static inline void dac_start (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_stop","title":"function dac_stop","text":"<pre><code>static inline void dac_stop (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/dac_8h_source/","title":"File dac.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n\n#ifndef DAC_H_\n#define DAC_H_\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#define DAC1_DEVICE DT_NODELABEL(dac1)\n#define DAC2_DEVICE DT_NODELABEL(dac2)\n#define DAC3_DEVICE DT_NODELABEL(dac3)\n\n\ntypedef enum\n{\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n} dac_function_t;\n\ntypedef enum\n{\n    dac_polarity_decrement,\n    dac_polarity_increment\n} dac_polarity_t;\n\ntypedef enum\n{\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n} dac_trigger_t;\n\n\ntypedef struct\n{\n    dac_function_t dac_function;\n    dac_trigger_t  reset_trigger_source;\n    dac_trigger_t  step_trigger_source;\n    dac_polarity_t polarity;\n    uint32_t       reset_data;\n    uint32_t       step_data;\n} dac_function_config_t;\n\ntypedef enum\n{\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n} dac_pin_config_t;\n\n/* API */\n\ntypedef void (*dac_api_setconstvalue)(\n    const struct device* dev,\n    uint8_t channel,\n    uint32_t value\n);\n\ntypedef void (*dac_api_setfunction)(\n    const struct device* dev,\n    uint8_t channel,\n    const dac_function_config_t* config\n);\n\ntypedef void (*dac_api_fn_upd_reset)(\n    const struct device* dev,\n    uint8_t channel,\n    uint32_t reset_data\n);\n\ntypedef void (*dac_api_fn_upd_step)(\n    const struct device* dev,\n    uint8_t channel,\n    uint32_t step_data\n);\n\ntypedef void (*dac_api_pinconfigure)(\n    const struct device* dev,\n    uint8_t channel,\n    dac_pin_config_t config\n);\n\ntypedef void (*dac_api_start)(\n    const struct device* dev,\n    uint8_t channel\n);\n\ntypedef void (*dac_api_stop)(\n    const struct device* dev,\n    uint8_t channel\n);\n\n__subsystem struct dac_driver_api\n{\n    dac_api_setconstvalue setconstvalue;\n    dac_api_setfunction   setfunction;\n    dac_api_fn_upd_reset  fn_upd_reset;\n    dac_api_fn_upd_step   fn_upd_step;\n    dac_api_pinconfigure  pinconfigure;\n    dac_api_start         start;\n    dac_api_stop          stop;\n};\n\nstatic inline void dac_set_const_value(const struct device* dev,\n                                       uint8_t channel,\n                                       uint32_t value)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setconstvalue(dev, channel, value);\n}\n\nstatic inline void dac_set_function(\n                                const struct device* dev,\n                                uint8_t channel,\n                                const dac_function_config_t* function_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setfunction(dev, channel, function_config);\n}\n\nstatic inline void dac_function_update_reset(const struct device* dev,\n                                             uint8_t channel,\n                                             uint32_t reset_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_reset(dev, channel, reset_data);\n}\n\nstatic inline void dac_function_update_step(const struct device* dev,\n                                            uint8_t channel,\n                                            uint32_t step_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_step(dev, channel, step_data);\n}\n\nstatic inline void dac_pin_configure(const struct device* dev,\n                                     uint8_t channel,\n                                     dac_pin_config_t pin_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;pinconfigure(dev, channel, pin_config);\n}\n\nstatic inline void dac_start(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev, channel);\n}\n\nstatic inline void dac_stop(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev, channel);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* DAC_H_ */\n</code></pre>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver</p>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/</code></p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/#files","title":"Files","text":"Type Name file nvs_storage.c file nvs_storage.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/nvs__storage_8c/","title":"File nvs_storage.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t current_storage_version   = <code>0x0001</code> struct nvs_fs fs   = <code>/* multi line expression */</code>Flash memory file system. bool initialized   = <code>false</code> uint16_t storage_version_in_nvs   = <code>0</code>"},{"location":"powerAPI/nvs__storage_8c/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data () Clear all data stored in the NVS partition. uint16_t nvs_storage_get_current_version () Get the current in-code version of the NVS layout. uint16_t nvs_storage_get_version_in_nvs () Get the version stored in the NVS flash memory. int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size) Retrieve a data item from non-volatile storage (NVS). int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size) Store a data item in non-volatile storage (NVS)."},{"location":"powerAPI/nvs__storage_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name int8_t _nvs_storage_init () PRIVATE FUNCTION - Initialize the NVS (Non-Volatile Storage) subsystem. int8_t _nvs_storage_store_version () PRIVATE FUNCTION - Store the current NVS (Non-Volatile Storage) version if needed."},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#variable-current_storage_version","title":"variable current_storage_version","text":"<pre><code>const uint16_t current_storage_version;\n</code></pre> <p>Includes </p>"},{"location":"powerAPI/nvs__storage_8c/#variable-fs","title":"variable fs","text":"<p>Flash memory file system. <pre><code>struct nvs_fs fs;\n</code></pre></p>"},{"location":"powerAPI/nvs__storage_8c/#variable-initialized","title":"variable initialized","text":"<pre><code>bool initialized;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#variable-storage_version_in_nvs","title":"variable storage_version_in_nvs","text":"<pre><code>uint16_t storage_version_in_nvs;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<p>Clear all data stored in the NVS partition. <pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre></p> <p>Erases all key-value entries in the configured NVS area. Use with caution.</p> <p>Returns:</p> <p>0 on success, negative value on error. </p>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<p>Get the current in-code version of the NVS layout. <pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre></p> <p>This version corresponds to the structure of data expected by the firmware.</p> <p>Used to detect incompatibility between NVS layout and firmware logic.</p> <p>Returns:</p> <p>Current version defined in code. </p>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<p>Get the version stored in the NVS flash memory. <pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre></p> <p>Used to compare with the in-code version to validate compatibility.</p> <p>Returns:</p> <p>Stored version value from flash. </p>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<p>Retrieve a data item from non-volatile storage (NVS). <pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre></p> <p>Reads the stored data associated with the given identifier (data_id) and copies it into the provided buffer.</p> <p>Parameters:</p> <ul> <li><code>data_id</code> Identifier for the stored data. </li> <li><code>data_buffer</code> Pointer to the buffer where data will be copied. </li> <li><code>data_buffer_size</code> Size of the buffer in bytes.</li> </ul> <p>Returns:</p> <p>Number of bytes read on success, negative value on error. </p>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<p>Store a data item in non-volatile storage (NVS). <pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre></p> <p>Stores a block of data under a given identifier (data_id) in flash memory.</p> <p>If the data already exists, it is overwritten. Useful for persisting configuration.</p> <p>Parameters:</p> <ul> <li><code>data_id</code> Identifier for the data item. </li> <li><code>data</code> Pointer to the data to be stored. </li> <li><code>data_size</code> Size of the data in bytes.</li> </ul> <p>Returns:</p> <p>0 on success, negative value on error. </p>"},{"location":"powerAPI/nvs__storage_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_init","title":"function _nvs_storage_init","text":"<p>PRIVATE FUNCTION - Initialize the NVS (Non-Volatile Storage) subsystem. <pre><code>static int8_t _nvs_storage_init () \n</code></pre></p> <p>This function sets up the flash storage environment used to store ADC parameters.</p> <ul> <li>Verifies if initialization has already been completed.</li> <li>Checks if the flash device is ready for operations.</li> <li>Retrieves flash page information to determine sector size and count.</li> <li>Mounts the NVS file system.</li> <li>Checks and validates the stored version against the current module version.</li> </ul> <p>Returns:</p> <p><code>0</code> if initialization succeeds, <code>-1</code> if initialization fails, <code>-2</code> if a version mismatch is detected. </p>"},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_store_version","title":"function _nvs_storage_store_version","text":"<p>PRIVATE FUNCTION - Store the current NVS (Non-Volatile Storage) version if needed. <pre><code>static int8_t _nvs_storage_store_version () \n</code></pre></p> <p>This function ensures that the storage version recorded in NVS is consistent with the current API's storage version.</p> <ul> <li>If the stored version matches the current version, nothing is done.</li> <li>If no version exists in NVS (first use), it writes the current version into NVS.</li> <li>If a different version exists, it treats the mismatch as an error and signals that manual clearing is required.</li> </ul> <p>Returns:</p> <p><code>0</code> if version is already correct or successfully written, <code>-1</code> on failure. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.c</code></p>"},{"location":"powerAPI/nvs__storage_8c_source/","title":"File nvs_storage.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@laas.fr&gt;\n */\n\n\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/fs/nvs.h&gt;\n#include &lt;zephyr/drivers/flash.h&gt;\n#include &lt;zephyr/storage/flash_map.h&gt;\n\n/* CMSIS */\n#include &lt;arm_math.h&gt;\n\n/* Current file header */\n#include \"nvs_storage.h\"\n\n\n/* Constants and variables */\nstatic const uint16_t current_storage_version = 0x0001; \nstatic uint16_t storage_version_in_nvs = 0;\nstatic bool initialized = false;\n\n/* Device-tree related macros */\n#define NVS_PARTITION storage_partition\n#define STORAGE_NODE  DT_NODE_BY_FIXED_PARTITION_LABEL(NVS_PARTITION)\n\nstatic struct nvs_fs fs =\n{\n    .offset       = FIXED_PARTITION_OFFSET(NVS_PARTITION),\n    .flash_device = FIXED_PARTITION_DEVICE(NVS_PARTITION)\n};\n\n\nstatic int8_t _nvs_storage_store_version()\n{\n    if (storage_version_in_nvs == current_storage_version)\n    {\n        /* Ok, nothing to do */\n        return 0;\n    }\n    else if (storage_version_in_nvs == 0)\n    {\n        /* No version in NVS: this is the first use of NVS,\n         * store current version number. */\n        int rc = nvs_write(&amp;fs, VERSION, &amp;current_storage_version, 2);\n\n        if (rc == 2)\n        {\n            storage_version_in_nvs = current_storage_version;\n            return 0;\n        }\n\n        return -1;\n    }\n    else\n    {\n        /* There is already a version number in NVS,\n         * but it differs from current API version.\n         * This is currently treated as an error and requires\n         * to explicitly clear NVS. */\n        return -1;\n    }\n}\n\nstatic int8_t _nvs_storage_init()\n{\n    if (initialized == true)\n        return 0;\n\n    if (!device_is_ready(fs.flash_device))\n    {\n        printk(\"Flash device %s is not ready\\n\", fs.flash_device-&gt;name);\n        return -1;\n    }\n\n\n    struct flash_pages_info info;\n    int rc = flash_get_page_info_by_offs(fs.flash_device, fs.offset, &amp;info);\n    if (rc != 0)\n    {\n        printk(\"Unable to get page info\\n\");\n        return -1;\n    }\n    fs.sector_size = info.size;\n    fs.sector_count = 2U;\n\n    rc = nvs_mount(&amp;fs);\n    if (rc != 0)\n    {\n        printk(\"Flash Init failed\\n\");\n        return -1;\n    }\n\n    /* Init OK */\n    initialized = true;\n\n    /* Check version in storage */\n    rc = nvs_storage_retrieve_data(VERSION, &amp;storage_version_in_nvs, 2);\n\n    if (rc &lt; 0)\n    {\n        /* No version in NVS: this is the first use of NVS. */\n        storage_version_in_nvs = 0;\n    }\n    else if (storage_version_in_nvs != current_storage_version)\n    {\n        printk(\"WARNING: stored version in NVS is different from \\\n                current module version! \\\n                Stored data may not have the expected format.\\n\");\n\n        /* -2 indicates that the current version stored in NVS\n         * is different from current code version. */\n        return -2;\n    }\n\n    return 0;\n}\n\n\n/* Public functions */\n\nint8_t nvs_storage_store_data(uint16_t data_id,\n                              const void* data,\n                              uint8_t data_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = _nvs_storage_store_version();\n    if (rc != 0)\n    {\n        return rc;\n    }\n\n    rc = nvs_write(&amp;fs, data_id, data, data_size);\n\n    return rc;\n}\n\nint8_t nvs_storage_retrieve_data(uint16_t data_id,\n                                 void* data_buffer,\n                                 uint8_t data_buffer_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = nvs_read(&amp;fs, data_id, data_buffer, 1);\n\n    if (rc &gt; 1) /* There is more than 1 byte of data */\n    {\n        if (rc &gt; data_buffer_size)\n        {\n            /* Indicate that provided buffer is too small to retrieve data */\n            return -1;\n        }\n\n        rc = nvs_read(&amp;fs, data_id, data_buffer, rc);\n    }\n\n    return rc;\n}\n\nint8_t nvs_storage_clear_all_stored_data()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return nvs_clear(&amp;fs);\n}\n\nuint16_t nvs_storage_get_current_version()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return current_storage_version;\n}\n\nuint16_t nvs_storage_get_version_in_nvs()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return storage_version_in_nvs;\n}\n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/","title":"File nvs_storage.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8h/#public-types","title":"Public Types","text":"Type Name enum nvs_category_t Defines the NVS categories."},{"location":"powerAPI/nvs__storage_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data () Clear all data stored in the NVS partition. uint16_t nvs_storage_get_current_version () Get the current in-code version of the NVS layout. uint16_t nvs_storage_get_version_in_nvs () Get the version stored in the NVS flash memory. int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size) Retrieve a data item from non-volatile storage (NVS). int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size) Store a data item in non-volatile storage (NVS)."},{"location":"powerAPI/nvs__storage_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#enum-nvs_category_t","title":"enum nvs_category_t","text":"<p>Defines the NVS categories. <pre><code>enum nvs_category_t {\n    VERSION = 0x0100,\n    ADC_CALIBRATION = 0x0200,\n    MEASURE_THRESHOLD = 0x0300\n};\n</code></pre></p> <ul> <li><code>VERSION</code> = 0x0100</li> <li><code>ADC_CALIBRATION</code> = 0x0200</li> <li><code>MEASURE_THRESHOLD</code> = 0x0300</li> </ul> <p>Note:</p> <p>Must be on the upper half of the 2-bytes value, hence end with 00 </p>"},{"location":"powerAPI/nvs__storage_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<p>Clear all data stored in the NVS partition. <pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre></p> <p>Erases all key-value entries in the configured NVS area. Use with caution.</p> <p>Returns:</p> <p>0 on success, negative value on error. </p>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<p>Get the current in-code version of the NVS layout. <pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre></p> <p>This version corresponds to the structure of data expected by the firmware.</p> <p>Used to detect incompatibility between NVS layout and firmware logic.</p> <p>Returns:</p> <p>Current version defined in code. </p>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<p>Get the version stored in the NVS flash memory. <pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre></p> <p>Used to compare with the in-code version to validate compatibility.</p> <p>Returns:</p> <p>Stored version value from flash. </p>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<p>Retrieve a data item from non-volatile storage (NVS). <pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre></p> <p>Reads the stored data associated with the given identifier (data_id) and copies it into the provided buffer.</p> <p>Parameters:</p> <ul> <li><code>data_id</code> Identifier for the stored data. </li> <li><code>data_buffer</code> Pointer to the buffer where data will be copied. </li> <li><code>data_buffer_size</code> Size of the buffer in bytes.</li> </ul> <p>Returns:</p> <p>Number of bytes read on success, negative value on error. </p>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<p>Store a data item in non-volatile storage (NVS). <pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre></p> <p>Stores a block of data under a given identifier (data_id) in flash memory.</p> <p>If the data already exists, it is overwritten. Useful for persisting configuration.</p> <p>Parameters:</p> <ul> <li><code>data_id</code> Identifier for the data item. </li> <li><code>data</code> Pointer to the data to be stored. </li> <li><code>data_size</code> Size of the data in bytes.</li> </ul> <p>Returns:</p> <p>0 on success, negative value on error. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.h</code></p>"},{"location":"powerAPI/nvs__storage_8h_source/","title":"File nvs_storage.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef NVS_STORAGE_H_\n#define NVS_STORAGE_H_\n\n\n#include &lt;stdint.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Types definition */\n\ntypedef enum\n{\n    VERSION          = 0x0100,\n    ADC_CALIBRATION  = 0x0200,\n    MEASURE_THRESHOLD = 0x0300,\n}nvs_category_t;\n\nint8_t nvs_storage_store_data(uint16_t data_id,\n                              const void* data,\n                              uint8_t data_size);\n\nint8_t nvs_storage_retrieve_data(uint16_t data_id,\n                                 void* data_buffer,\n                                 uint8_t data_buffer_size);\n\nint8_t nvs_storage_clear_all_stored_data();\n\nuint16_t nvs_storage_get_current_version();\n\nuint16_t nvs_storage_get_version_in_nvs();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NVS_STORAGE_H_ */\n</code></pre>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver</p>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/</code></p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/#files","title":"Files","text":"Type Name file hrtim.h file hrtim_enum.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/hrtim_8h/","title":"File hrtim.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim_8h/#classes","title":"Classes","text":"Type Name struct timer_hrtim_t Timing unit configuration that aggregates all the structures:"},{"location":"powerAPI/hrtim_8h/#public-attributes","title":"Public Attributes","text":"Type Name timer_hrtim_t * tu_channel"},{"location":"powerAPI/hrtim_8h/#public-functions","title":"Public Functions","text":"Type Name void DualDAC_init (hrtim_tu_number_t tu) Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). uint32_t hrtim_PeriodicEvent_GetRep (hrtim_tu_t tu) Gets the current value of the repetition counter. void hrtim_PeriodicEvent_SetRep (hrtim_tu_t tu, uint32_t repetition) Changes the repetition counter value to control the ISR interrupt. void hrtim_PeriodicEvent_configure (hrtim_tu_t tu, uint32_t repetition, hrtim_callback_t callback) Configures interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_dis (hrtim_tu_t tu) Disables interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_en (hrtim_tu_t tu) Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (hrtim_tu_number_t tu_number) Returns the adc rollover mode. void hrtim_adc_rollover_set (hrtim_tu_number_t tu_number, hrtim_adc_edgetrigger_t adc_rollover) Configures the adc rollover mode. void hrtim_adc_trigger_dis (hrtim_tu_number_t tu_number) Disbables a ADCx trigger event. void hrtim_adc_trigger_en (hrtim_tu_number_t tu_number) Configures and enables an ADC trigger event. hrtim_adc_trigger_t hrtim_adc_trigger_get (hrtim_tu_number_t tu_number) Returns the adc trigger. void hrtim_adc_trigger_set (hrtim_tu_number_t tu_number, hrtim_adc_trigger_t adc_trig) Sets the adc trigger number for a timing unit. void hrtim_adc_trigger_set_postscaler (hrtim_tu_number_t tu_number, uint32_t ps_ratio) Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. void hrtim_burst_dis (void) Disable burst mode. void hrtim_burst_mode_init (void) Initialize burst mode This mode permits to skip one or multiple PWM periods by idling the output on a low state. It is used in light load conditions to minimize switching losses. void hrtim_burst_set (int bm_cmp, int bm_per) Set burst mode parameters. void hrtim_burst_start (void) Starts burst mode. Burst mode won't stop until hrtim_burst_stop is called. void hrtim_burst_stop (void) Stops burst mode. void hrtim_change_frequency (uint32_t new_frequency) Change the frequency/period after it has been initialized. void hrtim_cmpl_pwm_out (hrtim_tu_number_t tu_number) Activates OUT 1 and 2 (switch H and L) with a given switching convention. void hrtim_cnt_dis (hrtim_tu_number_t tu_number) Disables a timing unit counter. void hrtim_cnt_en (hrtim_tu_number_t tu_number) Enables a timing unit counter. void hrtim_dt_init (hrtim_tu_number_t tu_number) Initialize the dead-time for the PWM. void hrtim_dt_set (hrtim_tu_number_t tu_number, uint16_t rise_ns, uint16_t fall_ns) Sets up a dead time in nano second for given complementary outputs. void hrtim_duty_cycle_set (hrtim_tu_number_t tu_number, uint16_t value) Updates the duty cycle of a timing unit. hrtim_external_trigger_t hrtim_eev_get (hrtim_tu_number_t tu_number) Returns the external event trigger used in current mode. void hrtim_eev_set (hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev) Sets the external event used in current mode for a timing unit. void hrtim_frequency_set (uint32_t frequency_set, uint32_t frequency_min) Sets the frequency of a given timing unit in Hz. int hrtim_get_apb2_clock () Get the current APB2 clock frequency used by HRTIM. uint32_t hrtim_get_max_frequency (hrtim_tu_number_t tu_number) Gets the minimum frequency of the timing unit in Hertz. uint16_t hrtim_get_max_period (hrtim_tu_number_t tu_number) Gets the maximum period of the timing unit in number of clock cycles. uint32_t hrtim_get_min_frequency (hrtim_tu_number_t tu_number) Gets the minimum frequency of the timing unit in Hertz. uint16_t hrtim_get_min_period (hrtim_tu_number_t tu_number) Gets the minimum period of the timing unit in number of clock cycles. hrtim_cnt_t hrtim_get_modulation (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. uint32_t hrtim_get_resolution_ps (hrtim_tu_number_t tu_number) Gets the time resolution for a given timing unit. hrtim_tu_ON_OFF_t hrtim_get_status (hrtim_tu_number_t tu_number) Returns if the timer was initialized with default value or not. hrtim_switch_convention_t hrtim_get_switch_convention (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. void hrtim_init_default_all () This function initialize all the default parameters for each timing unit structure. void hrtim_master_cmp_set (hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_out_dis (hrtim_tu_number_t tu_number) Disables the output of a given timing unit. void hrtim_out_dis_single (hrtim_output_units_t PWM_OUT) Disables only one output of a given timing unit. void hrtim_out_en (hrtim_tu_number_t tu_number) Enables the output of a given timing unit. void hrtim_out_en_single (hrtim_output_units_t PWM_OUT) Enables only one output of a given timing unit. void hrtim_output_hot_swap (hrtim_tu_number_t tu_number) Hot swaps the output channels for the timing unit. uint16_t hrtim_period_Master_get () Returns the period of a master timer in number of clock cycles. uint32_t hrtim_period_Master_get_us () Returns the period of the master timer in microseconds. uint16_t hrtim_period_get (hrtim_tu_number_t tu_number) Returns the period of a given timing unit in number of clock cycles. uint32_t hrtim_period_get_us (hrtim_tu_number_t tu_number) Returns the period of a given timing unit in microseconds. void hrtim_phase_shift_set (hrtim_tu_number_t tu_number, uint16_t shift) Shifts the PWM of a timing unit. hrtim_pwm_mode_t hrtim_pwm_mode_get (hrtim_tu_number_t tu_number) Returns timing unit pwm mode. void hrtim_pwm_mode_set (hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode) Sets the pwm mode : voltage or current mode. void hrtim_rst_evt_dis (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Disables a timer counter reset event. void hrtim_rst_evt_en (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Enables a timer counter reset event. void hrtim_set_modulation (hrtim_tu_number_t tu_number, hrtim_cnt_t modulation) Sets the switching convention of a given timing unit. void hrtim_set_switch_convention (hrtim_tu_number_t tu_number, hrtim_switch_convention_t convention) Sets the switching convention of a given timing unit. void hrtim_tu_cmp_set (hrtim_tu_number_t tu_number, hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_tu_gpio_init (hrtim_tu_number_t tu_number) Initializes the gpio elements of a given timing unit. uint16_t hrtim_tu_init (hrtim_tu_number_t tu_number) Initializes a given timing unit."},{"location":"powerAPI/hrtim_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/hrtim_8h/#variable-tu_channel","title":"variable tu_channel","text":"<pre><code>timer_hrtim_t* tu_channel[HRTIM_STU_NUMOF];\n</code></pre>"},{"location":"powerAPI/hrtim_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hrtim_8h/#function-dualdac_init","title":"function DualDAC_init","text":"<p>Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). <pre><code>void DualDAC_init (\n    hrtim_tu_number_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_getrep","title":"function hrtim_PeriodicEvent_GetRep","text":"<p>Gets the current value of the repetition counter. <pre><code>uint32_t hrtim_PeriodicEvent_GetRep (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> timing unit which will be the source for the ISR <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code></li> </ul> <p>Returns:</p> <p>Value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_setrep","title":"function hrtim_PeriodicEvent_SetRep","text":"<p>Changes the repetition counter value to control the ISR interrupt. <pre><code>void hrtim_PeriodicEvent_SetRep (\n    hrtim_tu_t tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>repetion</code> value between 1 and 256 for the repetition counter: period of the event write periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_configure","title":"function hrtim_PeriodicEvent_configure","text":"<p>Configures interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_configure (\n    hrtim_tu_t tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>repetition</code> value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </li> <li><code>callback</code> Pointer to a void(void) function that will be called when the event is triggerred. </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_dis","title":"function hrtim_PeriodicEvent_dis","text":"<p>Disables interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_dis (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_en","title":"function hrtim_PeriodicEvent_en","text":"<p>Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. <pre><code>void hrtim_PeriodicEvent_en (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_get","title":"function hrtim_adc_rollover_get","text":"<p>Returns the adc rollover mode. <pre><code>hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code></li> </ul> <p>Returns:</p> <p>adc_rollover rollover mode : <code>EdgeTrigger_up</code>,<code>EdgeTrigger_down</code>,<code>EdgeTrigger_Both</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_set","title":"function hrtim_adc_rollover_set","text":"<p>Configures the adc rollover mode. <pre><code>void hrtim_adc_rollover_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_edgetrigger_t adc_rollover\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code></li> <li><code>adc_rollover</code> rollover mode: <code>EdgeTrigger_up</code>,<code>EdgeTrigger_down</code>,<code>EdgeTrigger_Both</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_dis","title":"function hrtim_adc_trigger_dis","text":"<p>Disbables a ADCx trigger event. <pre><code>void hrtim_adc_trigger_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_en","title":"function hrtim_adc_trigger_en","text":"<p>Configures and enables an ADC trigger event. <pre><code>void hrtim_adc_trigger_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_get","title":"function hrtim_adc_trigger_get","text":"<p>Returns the adc trigger. <pre><code>hrtim_adc_trigger_t hrtim_adc_trigger_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <p><code>ADCTRIG_1</code>, <code>ADCTRIG_2</code>, <code>ADCTRIG_3</code>, <code>ADCTRIG_4</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_set","title":"function hrtim_adc_trigger_set","text":"<p>Sets the adc trigger number for a timing unit. <pre><code>void hrtim_adc_trigger_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>adc_trig</code> pwm mode: <code>ADCTRIG_1</code>, <code>ADCTRIG_2</code>, <code>ADCTRIG_3</code>, <code>ADCTRIG_4</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_set_postscaler","title":"function hrtim_adc_trigger_set_postscaler","text":"<p>Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. <pre><code>void hrtim_adc_trigger_set_postscaler (\n    hrtim_tu_number_t tu_number,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ps_ratio</code> Post scaler ratio (0 = no post scaler, default) </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_burst_dis","title":"function hrtim_burst_dis","text":"<p>Disable burst mode. <pre><code>void hrtim_burst_dis (\n    void\n) \n</code></pre></p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_burst_mode_init","title":"function hrtim_burst_mode_init","text":"<p>Initialize burst mode This mode permits to skip one or multiple PWM periods by idling the output on a low state. It is used in light load conditions to minimize switching losses. <pre><code>void hrtim_burst_mode_init (\n    void\n) \n</code></pre></p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_burst_set","title":"function hrtim_burst_set","text":"<p>Set burst mode parameters. <pre><code>void hrtim_burst_set (\n    int bm_cmp,\n    int bm_per\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>bm_cmp</code> number of periods idle: </li> <li><code>bm_per</code> total number of period during a cycle (idle and active) </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_burst_start","title":"function hrtim_burst_start","text":"<p>Starts burst mode. Burst mode won't stop until hrtim_burst_stop is called. <pre><code>void hrtim_burst_start (\n    void\n) \n</code></pre></p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_burst_stop","title":"function hrtim_burst_stop","text":"<p>Stops burst mode. <pre><code>void hrtim_burst_stop (\n    void\n) \n</code></pre></p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_change_frequency","title":"function hrtim_change_frequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void hrtim_change_frequency (\n    uint32_t new_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>new_frequency</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cmpl_pwm_out","title":"function hrtim_cmpl_pwm_out","text":"<p>Activates OUT 1 and 2 (switch H and L) with a given switching convention. <pre><code>void hrtim_cmpl_pwm_out (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_dis","title":"function hrtim_cnt_dis","text":"<p>Disables a timing unit counter. <pre><code>void hrtim_cnt_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_en","title":"function hrtim_cnt_en","text":"<p>Enables a timing unit counter. <pre><code>void hrtim_cnt_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_init","title":"function hrtim_dt_init","text":"<p>Initialize the dead-time for the PWM. <pre><code>void hrtim_dt_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_set","title":"function hrtim_dt_set","text":"<p>Sets up a dead time in nano second for given complementary outputs. <pre><code>void hrtim_dt_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>rise_ns</code> The desired dead time of the rising edge in nano second </li> <li><code>fall_ns</code> The desired dead time of the falling edge in nano second </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_duty_cycle_set","title":"function hrtim_duty_cycle_set","text":"<p>Updates the duty cycle of a timing unit. <pre><code>void hrtim_duty_cycle_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>value</code> The desired duty cycle value </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_get","title":"function hrtim_eev_get","text":"<p>Returns the external event trigger used in current mode. <pre><code>hrtim_external_trigger_t hrtim_eev_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <p><code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_set","title":"function hrtim_eev_set","text":"<p>Sets the external event used in current mode for a timing unit. <pre><code>void hrtim_eev_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code></li> <li><code>adc_trig</code> pwm mode: <code>EEV1</code>,<code>EEV2</code>,<code>EEV3</code>,<code>EEV4</code>,<code>EEV5</code>,<code>EEV6</code>,<code>EEV7</code>,<code>EEV8</code>,<code>EEV9</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_frequency_set","title":"function hrtim_frequency_set","text":"<p>Sets the frequency of a given timing unit in Hz. <pre><code>void hrtim_frequency_set (\n    uint32_t frequency_set,\n    uint32_t frequency_min\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>tu_number</code> Timing unit number: </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_apb2_clock","title":"function hrtim_get_apb2_clock","text":"<p>Get the current APB2 clock frequency used by HRTIM. <pre><code>int hrtim_get_apb2_clock () \n</code></pre></p> <p>This function retrieves the prescaler value configured for the APB2 bus and returns the effective clock frequency driving the HRTIM peripheral.</p> <ul> <li>Reads the APB2 prescaler from RCC configuration.</li> <li>Calculates the actual APB2 clock by dividing the system clock by the prescaler value.</li> </ul> <p>Returns:</p> <p>The APB2 clock frequency in Hz. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_max_frequency","title":"function hrtim_get_max_frequency","text":"<p>Gets the minimum frequency of the timing unit in Hertz. <pre><code>uint32_t hrtim_get_max_frequency (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>frequency in Hertz </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_max_period","title":"function hrtim_get_max_period","text":"<p>Gets the maximum period of the timing unit in number of clock cycles. <pre><code>uint16_t hrtim_get_max_period (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>period in number of clock cycles </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_min_frequency","title":"function hrtim_get_min_frequency","text":"<p>Gets the minimum frequency of the timing unit in Hertz. <pre><code>uint32_t hrtim_get_min_frequency (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>frequency in Hertz </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_min_period","title":"function hrtim_get_min_period","text":"<p>Gets the minimum period of the timing unit in number of clock cycles. <pre><code>uint16_t hrtim_get_min_period (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>period in number of clock cycles </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_modulation","title":"function hrtim_get_modulation","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_cnt_t hrtim_get_modulation (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>Modulation type: <code>Lft_aligned</code>, <code>UpDwn</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_resolution_ps","title":"function hrtim_get_resolution_ps","text":"<p>Gets the time resolution for a given timing unit. <pre><code>uint32_t hrtim_get_resolution_ps (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>resolution in picoseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_status","title":"function hrtim_get_status","text":"<p>Returns if the timer was initialized with default value or not. <pre><code>hrtim_tu_ON_OFF_t hrtim_get_status (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p><code>true</code> or <code>false</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_switch_convention","title":"function hrtim_get_switch_convention","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_switch_convention_t hrtim_get_switch_convention (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>Switching convention of the given time unit: <code>PWMx1=0</code>, <code>PWMx2=1</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_init_default_all","title":"function hrtim_init_default_all","text":"<p>This function initialize all the default parameters for each timing unit structure. <pre><code>void hrtim_init_default_all () \n</code></pre></p> <p>Warning:</p> <p>This function must be called before changing any timing unit parameters (frequency, phase_shift) </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_master_cmp_set","title":"function hrtim_master_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_master_cmp_set (\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmp</code> Master comparators: <code>MCMP1R</code>,<code>MCMP2R</code>,<code>MCMP3R</code>,<code>MCMP4R</code> </li> <li><code>value</code> Comparator new value to set: </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis","title":"function hrtim_out_dis","text":"<p>Disables the output of a given timing unit. <pre><code>void hrtim_out_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis_single","title":"function hrtim_out_dis_single","text":"<p>Disables only one output of a given timing unit. <pre><code>void hrtim_out_dis_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: <code>PWMA1</code>,<code>PWMA2</code>,<code>PWMB1</code>,<code>PWMB2</code>,<code>PWMC1</code>,<code>PWMC2</code>, <code>PWMD1</code>,<code>PWMD2</code>,<code>PWME1</code>,<code>PWME2</code>,<code>PWMF1</code>,<code>PWMF2</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en","title":"function hrtim_out_en","text":"<p>Enables the output of a given timing unit. <pre><code>void hrtim_out_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en_single","title":"function hrtim_out_en_single","text":"<p>Enables only one output of a given timing unit. <pre><code>void hrtim_out_en_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: <code>PWMA1</code>,<code>PWMA2</code>,<code>PWMB1</code>,<code>PWMB2</code>,<code>PWMC1</code>,<code>PWMC2</code>, <code>PWMD1</code>,<code>PWMD2</code>,<code>PWME1</code>,<code>PWME2</code>,<code>PWMF1</code>,<code>PWMF2</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_output_hot_swap","title":"function hrtim_output_hot_swap","text":"<p>Hot swaps the output channels for the timing unit. <pre><code>void hrtim_output_hot_swap (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> the timing unit to swap the outputs </li> </ul> <p>Note:</p> <p>The variable pwm_swap holds the new swap state. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get","title":"function hrtim_period_Master_get","text":"<p>Returns the period of a master timer in number of clock cycles. <pre><code>uint16_t hrtim_period_Master_get () \n</code></pre></p> <p>Returns:</p> <p>Period of the master timer </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get_us","title":"function hrtim_period_Master_get_us","text":"<p>Returns the period of the master timer in microseconds. <pre><code>uint32_t hrtim_period_Master_get_us () \n</code></pre></p> <p>Returns:</p> <p>Period of the timer master in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get","title":"function hrtim_period_get","text":"<p>Returns the period of a given timing unit in number of clock cycles. <pre><code>uint16_t hrtim_period_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>Period of the timing unit </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get_us","title":"function hrtim_period_get_us","text":"<p>Returns the period of a given timing unit in microseconds. <pre><code>uint32_t hrtim_period_get_us (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>Period of the timing unit in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_phase_shift_set","title":"function hrtim_phase_shift_set","text":"<p>Shifts the PWM of a timing unit. <pre><code>void hrtim_phase_shift_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>shift</code> The desired phase shift value </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_get","title":"function hrtim_pwm_mode_get","text":"<p>Returns timing unit pwm mode. <pre><code>hrtim_pwm_mode_t hrtim_pwm_mode_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <p><code>CURRENT_MODE</code> or <code>VOLTAGE_MODE</code> </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_set","title":"function hrtim_pwm_mode_set","text":"<p>Sets the pwm mode : voltage or current mode. <pre><code>void hrtim_pwm_mode_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code></li> <li><code>mode</code> pwm mode: <code>VOLTAGE_MODE</code>, <code>CURRENT_MODE</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_dis","title":"function hrtim_rst_evt_dis","text":"<p>Disables a timer counter reset event. <pre><code>void hrtim_rst_evt_dis (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>evt</code> Reset EVent:</li> <li><code>MSTR_PER</code>,<code>MSTR_CMP1</code>,<code>MSTR_CMP2</code>,<code>MSTR_CMP3</code>,<code>MSTR_CMP4</code>,<code>PWMA_CMP2</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_en","title":"function hrtim_rst_evt_en","text":"<p>Enables a timer counter reset event. <pre><code>void hrtim_rst_evt_en (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>evt</code> Reset EVent:</li> <li><code>MSTR_PER</code>,<code>MSTR_CMP1</code>,<code>MSTR_CMP2</code>,<code>MSTR_CMP3</code>,<code>MSTR_CMP4</code>,<code>PWMA_CMP2</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_modulation","title":"function hrtim_set_modulation","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_modulation (\n    hrtim_tu_number_t tu_number,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>modulation</code> modulation: <code>Lft_aligned</code>, <code>UpDwn</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_switch_convention","title":"function hrtim_set_switch_convention","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_switch_convention (\n    hrtim_tu_number_t tu_number,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>convention</code> Switching convention: <code>PWMx1</code>, <code>PWMx2</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_cmp_set","title":"function hrtim_tu_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_tu_cmp_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> <li><code>cmp</code> Master comparators: <code>CMP1xR</code>,<code>CMP2xR</code>,<code>CMP3xR</code>,<code>CMP4xR</code> </li> <li><code>value</code> Comparator new value to set </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_gpio_init","title":"function hrtim_tu_gpio_init","text":"<p>Initializes the gpio elements of a given timing unit. <pre><code>void hrtim_tu_gpio_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_init","title":"function hrtim_tu_init","text":"<p>Initializes a given timing unit. <pre><code>uint16_t hrtim_tu_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: <code>MSTR</code>, <code>TIMA</code>, <code>TIMB</code>, <code>TIMC</code>, <code>TIMD</code>, <code>TIME</code>, <code>TIMF</code> </li> </ul> <p>Returns:</p> <p>Timing unit period in clock pulses </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/hrtim_8h_source/","title":"File hrtim.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef HRTIM_H_\n#define HRTIM_H_\n\n#include &lt;stdint.h&gt;\n#include \"arm_math.h\"\n#include &lt;zephyr/kernel.h&gt;\n#include \"hrtim_enum.h\"\n\n#define TU_DEFAULT_DT (100U)       /* dead-time in ns */\n#define TU_DEFAULT_FREQ (200000U)  /* frequency in Hz */\n#define TU_DEFAULT_PERIOD (27200U) /* default period for 200kHz in bits */\n\n#ifdef HRTIM_MCR_TFCEN\n#define HRTIM_STU_NUMOF (6U) /* number of slave timing units */\n#else\n#define HRTIM_STU_NUMOF (5U)\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef struct\n{\n    pwm_conf_t pwm_conf;            \n    phase_shift_conf_t phase_shift;            \n    gpio_conf_t gpio_conf;          \n    switch_conv_conf_t switch_conv; \n    adc_hrtim_conf_t adc_hrtim;     \n    comp_usage_conf_t comp_usage;   \n} timer_hrtim_t;\n\nextern timer_hrtim_t *tu_channel[HRTIM_STU_NUMOF];\n\n/* Public Functions */\n\nint hrtim_get_apb2_clock();\n\nvoid hrtim_init_default_all();\n\nuint16_t hrtim_tu_init(hrtim_tu_number_t tu_number);\n\nhrtim_tu_ON_OFF_t hrtim_get_status(hrtim_tu_number_t tu_number);\n\nvoid hrtim_tu_gpio_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_out_dis_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_set_modulation(hrtim_tu_number_t tu_number, hrtim_cnt_t modulation);\n\nhrtim_cnt_t hrtim_get_modulation(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_get_resolution_ps(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_get_max_period(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_get_min_period(hrtim_tu_number_t tu_number);\n\n\nuint32_t hrtim_get_max_frequency(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_get_min_frequency(hrtim_tu_number_t tu_number);\n\n\n\nvoid hrtim_set_switch_convention(hrtim_tu_number_t tu_number,\n                                 hrtim_switch_convention_t convention);\n\nhrtim_switch_convention_t hrtim_get_switch_convention(\n    hrtim_tu_number_t tu_number\n);\n\nvoid hrtim_cmpl_pwm_out(hrtim_tu_number_t tu_number);\n\n\nvoid hrtim_frequency_set(uint32_t frequency_set, uint32_t frequency_min);\n\nuint16_t hrtim_period_get(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_period_Master_get();\n\nuint32_t hrtim_period_get_us(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_period_Master_get_us();\n\nvoid hrtim_tu_cmp_set(hrtim_tu_number_t tu_number,\n                      hrtim_cmp_t cmp,\n                      uint16_t value);\n\nvoid hrtim_master_cmp_set(hrtim_cmp_t cmp, uint16_t value);\n\nvoid hrtim_dt_set(hrtim_tu_number_t tu_number,\n                  uint16_t rise_ns,\n                  uint16_t fall_ns);\n\nvoid hrtim_duty_cycle_set(hrtim_tu_number_t tu_number, uint16_t value);\n\nvoid hrtim_phase_shift_set(hrtim_tu_number_t tu_number, uint16_t shift);\n\nvoid hrtim_dt_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_burst_mode_init(void);\n\nvoid hrtim_burst_set(int bm_cmp, int bm_per);\n\nvoid hrtim_burst_start(void);\n\nvoid hrtim_burst_stop(void);\n\nvoid hrtim_burst_dis(void);\n\nvoid hrtim_cnt_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cnt_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_rst_evt_en(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_rst_evt_dis(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_adc_trigger_set_postscaler(hrtim_tu_number_t tu_number,\n                                      uint32_t ps_ratio);\n\nvoid hrtim_adc_trigger_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_trigger_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_rollover_set(hrtim_tu_number_t tu_number,\n                            hrtim_adc_edgetrigger_t adc_rollover);\n\nhrtim_adc_edgetrigger_t hrtim_adc_rollover_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_PeriodicEvent_configure(hrtim_tu_t tu,\n                                   uint32_t repetition,\n                                   hrtim_callback_t callback);\n\nvoid hrtim_PeriodicEvent_en(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_dis(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_SetRep(hrtim_tu_t tu, uint32_t repetition);\n\nuint32_t hrtim_PeriodicEvent_GetRep(hrtim_tu_t tu);\n\nvoid DualDAC_init(hrtim_tu_number_t tu);\n\nvoid hrtim_pwm_mode_set(hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode);\n\nhrtim_pwm_mode_t hrtim_pwm_mode_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_trigger_set(hrtim_tu_number_t tu_number,\n                           hrtim_adc_trigger_t adc_trig);\n\nhrtim_adc_trigger_t hrtim_adc_trigger_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_eev_set(hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev);\n\nhrtim_external_trigger_t hrtim_eev_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_change_frequency(uint32_t new_frequency);\n\n\nvoid hrtim_output_hot_swap(hrtim_tu_number_t tu_number);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* HRTIM_H_ */\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/","title":"File hrtim_enum.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim__enum_8h/#classes","title":"Classes","text":"Type Name struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. struct switch_conv_conf_t Structure describing the switching convention of a given timing unit."},{"location":"powerAPI/hrtim__enum_8h/#public-types","title":"Public Types","text":"Type Name enum hrtim_adc_edgetrigger_t Edge Trigger behavior. enum hrtim_adc_event_t HRTIM ADC event update. enum hrtim_adc_source_t HRTIM ADC Event Number and its associated source. enum hrtim_adc_t HRTIM ADC trigger registers definition. enum hrtim_adc_trigger_t HRTIM ADC trigger. enum hrtim_burst_clk_t HRTIM burst mode clock setting. typedef void(* hrtim_callback_t callback function enum hrtim_cmp_t HRTIM comparators definition. enum hrtim_cnt_t HRTIM counting mode setting. enum hrtim_comp_usage_t comparator usage for a timing unit enum hrtim_external_trigger_t External eventcoming from comparator used for current mode. enum hrtim_gpio_clock_number_t HRTIM gpio clock units definition. enum hrtim_out_t timing unit output 1 or 2 enum hrtim_output_number_t enum hrtim_output_reset_t HRTIM output reset units definition. enum hrtim_output_set_t HRTIM output set units definition. enum hrtim_output_units_t HRTIM output units definition. enum hrtim_pwm_mode_t Special PWM mode for current mode. enum hrtim_reset_trig_t HRTIM reset trig source definitions. enum hrtim_switch_convention_t HRTIM TU switch convention. enum hrtim_tu_ON_OFF_t describe if a timing unit has been initialized enum hrtim_tu_number_t HRTIM timing units number definition. enum hrtim_tu_t HRTIM timing units definition."},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t HRTIM_CHANNELS   = <code>6</code>Number of HRTIM channels. const uint32_t HRTIM_MAX_PER_and_CMP_REG_VALUES   = <code>/* multi line expression */</code> const uint32_t HRTIM_MIN_PER_and_CMP_REG_VALUES   = <code>/* multi line expression */</code> const uint32_t HRTIM_PRESCALER_RESOLUTION_PS   = <code>/* multi line expression */</code>Resolution of the HRTIM prescaler in pico-seconds. * <code>values[8] = [184, 368, 735,1470, 2940, 5880,11760,23530]</code> __"},{"location":"powerAPI/hrtim__enum_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_edgetrigger_t","title":"enum hrtim_adc_edgetrigger_t","text":"<p>Edge Trigger behavior. <pre><code>enum hrtim_adc_edgetrigger_t {\n    EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n    EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n    EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n};\n</code></pre></p> <p><code>EdgeTrigger_up</code> = <code>LL_HRTIM_ROLLOVER_MODE_PER</code>,</p> <p><code>EdgeTrigger_down</code> = <code>LL_HRTIM_ROLLOVER_MODE_RST</code>,</p> <p><code>EdgeTrigger_Both</code> = <code>LL_HRTIM_ROLLOVER_MODE_BOTH</code> </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_event_t","title":"enum hrtim_adc_event_t","text":"<p>HRTIM ADC event update. <pre><code>enum hrtim_adc_event_t {\n    PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n    PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n    PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n    PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n    PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n    PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_source_t","title":"enum hrtim_adc_source_t","text":"<p>HRTIM ADC Event Number and its associated source. <pre><code>enum hrtim_adc_source_t {\n    TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n    TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n    TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n    TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n    TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n    TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n};\n</code></pre></p> <p>Warning:</p> <p>Please Prioritize cmp3, because cmp4 and cmp2 might be used for current mode, and cmp1 is used for duty cycle </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_t","title":"enum hrtim_adc_t","text":"<p>HRTIM ADC trigger registers definition. <pre><code>enum hrtim_adc_t {\n    ADC1R = 1,\n    ADC2R = 2,\n    ADC3R = 3,\n    ADC4R = 4\n};\n</code></pre></p> <ul> <li><code>ADC1R = 1</code>,</li> <li><code>ADC2R = 2</code>,</li> <li><code>ADC3R = 3</code>,</li> <li><code>ADC4R = 4</code> </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_trigger_t","title":"enum hrtim_adc_trigger_t","text":"<p>HRTIM ADC trigger. <pre><code>enum hrtim_adc_trigger_t {\n    ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n    ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n    ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n    ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n    ADCTRIG_5 = LL_HRTIM_ADCTRIG_5,\n    ADCTRIG_6 = LL_HRTIM_ADCTRIG_6,\n    ADCTRIG_7 = LL_HRTIM_ADCTRIG_7,\n    ADCTRIG_8 = LL_HRTIM_ADCTRIG_8,\n    ADCTRIG_9 = LL_HRTIM_ADCTRIG_9,\n    ADCTRIG_NONE\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_burst_clk_t","title":"enum hrtim_burst_clk_t","text":"<p>HRTIM burst mode clock setting. <pre><code>enum hrtim_burst_clk_t {\n    BURST_TIMA = LL_HRTIM_BM_CLKSRC_TIMER_A,\n    BURST_TIMB = LL_HRTIM_BM_CLKSRC_TIMER_B,\n    BURST_TIMC = LL_HRTIM_BM_CLKSRC_TIMER_C,\n    BURST_TIMD = LL_HRTIM_BM_CLKSRC_TIMER_D,\n    BURST_TIME = LL_HRTIM_BM_CLKSRC_TIMER_E,\n    BURST_TIMF = LL_HRTIM_BM_CLKSRC_TIMER_F\n};\n</code></pre></p> <ul> <li><code>BURST_TIMA</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_A</code></li> <li><code>BURST_TIMB</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_B</code></li> <li><code>BURST_TIMC</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_C</code></li> <li><code>BURST_TIMD</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_D</code></li> <li><code>BURST_TIME</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_E</code></li> <li><code>BURST_TIMF</code> = <code>LL_HRTIM_BM_CLKSRC_TIMER_F</code> </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#typedef-hrtim_callback_t","title":"typedef hrtim_callback_t","text":"<p>callback function <pre><code>typedef void(* hrtim_callback_t) ();\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cmp_t","title":"enum hrtim_cmp_t","text":"<p>HRTIM comparators definition. <pre><code>enum hrtim_cmp_t {\n    CMP1xR = 1,\n    CMP2xR = 2,\n    CMP3xR = 3,\n    CMP4xR = 4,\n    MCMP1R = 5,\n    MCMP2R = 6,\n    MCMP3R = 7,\n    MCMP4R = 8,\n    MCMPER = 10\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cnt_t","title":"enum hrtim_cnt_t","text":"<p>HRTIM counting mode setting. <pre><code>enum hrtim_cnt_t {\n    Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n    UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN\n};\n</code></pre></p> <ul> <li><code>Lft_aligned</code> = <code>LL_HRTIM_COUNTING_MODE_UP</code></li> <li><code>UpDwn</code> = <code>LL_HRTIM_COUNTING_MODE_UP_DOWN</code> = Center Aligned </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_comp_usage_t","title":"enum hrtim_comp_usage_t","text":"<p>comparator usage for a timing unit <pre><code>enum hrtim_comp_usage_t {\n    USED = true,\n    FREE = false\n};\n</code></pre></p> <ul> <li><code>USED=true</code></li> <li><code>FREE=false</code> </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_external_trigger_t","title":"enum hrtim_external_trigger_t","text":"<p>External eventcoming from comparator used for current mode. <pre><code>enum hrtim_external_trigger_t {\n    EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n    EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n    EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n    EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n    EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n    EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n    EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n    EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n    EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n};\n</code></pre></p> <ul> <li><code>EEV1</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_1</code></li> <li><code>EEV2</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_2</code></li> <li><code>EEV3</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_3</code></li> <li><code>EEV4</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_4</code></li> <li><code>EEV5</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_5</code></li> <li><code>EEV6</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_6</code></li> <li><code>EEV7</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_7</code></li> <li><code>EEV8</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_8</code></li> <li><code>EEV9</code> = <code>LL_HRTIM_OUTPUTRESET_EEV_9</code> </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_gpio_clock_number_t","title":"enum hrtim_gpio_clock_number_t","text":"<p>HRTIM gpio clock units definition. <pre><code>enum hrtim_gpio_clock_number_t {\n    CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n    CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n    CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_out_t","title":"enum hrtim_out_t","text":"<p>timing unit output 1 or 2 <pre><code>enum hrtim_out_t {\n    OUT1 = 1,\n    OUT2 = 2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_number_t","title":"enum hrtim_output_number_t","text":"<pre><code>enum hrtim_output_number_t {\n    TIMING_OUTPUT1,\n    TIMING_OUTPUT2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_reset_t","title":"enum hrtim_output_reset_t","text":"<p>HRTIM output reset units definition. <pre><code>enum hrtim_output_reset_t {\n    RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n    RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n    RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n    RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n    RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n    RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_set_t","title":"enum hrtim_output_set_t","text":"<p>HRTIM output set units definition. <pre><code>enum hrtim_output_set_t {\n    SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n    SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n    SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n    SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n    SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n    SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_units_t","title":"enum hrtim_output_units_t","text":"<p>HRTIM output units definition. <pre><code>enum hrtim_output_units_t {\n    PWMA1 = LL_HRTIM_OUTPUT_TA1,\n    PWMA2 = LL_HRTIM_OUTPUT_TA2,\n    PWMB1 = LL_HRTIM_OUTPUT_TB1,\n    PWMB2 = LL_HRTIM_OUTPUT_TB2,\n    PWMC1 = LL_HRTIM_OUTPUT_TC1,\n    PWMC2 = LL_HRTIM_OUTPUT_TC2,\n    PWMD1 = LL_HRTIM_OUTPUT_TD1,\n    PWMD2 = LL_HRTIM_OUTPUT_TD2,\n    PWME1 = LL_HRTIM_OUTPUT_TE1,\n    PWME2 = LL_HRTIM_OUTPUT_TE2,\n    PWMF1 = LL_HRTIM_OUTPUT_TF1,\n    PWMF2 = LL_HRTIM_OUTPUT_TF2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_pwm_mode_t","title":"enum hrtim_pwm_mode_t","text":"<p>Special PWM mode for current mode. <pre><code>enum hrtim_pwm_mode_t {\n    VOLTAGE_MODE = 0,\n    CURRENT_MODE = 1\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_reset_trig_t","title":"enum hrtim_reset_trig_t","text":"<p>HRTIM reset trig source definitions. <pre><code>enum hrtim_reset_trig_t {\n    MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n    MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n    MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n    MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n    MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n    PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_switch_convention_t","title":"enum hrtim_switch_convention_t","text":"<p>HRTIM TU switch convention. <pre><code>enum hrtim_switch_convention_t {\n    PWMx1 = 0,\n    PWMx2 = 1\n};\n</code></pre></p> <ul> <li><code>PWMx1=0</code>: high-side mosfet`,</li> <li><code>PWMx2=1</code>: low-side mosfet` </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_on_off_t","title":"enum hrtim_tu_ON_OFF_t","text":"<p>describe if a timing unit has been initialized <pre><code>enum hrtim_tu_ON_OFF_t {\n    UNIT_ON = true,\n    UNIT_OFF = false\n};\n</code></pre></p> <ul> <li><code>UNIT_ON=true</code></li> <li><code>UNIT_OFF=false</code> </li> </ul>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_number_t","title":"enum hrtim_tu_number_t","text":"<p>HRTIM timing units number definition. <pre><code>enum hrtim_tu_number_t {\n    PWMA = 0,\n    PWMB = 1,\n    PWMC = 2,\n    PWMD = 3,\n    PWME = 4,\n    PWMF = 5\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_t","title":"enum hrtim_tu_t","text":"<p>HRTIM timing units definition. <pre><code>enum hrtim_tu_t {\n    TIMA = LL_HRTIM_TIMER_A,\n    TIMB = LL_HRTIM_TIMER_B,\n    TIMC = LL_HRTIM_TIMER_C,\n    TIMD = LL_HRTIM_TIMER_D,\n    TIME = LL_HRTIM_TIMER_E,\n    TIMF = LL_HRTIM_TIMER_F,\n    MSTR = LL_HRTIM_TIMER_MASTER\n};\n</code></pre></p> <p>Enums </p>"},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_channels","title":"variable HRTIM_CHANNELS","text":"<p>Number of HRTIM channels. <pre><code>const uint8_t HRTIM_CHANNELS;\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_max_per_and_cmp_reg_values","title":"variable HRTIM_MAX_PER_and_CMP_REG_VALUES","text":"<pre><code>const uint32_t HRTIM_MAX_PER_and_CMP_REG_VALUES[8];\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_min_per_and_cmp_reg_values","title":"variable HRTIM_MIN_PER_and_CMP_REG_VALUES","text":"<pre><code>const uint32_t HRTIM_MIN_PER_and_CMP_REG_VALUES[8];\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_prescaler_resolution_ps","title":"variable HRTIM_PRESCALER_RESOLUTION_PS","text":"<p>Resolution of the HRTIM prescaler in pico-seconds. * <code>values[8] = [184, 368, 735,1470, 2940, 5880,11760,23530]</code> __ <pre><code>const uint32_t HRTIM_PRESCALER_RESOLUTION_PS[8];\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/hrtim__enum_8h_source/","title":"File hrtim_enum.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef HRTIM_ENUM_H_\n#define HRTIM_ENUM_H_\n\n#include &lt;stm32_ll_hrtim.h&gt;\n#include &lt;stm32g4xx_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    typedef void (*hrtim_callback_t)();\n\n    static const uint8_t HRTIM_CHANNELS = 6;\n\n    static const uint32_t HRTIM_PRESCALER_RESOLUTION_PS[8] = {184,\n                                                              368,\n                                                              735,\n                                                              1470,\n                                                              2940,\n                                                              5880,\n                                                              11760,\n                                                              23530};\n    /* RM0440 REV8 PAGE 842 */\n    static const uint32_t HRTIM_MIN_PER_and_CMP_REG_VALUES[8] = {0x0060,\n                                                                 0x0030,\n                                                                 0x0018,\n                                                                 0x000C,\n                                                                 0x0006,\n                                                                 0x0003,\n                                                                 0x0003,\n                                                                 0x0003};\n\n    static const uint32_t HRTIM_MAX_PER_and_CMP_REG_VALUES[8] = {0xFFDF,\n                                                                 0xFFEF,\n                                                                 0xFFF7,\n                                                                 0xFFFB,\n                                                                 0xFFFD,\n                                                                 0xFFFD,\n                                                                 0xFFFD,\n                                                                 0xFFFD};\n\n\n\n    typedef enum\n    {\n        TIMA = LL_HRTIM_TIMER_A,\n        TIMB = LL_HRTIM_TIMER_B,\n        TIMC = LL_HRTIM_TIMER_C,\n        TIMD = LL_HRTIM_TIMER_D,\n        TIME = LL_HRTIM_TIMER_E,\n        TIMF = LL_HRTIM_TIMER_F,\n        MSTR = LL_HRTIM_TIMER_MASTER\n    } hrtim_tu_t;\n\n    typedef enum\n    {\n        PWMA = 0,\n        PWMB = 1,\n        PWMC = 2,\n        PWMD = 3,\n        PWME = 4,\n        PWMF = 5\n    } hrtim_tu_number_t;\n\n    typedef enum\n    {\n        CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n        CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n        CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n    } hrtim_gpio_clock_number_t;\n\n    typedef enum\n    {\n        MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n        MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n        MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n        MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n        MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n        PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n    } hrtim_reset_trig_t;\n\n    typedef enum\n    {\n        VOLTAGE_MODE = 0,\n        CURRENT_MODE = 1\n    } hrtim_pwm_mode_t;\n\n    typedef enum\n    {\n        SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n        SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n        SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n        SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n        SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n        SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n    } hrtim_output_set_t;\n\n    typedef enum\n    {\n        RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n        RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n        RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n        RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n        RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n        RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n    } hrtim_output_reset_t;\n\n    typedef enum\n    {\n        PWMA1 = LL_HRTIM_OUTPUT_TA1,\n        PWMA2 = LL_HRTIM_OUTPUT_TA2,\n        PWMB1 = LL_HRTIM_OUTPUT_TB1,\n        PWMB2 = LL_HRTIM_OUTPUT_TB2,\n        PWMC1 = LL_HRTIM_OUTPUT_TC1,\n        PWMC2 = LL_HRTIM_OUTPUT_TC2,\n        PWMD1 = LL_HRTIM_OUTPUT_TD1,\n        PWMD2 = LL_HRTIM_OUTPUT_TD2,\n        PWME1 = LL_HRTIM_OUTPUT_TE1,\n        PWME2 = LL_HRTIM_OUTPUT_TE2,\n        PWMF1 = LL_HRTIM_OUTPUT_TF1,\n        PWMF2 = LL_HRTIM_OUTPUT_TF2\n    } hrtim_output_units_t;\n\n    typedef enum\n    {\n        TIMING_OUTPUT1,\n        TIMING_OUTPUT2,\n    }hrtim_output_number_t;\n\n    typedef enum\n    {\n        ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n        ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n        ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n        ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n        ADCTRIG_5 = LL_HRTIM_ADCTRIG_5,\n        ADCTRIG_6 = LL_HRTIM_ADCTRIG_6,\n        ADCTRIG_7 = LL_HRTIM_ADCTRIG_7,\n        ADCTRIG_8 = LL_HRTIM_ADCTRIG_8,\n        ADCTRIG_9 = LL_HRTIM_ADCTRIG_9,\n        ADCTRIG_NONE,\n    } hrtim_adc_trigger_t;\n\n    typedef enum\n    {\n        PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n        PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n        PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n        PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n        PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n        PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n    } hrtim_adc_event_t;\n\n    typedef enum\n    {\n        TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n        TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n        TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n        TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n        TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n        TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n    } hrtim_adc_source_t;\n\n    typedef enum\n    {\n        CMP1xR = 1,\n        CMP2xR = 2,\n        CMP3xR = 3,\n        CMP4xR = 4,\n        MCMP1R = 5,\n        MCMP2R = 6,\n        MCMP3R = 7,\n        MCMP4R = 8,\n        MCMPER = 10\n    } hrtim_cmp_t;\n\n    typedef enum\n    {\n        OUT1 = 1,\n        OUT2 = 2\n    } hrtim_out_t;\n\n    typedef enum\n    {\n        PWMx1 = 0,\n        PWMx2 = 1\n    } hrtim_switch_convention_t;\n\n    typedef enum\n    {\n        USED = true,\n        FREE = false\n    } hrtim_comp_usage_t;\n\n    typedef enum\n    {\n        UNIT_ON = true,\n        UNIT_OFF = false\n    } hrtim_tu_ON_OFF_t;\n\n    typedef enum\n    {\n        ADC1R = 1,\n        ADC2R = 2,\n        ADC3R = 3,\n        ADC4R = 4\n    } hrtim_adc_t;\n\n    typedef enum\n    {\n        EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n        EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n        EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n    } hrtim_adc_edgetrigger_t;\n\n    typedef enum\n    {\n        EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n        EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n        EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n        EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n        EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n        EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n        EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n        EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n        EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n    } hrtim_external_trigger_t;\n\n    typedef enum\n    {\n        Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n        UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN /* also known as center aligned */\n\n    } hrtim_cnt_t;\n\n    typedef enum\n    {\n        BURST_TIMA = LL_HRTIM_BM_CLKSRC_TIMER_A,\n        BURST_TIMB = LL_HRTIM_BM_CLKSRC_TIMER_B,\n        BURST_TIMC = LL_HRTIM_BM_CLKSRC_TIMER_C,\n        BURST_TIMD = LL_HRTIM_BM_CLKSRC_TIMER_D,\n        BURST_TIME = LL_HRTIM_BM_CLKSRC_TIMER_E,\n        BURST_TIMF = LL_HRTIM_BM_CLKSRC_TIMER_F\n    } hrtim_burst_clk_t;\n\n\n    typedef struct\n    {\n        hrtim_tu_t pwm_tu;             /* Timing Unit associated with the PWM */\n        uint16_t rise_dead_time;       /* Rising Edge Dead time */\n        uint16_t fall_dead_time;       /* Falling Edge Dead time */\n        uint16_t duty_cycle;           /* Current value of its duty cycle */\n        uint16_t period;               /* Period used by the unit */\n        uint16_t max_period;           /* Absolute Max Period used by the unit */\n        uint16_t min_period;           /* Absolute Min Period used by the unit */\n        uint32_t frequency;            /* Frequency used by the unit */\n        uint32_t max_frequency;        /* Max frequency used by the unit */\n        uint32_t min_frequency;        /* Min frequency used by the unit */\n        hrtim_cnt_t modulation;        /* Type of modulation used for this unit */\n        hrtim_tu_ON_OFF_t unit_on;     /* State of the time unit (ON/OFF) */\n        uint8_t ckpsc;                 /* Clock pre-scaler of the timing unit */\n        uint32_t resolution;           /* Resolution of the timing unit */\n        uint16_t duty_min;             /* Absolute Minimum duty cycle for the timing unit */\n        uint16_t duty_max;             /* Absolute Maximum duty cycle for the timing unit */\n        uint16_t duty_min_user;        /* Minimum duty cycle set by the user */\n        uint16_t duty_max_user;        /* Maximum duty cycle set by the user */\n        float32_t duty_min_user_float; /* Minimum duty cycle set by the user in float */\n        float32_t duty_max_user_float; /* Maximum duty cycle set by the user in float */\n        uint8_t duty_swap;             /* Detects if the duty has been swapped */\n        hrtim_pwm_mode_t pwm_mode;     /* voltage mode or current mode */\n        hrtim_external_trigger_t external_trigger;  /* event for current mode */\n        hrtim_burst_clk_t burst_clk;   /* clock source for burst mode generator*/\n    } pwm_conf_t;\n\n    typedef struct\n    {\n        uint16_t value;            /* Value of the phase shift */\n        hrtim_tu_t compare_tu;     /* Compare timing unit used to make the phase shift */\n        hrtim_reset_trig_t reset_trig; /* Pulse width */\n    } phase_shift_conf_t;\n\n    typedef struct\n    {\n        GPIO_TypeDef *unit;                    /* The GPIO structure to which the TU pins belong */\n        LL_GPIO_InitTypeDef switch_H;          /* Details of the high-side switch gpio */\n        hrtim_output_units_t OUT_H;            /* High-side switch hrtim output unit */\n        LL_GPIO_InitTypeDef switch_L;          /* Details of the low-side switch */\n        hrtim_output_units_t OUT_L;            /* Low-side switch hrtim output unit */\n        hrtim_gpio_clock_number_t tu_gpio_CLK; /* Gpio clock unit */\n    } gpio_conf_t;\n\n    typedef struct\n    {\n        /* High-side or Low-side switch convention */\n        hrtim_switch_convention_t convention;\n        /* Set event used to the High-side switch on the high-side convention */\n        uint32_t set_H;\n        /* Set event used to the Low-side switch on the high-side convention */\n        uint32_t reset_H;\n        /* Set event used to the High-side switch on the high-side convention */\n        uint32_t set_L;\n        /* Set event used to the Low-side switch on the high-side convention */\n        uint32_t reset_L;\n    } switch_conv_conf_t;\n\n    typedef struct\n    {\n        hrtim_adc_event_t adc_event;       /* ADC event linked to this PWM time unit */\n        hrtim_adc_source_t adc_source;     /* ADC time unit linked to this event */\n        hrtim_adc_trigger_t adc_trigger;   /* ADC trigger between source and event */\n        hrtim_adc_edgetrigger_t adc_rollover; /* ADC rollover only relevant in center aligned */\n    } adc_hrtim_conf_t;\n\n    typedef struct\n    {\n        hrtim_comp_usage_t cmp1; /* Sets if the COMP 1 of the tu is being used */\n        uint16_t cmp1_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp2; /* Sets if the COMP 2 of the tu is being used */\n        uint16_t cmp2_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp3; /* Sets if the COMP 3 of the tu is being used */\n        uint16_t cmp3_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp4; /* Sets if the COMP 4 of the tu is being used */\n        uint16_t cmp4_value;     /* Sets if the COMP 1 of the tu is being used */\n    } comp_usage_conf_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* COMPARATOR_DRIVER_H_ */\n</code></pre>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver</p>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/</code></p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/#files","title":"Files","text":"Type Name file ngnd.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/ngnd_8h/","title":"File ngnd.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ngnd_8h/#public-functions","title":"Public Functions","text":"Type Name void ngnd_set (const struct device * dev, int value) Set the state of the NGND (Neutral Ground) switch."},{"location":"powerAPI/ngnd_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/ngnd_8h/#function-ngnd_set","title":"function ngnd_set","text":"<p>Set the state of the NGND (Neutral Ground) switch. <pre><code>void ngnd_set (\n    const struct device * dev,\n    int value\n) \n</code></pre></p> <p>This function controls the activation state of the NGND hardware line.</p> <p>Passing a non-zero value activates (connects) NGND to the GND of the O2 board.</p> <p>Zero disconnects the NGND from the GND.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to the NGND device structure. </li> <li><code>value</code> Desired state: <code>1</code> to activate, <code>0</code> to deactivate. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/ngnd.h</code></p>"},{"location":"powerAPI/ngnd_8h_source/","title":"File ngnd.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2020-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n\n\n#ifndef NGND_H_\n#define NGND_H_\n\n\n/* Zephyr */\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#define NGND_DEVICE DT_NODELABEL(ngnd)\n\n\nvoid ngnd_set(const struct device* dev, int value);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NGND_H_ */\n</code></pre>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/","title":"Dir docs/core/zephyr/modules/owntech_safety_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api</p>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/</code></p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr</p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/</code></p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/#files","title":"Files","text":"Type Name file SafetyAPI.cpp file SafetyAPI.h file safety_internal.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp/","title":"File SafetyAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name SafetyAPI safety"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8cpp/#variable-safety","title":"variable safety","text":"<pre><code>SafetyAPI safety;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.cpp</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp_source/","title":"File SafetyAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date 2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n *\n */\n\n#include \"SafetyAPI.h\"\n#include \"../src/safety_shield.h\"\n#include \"../src/safety_setting.h\"\n\nSafetyAPI safety;\n\nvoid SafetyAPI::initShield()\n{\n    safety_init_shield(true);\n}\n\nvoid SafetyAPI::initShield(sensor_t* sensors_watch,\n                           uint8_t sensors_watch_number)\n{\n    safety_init_shield(false);\n    safety_set_sensor_watch(sensors_watch, sensors_watch_number);\n}\n\nint8_t SafetyAPI::setChannelWatch(sensor_t* sensors_watch,\n                                  uint8_t sensors_watch_number)\n{\n    int8_t status =  safety_set_sensor_watch(sensors_watch, sensors_watch_number);\n    return status;\n}\n\nint8_t SafetyAPI::unsetChannelWatch(sensor_t* sensors_watch,\n                                    uint8_t sensors_watch_number)\n{\n    int8_t status =  safety_unset_sensor_watch(sensors_watch,\n                                               sensors_watch_number);\n    return status;\n}\n\nbool SafetyAPI::getChannelWatch(sensor_t  sensors_watch)\n{\n    bool Is_watched = safety_get_sensor_watch(sensors_watch);\n    return Is_watched;\n}\n\nvoid SafetyAPI::setChannelReaction(safety_reaction_t sensors_reaction)\n{\n    safety_set_sensor_reaction(sensors_reaction);\n\n}\n\nsafety_reaction_t SafetyAPI::getChannelReaction()\n{\n    safety_reaction_t sensors_reaction = safety_get_sensor_reaction();\n    return sensors_reaction;\n}\n\nint8_t SafetyAPI::setChannelThresholdMax(sensor_t *sensors_threshold,\n                                         float32_t *threshold_max,\n                                         uint8_t sensors_threshold_number)\n{\n    uint8_t ret =  safety_set_sensor_threshold_max(sensors_threshold,\n                                                   threshold_max,\n                                                   sensors_threshold_number);\n    return ret;\n}\n\nint8_t SafetyAPI::setChannelThresholdMin(sensor_t *sensors_threshold,\n                                         float32_t *threshold_min,\n                                         uint8_t sensors_threshold_number)\n{\n    uint8_t ret =  safety_set_sensor_threshold_min(sensors_threshold,\n                                                   threshold_min,\n                                                   sensors_threshold_number);\n    return ret;\n}\n\nfloat32_t SafetyAPI::getChannelThresholdMax(sensor_t sensors_threshold)\n{\n    float32_t threshold = safety_get_sensor_threshold_max(sensors_threshold);\n    return threshold;\n}\n\nfloat32_t SafetyAPI::getChannelThresholdMin(sensor_t sensors_threshold)\n{\n    float32_t threshold = safety_get_sensor_threshold_min(sensors_threshold);\n    return threshold;\n}\n\nbool SafetyAPI::getChannelError(sensor_t sensors_error)\n{\n    bool error_status = safety_get_sensor_error(sensors_error);\n    return error_status;\n}\n\nvoid SafetyAPI::enableSafetyApi()\n{\n    safety_enable_task();\n}\n\nvoid SafetyAPI::disableSafetyApi()\n{\n    safety_disable_task();\n}\n\nint8_t SafetyAPI::storeThreshold(sensor_t sensor_threshold_store)\n{\n    uint8_t ret = safety_store_threshold_in_nvs(sensor_threshold_store);\n    return ret;\n}\nint8_t SafetyAPI::retrieveThreshold(sensor_t sensor_threshold_retrieve)\n{\n    uint8_t ret = safety_retrieve_threshold_in_nvs(sensor_threshold_retrieve);\n    return ret;\n}\n</code></pre>"},{"location":"powerAPI/SafetyAPI_8h/","title":"File SafetyAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8h/#classes","title":"Classes","text":"Type Name class SafetyAPI"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name SafetyAPI safety"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8h/#variable-safety","title":"variable safety","text":"<pre><code>SafetyAPI safety;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/SafetyAPI_8h_source/","title":"File SafetyAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date 2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n *\n * @brief Public class to use safety function\n *\n */\n\n#ifndef SAFETYAPI_H_\n#define SAFETYAPI_H_\n\n#include \"arm_math.h\"\n#include \"ShieldAPI.h\"\n#include \"../src/safety_enum.h\"\n\n\nclass SafetyAPI{\n\n    public:\n\n    void initShield();\n\n    void initShield(sensor_t* sensors_watch, uint8_t sensors_watch_number);\n\n    int8_t setChannelWatch(sensor_t* sensors_watch,\n                           uint8_t sensors_watch_number);\n\n    int8_t unsetChannelWatch(sensor_t* sensors_watch,\n                             uint8_t sensors_watch_number);\n\n    bool getChannelWatch(sensor_t  sensors_watch);\n\n    void setChannelReaction(safety_reaction_t sensors_reaction);\n\n    safety_reaction_t getChannelReaction();\n\n    int8_t setChannelThresholdMax(sensor_t *sensors_threshold,\n                                  float32_t *threshold_max,\n                                  uint8_t sensors_threshold_number);\n\n    int8_t setChannelThresholdMin(sensor_t *sensors_threshold,\n                                  float32_t *threshold_min,\n                                  uint8_t sensors_threshold_number);\n\n    float32_t getChannelThresholdMax(sensor_t sensors_threshold);\n\n    float32_t getChannelThresholdMin(sensor_t sensors_threshold);\n\n    bool getChannelError(sensor_t sensors_error);\n\n\n    void enableSafetyApi();\n\n    void disableSafetyApi();\n    int8_t storeThreshold(sensor_t sensor_threshold_store);\n    int8_t retrieveThreshold(sensor_t sensor_threshold_retrieve);\n\n\n};\n\nextern SafetyAPI safety;\n\n#endif /* SAFETYAPI_H_ */\n</code></pre>"},{"location":"powerAPI/safety__internal_8h/","title":"File safety_internal.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/safety__internal_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t safety_task () This function first watches the measure from the monitored channels, and then compares it with the threshold values max/min to detect faults."},{"location":"powerAPI/safety__internal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/safety__internal_8h/#function-safety_task","title":"function safety_task","text":"<p>This function first watches the measure from the monitored channels, and then compares it with the threshold values max/min to detect faults. <pre><code>int8_t safety_task () \n</code></pre></p> <p>If an error was detected, the switches will either in open-circuit mode or in short-circuit mode.</p> <p>Returns:</p> <p><code>0</code> if no error was detected, <code>-1</code> else </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/safety_internal.h</code></p>"},{"location":"powerAPI/safety__internal_8h_source/","title":"File safety_internal.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date 2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n *\n * @brief This header contains the function safety_task which will be used\n *        by the uninterruptible task.\n *\n * @warning Only for internal use.\n */\n\n#ifndef SAFETY_INTERNAL_H_\n#define SAFETY_INTERNAL_H_\n\n#include \"arm_math.h\"\n\nint8_t safety_task();\n\n#endif /* SAFETY_INTERNAL_H_ */\n</code></pre>"},{"location":"powerAPI/dir_9a89dd71eabb2209bdecc753bd3dc4ac/","title":"Dir docs/core/zephyr/modules/owntech_shield_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api</p>"},{"location":"powerAPI/dir_9a89dd71eabb2209bdecc753bd3dc4ac/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/</code></p>"},{"location":"powerAPI/dir_b3d0c58b5ddf7b1e26f8d905ca8e43b0/","title":"Dir docs/core/zephyr/modules/owntech_shield_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr</p>"},{"location":"powerAPI/dir_b3d0c58b5ddf7b1e26f8d905ca8e43b0/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/</code></p>"},{"location":"powerAPI/dir_1545707aba7ea3e5dcde32c7d0a91b3a/","title":"Dir docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_1545707aba7ea3e5dcde32c7d0a91b3a/#files","title":"Files","text":"Type Name file ShieldAPI.cpp file ShieldAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/ShieldAPI_8cpp/","title":"File ShieldAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ShieldAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name ShieldAPI shield"},{"location":"powerAPI/ShieldAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/ShieldAPI_8cpp/#variable-shield","title":"variable shield","text":"<pre><code>ShieldAPI shield;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.cpp</code></p>"},{"location":"powerAPI/ShieldAPI_8cpp_source/","title":"File ShieldAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n */\n\n\n/* Current class header */\n#include \"ShieldAPI.h\"\n\n\nShieldAPI shield;\n\nPowerAPI ShieldAPI::power;\nSensorsAPI ShieldAPI::sensors;\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\nNgndHAL ShieldAPI::ngnd;\n#endif\n</code></pre>"},{"location":"powerAPI/ShieldAPI_8h/","title":"File ShieldAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ShieldAPI_8h/#classes","title":"Classes","text":"Type Name class ShieldAPI"},{"location":"powerAPI/ShieldAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name ShieldAPI shield"},{"location":"powerAPI/ShieldAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/ShieldAPI_8h/#variable-shield","title":"variable shield","text":"<pre><code>ShieldAPI shield;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.h</code></p>"},{"location":"powerAPI/ShieldAPI_8h_source/","title":"File ShieldAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n */\n\n\n#ifndef SHIELDAPI_H_\n#define SHIELDAPI_H_\n\n\n#include \"../src/Sensors.h\"\n#include \"../src/Power.h\"\n\n\n/* Static class definition */\n\nclass ShieldAPI\n{\npublic:\n\n    static SensorsAPI sensors;\n\n    static PowerAPI power;\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\n    static NgndHAL ngnd;\n#endif\n\n};\n\n\nextern ShieldAPI shield;\n\n\n#endif /* SHIELDAPI_H_ */\n</code></pre>"},{"location":"powerAPI/dir_cc8f80e4cf83a61a7635b2e9633862a2/","title":"Dir docs/core/zephyr/modules/owntech_shield_api/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_cc8f80e4cf83a61a7635b2e9633862a2/#files","title":"Files","text":"Type Name file NgndHAL.cpp file NgndHAL.h file Power.cpp file Power.h file Sensors.cpp file Sensors.h file power_init.cpp file power_init.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/</code></p>"},{"location":"powerAPI/NgndHAL_8cpp/","title":"File NgndHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; NgndHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/NgndHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * ngnd_switch   = <code>DEVICE\\_DT\\_GET(NGND\\_DEVICE)</code>"},{"location":"powerAPI/NgndHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/NgndHAL_8cpp/#variable-ngnd_switch","title":"variable ngnd_switch","text":"<pre><code>const struct device* ngnd_switch;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/NgndHAL.cpp</code></p>"},{"location":"powerAPI/NgndHAL_8cpp_source/","title":"File NgndHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; NgndHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* Owntech driver */\n#include \"ngnd.h\"\n\n/* Current file header */\n#include \"NgndHAL.h\"\n\n\nstatic const struct device* ngnd_switch = DEVICE_DT_GET(NGND_DEVICE);\n\n\nvoid NgndHAL::turnOn()\n{\n    if (device_is_ready(ngnd_switch) == true)\n    {\n        ngnd_set(ngnd_switch, 1);\n    }\n}\n\nvoid NgndHAL::turnOff()\n{\n    if (device_is_ready(ngnd_switch) == true)\n    {\n        ngnd_set(ngnd_switch, 0);\n    }\n}\n</code></pre>"},{"location":"powerAPI/NgndHAL_8h/","title":"File NgndHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; NgndHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/NgndHAL_8h/#classes","title":"Classes","text":"Type Name class NgndHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/NgndHAL.h</code></p>"},{"location":"powerAPI/NgndHAL_8h_source/","title":"File NgndHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; NgndHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n\n\n#ifndef NGNDHAL_H_\n#define NGNDHAL_H_\n\n\nclass NgndHAL\n{\npublic:\n\n    void turnOn();\n\n    void turnOff();\n\nprivate:\n\n};\n\n\n\n#endif /* NGND_H_ */\n</code></pre>"},{"location":"powerAPI/Power_8cpp/","title":"File Power.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Power.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Power.cpp</code></p>"},{"location":"powerAPI/Power_8cpp_source/","title":"File Power.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Power.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n#include \"power_init.h\"\n#include \"Power.h\"\n#include \"SpinAPI.h\"\n\n\nhrtim_tu_number_t PowerAPI::spinNumberToTu(uint16_t spin_number)\n{\n    if(spin_number == 12 || spin_number == 14)\n    {\n        return PWMA;\n    }\n    else if(spin_number == 15)\n    {\n        return PWMB;\n    }\n    else if(spin_number == 2 || spin_number == 4)\n    {\n        return PWMC;\n    }\n    else if(spin_number == 5 || spin_number == 6)\n    {\n        return PWMD;\n    }\n    else if(spin_number == 10 || spin_number == 11)\n    {\n        return PWME;\n    }\n    else if(spin_number == 7 || spin_number == 9)\n    {\n        return PWMF;\n    }\n    else\n    {\n        return PWMA;\n    }\n}\n\nvoid PowerAPI::initMode(leg_t leg,\n                        hrtim_switch_convention_t leg_convention,\n                        hrtim_pwm_mode_t leg_mode)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n    uint16_t period = 0;\n\n   /*  If ALL is selected, loop through all legs */\n    if (leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        /* Configure PWM frequency */\n        spin.pwm.initVariableFrequency(timer_frequency, timer_min_frequency);\n\n        /* Set modulation */\n        spin.pwm.setModulation(spinNumberToTu(dt_pwm_pin[i]),\n                               dt_modulation[i]);\n\n        /* Configure ADC rollover in center aligned mode */\n        spin.pwm.setAdcEdgeTrigger(spinNumberToTu(dt_pwm_pin[i]),\n                                   dt_edge_trigger[i]);\n\n        if (leg_mode == CURRENT_MODE)\n        {\n            if (dt_current_pin[i] == CM_DAC3)\n            {\n                spin.pwm.setEev(spinNumberToTu(dt_pwm_pin[i]), EEV4);\n            }\n            else if (dt_current_pin[i] == CM_DAC1)\n            {\n                spin.pwm.setEev(spinNumberToTu(dt_pwm_pin[i]), EEV5);\n            }\n\n            /* Configure current mode */\n            spin.pwm.setMode(spinNumberToTu(dt_pwm_pin[i]), CURRENT_MODE);\n        }\n\n        /* Choose which output of the timer unit to control with duty cycle */\n        spin.pwm.setSwitchConvention(spinNumberToTu(dt_pwm_pin[i]),\n                                     leg_convention);\n\n        /* Initialize leg unit */\n        spin.pwm.initUnit(spinNumberToTu(dt_pwm_pin[i]));\n\n        /* Configure PWM initial phase shift */\n        spin.pwm.setPhaseShift(spinNumberToTu(dt_pwm_pin[i]),\n                               dt_phase_shift[i]);\n\n        /* Configure PWM dead time */\n        spin.pwm.setDeadTime(spinNumberToTu(dt_pwm_pin[i]),\n                             dt_rising_deadtime[i],\n                             dt_falling_deadtime[i]);\n\n        if (dt_adc[i] != UNKNOWN_ADC)\n        {\n            spin.pwm.setAdcDecimation(spinNumberToTu(dt_pwm_pin[i]),\n                                      dt_adc_decim[i]);\n\n            spin.pwm.setAdcTrigger(spinNumberToTu(dt_pwm_pin[i]),\n                                   dt_adc[i]);\n\n            spin.pwm.enableAdcTrigger(spinNumberToTu(dt_pwm_pin[i]));\n\n            spin.data.configureTriggerSource(dt_adc[i], TRIG_PWM);\n        }\n\n        if (leg_mode == CURRENT_MODE)\n        {\n            if (dt_current_pin[i] == CM_DAC1)\n            {\n                spin.dac.currentModeInit(\n                    1,\n                    tu_channel[spinNumberToTu(dt_pwm_pin[i])]-&gt;pwm_conf.pwm_tu\n                );\n\n                spin.comp.initialize(3);\n            }\n            else if (dt_current_pin[i] == CM_DAC3)\n            {\n                spin.dac.currentModeInit(\n                    3,\n                    tu_channel[spinNumberToTu(dt_pwm_pin[i])]-&gt;pwm_conf.pwm_tu\n                );\n\n                spin.comp.initialize(1);\n            }\n        }\n\n        if (dt_pin_driver[i] != 0)\n        {\n            spin.gpio.configurePin(dt_pin_driver[i], OUTPUT);\n        }\n        if (dt_pin_capacitor[i] != 0)\n        {\n            spin.gpio.configurePin(dt_pin_capacitor[i], OUTPUT);\n        }\n    }\n}\n\n\nvoid PowerAPI::setDutyCycle(leg_t leg, float32_t duty_value)\n{\n    uint16_t period;\n    uint16_t value;\n\n    period = tu_channel[spinNumberToTu(dt_pwm_pin[leg])]-&gt;pwm_conf.period;\n    value = duty_value * period;\n\n    setDutyCycleRaw(leg, value);\n}\n\nvoid PowerAPI::setDutyCycleRaw(leg_t leg, uint16_t duty_value)\n{\n    uint16_t period;\n    uint8_t swap_state;\n    hrtim_tu_number_t leg_tu;\n    uint16_t duty_cycle_max_raw;\n    uint16_t duty_cycle_min_raw;\n\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;    \n\n    /*  If ALL is selected, loop through all legs */\n    if (leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        startIndex = leg; /* Treat `leg` as the specific leg index */\n        endIndex = leg + 1; /* Only iterate for this specific leg */\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        leg_tu = spinNumberToTu(dt_pwm_pin[i]);\n\n        duty_cycle_max_raw = tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user;\n        duty_cycle_min_raw = tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user;\n\n        /* Clamp the duty cycle to be within the range min to max */\n        if (duty_value &gt; duty_cycle_max_raw)\n        {\n            duty_value = duty_cycle_max_raw;\n        }\n        else if (duty_value &lt; duty_cycle_min_raw)\n        {\n            duty_value = duty_cycle_min_raw;\n        }\n\n        period = tu_channel[leg_tu]-&gt;pwm_conf.period;\n        swap_state = tu_channel[leg_tu]-&gt;pwm_conf.duty_swap;\n\n        /* Implements a logic that allows for a duty cycle of 100% */\n        if (duty_value &gt;= period-3){\n            duty_value = 0;\n            hrtim_duty_cycle_set(leg_tu, duty_value);\n\n            if(swap_state == false){ \n                hrtim_output_hot_swap(leg_tu);\n            }        \n        }\n        else\n        {    \n            if(swap_state == true) {\n                hrtim_duty_cycle_set(leg_tu, duty_value);\n                hrtim_output_hot_swap(leg_tu);\n            }else{\n                hrtim_duty_cycle_set(leg_tu, duty_value);\n            }\n        }\n    }\n}\n\nvoid PowerAPI::start(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /* If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterates for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t leg_index = startIndex; leg_index &lt; endIndex; leg_index++)\n    {\n        if(dt_pin_driver[leg_index] != 0) {\n            spin.gpio.setPin(dt_pin_driver[leg_index]);\n        }\n\n        if (!dt_output1_inactive[leg_index])\n        {\n            spin.pwm.startSingleOutput(spinNumberToTu(dt_pwm_pin[leg_index]),\n                                       TIMING_OUTPUT1);\n        }\n        if (!dt_output2_inactive[leg_index])\n        {\n            spin.pwm.startSingleOutput(spinNumberToTu(dt_pwm_pin[leg_index]),\n                                       TIMING_OUTPUT2);\n        }\n    }\n}\n\nvoid PowerAPI::stop(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        /* Stop PWM */\n        spin.pwm.stopDualOutput(spinNumberToTu(dt_pwm_pin[i]));\n\n        if(dt_pin_driver[i] != 0)\n        {\n            spin.gpio.resetPin(dt_pin_driver[i]);\n        }\n    }\n}\n\n#ifdef CONFIG_SHIELD_TWIST\n\nvoid PowerAPI::connectCapacitor(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if(dt_pin_capacitor[i] != 0)\n        {\n            spin.gpio.resetPin(dt_pin_capacitor[i]);\n        }\n    }\n}\n\nvoid PowerAPI::disconnectCapacitor(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if(dt_pin_capacitor[i] != 0)\n        {\n            spin.gpio.setPin(dt_pin_capacitor[i]);\n        }\n    }\n}\n\n#endif\n\n#ifndef CONFIG_SHIELD_O2\n\nvoid PowerAPI::connectDriver(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        endIndex = dt_leg_count; /* retrieves the total number of legs */\n    }\n    else\n    {\n        startIndex = leg; /* Treat `leg` as the specific leg index */\n        endIndex = leg + 1; /* Only iterate for this specific leg */\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if(dt_pin_driver[i] != 0) {\n            spin.gpio.setPin(dt_pin_driver[i]);\n        }\n    }\n}\n\nvoid PowerAPI::disconnectDriver(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if(dt_pin_driver[i] != 0) {\n            spin.gpio.setPin(dt_pin_driver[i]);\n        }\n    }\n}\n\n#endif\n\nvoid PowerAPI::setSlopeCompensation(leg_t leg,\n                                    float32_t set_voltage,\n                                    float32_t reset_voltage)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        switch (dt_current_pin[i])\n        {\n        case CM_DAC1:\n            spin.dac.slopeCompensation(1, set_voltage, reset_voltage);\n            break;\n        case CM_DAC3:\n            spin.dac.slopeCompensation(3, set_voltage, reset_voltage);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PowerAPI::setTriggerValue(leg_t leg, float32_t trigger_value)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /* Clamp the trigger value within the acceptable range */\n    if (trigger_value &gt; 0.95)\n    {\n        trigger_value = 0.95;\n    }\n    else if (trigger_value &lt; 0.05)\n    {\n        trigger_value = 0.05;\n    }\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        spin.pwm.setAdcTriggerInstant(spinNumberToTu(dt_pwm_pin[i]),\n                                      trigger_value);\n    }\n}\n\nvoid PowerAPI::setPhaseShift(leg_t leg, int16_t phase_shift)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        spin.pwm.setPhaseShift(spinNumberToTu(dt_pwm_pin[i]), phase_shift);\n    }\n}\n\nvoid PowerAPI::setDeadTime(leg_t leg,\n                           uint16_t ns_rising_dt,\n                           uint16_t ns_falling_dt)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        spin.pwm.setDeadTime(spinNumberToTu(dt_pwm_pin[i]),\n                             ns_rising_dt, ns_falling_dt);\n    }\n}\n\n\nvoid PowerAPI::setDutyCycleMin(leg_t leg, float32_t duty_cycle){\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n    hrtim_tu_number_t leg_tu;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if (duty_cycle &lt;= 1.0 &amp;&amp; duty_cycle &gt;=0.0){\n            leg_tu = spinNumberToTu(dt_pwm_pin[i]);\n            uint16_t period = tu_channel[leg_tu]-&gt;pwm_conf.period;\n            tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user = duty_cycle * period;\n            tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user_float = duty_cycle;\n        }\n    }\n}\n\nvoid PowerAPI::setDutyCycleMax(leg_t leg, float32_t duty_cycle){\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n    hrtim_tu_number_t leg_tu;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if (duty_cycle &lt;= 1.0 &amp;&amp; duty_cycle &gt;=0.0){\n            leg_tu = spinNumberToTu(dt_pwm_pin[i]);\n            uint16_t period = tu_channel[leg_tu]-&gt;pwm_conf.period;\n            tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user = duty_cycle * period;\n            tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user_float = duty_cycle;\n        }\n    }\n}\n\nvoid PowerAPI::setDutyCycleMinRaw(leg_t leg, uint16_t duty_cycle){\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n    hrtim_tu_number_t leg_tu;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if (duty_cycle &lt;= 0){\n            duty_cycle = 0;\n        }\n        leg_tu = spinNumberToTu(dt_pwm_pin[i]);\n        tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user = duty_cycle;\n        uint16_t period = tu_channel[leg_tu]-&gt;pwm_conf.period;\n        tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user_float = \n                                            (float32_t)(duty_cycle/period);\n\n    }\n\n}\n\nvoid PowerAPI::setDutyCycleMaxRaw(leg_t leg,uint16_t duty_cycle){\n\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n    hrtim_tu_number_t leg_tu;\n    uint16_t period;\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        leg_tu = spinNumberToTu(dt_pwm_pin[i]);\n        period = tu_channel[leg_tu]-&gt;pwm_conf.period;\n        if (duty_cycle &gt;= period){\n            duty_cycle = period; \n        }    \n        tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user = duty_cycle;\n        tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user_float = \n                                                (float32_t)(duty_cycle/period);\n    }\n}\n\nfloat32_t PowerAPI::getDutyCycleMax(leg_t leg){\n    hrtim_tu_number_t leg_tu = spinNumberToTu(dt_pwm_pin[leg]);\n    return  tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user_float; \n}\n\nuint16_t PowerAPI::getDutyCycleMaxRaw(leg_t leg){\n    hrtim_tu_number_t leg_tu = spinNumberToTu(dt_pwm_pin[leg]);\n    return  tu_channel[leg_tu]-&gt;pwm_conf.duty_max_user; \n}\n\nfloat32_t PowerAPI::getDutyCycleMin(leg_t leg){\n    hrtim_tu_number_t leg_tu = spinNumberToTu(dt_pwm_pin[leg]);\n    return  tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user_float; \n}\n\nuint16_t PowerAPI::getDutyCycleMinRaw(leg_t leg){\n    hrtim_tu_number_t leg_tu = spinNumberToTu(dt_pwm_pin[leg]);\n    return  tu_channel[leg_tu]-&gt;pwm_conf.duty_min_user; \n}\n\nuint16_t PowerAPI::getPeriod(leg_t leg){\n    hrtim_tu_number_t leg_tu = spinNumberToTu(dt_pwm_pin[leg]);\n    return  tu_channel[leg_tu]-&gt;pwm_conf.period; \n}\n\n\nvoid PowerAPI::setAdcDecim(leg_t leg, uint16_t adc_decim)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n         /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        spin.pwm.setAdcDecimation(spinNumberToTu(dt_pwm_pin[i]), adc_decim);\n    }\n}\n\n\nvoid PowerAPI::initBuck(leg_t leg, hrtim_pwm_mode_t leg_mode)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if (!dt_pwm_x1_high[i])\n        {\n            /* PWMx1 is connected in hardware to switch low */\n            initMode(static_cast&lt;leg_t&gt;(i), PWMx2, leg_mode);\n        }\n        else\n        {\n            /* PWMx1 is connected in hardware to switch high */\n            initMode(static_cast&lt;leg_t&gt;(i), PWMx1, leg_mode);\n        }\n    }\n}\n\nvoid PowerAPI::initBoost(leg_t leg)\n{\n    int8_t startIndex = 0;\n    int8_t endIndex = 0;\n\n    /*  If ALL is selected, loop through all legs */\n    if(leg == ALL)\n    {\n        startIndex = 0;\n        /* retrieves the total number of legs */\n        endIndex = dt_leg_count;\n    }\n    else\n    {\n        /* Treat `leg` as the specific leg index */\n        startIndex = leg;\n        /* Only iterate for this specific leg */\n        endIndex = leg + 1;\n    }\n\n    for (int8_t i = startIndex; i &lt; endIndex; i++)\n    {\n        if (!dt_pwm_x1_high[i])\n        {\n            /* PWMx1 is connected in hardware to switch low */\n            initMode(static_cast&lt;leg_t&gt;(i), PWMx1, VOLTAGE_MODE);\n        }\n        else\n        {\n            /* PWMx1 is connected in hardware to switch high */\n            initMode(static_cast&lt;leg_t&gt;(i), PWMx2, VOLTAGE_MODE);\n        }\n    }\n}\n</code></pre>"},{"location":"powerAPI/Power_8h/","title":"File Power.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Power.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Power_8h/#classes","title":"Classes","text":"Type Name class PowerAPI"},{"location":"powerAPI/Power_8h/#public-types","title":"Public Types","text":"Type Name enum leg_t Parses all the legs with okay status in the device tree and fills this type def."},{"location":"powerAPI/Power_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Power_8h/#enum-leg_t","title":"enum leg_t","text":"<p>Parses all the legs with okay status in the device tree and fills this type def. <pre><code>enum leg_t {\n    DT_FOREACH_CHILD_STATUS_OKAY =(DT_NODELABEL(powershield), LEG_TOKEN)\n    ALL\n};\n</code></pre></p> <ul> <li><code>LEG1</code> to <code>LEG5</code> - values supported by the SPIN</li> <li><code>ALL</code> - Applies the function to all legs in the list </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Power.h</code></p>"},{"location":"powerAPI/Power_8h_source/","title":"File Power.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Power.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date 2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org\n *\n * @brief This file is based on the device tree to initialize legs controlled\n *        by the HRTIM\n */\n\n#ifndef POWER_H_\n#define POWER_H_\n\n#include &lt;zephyr/kernel.h&gt;\n#include \"arm_math.h\"\n#include \"hrtim_enum.h\"\n\n#define LEG_TOKEN(node_id) DT_STRING_TOKEN(node_id, leg_name),\n\ntypedef enum\n{\n    DT_FOREACH_CHILD_STATUS_OKAY(DT_NODELABEL(powershield), LEG_TOKEN)\n    ALL\n} leg_t;\n\nclass PowerAPI\n{\nprivate:\n    /* return timing unit from spin pin number */\n    hrtim_tu_number_t spinNumberToTu(uint16_t spin_number);\n\n\npublic:\n    void initMode(leg_t leg,\n                  hrtim_switch_convention_t leg_convention,\n                  hrtim_pwm_mode_t leg_mode);\n\n    void setDutyCycle(leg_t leg, float32_t duty_value);\n\n    void setDutyCycleRaw(leg_t leg, uint16_t duty_value);\n\n\n    void start(leg_t leg);\n\n    void stop(leg_t leg);\n\n    void connectCapacitor(leg_t leg);\n\n    void disconnectCapacitor(leg_t leg);\n\n    void connectDriver(leg_t leg);\n\n    void disconnectDriver(leg_t leg);\n\n    void setTriggerValue(leg_t leg, float32_t trigger_value);\n\n    void setPhaseShift(leg_t leg, int16_t phase_shift);\n\n    void setSlopeCompensation(leg_t leg,\n                              float32_t set_voltage,\n                              float32_t reset_voltage);\n\n    void setDeadTime(leg_t leg,\n                     uint16_t ns_rising_dt,\n                     uint16_t ns_falling_dt);\n\n    void setDutyCycleMin(leg_t leg, float32_t duty_cycle);\n\n    void setDutyCycleMinRaw(leg_t leg, uint16_t duty_cycle);\n\n    void setDutyCycleMaxRaw(leg_t leg, uint16_t duty_cycle);\n\n    void setDutyCycleMax(leg_t leg, float32_t duty_cycle);\n\n    float32_t getDutyCycleMax(leg_t leg);\n\n    uint16_t getDutyCycleMaxRaw(leg_t leg);\n\n    float32_t getDutyCycleMin(leg_t leg);\n\n    uint16_t getDutyCycleMinRaw(leg_t leg);\n\n    uint16_t getPeriod(leg_t leg);\n\n\n    void setAdcDecim(leg_t leg, uint16_t adc_decim);\n\n    void initBuck(leg_t leg, hrtim_pwm_mode_t leg_mode = VOLTAGE_MODE);\n\n    void initBoost(leg_t leg);\n\n};\n\n#endif /* POWER_H_ */\n</code></pre>"},{"location":"powerAPI/Sensors_8cpp/","title":"File Sensors.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Sensors.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.cpp</code></p>"},{"location":"powerAPI/Sensors_8cpp_source/","title":"File Sensors.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Sensors.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Hugues Larrive &lt;hugues.larrive@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Thomas Walter &lt;thomas.walter@laas.fr&gt;\n */\n\n/* Stdlib */\n#include &lt;stdlib.h&gt;\n\n/* Zephyr headers */\n#include &lt;zephyr/console/console.h&gt;\n\n/* Current class header */\n#include \"Sensors.h\"\n\n/* Other modules public API */\n#include \"SpinAPI.h\"\n\n\n#define SENSOR_NAME(node_id) \\\n                DT_STRING_TOKEN(DT_PARENT(node_id), sensor_name)\n\n#define CHANNEL_IS_DIFF(node_id) \\\n                DT_PROP(node_id, differential)\n\n#define CHANNEL_NUMBER(node_id) \\\n                DT_PHA_BY_IDX(node_id, io_channels, 0, input)\n\n#define PIN_NUMBER(node_id) \\\n                DT_PROP(node_id, spin_pin)\n\n#define ADC_REG_ADDR(node_id) \\\n                DT_REG_ADDR(DT_PHANDLE(node_id, io_channels))\n\n#define CONVERSION_TYPE(node_id) \\\n                DT_STRING_TOKEN(DT_PARENT(node_id), sensor_conv_type)\n\n#define SENSOR_DEFAULT_PARAM(node_id, param_name) \\\n                DT_PROP_OR(DT_PARENT(node_id), default_##param_name, 0)\n\n/* Sensor properties */\n#define SENSOR_WRITE_PROP(node_id)                                            \\\n    {                                                                         \\\n        .name=SENSOR_NAME(node_id),                                           \\\n        .channel_number=CHANNEL_NUMBER(node_id),                              \\\n        .pin_number=PIN_NUMBER(node_id),                                      \\\n        .is_differential=CHANNEL_IS_DIFF(node_id),                            \\\n        .adc_reg_addr=ADC_REG_ADDR(node_id),                                  \\\n        .conversion_type=CONVERSION_TYPE(node_id),                            \\\n        .default_gain={.raw_value = SENSOR_DEFAULT_PARAM(node_id, gain)},     \\\n        .default_offset={.raw_value = SENSOR_DEFAULT_PARAM(node_id, offset)}, \\\n        .default_r0={.raw_value = SENSOR_DEFAULT_PARAM(node_id, r0)},         \\\n        .default_b={.raw_value = SENSOR_DEFAULT_PARAM(node_id, b)},           \\\n        .default_rdiv={.raw_value = SENSOR_DEFAULT_PARAM(node_id, rdiv)},     \\\n        .default_t0={.raw_value = SENSOR_DEFAULT_PARAM(node_id, t0)}          \\\n    },\n\n#define SUBSENSOR_WRITE_PROP(node_id) \\\n                    DT_FOREACH_CHILD(node_id, SENSOR_WRITE_PROP)\n\n\n/* Sensors count. This is very dirty! */\n#define SENSORS_COUNTER(node_id) +1\n#define SUBSENSORS_COUNTER(node_id) \\\n                    DT_FOREACH_CHILD(node_id, SENSORS_COUNTER)\n\n#define DT_SENSORS_COUNT \\\n                    DT_FOREACH_STATUS_OKAY(shield_sensors, SUBSENSORS_COUNTER)\n\n\n\n#ifdef CONFIG_SHIELD_OWNVERTER\n    uint8_t SensorsAPI::temp_mux_in_1 =\n                            DT_PROP(DT_NODELABEL(temp), mux_spin_pin_1);\n\n    uint8_t SensorsAPI::temp_mux_in_2 =\n                            DT_PROP(DT_NODELABEL(temp), mux_spin_pin_2);\n#endif\n\n\n\nSensorsAPI::sensor_dt_data_t SensorsAPI::dt_sensors_props[] =\n{\n    DT_FOREACH_STATUS_OKAY(shield_sensors, SUBSENSOR_WRITE_PROP)\n};\n\n/* Number of available sensors defined in device tree for each ADC. */\nuint8_t SensorsAPI::available_sensors_count[ADC_COUNT] = {0};\n\nSensorsAPI::sensor_dt_data_t** SensorsAPI::available_sensors_props[ADC_COUNT] = {0};\n\nSensorsAPI::sensor_dt_data_t* SensorsAPI::enabled_sensors[DT_SENSORS_COUNT] = {0};\n\nbool SensorsAPI::initialized = false;\n\n\n\nint8_t SensorsAPI::enableSensor(sensor_t sensor_name, adc_t adc_num)\n{\n    if (initialized == false)\n    {\n        buildSensorListFromDeviceTree();\n    }\n\n    /* Check parameters */\n    if (adc_num &gt; ADC_COUNT) return ERROR_CHANNEL_NOT_FOUND;\n    if (sensor_name == UNDEFINED_SENSOR) return ERROR_CHANNEL_NOT_FOUND;\n\n    /* Find sensor property */\n    uint8_t adc_index = adc_num-1;\n    sensor_dt_data_t* sensor_prop = nullptr;\n    for (uint8_t sensor = 0 ;\n         sensor &lt; available_sensors_count[adc_index];\n         sensor++)\n    {\n        sensor_dt_data_t* current_sensor =\n                            available_sensors_props[adc_index][sensor];\n\n        if (current_sensor-&gt;name == sensor_name)\n        {\n            sensor_prop = current_sensor;\n        }\n    }\n\n    /* Check if we did find a sensor */\n    if (sensor_prop == nullptr) return ERROR_CHANNEL_NOT_FOUND;\n\n    /* Register sensor enabling */\n    int sensor_index = ((int)sensor_name) - 1;\n    enabled_sensors[sensor_index] = sensor_prop;\n\n\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n    return DataAPI::enableChannel(sensor_info.adc_num, sensor_info.channel_num);\n}\n\nuint16_t* SensorsAPI::getRawValues(sensor_t sensor_name,\n                                   uint32_t&amp; number_of_values_acquired)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return DataAPI::getChannelRawValues(sensor_info.adc_num,\n                                        sensor_info.channel_num,\n                                        number_of_values_acquired);\n}\n\nfloat32_t* SensorsAPI::getValues(sensor_t sensor_name,\n                                 uint32_t&amp; number_of_values_acquired)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return DataAPI::getChannelValues(sensor_info.adc_num,\n                                     sensor_info.channel_num,\n                                     number_of_values_acquired);\n}\n\nfloat32_t SensorsAPI::peekLatestValue(sensor_t sensor_name)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return DataAPI::peekChannel(sensor_info.adc_num,\n                                sensor_info.channel_num);\n}\n\nfloat32_t SensorsAPI::getLatestValue(sensor_t sensor_name, uint8_t* dataValid)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return DataAPI::getChannelLatest(sensor_info.adc_num,\n                                     sensor_info.channel_num,\n                                     dataValid);\n}\n\nfloat32_t SensorsAPI::convertRawValue(sensor_t sensor_name, uint16_t raw_value)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return data_conversion_convert_raw_value(sensor_info.adc_num,\n                                             sensor_info.channel_num,\n                                             raw_value);\n}\n\nvoid SensorsAPI::setConversionParametersLinear(sensor_t sensor_name,\n                                               float32_t gain,\n                                               float32_t offset)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n    conversion_type_t sensor_conv_type =\n                            retrieveStoredConversionType(sensor_name);\n\n    /* Verifies the conversion is of type linear */\n    if(sensor_conv_type == conversion_linear){\n        data_conversion_set_conversion_parameters_linear(\n            sensor_info.adc_num,\n            sensor_info.channel_num,\n            gain,\n            offset\n        );\n    }\n}\n\nvoid SensorsAPI::setConversionParametersNtcThermistor(sensor_t sensor_name,\n                                                      float32_t r0,\n                                                      float32_t b,\n                                                      float32_t rdiv,\n                                                      float32_t t0)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n    conversion_type_t sensor_conv_type =\n                        retrieveStoredConversionType(sensor_name);\n\n    if(sensor_conv_type == conversion_therm){\n        data_conversion_set_conversion_parameters_therm(\n            sensor_info.adc_num,\n            sensor_info.channel_num,\\\n            r0,\n            b,\n            rdiv,\n            t0\n        );\n    }\n}\n\n\nfloat32_t SensorsAPI::retrieveStoredParameterValue(sensor_t sensor_name,\n                                                   parameter_t parameter_name)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return data_conversion_get_parameter(sensor_info.adc_num,\n                                         sensor_info.channel_num,\n                                         parameter_name);\n}\n\nconversion_type_t SensorsAPI::retrieveStoredConversionType(sensor_t sensor_name)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return data_conversion_get_conversion_type(sensor_info.adc_num,\n                                               sensor_info.channel_num);\n}\n\nint8_t SensorsAPI::retrieveParametersFromMemory(sensor_t sensor_name)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n\n    return data_conversion_retrieve_channel_parameters_from_nvs(\n                sensor_info.adc_num,\n                sensor_info.channel_num\n            );\n}\n\nint8_t SensorsAPI::storeParametersInMemory(sensor_t sensor_name)\n{\n    sensor_info_t sensor_info = getEnabledSensorInfo(sensor_name);\n    return data_conversion_store_channel_parameters_in_nvs(\n                sensor_info.adc_num,\n                sensor_info.channel_num\n            );\n}\n\n#ifdef CONFIG_SHIELD_OWNVERTER\n\nvoid SensorsAPI::enableDefaultOwnverterSensors()\n{\n    spin.data.configureTriggerSource(ADC_1, TRIG_PWM);\n    spin.data.configureTriggerSource(ADC_2, TRIG_PWM);\n    spin.data.configureTriggerSource(ADC_3, TRIG_SOFTWARE);\n    spin.data.configureTriggerSource(ADC_4, TRIG_SOFTWARE);\n    spin.data.configureTriggerSource(ADC_5, TRIG_SOFTWARE);\n\n    spin.data.configureDiscontinuousMode(ADC_1, 1);\n    spin.data.configureDiscontinuousMode(ADC_2, 1);\n\n    /* Creates the list of measurements of the ADC 1 */\n    this-&gt;enableSensor(V1_LOW, ADC_1);\n    this-&gt;enableSensor(V2_LOW, ADC_1);\n    this-&gt;enableSensor(I3_LOW, ADC_1);\n    this-&gt;enableSensor(V_HIGH, ADC_1);\n    this-&gt;enableSensor(V_NEUTR, ADC_1);\n\n    /* Creates the list of measurements of the ADC 2 */\n    this-&gt;enableSensor(I1_LOW, ADC_2);\n    this-&gt;enableSensor(I2_LOW, ADC_2);\n    this-&gt;enableSensor(V3_LOW, ADC_2);\n    this-&gt;enableSensor(I_HIGH, ADC_2);\n    this-&gt;enableSensor(TEMP_SENSOR, ADC_2);\n\n    /* Configure the pins of the temperature MUX */\n    spin.gpio.configurePin(temp_mux_in_1,OUTPUT);\n    spin.gpio.configurePin(temp_mux_in_2,OUTPUT);\n\n\n}\n\nvoid SensorsAPI::setOwnverterTempMeas(ownverter_temp_sensor_t temperature_sensor)\n{\n    if(temperature_sensor == TEMP_1){\n        spin.gpio.setPin(temp_mux_in_1);\n        spin.gpio.resetPin(temp_mux_in_2);\n    }else if(temperature_sensor == TEMP_2){\n        spin.gpio.resetPin(temp_mux_in_1);\n        spin.gpio.setPin(temp_mux_in_2);\n    }else if(temperature_sensor == TEMP_3){\n        spin.gpio.setPin(temp_mux_in_1);\n        spin.gpio.setPin(temp_mux_in_2);\n    }\n}\n\n\n#endif\n\n#ifdef CONFIG_SHIELD_TWIST\n\nvoid SensorsAPI::enableDefaultTwistSensors()\n{\n    spin.data.configureTriggerSource(ADC_1, TRIG_PWM);\n    spin.data.configureTriggerSource(ADC_2, TRIG_PWM);\n    spin.data.configureTriggerSource(ADC_3, TRIG_SOFTWARE);\n    spin.data.configureTriggerSource(ADC_4, TRIG_SOFTWARE);\n    spin.data.configureTriggerSource(ADC_5, TRIG_SOFTWARE);\n\n    uint32_t num_discontinuous_meas = 1;\n    spin.data.configureDiscontinuousMode(ADC_1, num_discontinuous_meas);\n    spin.data.configureDiscontinuousMode(ADC_2, num_discontinuous_meas);\n\n    /* Creates the list of measurements of the ADC 1 */\n    this-&gt;enableSensor(I1_LOW, ADC_1);\n    this-&gt;enableSensor(V1_LOW, ADC_1);\n    this-&gt;enableSensor(V_HIGH, ADC_1);\n\n    /* Creates the list of measurements of the ADC 2 */\n    this-&gt;enableSensor(I2_LOW, ADC_2);\n    this-&gt;enableSensor(V2_LOW, ADC_2);\n    this-&gt;enableSensor(I_HIGH, ADC_2);\n\n    /* Creates the list of measurements of the ADC 3 */\n    int8_t test = this-&gt;enableSensor(TEMP_SENSOR_1, ADC_4);\n\n    /* Creates the list of measurements of the ADC 4 */\n    test = this-&gt;enableSensor(TEMP_SENSOR_2, ADC_3);\n\n}\n\nvoid SensorsAPI::triggerTwistTempMeas(sensor_t temperature_sensor)\n{\n    if(temperature_sensor == TEMP_SENSOR_1){\n         spin.data.triggerAcquisition(ADC_4);\n    }else{\n         spin.data.triggerAcquisition(ADC_3);\n    }\n}\n\nvoid SensorsAPI::setTwistSensorsUserCalibrationFactors()\n{\n    /* VH, V1, V2, IH, I1, I2 */\n    float32_t gains[6];\n    /* VH, V1, V2, IH, I1, I2 */\n    float32_t offsets[6];\n\n    /* T1 and T2 R0 - sensor resistance at reference temperature */\n    float32_t r0[2];\n    /* T1 and T2 B - sensor temperature negative coefficient */\n    float32_t b[2];\n    /* T1 and T2 R_DIV - bridge divider resistance */\n    float32_t rdiv[2];\n    /* T1 and T2 T0 - Reference temperature */\n    float32_t t0[2];\n\n    gains[0]   = getCalibrationCoefficients(\"VHigh\", \"gain\");\n    offsets[0] = getCalibrationCoefficients(\"VHigh\", \"offset\");\n\n    gains[1]   = getCalibrationCoefficients(\"V1Low\", \"gain\");\n    offsets[1] = getCalibrationCoefficients(\"V1Low\", \"offset\");\n\n    gains[2]   = getCalibrationCoefficients(\"V2Low\", \"gain\");\n    offsets[2] = getCalibrationCoefficients(\"V2Low\", \"offset\");\n\n    gains[3]   = getCalibrationCoefficients(\"IHigh\", \"gain\");\n    offsets[3] = getCalibrationCoefficients(\"IHigh\", \"offset\");\n\n    gains[4]   = getCalibrationCoefficients(\"I1Low\", \"gain\");\n    offsets[4] = getCalibrationCoefficients(\"I1Low\", \"offset\");\n\n    gains[5]   = getCalibrationCoefficients(\"I2Low\", \"gain\");\n    offsets[5] = getCalibrationCoefficients(\"I2Low\", \"offset\");\n\n    r0[0]   = getCalibrationCoefficients(\"Temp1\", \"r0\");\n    b[0]    = getCalibrationCoefficients(\"Temp1\", \"b\");\n    rdiv[0] = getCalibrationCoefficients(\"Temp1\", \"rdiv\");\n    t0[0]   = getCalibrationCoefficients(\"Temp1\", \"t0\");\n\n    r0[1]   = getCalibrationCoefficients(\"Temp2\", \"r0\");\n    b[1]    = getCalibrationCoefficients(\"Temp2\", \"b\");\n    rdiv[1] = getCalibrationCoefficients(\"Temp2\", \"rdiv\");\n    t0[1]   = getCalibrationCoefficients(\"Temp2\", \"t0\");\n\n\n    sensor_info_t sensor_info = getEnabledSensorInfo(V_HIGH);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[0],\n        offsets[0]\n    );\n\n    sensor_info = getEnabledSensorInfo(V1_LOW);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[1],\n        offsets[1]\n    );\n\n    sensor_info = getEnabledSensorInfo(V2_LOW);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[2],\n        offsets[2]\n    );\n\n    sensor_info = getEnabledSensorInfo(I_HIGH);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[3],\n        offsets[3]\n    );\n\n    sensor_info = getEnabledSensorInfo(I1_LOW);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[4],\n        offsets[4]\n    );\n\n    sensor_info = getEnabledSensorInfo(I2_LOW);\n    data_conversion_set_conversion_parameters_linear(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        gains[5],\n        offsets[5]\n    );\n\n    sensor_info = getEnabledSensorInfo(TEMP_SENSOR_1);\n    data_conversion_set_conversion_parameters_therm(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        r0[0],\n        b[0],\n        rdiv[0],\n        t0[0]\n    );\n\n    sensor_info = getEnabledSensorInfo(TEMP_SENSOR_2);\n    data_conversion_set_conversion_parameters_therm(\n        sensor_info.adc_num,\n        sensor_info.channel_num,\n        r0[1],\n        b[1],\n        rdiv[1],\n        t0[1]\n    );\n\n    printk(\"Calibration coefficients successfully updated!\\n\");\n\n    /* Ask for save in NVS */\n    printk(\"Do you want to store these parameters in permanent storage?\\n\");\n    printk(\"Parameters stored in permanent storage are automatically \"\n           \"retrieved at board boot.\\n\");\n\n    printk(\"Not storing them in permanent storage will result in parameters \"\n           \"being lost on board power cycle.\\n\");\n\n    printk(\"Press y to store parameters in permanent storage, \"\n           \"any other key to don't store them.\\n\");\n\n    char received_char = console_getchar();\n    if (received_char == 'y')\n    {\n        sensor_info = getEnabledSensorInfo(V_HIGH);\n        int8_t err = data_conversion_store_channel_parameters_in_nvs(\n                        sensor_info.adc_num,\n                        sensor_info.channel_num\n                     );\n\n        sensor_info = getEnabledSensorInfo(V1_LOW);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(V2_LOW);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(I_HIGH);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(I1_LOW);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(I2_LOW);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(TEMP_SENSOR_1);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        sensor_info = getEnabledSensorInfo(TEMP_SENSOR_2);\n        err |= data_conversion_store_channel_parameters_in_nvs(\n                    sensor_info.adc_num,\n                    sensor_info.channel_num\n                );\n\n        if (err == 0)\n        {\n            printk(\"Parameters were successfully written in permanent storage.\\n\");\n        }\n        else\n        {\n            printk(\"Error writing parameters in permanent storage!\\n\");\n        }\n    }\n    else\n    {\n        printk(\"Exiting without permanent storage.\"\n               \"Parameters won't be retained after power cycling.\\n\");\n    }\n}\n\n#endif\n\n\n\nsensor_info_t SensorsAPI::getEnabledSensorInfo(sensor_t sensor_name)\n{\n    if (initialized == false)\n    {\n        buildSensorListFromDeviceTree();\n    }\n\n    int sensor_index = ((int)sensor_name) - 1;\n    sensor_dt_data_t* sensor_prop = enabled_sensors[sensor_index];\n    if (sensor_prop != nullptr)\n    {\n        return sensor_info_t((adc_t)sensor_prop-&gt;adc_number,\n                             sensor_prop-&gt;channel_number,\n                             sensor_prop-&gt;pin_number);\n    }\n    else\n    {\n        return sensor_info_t(DEFAULT_ADC, 0, 0);\n    }\n}\n\nvoid SensorsAPI::buildSensorListFromDeviceTree()\n{\n    bool checkNvs = true;\n\n    /* Retrieve calibration coefficients for each sensor listed in device tree */\n    for (uint8_t dt_sensor_index = 0 ;\n         dt_sensor_index &lt; DT_SENSORS_COUNT ;\n         dt_sensor_index++)\n    {\n        /* Determine ADC number based on its address */\n        switch (dt_sensors_props[dt_sensor_index].adc_reg_addr)\n        {\n            case 0x50000000:\n                dt_sensors_props[dt_sensor_index].adc_number = 1;\n                break;\n            case 0x50000100:\n                dt_sensors_props[dt_sensor_index].adc_number = 2;\n                break;\n            case 0x50000400:\n                dt_sensors_props[dt_sensor_index].adc_number = 3;\n                break;\n            case 0x50000500:\n                dt_sensors_props[dt_sensor_index].adc_number = 4;\n                break;\n            case 0x50000600:\n                dt_sensors_props[dt_sensor_index].adc_number = 5;\n                break;\n            default:\n                dt_sensors_props[dt_sensor_index].adc_number = 0;\n                continue;\n                break;\n        }\n\n        /* Get parameters from NVS if they exist */\n        bool nvsRetrieved = false;\n        if (checkNvs == true)\n        {\n            int8_t res = data_conversion_retrieve_channel_parameters_from_nvs(\n                            dt_sensors_props[dt_sensor_index].adc_number,\n                            dt_sensors_props[dt_sensor_index].channel_number\n                         );\n\n            if (res == 0)\n            {\n                printk(\"Parameters for ADC %u channel %u \"\n                       \"have been retrieved from flash\\n\",\n                        dt_sensors_props[dt_sensor_index].adc_number,\n                        dt_sensors_props[dt_sensor_index].channel_number);\n\n                conversion_type_t conv_type =\n                        data_conversion_get_conversion_type(\n                            dt_sensors_props[dt_sensor_index].adc_number,\n                            dt_sensors_props[dt_sensor_index].channel_number\n                        );\n\n                switch (conv_type)\n                {\n                    case conversion_linear:\n                    {\n                        float32_t gain   =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                1\n                            );\n\n                        float32_t offset =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                2\n                            );\n\n                        printk(\"    Conversion type is linear, \"\n                               \"with gain=%f and offset=%f\\n\",\n                               (double)gain,\n                               (double)offset);\n                    }\n                    break;\n\n                    case conversion_therm:\n                    {\n                        float32_t r0 =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                1\n                            );\n\n                        float32_t b =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                2\n                            );\n\n                        float32_t rdiv =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                3\n                            );\n\n                        float32_t t0 =\n                            data_conversion_get_parameter(\n                                dt_sensors_props[dt_sensor_index].adc_number,\n                                dt_sensors_props[dt_sensor_index].channel_number,\n                                4\n                            );\n\n                        printk(\"    Conversion type is therm, \\\n                               with r0=%f, b=%f, rdiv=%f and t0=%f\\n\",\n                               (double)r0,\n                               (double)b,\n                               (double)rdiv,\n                               (double)t0);\n                    }\n                    break;\n\n                    case no_channel_error:\n                        continue;\n                }\n                nvsRetrieved = true;\n            }\n            else if (res == -1)\n            {\n                printk(\"No calibration value found in persistent storage. \"\n                       \"Default values will be used for data conversion.\\n\");\n                checkNvs = false;\n            }\n            else if (res == -2)\n            {\n                printk(\"Calibration values in persistent storage were stored\"\n                       \"with a previous version of the API \"\n                       \"and can't be recovered.\"\n                       \"Default values will be used for data conversion.\\n\");\n                checkNvs = false;\n            }\n            else if (res == -3)\n            {\n                printk(\"Calibration values for ADC %u channel %u were found \"\n                       \"in persistent storage, but their format is incorrect. \"\n                       \"Possible data corruption.\\n\",\n                       dt_sensors_props[dt_sensor_index].adc_number,\n                       dt_sensors_props[dt_sensor_index].channel_number\n                      );\n            }\n            else if (res == -4)\n            {\n                printk(\"Unable to find calibration values for ADC \"\n                       \"%u channel %u in persistent storage. \"\n                       \"Default values will be used.\\n\",\n                       dt_sensors_props[dt_sensor_index].adc_number,\n                       dt_sensors_props[dt_sensor_index].channel_number\n                      );\n            }\n        }\n\n        if (nvsRetrieved == false)\n        {\n            /* In case parameters were not found in NVS,\n             * get default values from device tree */\n            switch (dt_sensors_props[dt_sensor_index].conversion_type)\n            {\n            case LINEAR:\n                data_conversion_set_conversion_parameters_linear(\n                    dt_sensors_props[dt_sensor_index].adc_number,\n                    dt_sensors_props[dt_sensor_index].channel_number,\n                    dt_sensors_props[dt_sensor_index].default_gain.float_value,\n                    dt_sensors_props[dt_sensor_index].default_offset.float_value\n                );\n                break;\n            case THERMISTANCE:\n                data_conversion_set_conversion_parameters_therm(\n                    dt_sensors_props[dt_sensor_index].adc_number,\n                    dt_sensors_props[dt_sensor_index].channel_number,\n                    dt_sensors_props[dt_sensor_index].default_r0.float_value,\n                    dt_sensors_props[dt_sensor_index].default_b.float_value,\n                    dt_sensors_props[dt_sensor_index].default_rdiv.float_value,\n                    dt_sensors_props[dt_sensor_index].default_t0.float_value\n                );\n                break;\n            default:\n                break;\n            }\n        }\n\n        /* Count sensor for ADC */\n        uint8_t adc_index = dt_sensors_props[dt_sensor_index].adc_number - 1;\n        available_sensors_count[adc_index]++;\n    }\n\n    /* Create the channels list for each ADC */\n    for (uint8_t adc_index = 0 ; adc_index &lt; ADC_COUNT ; adc_index++)\n    {\n        available_sensors_props[adc_index] =\n            (sensor_dt_data_t**)k_malloc(sizeof(sensor_dt_data_t*) *\n                                        available_sensors_count[adc_index]);\n    }\n\n    /* Populate the channels list for each ADC */\n    uint8_t adc_channels_count[ADC_COUNT] = {0};\n    for (uint8_t dt_sensor_index = 0 ;\n         dt_sensor_index &lt; DT_SENSORS_COUNT ;\n         dt_sensor_index++)\n    {\n        uint8_t adc_index = dt_sensors_props[dt_sensor_index].adc_number - 1;\n        if (adc_index &lt; ADC_COUNT)\n        {\n            uint8_t&amp; current_adc_channels_count = adc_channels_count[adc_index];\n\n            available_sensors_props[adc_index][current_adc_channels_count] =\n                    &amp;dt_sensors_props[dt_sensor_index];\n\n            current_adc_channels_count++;\n        }\n    }\n\n    initialized = true;\n}\n\n\nvoid SensorsAPI::getLineFromConsole(char* buffer, uint8_t buffer_size)\n{\n    /* Initializing variables for eventual loop */\n    uint8_t carcount = 0;\n    char received_char;\n\n    do\n    {\n        received_char = console_getchar();\n        buffer[carcount] = received_char;\n\n        /* Backspace character */\n        if (received_char == 0x08)\n        {\n            /* To avoid character count being negative */\n            if (carcount&gt;0)\n            {\n                carcount--;\n            }\n        }\n        else\n        {\n            carcount++;\n        }\n\n        /* Echo received char */\n        printk(\"%c\", received_char);\n\n        if (carcount &gt;= (buffer_size-1))\n        {\n            printk(\"Maximum character allowed reached \\n\");\n            break;\n        }\n    /* EOL char : CRLF */\n    } while ((received_char!='\\n'));\n     /* Adding end of tab character to prepare for atof function */\n    buffer[carcount-2] = '\\0';\n}\n\nfloat32_t SensorsAPI::getCalibrationCoefficients(const char* physicalParameter,\n                                                 const char* gainOrOffset)\n{\n    /* Maximum number of number for gain and offset value */\n    const uint8_t MaxCharInOneLine = 20;\n    /* Number of character in one line */\n    char line[MaxCharInOneLine];\n    /* Confirmation */\n    float32_t confirm;\n    float32_t parameterCoefficient;\n\n    do\n    {\n        printk(\"Type %s %s and press enter \\n\", physicalParameter, gainOrOffset);\n        getLineFromConsole(line, MaxCharInOneLine);\n\n        /* Convert string to float */\n        parameterCoefficient = atof(line);\n\n        /* Get confirmation */\n        printk(\"%s %s applied will be : %f\\n\",\n               physicalParameter,\n               gainOrOffset,\n               (double)parameterCoefficient);\n\n        printk(\"Press enter to validate, any other character \"\n               \"to retype the %s \\n\",\n                gainOrOffset);\n\n        getLineFromConsole(line, MaxCharInOneLine);\n\n        /* Check if Enter was pressed (empty input) */\n        if (strlen(line) == 0) {\n            /* Confirmed */\n            confirm = 0;\n        } else {\n            /* Re-type required */\n            confirm = 1;\n        }\n\n    } while(confirm);\n\n    return parameterCoefficient;\n}\n</code></pre>"},{"location":"powerAPI/Sensors_8h/","title":"File Sensors.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Sensors.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Sensors_8h/#classes","title":"Classes","text":"Type Name class SensorsAPI struct sensor_info_t"},{"location":"powerAPI/Sensors_8h/#public-types","title":"Public Types","text":"Type Name enum ownverter_temp_sensor_t enum sensor_t"},{"location":"powerAPI/Sensors_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Sensors_8h/#enum-ownverter_temp_sensor_t","title":"enum ownverter_temp_sensor_t","text":"<pre><code>enum ownverter_temp_sensor_t {\n    TEMP_1 = 0,\n    TEMP_2 = 1,\n    TEMP_3 = 2\n};\n</code></pre>"},{"location":"powerAPI/Sensors_8h/#enum-sensor_t","title":"enum sensor_t","text":"<pre><code>enum sensor_t {\n    UNDEFINED_SENSOR = 0,\n    DT_FOREACH_STATUS_OKAY =(shield_sensors, SENSOR_TOKEN)\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/Sensors.h</code></p>"},{"location":"powerAPI/Sensors_8h_source/","title":"File Sensors.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; Sensors.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief  Shield sensors management from device tree.\n *         This class allows, for shields that define\n *         shield-sensor nodes in device tree, to\n *         automatically extract available sensors and\n *         manage them by name using an enumeration.\n */\n\n\n#ifndef SENSORS_H_\n#define SENSORS_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n\n/* ARM CMSIS library */\n#include &lt;arm_math.h&gt;\n\n/* Other modules public API */\n#include \"SpinAPI.h\"\n\n/* Device-tree related macro */\n\n#define SENSOR_TOKEN(node_id) DT_STRING_TOKEN(node_id, sensor_name),\n\n\n/* Type definitions */\n\ntypedef enum\n{\n    UNDEFINED_SENSOR = 0,\n    DT_FOREACH_STATUS_OKAY(shield_sensors, SENSOR_TOKEN)\n} sensor_t;\n\nstruct sensor_info_t\n{\n    sensor_info_t(adc_t adc_num, uint8_t channel_num, uint8_t pin_num)\n    {\n        this-&gt;adc_num     = adc_num;\n        this-&gt;channel_num = channel_num;\n        this-&gt;pin_num     = pin_num;\n    }\n\n    adc_t   adc_num;\n    uint8_t channel_num;\n    uint8_t pin_num;\n};\n\n#ifdef CONFIG_SHIELD_OWNVERTER\n    typedef enum\n    {\n        TEMP_1 = 0,\n        TEMP_2 = 1,\n        TEMP_3 = 2\n    } ownverter_temp_sensor_t;\n#endif\n\n/* Static class definition */\n\nclass SensorsAPI\n{\n\n\nprivate:\n    typedef union\n    {\n        uint32_t  raw_value;\n        float32_t float_value;\n    } int2float;\n\n    enum conv_type_string_t\n    {\n        LINEAR,\n        THERMISTANCE\n    };\n\n    typedef struct\n    {\n        sensor_t           name;\n        uint8_t            adc_number;\n        uint8_t            channel_number;\n        uint8_t            pin_number;\n        bool               is_differential;\n        uint32_t           adc_reg_addr; /* ADC addr is used to identify ADC */\n        conv_type_string_t conversion_type;\n        /* Default calibration parameters */\n        int2float default_gain;\n        int2float default_offset;\n        int2float default_r0;\n        int2float default_b;\n        int2float default_rdiv;\n        int2float default_t0;\n    } sensor_dt_data_t;\n\n\npublic:\n\n    int8_t enableSensor(sensor_t sensor_name, adc_t adc_number);\n\n    uint16_t* getRawValues(sensor_t sensor_name,\n                           uint32_t&amp; number_of_values_acquired);\n\n    float32_t* getValues(sensor_t sensor_name,\n                         uint32_t&amp; number_of_values_acquired);\n\n    float32_t peekLatestValue(sensor_t sensor_name);\n\n    float32_t getLatestValue(sensor_t sensor_name, uint8_t* dataValid = nullptr);\n\n    float32_t convertRawValue(sensor_t sensor_name, uint16_t raw_value);\n\n    void setConversionParametersLinear(sensor_t sensor_name,\n                                       float32_t gain,\n                                       float32_t offset);\n\n    void setConversionParametersNtcThermistor(sensor_t sensor_name,\n                                              float32_t r0,\n                                              float32_t b,\n                                              float32_t rdiv,\n                                              float32_t t0);\n\n    float32_t retrieveStoredParameterValue(sensor_t sensor_name,\n                                           parameter_t parameter_name);\n\n    conversion_type_t retrieveStoredConversionType(sensor_t sensor_name);\n\n    int8_t storeParametersInMemory(sensor_t sensor_name);\n\n    int8_t retrieveParametersFromMemory(sensor_t sensor_name);\n\n#ifdef CONFIG_SHIELD_OWNVERTER\n\n    void enableDefaultOwnverterSensors();\n\n    void setOwnverterTempMeas(ownverter_temp_sensor_t temperature_sensor);\n#endif\n\n#ifdef CONFIG_SHIELD_TWIST\n\n    void enableDefaultTwistSensors();\n\n    void setTwistSensorsUserCalibrationFactors();\n\n    void triggerTwistTempMeas(sensor_t temperature_sensor);\n\n#endif\n\nprivate:\n\n\n    sensor_info_t getEnabledSensorInfo(sensor_t sensor_name);\n\n    void buildSensorListFromDeviceTree();\n\n    void getLineFromConsole(char* buffer, uint8_t buffer_size);\n\n    float32_t getCalibrationCoefficients(const char* physicalParameter,\n                                         const char* gainOrOffset);\n\nprivate:\n    static sensor_dt_data_t dt_sensors_props[];\n    static uint8_t available_sensors_count[ADC_COUNT];\n    static sensor_dt_data_t** available_sensors_props[ADC_COUNT];\n    static sensor_dt_data_t* enabled_sensors[];\n    static bool initialized;\n\n    #ifdef CONFIG_SHIELD_OWNVERTER\n    static uint8_t   temp_mux_in_1;\n    static uint8_t   temp_mux_in_2;\n\n    #endif\n\n};\n\n#endif /* SENSORS_H */\n</code></pre>"},{"location":"powerAPI/power__init_8cpp/","title":"File power_init.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; power_init.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/power__init_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name adc_t dt_adc   = <code>/* multi line expression */</code> uint32_t dt_adc_decim   = <code>/* multi line expression */</code> uint16_t dt_current_pin   = <code>/* multi line expression */</code> hrtim_adc_edgetrigger_t dt_edge_trigger   = <code>/* multi line expression */</code> uint16_t dt_falling_deadtime   = <code>/* multi line expression */</code> uint8_t dt_leg_count   = <code>/* multi line expression */</code> hrtim_cnt_t dt_modulation   = <code>/* multi line expression */</code> uint8_t dt_output1_inactive   = <code>/* multi line expression */</code> uint8_t dt_output2_inactive   = <code>/* multi line expression */</code> int16_t dt_phase_shift   = <code>/* multi line expression */</code> uint16_t dt_pin_capacitor   = <code>/* multi line expression */</code> uint16_t dt_pin_driver   = <code>/* multi line expression */</code> uint16_t dt_pwm_pin   = <code>/* multi line expression */</code> uint16_t dt_pwm_x1_high   = <code>/* multi line expression */</code> uint16_t dt_rising_deadtime   = <code>/* multi line expression */</code> uint32_t timer_frequency   = <code>DT\\_PROP(POWER\\_SHIELD\\_ID, default\\_frequency)</code> uint32_t timer_min_frequency   = <code>DT\\_PROP(POWER\\_SHIELD\\_ID, min\\_frequency)</code>"},{"location":"powerAPI/power__init_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/power__init_8cpp/#variable-dt_adc","title":"variable dt_adc","text":"<pre><code>adc_t dt_adc[];\n</code></pre> <p>Define an array <code>dt_adc</code> of type <code>adc_t</code> and initialize it with an array of <code>adc</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_adc_decim","title":"variable dt_adc_decim","text":"<pre><code>uint32_t dt_adc_decim[];\n</code></pre> <p>Define an array <code>dt_adc_decim</code> of type <code>uint32_t</code> and initialize it with an array of <code>adc_decim</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_current_pin","title":"variable dt_current_pin","text":"<pre><code>uint16_t dt_current_pin[];\n</code></pre> <p>Define an array <code>dt_current_pin</code> of type <code>uint16</code> and initialize it with an array of <code>curent_pin_num</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_edge_trigger","title":"variable dt_edge_trigger","text":"<pre><code>hrtim_adc_edgetrigger_t dt_edge_trigger[];\n</code></pre> <p>Define an array <code>dt_rollover</code> of type <code>hrtim_adc_rollover_t</code> and initialize it with an array of <code>roll_over</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_falling_deadtime","title":"variable dt_falling_deadtime","text":"<pre><code>uint16_t dt_falling_deadtime[];\n</code></pre> <p>Define an array <code>dt_falling_deadtime</code> of type <code>uint16_t</code> and initialize it with an array of falling dead time values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_leg_count","title":"variable dt_leg_count","text":"<pre><code>uint8_t dt_leg_count;\n</code></pre> <p>Define a variable <code>dt_leg_count</code> and initialize it with the count of children with status <code>OKAY</code> under the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_modulation","title":"variable dt_modulation","text":"<pre><code>hrtim_cnt_t dt_modulation[];\n</code></pre> <p>Define an array <code>dt_modulation</code> of type <code>hrtim_cnt_t</code> and initialize it with an array of <code>modulation</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_output1_inactive","title":"variable dt_output1_inactive","text":"<pre><code>uint8_t dt_output1_inactive[];\n</code></pre> <p>Define an array <code>dt_output1_inactive</code> of type <code>uint8_t</code> and initialize it with an array of <code>output1_inactive</code> values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_output2_inactive","title":"variable dt_output2_inactive","text":"<pre><code>uint8_t dt_output2_inactive[];\n</code></pre> <p>Define an array <code>dt_output2_inactive</code> of type <code>uint8_t</code> and initialize it with an array of <code>output2_inactive</code> values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_phase_shift","title":"variable dt_phase_shift","text":"<pre><code>int16_t dt_phase_shift[];\n</code></pre> <p>Define an array <code>dt_phase_shift</code> of type <code>int16_t</code> and initialize it with an array of <code>phase_shift</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_pin_capacitor","title":"variable dt_pin_capacitor","text":"<pre><code>uint16_t dt_pin_capacitor[];\n</code></pre> <p>Define an array <code>dt_pin_driver</code> of type <code>uint16</code> and initialize it with an array of <code>capa_pin_num</code> values from the children of the Device Tree node with ID <code>POWER_SHIELD_ID</code> </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_pin_driver","title":"variable dt_pin_driver","text":"<pre><code>uint16_t dt_pin_driver[];\n</code></pre> <p>Define an array <code>dt_pin_driver</code> of type <code>uint16</code> and initialize it with an array of <code>driver_pin_num</code> values from the children of the Device Tree node with ID <code>POWER_SHIELD_ID</code> </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_pwm_pin","title":"variable dt_pwm_pin","text":"<pre><code>uint16_t dt_pwm_pin[];\n</code></pre> <p>Define an array <code>dt_pwm_pin</code> of type <code>hrtim_tu_number_t</code> and initialize it with an array containing the first element of <code>pwm_pin_num</code> properties from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_pwm_x1_high","title":"variable dt_pwm_x1_high","text":"<pre><code>uint16_t dt_pwm_x1_high[];\n</code></pre> <p>Define an array <code>dt_pwm_x1_high</code> and initialize it with an array of <code>timing_unit</code> properties from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-dt_rising_deadtime","title":"variable dt_rising_deadtime","text":"<pre><code>uint16_t dt_rising_deadtime[];\n</code></pre> <p>Define an array <code>dt_rising_deadtime</code> of type <code>uint16_t</code> and initialize it with an array of rising dead time values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-timer_frequency","title":"variable timer_frequency","text":"<pre><code>uint32_t timer_frequency;\n</code></pre> <p>Define a variable <code>timer_frequency</code> and initialize it with the <code>frequency</code> property from the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8cpp/#variable-timer_min_frequency","title":"variable timer_min_frequency","text":"<pre><code>uint32_t timer_min_frequency;\n</code></pre> <p>Define a variable 'timer_min_frequency' and initialize it with the 'min-frequency' property from the Device Tree node with the ID 'POWER_SHIELD_ID'. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/power_init.cpp</code></p>"},{"location":"powerAPI/power__init_8cpp_source/","title":"File power_init.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; power_init.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n#include \"power_init.h\"\n\nuint32_t timer_frequency = DT_PROP(POWER_SHIELD_ID, default_frequency);\n\nuint32_t timer_min_frequency = DT_PROP(POWER_SHIELD_ID, min_frequency);\n\nuint16_t dt_pwm_pin[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_PWM_PIN)};\n\nuint16_t dt_pwm_x1_high[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_PWM_X1_HIGH)};\n\nadc_t dt_adc[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_ADC)};\n\nuint32_t dt_adc_decim[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_ADC_DECIM)};\n\nhrtim_cnt_t dt_modulation[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_MODULATION)};\n\nhrtim_adc_edgetrigger_t dt_edge_trigger[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_EDGE_TRIGGER)};\n\nuint16_t dt_rising_deadtime[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_RISING_DT)};\n\nuint16_t dt_falling_deadtime[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_FALLING_DT)};\n\nint16_t dt_phase_shift[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_PHASE)};\n\nuint8_t dt_leg_count =\n    DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_COUNTER);\n\nuint8_t dt_output1_inactive[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_OUTPUT1)};\n\nuint8_t dt_output2_inactive[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_OUTPUT2)};\n\nuint16_t dt_current_pin[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_CURRENT_PIN)};\n\nuint16_t dt_pin_driver[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_DRIVER_PIN)};\n\nuint16_t dt_pin_capacitor[] =\n    {DT_FOREACH_CHILD_STATUS_OKAY(POWER_SHIELD_ID, LEG_CAPACITOR_PIN)};\n</code></pre>"},{"location":"powerAPI/power__init_8h/","title":"File power_init.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; power_init.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/power__init_8h/#public-types","title":"Public Types","text":"Type Name enum cm_dac_t"},{"location":"powerAPI/power__init_8h/#public-attributes","title":"Public Attributes","text":"Type Name adc_t dt_adc uint32_t dt_adc_decim uint16_t dt_current_pin hrtim_adc_edgetrigger_t dt_edge_trigger uint16_t dt_falling_deadtime uint8_t dt_leg_count hrtim_cnt_t dt_modulation uint8_t dt_output1_inactive uint8_t dt_output2_inactive int16_t dt_phase_shift uint16_t dt_pin_capacitor uint16_t dt_pin_driver uint16_t dt_pwm_pin uint16_t dt_pwm_x1_high uint16_t dt_rising_deadtime uint32_t timer_frequency uint32_t timer_min_frequency"},{"location":"powerAPI/power__init_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/power__init_8h/#enum-cm_dac_t","title":"enum cm_dac_t","text":"<pre><code>enum cm_dac_t {\n    CM_DAC_NONE = 0,\n    CM_DAC1 = 25,\n    CM_DAC3 = 30\n};\n</code></pre> <p>Enum to define which DAC to use for current mode </p>"},{"location":"powerAPI/power__init_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/power__init_8h/#variable-dt_adc","title":"variable dt_adc","text":"<pre><code>adc_t dt_adc[];\n</code></pre> <p>Define an array <code>dt_adc</code> of type <code>adc_t</code> and initialize it with an array of <code>adc</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_adc_decim","title":"variable dt_adc_decim","text":"<pre><code>uint32_t dt_adc_decim[];\n</code></pre> <p>Define an array <code>dt_adc_decim</code> of type <code>uint32_t</code> and initialize it with an array of <code>adc_decim</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_current_pin","title":"variable dt_current_pin","text":"<pre><code>uint16_t dt_current_pin[];\n</code></pre> <p>Define an array <code>dt_current_pin</code> of type <code>uint16</code> and initialize it with an array of <code>curent_pin_num</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_edge_trigger","title":"variable dt_edge_trigger","text":"<pre><code>hrtim_adc_edgetrigger_t dt_edge_trigger[];\n</code></pre> <p>Define an array <code>dt_rollover</code> of type <code>hrtim_adc_rollover_t</code> and initialize it with an array of <code>roll_over</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_falling_deadtime","title":"variable dt_falling_deadtime","text":"<pre><code>uint16_t dt_falling_deadtime[];\n</code></pre> <p>Define an array <code>dt_falling_deadtime</code> of type <code>uint16_t</code> and initialize it with an array of falling dead time values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_leg_count","title":"variable dt_leg_count","text":"<pre><code>uint8_t dt_leg_count;\n</code></pre> <p>Define a variable <code>dt_leg_count</code> and initialize it with the count of children with status <code>OKAY</code> under the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_modulation","title":"variable dt_modulation","text":"<pre><code>hrtim_cnt_t dt_modulation[];\n</code></pre> <p>Define an array <code>dt_modulation</code> of type <code>hrtim_cnt_t</code> and initialize it with an array of <code>modulation</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_output1_inactive","title":"variable dt_output1_inactive","text":"<pre><code>uint8_t dt_output1_inactive[];\n</code></pre> <p>Define an array <code>dt_output1_inactive</code> of type <code>uint8_t</code> and initialize it with an array of <code>output1_inactive</code> values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_output2_inactive","title":"variable dt_output2_inactive","text":"<pre><code>uint8_t dt_output2_inactive[];\n</code></pre> <p>Define an array <code>dt_output2_inactive</code> of type <code>uint8_t</code> and initialize it with an array of <code>output2_inactive</code> values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_phase_shift","title":"variable dt_phase_shift","text":"<pre><code>int16_t dt_phase_shift[];\n</code></pre> <p>Define an array <code>dt_phase_shift</code> of type <code>int16_t</code> and initialize it with an array of <code>phase_shift</code> property from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_pin_capacitor","title":"variable dt_pin_capacitor","text":"<pre><code>uint16_t dt_pin_capacitor[];\n</code></pre> <p>Define an array <code>dt_pin_driver</code> of type <code>uint16</code> and initialize it with an array of <code>capa_pin_num</code> values from the children of the Device Tree node with ID <code>POWER_SHIELD_ID</code> </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_pin_driver","title":"variable dt_pin_driver","text":"<pre><code>uint16_t dt_pin_driver[];\n</code></pre> <p>Define an array <code>dt_pin_driver</code> of type <code>uint16</code> and initialize it with an array of <code>driver_pin_num</code> values from the children of the Device Tree node with ID <code>POWER_SHIELD_ID</code> </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_pwm_pin","title":"variable dt_pwm_pin","text":"<pre><code>uint16_t dt_pwm_pin[];\n</code></pre> <p>Define an array <code>dt_pwm_pin</code> of type <code>hrtim_tu_number_t</code> and initialize it with an array containing the first element of <code>pwm_pin_num</code> properties from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_pwm_x1_high","title":"variable dt_pwm_x1_high","text":"<pre><code>uint16_t dt_pwm_x1_high[];\n</code></pre> <p>Define an array <code>dt_pwm_x1_high</code> and initialize it with an array of <code>timing_unit</code> properties from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-dt_rising_deadtime","title":"variable dt_rising_deadtime","text":"<pre><code>uint16_t dt_rising_deadtime[];\n</code></pre> <p>Define an array <code>dt_rising_deadtime</code> of type <code>uint16_t</code> and initialize it with an array of rising dead time values from the children of the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-timer_frequency","title":"variable timer_frequency","text":"<pre><code>uint32_t timer_frequency;\n</code></pre> <p>Define a variable <code>timer_frequency</code> and initialize it with the <code>frequency</code> property from the Device Tree node with the ID <code>POWER_SHIELD_ID</code>. </p>"},{"location":"powerAPI/power__init_8h/#variable-timer_min_frequency","title":"variable timer_min_frequency","text":"<pre><code>uint32_t timer_min_frequency;\n</code></pre> <p>Define a variable 'timer_min_frequency' and initialize it with the 'min-frequency' property from the Device Tree node with the ID 'POWER_SHIELD_ID'. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/src/power_init.h</code></p>"},{"location":"powerAPI/power__init_8h_source/","title":"File power_init.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; src &gt; power_init.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date 2024\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief This file save all the parameters set in the device tree\n */\n\n#ifndef POWER_INIT_H_\n#define POWER_INIT_H_\n\n#include &lt;zephyr/kernel.h&gt;\n#include \"hrtim.h\"\n#include \"SpinAPI.h\"\n\n#define LEG_PWM_PIN(node_id)    DT_PROP_BY_IDX(node_id, pwm_pin_num, 0),\n\n#define LEG_PWM_X1_HIGH(node_id)    DT_PROP_OR(node_id, pwm_x1_high, 1),\n\n#define LEG_CURRENT_PIN(node_id)    DT_PROP_OR(node_id, current_pin_num, 0),\n\n#define LEG_ADC(node_id)    DT_STRING_TOKEN(node_id, default_adc),\n\n#define LEG_EDGE_TRIGGER(node_id)   DT_STRING_TOKEN(node_id, default_edge_trigger),\n\n#define LEG_MODULATION(node_id) DT_STRING_TOKEN(node_id, default_modulation),\n\n#define LEG_RISING_DT(node_id)  DT_PROP_BY_IDX(node_id, default_dead_time, 0),\n\n#define LEG_FALLING_DT(node_id) DT_PROP_BY_IDX(node_id, default_dead_time, 1),\n\n#define LEG_PHASE(node_id)  DT_PROP(node_id, default_phase_shift),\n\n#define LEG_ADC_DECIM(node_id)  DT_PROP(node_id, default_adc_decim),\n\n#define LEG_OUTPUT1(node_id) DT_PROP(node_id, output1_inactive),\n\n#define LEG_OUTPUT2(node_id) DT_PROP(node_id, output2_inactive),\n\n#define  LEG_HAS_DRIVER(node_id) DT_NODE_HAS_PROP(node_id, driver_pin_num),\n\n#define  LEG_DRIVER_PIN(node_id) DT_PROP_OR(node_id, driver_pin_num, 0),\n\n\n#define  LEG_HAS_CAPACITOR(node_id) DT_NODE_HAS_PROP(node_id, capa_pin_num),\n\n#define LEG_CAPACITOR_PIN(node_id) DT_PROP_OR(node_id, capa_pin_num, 0),\n\n#define LEG_COUNTER(node_id) +1\n\n/* The shield node identifier in the device tree */\n#define POWER_SHIELD_ID           DT_NODELABEL(powershield)\n\ntypedef enum{\n    CM_DAC_NONE = 0,\n    CM_DAC1 = 25,\n    CM_DAC3 = 30,\n}cm_dac_t;\n\n\nextern uint32_t timer_frequency;\n\nextern uint32_t timer_min_frequency;\n\n\nextern uint32_t timer_min_frequency;\n\n\nextern uint16_t dt_pwm_pin[];\n\nextern uint16_t dt_pwm_x1_high[];\n\nextern adc_t dt_adc[];\n\nextern uint32_t dt_adc_decim[];\n\nextern hrtim_cnt_t dt_modulation[];\n\nextern hrtim_adc_edgetrigger_t dt_edge_trigger[];\n\nextern uint16_t dt_rising_deadtime[];\n\nextern uint16_t dt_falling_deadtime[];\n\nextern int16_t dt_phase_shift[];\n\nextern uint8_t dt_leg_count;\n\nextern uint8_t dt_output1_inactive[];\n\nextern uint8_t dt_output2_inactive[];\n\nextern uint16_t dt_current_pin[];\n\nextern uint16_t dt_pin_driver[];\n\nextern uint16_t dt_pin_capacitor[];\n\n#endif /* POWER_H_ */\n</code></pre>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/","title":"Dir docs/core/zephyr/modules/owntech_spin_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api</p>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/</code></p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr</p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/</code></p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/#files","title":"Files","text":"Type Name file SpinAPI.cpp file SpinAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SpinAPI_8cpp/","title":"File SpinAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SpinAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/SpinAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SpinAPI_8cpp/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.cpp</code></p>"},{"location":"powerAPI/SpinAPI_8cpp_source/","title":"File SpinAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Jean Alinei &lt;jean.alinei@owntech.org&gt;\n */\n\n\n/* Current class header */\n#include \"SpinAPI.h\"\n\n\nSpinAPI spin;\n\n#ifdef CONFIG_OWNTECH_GPIO_API\nGpioHAL SpinAPI::gpio;\n#endif\n\nLedHAL SpinAPI::led;\n\nDacHAL SpinAPI::dac;\n\nDataAPI SpinAPI::data;\n\nCompHAL SpinAPI::comp;\n\nPwmHAL SpinAPI::pwm;\n\n#ifdef CONFIG_OWNTECH_UART_API\nUartHAL SpinAPI::uart;\n#endif\n\nTimerHAL SpinAPI::timer;\n</code></pre>"},{"location":"powerAPI/SpinAPI_8h/","title":"File SpinAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SpinAPI_8h/#classes","title":"Classes","text":"Type Name class SpinAPI Contains all the elements linked to peripherals of the spin board."},{"location":"powerAPI/SpinAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/SpinAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SpinAPI_8h/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/SpinAPI_8h_source/","title":"File SpinAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n\n#ifndef SPINAPI_H_\n#define SPINAPI_H_\n\n#include \"../src/CompHAL.h\"\n#include \"../src/DacHAL.h\"\n#include \"../src/DataAPI.h\"\n#include \"../src/GpioHAL.h\"\n#include \"../src/LedHAL.h\"\n#include \"../src/PwmHAL.h\"\n#include \"../src/TimerHAL.h\"\n\n#ifdef CONFIG_OWNTECH_UART_API\n#include \"../src/UartHAL.h\"\n#endif\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\n#include \"../src/NgndHAL.h\"\n#endif\n\n\n\nclass SpinAPI\n{\npublic:\n\n#ifdef CONFIG_OWNTECH_GPIO_API\n    static GpioHAL gpio;\n#endif\n    static LedHAL led;\n\n    static DacHAL dac;\n\n    static CompHAL comp;\n\n    static PwmHAL pwm;\n\n#ifdef CONFIG_OWNTECH_UART_API\n    static UartHAL uart;\n#endif\n\n    static TimerHAL timer;\n\n    static DataAPI data;\n\n};\n\n\n\nextern SpinAPI spin;\n\n\n#endif /* SPINAPI_H_ */\n</code></pre>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/#files","title":"Files","text":"Type Name file CompHAL.cpp file CompHAL.h file DacHAL.cpp file DacHAL.h file DataAPI.cpp file DataAPI.h file GpioHAL.cpp file GpioHAL.h file LedHAL.cpp file LedHAL.h file PwmHAL.cpp file PwmHAL.h file TimerHAL.cpp file TimerHAL.h file UartHAL.cpp file UartHAL.h file hardware_auto_configuration.cpp"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/#directories","title":"Directories","text":"Type Name dir data <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/</code></p>"},{"location":"powerAPI/CompHAL_8cpp/","title":"File CompHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.cpp</code></p>"},{"location":"powerAPI/CompHAL_8cpp_source/","title":"File CompHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* OwnTech low level module */\n#include \"comparator.h\"\n\n/* Current file header */\n#include \"CompHAL.h\"\n\n\nvoid CompHAL::initialize(uint8_t comparator_number){\n\n    if (comparator_number == 1){\n        comparator1_init();\n    } else if(comparator_number ==3){\n        comparator3_init();\n    }\n}\n</code></pre>"},{"location":"powerAPI/CompHAL_8h/","title":"File CompHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CompHAL_8h/#classes","title":"Classes","text":"Type Name class CompHAL Handles comparator 1 and 3 of the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/CompHAL_8h_source/","title":"File CompHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n#ifndef COMPHAL_H_\n#define COMPHAL_H_\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\nclass CompHAL\n{\npublic:\n    void initialize(uint8_t comparator_number);\n};\n\n\n\n#endif /* COMPHAL_H_ */\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/","title":"File DacHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * dac1   = <code>DEVICE\\_DT\\_GET(DAC1\\_DEVICE)</code> const struct device * dac2   = <code>DEVICE\\_DT\\_GET(DAC2\\_DEVICE)</code> const struct device * dac3   = <code>DEVICE\\_DT\\_GET(DAC3\\_DEVICE)</code>"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DacHAL_8cpp/#variable-dac1","title":"variable dac1","text":"<pre><code>const struct device* dac1;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac2","title":"variable dac2","text":"<pre><code>const struct device* dac2;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac3","title":"variable dac3","text":"<pre><code>const struct device* dac3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.cpp</code></p>"},{"location":"powerAPI/DacHAL_8cpp_source/","title":"File DacHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n\n/* Owntech drivers */\n#include \"dac.h\"\n#include \"hrtim.h\"\n\n/* Current file header */\n#include \"DacHAL.h\"\n\n#define VREF 2.048f\n\nstatic const struct device* dac1 = DEVICE_DT_GET(DAC1_DEVICE);\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\nstatic const struct device* dac3 = DEVICE_DT_GET(DAC3_DEVICE);\n\nvoid DacHAL::initConstValue(uint8_t dac_number)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        /* sets the dac 2 as default */\n        dac_dev = dac2;\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, 1, 0);\n        dac_pin_configure(dac_dev, 1, dac_pin_external);\n        dac_start(dac_dev, 1);\n    }\n}\n\nvoid DacHAL::setConstValue(uint8_t dac_number,\n                           uint8_t channel,\n                           uint32_t const_value)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        /* sets the dac 2 as default */\n        dac_dev = dac2;\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, channel, const_value);\n    }\n}\n\nvoid DacHAL::currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src)\n{\n    if (dac_number == 1){\n        /* DAC1 */\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac1, 1, &amp;function_config);\n        dac_pin_configure(dac1, 1, dac_pin_internal_and_external);\n        dac_start(dac1, 1);\n    } else if(dac_number == 3){\n        /* DAC 3 */\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac3, 1, &amp;function_config);\n        dac_pin_configure(dac3, 1, dac_pin_internal);\n        dac_start(dac3, 1);\n    } else {\n        /* does nothing - Should return an error */\n    }\n}\n\n\nvoid DacHAL::slopeCompensation(uint8_t dac_number,\n                               float32_t set_voltage,\n                               float32_t reset_voltage)\n{\n    float32_t Dv = set_voltage - reset_voltage;\n\n        if (Dv &lt; 0)\n            Dv = 0;\n\n        if (Dv &gt; set_voltage)\n        {\n            Dv = set_voltage;\n            if (Dv &gt; VREF)\n                Dv = VREF;\n        }\n\n        uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n        if (set_data &gt; 4095U)\n            set_data = 4095U;\n\n    if (dac_number == 1){\n\n        dac_function_update_reset(dac1, 1, set_data);\n        /* Divided by 100 because we have 100 voltage steps */\n        uint32_t reset_data = (uint32_t)(Dv * 65536U) / (VREF * 100);\n\n        dac_function_update_step(dac1, 1, reset_data);\n    } else if (dac_number == 3){\n\n\n        dac_function_update_reset(dac3, 1, set_data);\n        /* Divided by 100 because we have 100 voltage steps */\n        uint32_t reset_data = (uint32_t)(Dv * 65536) / (VREF * 100);\n\n        dac_function_update_step(dac3, 1, reset_data);\n    }\n}\n</code></pre>"},{"location":"powerAPI/DacHAL_8h/","title":"File DacHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8h/#classes","title":"Classes","text":"Type Name class DacHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/DacHAL_8h_source/","title":"File DacHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n\n\n#ifndef DACHAL_H_\n#define DACHAL_H_\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* ARM lib */\n#include &lt;arm_math.h&gt;\n\n/* OwnTech Modules */\n#include \"hrtim_enum.h\"\n\n\nclass DacHAL\n{\npublic:\n    void initConstValue(uint8_t dac_number);\n\n    void setConstValue(uint8_t dac_number,\n                       uint8_t channel,\n                       uint32_t const_value);\n\n    void slopeCompensation(uint8_t dac_number,\n                           float32_t peak_voltage,\n                           float32_t low_voltage);\n\n    void currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src);\n};\n\n\n#endif /* DAC_HAL_H_ */\n</code></pre>"},{"location":"powerAPI/DataAPI_8cpp/","title":"File DataAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.cpp</code></p>"},{"location":"powerAPI/DataAPI_8cpp_source/","title":"File DataAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Thomas Walter &lt;thomas.walter@laas.fr&gt;\n */\n\n\n/* Stdlib */\n#include &lt;string.h&gt;\n\n/* Current class header */\n#include \"DataAPI.h\"\n\n/* OwnTech Power API */\n#include \"SpinAPI.h\"\n#include \"adc.h\"\n\n/* Current module private functions */\n#include \"./data/data_dispatch.h\"\n\n\nbool DataAPI::is_started = false;\nbool DataAPI::adcInitialized = false;\nuint8_t DataAPI::channels_ranks[ADC_COUNT][CHANNELS_PER_ADC] = {0};\nuint8_t DataAPI::current_rank[ADC_COUNT] = {0};\nDispatchMethod_t DataAPI::dispatch_method = DispatchMethod_t::on_dma_interrupt;\nuint32_t DataAPI::repetition_count_between_dispatches = 0;\nfloat32_t*** DataAPI::converted_values_buffer = nullptr;\n\n\nadc_t DataAPI::current_adc[PIN_COUNT] = {DEFAULT_ADC};\n\n\n/* Public functions */\n\nint8_t DataAPI::enableAcquisition(uint8_t pin_num, adc_t adc_num)\n{\n    if (adc_num == DEFAULT_ADC)\n    {\n        adc_num = DataAPI::getDefaultAdcForPin(pin_num);\n    }\n\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return -1;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return -1;\n    }\n\n    int8_t err = this-&gt;enableChannel(adc_num, channel_num);\n    if (err == 0)\n    {\n        DataAPI::current_adc[pin_num-1] = adc_num;\n    }\n\n    return err;\n}\n\nint8_t DataAPI::start()\n{\n    if (DataAPI::is_started == true)\n        return -1;\n\n    /* Initialize conversion */\n    data_conversion_init();\n\n    /* Initialize data dispatch */\n    switch (this-&gt;dispatch_method)\n    {\n        case DispatchMethod_t::on_dma_interrupt:\n            /* Dispatch is handled automatically by Data Dispatch on interrupt */\n            data_dispatch_init(interrupt, 0);\n            break;\n        case DispatchMethod_t::externally_triggered:\n            /* Dispatch is triggered by an external call */\n            if (this-&gt;repetition_count_between_dispatches == 0)\n                return -1;\n\n            data_dispatch_init(task, this-&gt;repetition_count_between_dispatches);\n    }\n\n    /* Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /* Launch ADC conversion */\n    adc_start();\n\n    DataAPI::is_started = true;\n\n    return 0;\n}\n\nbool DataAPI::started()\n{\n    return DataAPI::is_started;\n}\n\nint8_t DataAPI::stop()\n{\n    if (DataAPI::is_started != true)\n        return -1;\n\n    adc_stop();\n\n    /* Free buffers storage */\n    if (DataAPI::converted_values_buffer != nullptr)\n    {\n        for (int adc_index = 0 ; adc_index &lt; ADC_COUNT ; adc_index++)\n        {\n            if (DataAPI::converted_values_buffer[adc_index] != nullptr)\n            {\n                for (int channel_index = 0 ;\n                     channel_index &lt; CHANNELS_PER_ADC ;\n                     channel_index++)\n                {\n                    delete DataAPI::converted_values_buffer[adc_index][channel_index];\n                }\n                delete DataAPI::converted_values_buffer[adc_index];\n            }\n        }\n        delete DataAPI::converted_values_buffer;\n        DataAPI::converted_values_buffer = nullptr;\n    }\n\n    DataAPI::is_started = false;\n\n    return 0;\n}\n\nvoid DataAPI::triggerAcquisition(adc_t adc_num)\n{\n    /*Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /*  Proceed */\n    uint8_t enabled_channels =\n                adc_get_enabled_channels_count(adc_num);\n    adc_trigger_software_conversion(adc_num, enabled_channels);\n}\n\nuint16_t* DataAPI::getRawValues(uint8_t pin_num,\n                                uint32_t&amp; number_of_values_acquired)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return this-&gt;getChannelRawValues(adc_num,\n                                     channel_num,\n                                     number_of_values_acquired);\n}\n\nfloat32_t* DataAPI::getValues(uint8_t pin_number,\n                              uint32_t&amp; number_of_values_acquired)\n{\n    adc_t adc_number = DataAPI::getCurrentAdcForPin(pin_number);\n    if (adc_number == UNKNOWN_ADC)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_number, pin_number);\n    if (channel_num == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return this-&gt;getChannelValues(adc_number,\n                                  channel_num,\n                                  number_of_values_acquired);\n}\n\nfloat32_t DataAPI::peekLatestValue(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return NO_VALUE;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return NO_VALUE;\n    }\n\n    return this-&gt;peekChannel(adc_num, channel_num);\n}\n\nfloat32_t DataAPI::getLatestValue(uint8_t pin_num, uint8_t* dataValid)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    return this-&gt;getChannelLatest(adc_num, channel_num, dataValid);\n}\n\nfloat32_t DataAPI::convertValue(uint8_t pin_num, uint16_t raw_value)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nvoid DataAPI::setConversionParametersLinear(uint8_t pin_num,\n                                            float32_t gain,\n                                            float32_t offset)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return;\n    }\n\n    data_conversion_set_conversion_parameters_linear(adc_num,\n                                                     channel_num,\n                                                     gain,\n                                                     offset);\n}\n\nvoid DataAPI::setConversionParametersNtcThermistor(uint8_t pin_num,\n                                                   float32_t r0,\n                                                   float32_t b,\n                                                   float32_t rdiv,\n                                                   float32_t t0)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return;\n    }\n\n    data_conversion_set_conversion_parameters_therm(adc_num,\n                                                    channel_num,\n                                                    r0,\n                                                    b,\n                                                    rdiv,\n                                                    t0);\n}\n\n\nfloat32_t DataAPI::getConversionParameterValue(uint8_t pin_num,\n                                               parameter_t parameter_name)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_get_parameter(adc_num,channel_num, parameter_name);\n}\n\nconversion_type_t DataAPI::getConversionParameterType(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return no_channel_error;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return no_channel_error;\n    }\n\n    return data_conversion_get_conversion_type(adc_num,channel_num);\n}\n\nint8_t DataAPI::storeConversionParametersInMemory(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_store_channel_parameters_in_nvs(adc_num, channel_num);\n}\n\n\nint8_t DataAPI::retrieveConversionParametersFromMemory(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_retrieve_channel_parameters_from_nvs(adc_num,\n                                                                channel_num);\n}\n\nvoid DataAPI::configureDiscontinuousMode(adc_t adc_number,\n                                         uint32_t discontinuous_count)\n{\n    /* Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /* Proceed */\n    adc_configure_discontinuous_mode(adc_number, discontinuous_count);\n}\n\nvoid DataAPI::configureTriggerSource(adc_t adc_number,\n                                     trigger_source_t trigger_source)\n{\n\n    if ( (adc_number == UNKNOWN_ADC) || (adc_number == DEFAULT_ADC) ) return;\n\n    /* Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /* Proceed */\n\n    if (trigger_source == TRIG_SOFTWARE)\n    {\n        adc_configure_trigger_source(adc_number, software);\n    }\n    else /* (trigger_source == TRIG_PWM) */\n    {\n        adc_ev_src_t event;\n        switch(adc_number)\n        {\n            case ADC_1:\n                event = hrtim_ev1;\n                break;\n            case ADC_2:\n                event = hrtim_ev3;\n                break;\n            case ADC_3:\n                event = hrtim_ev5;\n                break;\n            case ADC_4:\n                event = hrtim_ev7;\n                break;\n            case ADC_5:\n                event = hrtim_ev9;\n                break;\n            case UNKNOWN_ADC:\n            case DEFAULT_ADC:\n            default:\n                return;\n        }\n        adc_configure_trigger_source(adc_number, event);\n    }\n}\n\n/* Private functions */\n\nvoid DataAPI::initializeAllAdcs()\n{\n    if (DataAPI::adcInitialized == false)\n    {\n        /* Perform default configuration */\n        adc_configure_trigger_source(1, software);\n        adc_configure_trigger_source(2, software);\n        adc_configure_trigger_source(3, software);\n        adc_configure_trigger_source(4, software);\n        adc_configure_trigger_source(5, software);\n\n        DataAPI::adcInitialized = true;\n    }\n}\n\nint8_t DataAPI::enableChannel(adc_t adc_num, uint8_t channel_num)\n{\n    if (DataAPI::is_started == true)\n        return -1;\n\n    if ( (adc_num == 0) || (adc_num &gt; ADC_COUNT) )\n        return -1;\n\n    if ( (channel_num == 0) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return -1;\n\n\n    /* Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /* Enable DMA */\n    adc_configure_use_dma(adc_num, true);\n\n    /* Set channel for activation */\n    adc_add_channel(adc_num, channel_num);\n\n\n    /* Remember rank */\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n    DataAPI::current_rank[adc_index]++;\n    DataAPI::channels_ranks[adc_index][channel_index] =\n                                            DataAPI::current_rank[adc_index];\n\n    return 0;\n}\n\nvoid DataAPI::disableChannel(adc_t adc_num, uint8_t channel)\n{\n    /* Make sure module is initialized */\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    /* Proceed */\n    adc_remove_channel(adc_num, channel);\n}\n\nuint16_t* DataAPI::getChannelRawValues(adc_t adc_num,\n                                       uint8_t channel_num,\n                                       uint32_t&amp; number_of_values_acquired)\n{\n    if (DataAPI::is_started == false)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return data_dispatch_get_acquired_values(adc_num,\n                                             channel_rank,\n                                             number_of_values_acquired);\n}\n\nfloat32_t* DataAPI::getChannelValues(adc_t adc_number,\n                                     uint8_t channel_num,\n                                     uint32_t&amp; number_of_values_acquired)\n{\n    /* Check that API is started */\n    if (DataAPI::is_started == false)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    /* Get raw values */\n    uint16_t* raw_values =\n                DataAPI::getChannelRawValues(adc_number,\n                                             channel_num,\n                                             number_of_values_acquired);\n\n    if (number_of_values_acquired == 0)\n    {\n        return nullptr;\n    }\n\n    /* At least one value to convert: make sure a buffer is available */\n    uint8_t adc_index = (uint8_t)adc_number - 1;\n    uint8_t channel_index = channel_num - 1;\n    if (DataAPI::converted_values_buffer == nullptr)\n    {\n        DataAPI::converted_values_buffer = new float32_t**[ADC_COUNT];\n        for (int i = 0 ; i &lt; ADC_COUNT ; i++)\n        {\n            DataAPI::converted_values_buffer[i] = nullptr;\n        }\n    }\n    if (DataAPI::converted_values_buffer[adc_index] == nullptr)\n    {\n        DataAPI::converted_values_buffer[adc_index] =\n                                        new float32_t*[CHANNELS_PER_ADC];\n\n        for (int i = 0 ; i &lt; CHANNELS_PER_ADC ; i++)\n        {\n            DataAPI::converted_values_buffer[adc_index][i] = nullptr;\n        }\n    }\n    if (DataAPI::converted_values_buffer[adc_index][channel_index] == nullptr)\n    {\n        DataAPI::converted_values_buffer[adc_index][channel_index] =\n                                        new float32_t[CHANNELS_BUFFERS_SIZE];\n    }\n\n    /* Proceed to conversion */\n    for (uint32_t i = 0 ; i &lt; number_of_values_acquired ; i++)\n    {\n        DataAPI::converted_values_buffer[adc_index][channel_index][i] =\n                    data_conversion_convert_raw_value(adc_number,\n                                                      channel_num,\n                                                      raw_values[i]);\n    }\n\n    /* Return converted values buffer */\n    return DataAPI::converted_values_buffer[adc_index][channel_index];\n}\n\nfloat32_t DataAPI::peekChannel(adc_t adc_num, uint8_t channel_num)\n{\n    if (DataAPI::is_started == false)\n    {\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        return NO_VALUE;\n    }\n\n    uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num,\n                                                           channel_rank);\n    if (raw_value == PEEK_NO_VALUE)\n    {\n        return NO_VALUE;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nfloat32_t DataAPI::getChannelLatest(adc_t adc_num,\n                                    uint8_t channel_num,\n                                    uint8_t* dataValid)\n{\n    if (DataAPI::is_started == false)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint32_t data_count;\n    uint16_t* buffer = data_dispatch_get_acquired_values(adc_num,\n                                                         channel_rank,\n                                                         data_count);\n\n    if (data_count &gt; 0)\n    {\n        uint16_t raw_value = buffer[data_count - 1];\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_OK;\n        }\n        return data_conversion_convert_raw_value(adc_num,\n                                                 channel_num,\n                                                 raw_value);\n    }\n    else\n    {\n        uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num,\n                                                               channel_rank);\n\n        float32_t peekValue;\n        if (raw_value != PEEK_NO_VALUE)\n        {\n            peekValue = data_conversion_convert_raw_value(adc_num,\n                                                          channel_num,\n                                                          raw_value);\n        }\n        else\n        {\n            peekValue = NO_VALUE;\n        }\n\n        if (dataValid != nullptr)\n        {\n            if (peekValue != NO_VALUE)\n            {\n                *dataValid = DATA_IS_OLD;\n            }\n            else\n            {\n                *dataValid = DATA_IS_MISSING;\n            }\n        }\n        return peekValue;\n    }\n}\n\nuint8_t DataAPI::getChannelRank(adc_t adc_num, uint8_t channel_num)\n{\n    if ( (adc_num &gt; ADC_COUNT) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return 0;\n\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n\n    return DataAPI::channels_ranks[adc_index][channel_index];\n}\n\nuint8_t DataAPI::getChannelNumber(adc_t adc_num, uint8_t shield_pin)\n{\n    switch (adc_num)\n    {\n    case 1:\n        switch (shield_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 2:\n                return 11;\n                break;\n            case 5:\n                return 5;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 31:\n                return 5;\n                break;\n            case 37:\n                return 12;\n                break;\n            case 50:\n                return 3;\n                break;\n            case 51:\n                return 4;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 2:\n        switch (shield_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 6:\n                return 15;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 32:\n                return 13;\n                break;\n            case 34:\n                return 3;\n                break;\n            case 35:\n                return 5;\n                break;\n            case 42:\n                return 12;\n                break;\n            case 43:\n                return 11;\n                break;\n            case 44:\n                return 4;\n                break;\n            case 45:\n                return 17;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 3:\n        switch (shield_pin)\n        {\n            case 4:\n                return 5;\n                break;\n            case 31:\n                return 12;\n                break;\n            case 37:\n                return 1;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 4:\n        switch (shield_pin)\n        {\n            case 2:\n                return 3;\n                break;\n            case 5:\n                return 4;\n                break;\n            case 6:\n                return 5;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 5:\n        switch (shield_pin)\n        {\n            case 12:\n                return 1;\n                break;\n            case 14:\n                return 2;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    default:\n        return 0;\n        break;\n    }\n}\n\nadc_t DataAPI::getDefaultAdcForPin(uint8_t pin_number)\n{\n    switch (pin_number)\n    {\n        /* These pins allow only ADC 1 */\n        case 51:\n        case 52:\n        /* These pins allow ADC 1 and ADC 2: default to ADC 1 */\n        case 1:\n        case 24:\n        case 25:\n        case 26:\n        case 27:\n        case 29:\n        case 30:\n        /* These pins allow ADC 1 and ADC 3: default to ADC 1 */\n        case 31:\n        case 37:\n            return ADC_1;\n            break;\n        /* These pins allow only ADC 2 */\n        case 32:\n        case 34:\n        case 35:\n        case 42:\n        case 43:\n        case 44:\n        case 45:\n        /* This pin allows ADC 2 and ADC 4: default to ADC 2 */\n        case 5:\n            return ADC_2;\n            break;\n        /* This pin allows only ADC 3 */\n        case 4:\n            return ADC_3;\n            break;\n        /* This pin allows only ADC 4 */\n        case 2:\n            return ADC_4;\n            break;\n        /* This pin allows only ADC 5 */\n        case 12:\n        case 14:\n            return ADC_5;\n            break;\n        default:\n            return UNKNOWN_ADC;\n    }\n}\n\nadc_t DataAPI::getCurrentAdcForPin(uint8_t pin_number)\n{\n    if ( (pin_number &gt; 1) &amp;&amp; (pin_number &lt;=PIN_COUNT) )\n    {\n        adc_t currentAdc = DataAPI::current_adc[pin_number-1];\n\n        if (currentAdc != DEFAULT_ADC)\n        {\n            return currentAdc;\n        }\n    }\n\n    return UNKNOWN_ADC;\n}\n\nvoid DataAPI::setRepetitionsBetweenDispatches(uint32_t repetition)\n{\n    DataAPI::repetition_count_between_dispatches = repetition;\n}\n\nvoid DataAPI::setDispatchMethod(DispatchMethod_t dispatch_method)\n{\n    DataAPI::dispatch_method = dispatch_method;\n}\n\nvoid DataAPI::doFullDispatch()\n{\n    data_dispatch_do_full_dispatch();\n}\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/","title":"File DataAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DataAPI_8h/#classes","title":"Classes","text":"Type Name class DataAPI"},{"location":"powerAPI/DataAPI_8h/#public-types","title":"Public Types","text":"Type Name enum DispatchMethod_t enum int8_t adc_t enum uint8_t parameter_t enum uint8_t trigger_source_t"},{"location":"powerAPI/DataAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t DATA_IS_MISSING   = <code>2</code> const uint8_t DATA_IS_OK   = <code>0</code> const uint8_t DATA_IS_OLD   = <code>1</code> const float32_t NO_VALUE   = <code>-10000</code>"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t ADC_COUNT   = <code>5</code> const uint8_t CHANNELS_PER_ADC   = <code>19</code> const uint8_t PIN_COUNT   = <code>59</code>"},{"location":"powerAPI/DataAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#enum-dispatchmethod_t","title":"enum DispatchMethod_t","text":"<pre><code>enum DispatchMethod_t {\n    on_dma_interrupt,\n    externally_triggered\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-adc_t","title":"enum adc_t","text":"<pre><code>enum adc_t {\n    UNKNOWN_ADC = -1,\n    DEFAULT_ADC = 0,\n    ADC_1 = 1,\n    ADC_2 = 2,\n    ADC_3 = 3,\n    ADC_4 = 4,\n    ADC_5 = 5\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-parameter_t","title":"enum parameter_t","text":"<pre><code>enum parameter_t {\n    gain = 1,\n    offset = 2,\n    r0 = 3,\n    b = 4,\n    rdiv = 5,\n    t0 = 6\n};\n</code></pre> <p>Type definitions </p>"},{"location":"powerAPI/DataAPI_8h/#enum-trigger_source_t","title":"enum trigger_source_t","text":"<pre><code>enum trigger_source_t {\n    TRIG_SOFTWARE,\n    TRIG_PWM\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-data_is_missing","title":"variable DATA_IS_MISSING","text":"<pre><code>const uint8_t DATA_IS_MISSING;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_ok","title":"variable DATA_IS_OK","text":"<pre><code>const uint8_t DATA_IS_OK;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_old","title":"variable DATA_IS_OLD","text":"<pre><code>const uint8_t DATA_IS_OLD;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-no_value","title":"variable NO_VALUE","text":"<pre><code>const float32_t NO_VALUE;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-adc_count","title":"variable ADC_COUNT","text":"<pre><code>const uint8_t ADC_COUNT;\n</code></pre> <p>Constants definitions </p>"},{"location":"powerAPI/DataAPI_8h/#variable-channels_per_adc","title":"variable CHANNELS_PER_ADC","text":"<pre><code>const uint8_t CHANNELS_PER_ADC;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-pin_count","title":"variable PIN_COUNT","text":"<pre><code>const uint8_t PIN_COUNT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"powerAPI/DataAPI_8h_source/","title":"File DataAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Thomas Walter &lt;thomas.walter@laas.fr&gt;\n */\n\n\n#ifndef DATAAPI_H_\n#define DATAAPI_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n\n/* ARM CMSIS library */\n#include &lt;arm_math.h&gt;\n\n/* Current module private functions */\n#include \"./data/data_conversion.h\"\n\n\ntypedef enum : uint8_t\n{\n    gain   = 1,\n    offset = 2,\n    r0     = 3,\n    b      = 4,\n    rdiv   = 5,\n    t0     = 6\n} parameter_t;\n\ntypedef enum : int8_t\n{\n    UNKNOWN_ADC = -1,\n    DEFAULT_ADC = 0,\n    ADC_1 = 1,\n    ADC_2 = 2,\n    ADC_3 = 3,\n    ADC_4 = 4,\n    ADC_5 = 5\n} adc_t;\n\ntypedef enum : uint8_t\n{\n    TRIG_SOFTWARE,\n    TRIG_PWM\n} trigger_source_t;\n\nenum class DispatchMethod_t\n{\n    on_dma_interrupt,\n    externally_triggered\n};\n\n\nstatic const uint8_t ADC_COUNT = 5;\nstatic const uint8_t PIN_COUNT = 59;\nstatic const uint8_t CHANNELS_PER_ADC = 19;\n\n/* Define \"no value\" as an impossible, out of range value */\nconst float32_t NO_VALUE = -10000;\n#define ERROR_CHANNEL_OFF -5\n#define ERROR_CHANNEL_NOT_FOUND -2\n\nconst uint8_t DATA_IS_OK      = 0;\nconst uint8_t DATA_IS_OLD     = 1;\nconst uint8_t DATA_IS_MISSING = 2;\n\n\nclass DataAPI\n{\n    /* Allow specific external members to access private members of this class */\n    friend class SensorsAPI;\n    friend void user_task_proxy();\n    friend void scheduling_start_uninterruptible_synchronous_task(bool);\n\npublic:\n\n    int8_t enableAcquisition(uint8_t pin_number, adc_t adc_number = DEFAULT_ADC);\n\n    int8_t start();\n\n    bool started();\n\n    int8_t stop();\n\n    void triggerAcquisition(adc_t adc_number);\n\n    uint16_t* getRawValues(uint8_t pin_number,\n                           uint32_t&amp; number_of_values_acquired);\n\n    float32_t* getValues(uint8_t pin_number,\n                         uint32_t&amp; number_of_values_acquired);\n\n    float32_t peekLatestValue(uint8_t pin_number);\n\n    float32_t getLatestValue(uint8_t pin_number, uint8_t* dataValid = nullptr);\n\n    float32_t convertValue(uint8_t pin_number, uint16_t raw_value);\n\n    void setConversionParametersLinear(uint8_t pin_number,\n                                       float32_t gain,\n                                       float32_t offset);\n\n    void setConversionParametersNtcThermistor(uint8_t pin_num,\n                                              float32_t r0,\n                                              float32_t b,\n                                              float32_t rdiv,\n                                              float32_t t0);\n\n    float32_t getConversionParameterValue(uint8_t pin_number,\n                                          parameter_t parameter_name);\n\n    conversion_type_t getConversionParameterType(uint8_t pin_number);\n\n    int8_t storeConversionParametersInMemory(uint8_t pin_number);\n\n    int8_t retrieveConversionParametersFromMemory(uint8_t pin_number);\n\n    void configureDiscontinuousMode(adc_t adc_number,\n                                    uint32_t dicontinuous_count);\n\n    void configureTriggerSource(adc_t adc_number, trigger_source_t trigger_source);\n\nprivate:\n    static void initializeAllAdcs();\n\n    static int8_t enableChannel(adc_t adc_number, uint8_t channel_num);\n\n    static void disableChannel(adc_t adc_number, uint8_t channel);\n\n\n    static uint16_t* getChannelRawValues(adc_t adc_number,\n                                         uint8_t channel_num,\n                                         uint32_t&amp; number_of_values_acquired);\n\n\n    static float32_t* getChannelValues(adc_t adc_number,\n                                       uint8_t channel_num,\n                                       uint32_t&amp; number_of_values_acquired);\n\n    static float32_t peekChannel(adc_t adc_number, uint8_t channel_num);\n\n    static float32_t getChannelLatest(adc_t adc_number,\n                                      uint8_t channel_num,\n                                      uint8_t* dataValid = nullptr);\n\n    static uint8_t getChannelRank(adc_t adc_number, uint8_t channel_num);\n\n    static uint8_t getChannelNumber(adc_t adc_number, uint8_t shield_pin);\n\n    static adc_t getDefaultAdcForPin(uint8_t pin_number);\n\n    static adc_t getCurrentAdcForPin(uint8_t pin_number);\n\n    /* Private members accessed by external friend members */\n\n    static void setRepetitionsBetweenDispatches(uint32_t repetition);\n\n    static void setDispatchMethod(DispatchMethod_t dispatch_method);\n\n    static void doFullDispatch();\n\nprivate:\n    static bool is_started;\n    static bool adcInitialized;\n    static uint8_t channels_ranks[ADC_COUNT][CHANNELS_PER_ADC];\n    static uint8_t current_rank[ADC_COUNT];\n    static DispatchMethod_t dispatch_method;\n    static uint32_t repetition_count_between_dispatches;\n    static adc_t current_adc[PIN_COUNT];\n    static float32_t*** converted_values_buffer;\n\n};\n\n#endif /* DATAAPI_H_ */\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/","title":"File GpioHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(gpioa))</code>Owntech GPIO API. const struct device *const GPIO_B   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(gpiob))</code> const struct device *const GPIO_C   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(gpioc))</code> const struct device *const GPIO_D   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(gpiod))</code> const gpio_flags_t INPUT   = <code>GPIO\\_INPUT</code> const gpio_flags_t INPUT_PULLUP   = <code>GPIO\\_INPUT \\| GPIO\\_PULL\\_UP</code> const gpio_flags_t OUTPUT   = <code>GPIO\\_OUTPUT</code>"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.cpp</code></p>"},{"location":"powerAPI/GpioHAL_8cpp_source/","title":"File GpioHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n\n\n#include \"GpioHAL.h\"\n\nconst struct device* const GPIO_A = DEVICE_DT_GET(DT_NODELABEL(gpioa));\nconst struct device* const GPIO_B = DEVICE_DT_GET(DT_NODELABEL(gpiob));\nconst struct device* const GPIO_C = DEVICE_DT_GET(DT_NODELABEL(gpioc));\nconst struct device* const GPIO_D = DEVICE_DT_GET(DT_NODELABEL(gpiod));\n\nconst gpio_flags_t INPUT        = GPIO_INPUT;\nconst gpio_flags_t INPUT_PULLUP = GPIO_INPUT | GPIO_PULL_UP;\nconst gpio_flags_t OUTPUT       = GPIO_OUTPUT;\n\n\nvoid GpioHAL::configurePin(uint8_t pin, gpio_flags_t flags)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_configure(port, pin_number, flags);\n    }\n}\n\nvoid GpioHAL::setPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 1);\n    }\n}\n\nvoid GpioHAL::resetPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 0);\n    }\n}\n\nvoid GpioHAL::togglePin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_toggle(port, pin_number);\n    }\n}\n\nvoid GpioHAL::writePin(uint8_t pin, uint8_t value)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, value);\n    }\n}\n\nuint8_t GpioHAL::readPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        return (uint8_t) gpio_pin_get(port, pin_number);\n    }\n\n    return 0;\n}\n\ngpio_pin_t GpioHAL::getPinNumber(uint8_t pin)\n{\n    /* Nucleo format */\n    if ( (pin &amp; 0x80) != 0)\n    {\n        return (((uint8_t)pin) &amp; 0x0F);\n    }\n    /* Pin number */\n    else\n    {\n        if      (pin == 1)  return 11;\n        else if (pin == 2)  return 12;\n        else if (pin == 4)  return 13;\n        else if (pin == 5)  return 14;\n        else if (pin == 6)  return 15;\n        else if (pin == 7)  return 6;\n        else if (pin == 9)  return 7;\n        else if (pin == 10) return 8;\n        else if (pin == 11) return 9;\n        else if (pin == 12) return 8;\n        else if (pin == 14) return 9;\n        else if (pin == 15) return 10;\n        else if (pin == 16) return 10;\n        else if (pin == 17) return 11;\n        else if (pin == 19) return 12;\n        else if (pin == 20) return 4;\n        else if (pin == 21) return 9;\n        else if (pin == 22) return 13;\n        else if (pin == 24) return 0;\n        else if (pin == 25) return 1;\n        else if (pin == 26) return 2;\n        else if (pin == 27) return 3;\n        else if (pin == 29) return 0;\n        else if (pin == 30) return 1;\n        else if (pin == 31) return 0;\n        else if (pin == 32) return 5;\n        else if (pin == 34) return 6;\n        else if (pin == 35) return 4;\n        else if (pin == 37) return 1;\n        else if (pin == 41) return 10;\n        else if (pin == 42) return 2;\n        else if (pin == 43) return 5;\n        else if (pin == 44) return 7;\n        else if (pin == 45) return 4;\n        else if (pin == 46) return 13;\n        else if (pin == 47) return 14;\n        else if (pin == 48) return 15;\n        else if (pin == 49) return 2;\n        else if (pin == 50) return 3;\n        else if (pin == 51) return 2;\n        else if (pin == 52) return 3;\n        else if (pin == 53) return 5;\n        else if (pin == 55) return 6;\n        else if (pin == 56) return 7;\n        else if (pin == 58) return 8;\n    }\n    return 0xFF;\n}\n\nconst struct device* GpioHAL::getGpioDevice(uint8_t pin)\n{\n    /* Nucleo format */\n    if ( (pin &amp; 0x80) != 0)\n    {\n        uint8_t deviceNumber = ((uint8_t)pin) &amp; 0xF0;\n        switch (deviceNumber)\n        {\n            case PA:\n                return GPIO_A;\n                break;\n            case PB:\n                return GPIO_B;\n                break;\n            case PC:\n                return GPIO_C;\n                break;\n            case PD:\n                return GPIO_D;\n                break;\n        }\n    }\n    /* Pin number */\n    else\n    {\n        switch (pin)\n        {\n            case 12:\n            case 14:\n            case 15:\n            case 29:\n            case 30:\n            case 32:\n            case 34:\n            case 44:\n            case 45:\n            case 46:\n            case 47:\n            case 48:\n            case 51:\n            case 52:\n                return GPIO_A;\n                break;\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n            case 6:\n            case 20:\n            case 21:\n            case 31:\n            case 37:\n            case 41:\n            case 42:\n            case 50:\n            case 53:\n            case 55:\n            case 56:\n            case 58:\n                return GPIO_B;\n                break;\n            case 7:\n            case 9:\n            case 10:\n            case 11:\n            case 16:\n            case 17:\n            case 19:\n            case 22:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 35:\n            case 43:\n                return GPIO_C;\n                break;\n            case 49:\n                return GPIO_D;\n                break;\n        }\n    }\n\n    return nullptr;\n}\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/","title":"File GpioHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8h/#classes","title":"Classes","text":"Type Name class GpioHAL"},{"location":"powerAPI/GpioHAL_8h/#public-types","title":"Public Types","text":"Type Name enum uint8_t pin_t"},{"location":"powerAPI/GpioHAL_8h/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A Owntech GPIO API. const struct device *const GPIO_B const struct device *const GPIO_C const struct device *const GPIO_D const gpio_flags_t INPUT const gpio_flags_t INPUT_PULLUP const gpio_flags_t OUTPUT"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t P0   = <code>0x0</code> const uint8_t P1   = <code>0x1</code> const uint8_t P10   = <code>0xA</code> const uint8_t P11   = <code>0xB</code> const uint8_t P12   = <code>0xC</code> const uint8_t P13   = <code>0xD</code> const uint8_t P14   = <code>0xE</code> const uint8_t P15   = <code>0xF</code> const uint8_t P2   = <code>0x2</code> const uint8_t P3   = <code>0x3</code> const uint8_t P4   = <code>0x4</code> const uint8_t P5   = <code>0x5</code> const uint8_t P6   = <code>0x6</code> const uint8_t P7   = <code>0x7</code> const uint8_t P8   = <code>0x8</code> const uint8_t P9   = <code>0x9</code> const uint8_t PA   = <code>0x80 \\| 0x00</code> const uint8_t PB   = <code>0x80 \\| 0x10</code> const uint8_t PC   = <code>0x80 \\| 0x20</code> const uint8_t PD   = <code>0x80 \\| 0x30</code>"},{"location":"powerAPI/GpioHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#enum-pin_t","title":"enum pin_t","text":"<pre><code>enum pin_t {\n    PA0 = PA | P0,\n    PA1 = PA | P1,\n    PA2 = PA | P2,\n    PA3 = PA | P3,\n    PA4 = PA | P4,\n    PA5 = PA | P5,\n    PA6 = PA | P6,\n    PA7 = PA | P7,\n    PA8 = PA | P8,\n    PA9 = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0 = PB | P0,\n    PB1 = PB | P1,\n    PB2 = PB | P2,\n    PB3 = PB | P3,\n    PB4 = PB | P4,\n    PB5 = PB | P5,\n    PB6 = PB | P6,\n    PB7 = PB | P7,\n    PB8 = PB | P8,\n    PB9 = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0 = PC | P0,\n    PC1 = PC | P1,\n    PC2 = PC | P2,\n    PC3 = PC | P3,\n    PC4 = PC | P4,\n    PC5 = PC | P5,\n    PC6 = PC | P6,\n    PC7 = PC | P7,\n    PC8 = PC | P8,\n    PC9 = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0 = PD | P0,\n    PD1 = PD | P1,\n    PD2 = PD | P2,\n    PD3 = PD | P3\n};\n</code></pre> <p>Public types </p>"},{"location":"powerAPI/GpioHAL_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Public constants</p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-p0","title":"variable P0","text":"<pre><code>const uint8_t P0;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p1","title":"variable P1","text":"<pre><code>const uint8_t P1;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p10","title":"variable P10","text":"<pre><code>const uint8_t P10;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p11","title":"variable P11","text":"<pre><code>const uint8_t P11;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p12","title":"variable P12","text":"<pre><code>const uint8_t P12;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p13","title":"variable P13","text":"<pre><code>const uint8_t P13;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p14","title":"variable P14","text":"<pre><code>const uint8_t P14;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p15","title":"variable P15","text":"<pre><code>const uint8_t P15;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p2","title":"variable P2","text":"<pre><code>const uint8_t P2;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p3","title":"variable P3","text":"<pre><code>const uint8_t P3;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p4","title":"variable P4","text":"<pre><code>const uint8_t P4;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p5","title":"variable P5","text":"<pre><code>const uint8_t P5;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p6","title":"variable P6","text":"<pre><code>const uint8_t P6;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p7","title":"variable P7","text":"<pre><code>const uint8_t P7;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p8","title":"variable P8","text":"<pre><code>const uint8_t P8;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p9","title":"variable P9","text":"<pre><code>const uint8_t P9;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pa","title":"variable PA","text":"<pre><code>const uint8_t PA;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pb","title":"variable PB","text":"<pre><code>const uint8_t PB;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pc","title":"variable PC","text":"<pre><code>const uint8_t PC;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pd","title":"variable PD","text":"<pre><code>const uint8_t PD;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/GpioHAL_8h_source/","title":"File GpioHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n\n#ifndef GPIOHAL_H_\n#define GPIOHAL_H_\n\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n\n\nextern const struct device* const GPIO_A;\nextern const struct device* const GPIO_B;\nextern const struct device* const GPIO_C;\nextern const struct device* const GPIO_D;\n\nextern const gpio_flags_t INPUT;\nextern const gpio_flags_t INPUT_PULLUP;\nextern const gpio_flags_t OUTPUT;\n\n/* 0x80 is used to indicate nucleo-style pin */\nstatic const uint8_t PA = 0x80 | 0x00;\nstatic const uint8_t PB = 0x80 | 0x10;\nstatic const uint8_t PC = 0x80 | 0x20;\nstatic const uint8_t PD = 0x80 | 0x30;\n\nstatic const uint8_t P0  = 0x0;\nstatic const uint8_t P1  = 0x1;\nstatic const uint8_t P2  = 0x2;\nstatic const uint8_t P3  = 0x3;\nstatic const uint8_t P4  = 0x4;\nstatic const uint8_t P5  = 0x5;\nstatic const uint8_t P6  = 0x6;\nstatic const uint8_t P7  = 0x7;\nstatic const uint8_t P8  = 0x8;\nstatic const uint8_t P9  = 0x9;\nstatic const uint8_t P10 = 0xA;\nstatic const uint8_t P11 = 0xB;\nstatic const uint8_t P12 = 0xC;\nstatic const uint8_t P13 = 0xD;\nstatic const uint8_t P14 = 0xE;\nstatic const uint8_t P15 = 0xF;\n\n\n\ntypedef enum : uint8_t\n{\n    PA0  = PA | P0,\n    PA1  = PA | P1,\n    PA2  = PA | P2,\n    PA3  = PA | P3,\n    PA4  = PA | P4,\n    PA5  = PA | P5,\n    PA6  = PA | P6,\n    PA7  = PA | P7,\n    PA8  = PA | P8,\n    PA9  = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0  = PB | P0,\n    PB1  = PB | P1,\n    PB2  = PB | P2,\n    PB3  = PB | P3,\n    PB4  = PB | P4,\n    PB5  = PB | P5,\n    PB6  = PB | P6,\n    PB7  = PB | P7,\n    PB8  = PB | P8,\n    PB9  = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0  = PC | P0,\n    PC1  = PC | P1,\n    PC2  = PC | P2,\n    PC3  = PC | P3,\n    PC4  = PC | P4,\n    PC5  = PC | P5,\n    PC6  = PC | P6,\n    PC7  = PC | P7,\n    PC8  = PC | P8,\n    PC9  = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0  = PD | P0,\n    PD1  = PD | P1,\n    PD2  = PD | P2,\n    PD3  = PD | P3\n} pin_t;\n\n\n\nclass GpioHAL\n{\npublic:\n\n    void configurePin(uint8_t pin, gpio_flags_t flags);\n\n    void setPin(uint8_t pin);\n\n    void resetPin(uint8_t pin);\n\n    void togglePin(uint8_t pin);\n\n    void writePin(uint8_t pin, uint8_t value);\n\n    uint8_t readPin(uint8_t pin);\n\nprivate:\n    gpio_pin_t getPinNumber(uint8_t pin);\n\n\n    const struct device* getGpioDevice(uint8_t pin);\n\n};\n\n#endif /* GPIOHAL_H_ */\n</code></pre>"},{"location":"powerAPI/LedHAL_8cpp/","title":"File LedHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name struct gpio_dt_spec led_pin_spec   = <code>/* multi line expression */</code>"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/LedHAL_8cpp/#variable-led_pin_spec","title":"variable led_pin_spec","text":"<pre><code>struct gpio_dt_spec led_pin_spec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.cpp</code></p>"},{"location":"powerAPI/LedHAL_8cpp_source/","title":"File LedHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n/* Current file header */\n#include \"LedHAL.h\"\n\n\nbool LedHAL::ledInitialized = false;\n\nstatic struct gpio_dt_spec led_pin_spec =\n                            GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\n\n\nvoid LedHAL::initialize()\n{\n    gpio_pin_configure_dt(&amp;led_pin_spec, GPIO_OUTPUT_INACTIVE);\n    ledInitialized = true;\n}\n\nvoid LedHAL::turnOn()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 1);\n}\n\nvoid LedHAL::turnOff()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 0);\n}\n\nvoid LedHAL::toggle()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_toggle_dt(&amp;led_pin_spec);\n}\n</code></pre>"},{"location":"powerAPI/LedHAL_8h/","title":"File LedHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8h/#classes","title":"Classes","text":"Type Name class LedHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/LedHAL_8h_source/","title":"File LedHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n\n\n#ifndef LEDHAL_H_\n#define LEDHAL_H_\n\nclass LedHAL\n{\npublic:\n    void turnOn();\n\n    void turnOff();\n\n    void toggle();\n\nprivate:\n    void initialize();\n\n    static bool ledInitialized;\n\n};\n\n\n\n#endif /* LED_H_ */\n</code></pre>"},{"location":"powerAPI/PwmHAL_8cpp/","title":"File PwmHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.cpp</code></p>"},{"location":"powerAPI/PwmHAL_8cpp_source/","title":"File PwmHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n/* OwnTech Power API */\n\n/* Current file header */\n#include \"PwmHAL.h\"\n/* PWM management layer by inverter leg interface */\n#include \"hrtim.h\"\n\nvoid PwmHAL::initUnit(hrtim_tu_number_t pwmX)\n{\n    period[pwmX] = hrtim_tu_init(pwmX);\n}\n\nvoid PwmHAL::startDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_en(pwmX);\n}\n\nvoid PwmHAL::stopDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_dis(pwmX);\n}\n\nvoid PwmHAL::startSingleOutput(hrtim_tu_number_t tu,\n                               hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::stopSingleOutput(hrtim_tu_number_t tu,\n                              hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_set_modulation(pwmX, modulation);\n}\n\nvoid PwmHAL::setSwitchConvention(hrtim_tu_number_t pwmX,\n                                 hrtim_switch_convention_t convention) \n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_set_switch_convention(pwmX, convention);\n}\n\nvoid PwmHAL::initVariableFrequency(uint32_t initial_frequency,\n                                   uint32_t minimal_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        /* Initialize default parameters before */\n        hrtim_init_default_all();\n    hrtim_frequency_set(initial_frequency, minimal_frequency);\n}\n\nvoid PwmHAL::initFixedFrequency(uint32_t fixed_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        /* Initialize default parameters before */\n        hrtim_init_default_all();\n    hrtim_frequency_set(fixed_frequency, fixed_frequency);\n}\n\nvoid PwmHAL::setDeadTime(hrtim_tu_number_t pwmX,\n                         uint16_t rise_ns,\n                         uint16_t fall_ns)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_dt_set(pwmX, rise_ns, fall_ns);\n}\n\nvoid PwmHAL::setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle)\n{\n    uint16_t period = tu_channel[pwmX]-&gt;pwm_conf.period;\n    uint16_t value = duty_cycle * period;\n\n    setDutyCycleRaw(pwmX,value);\n\n}\n\nvoid PwmHAL::setDutyCycleRaw(hrtim_tu_number_t pwmX, uint16_t duty_cycle)\n{\n    timer_hrtim_t *tu = tu_channel[pwmX]; /* Get pointer to timer unit config */\n    uint16_t previous_duty_cycle = tu-&gt;pwm_conf.duty_cycle; \n    /* Store previously set duty cycle */\n\n    if (previous_duty_cycle == duty_cycle) {\n        return; /* Skip update if duty cycle has not changed */\n    }\n\n    uint16_t period = tu-&gt;pwm_conf.period;         /* Get PWM period */\n    bool swap_state = tu-&gt;pwm_conf.duty_swap;      /* Get output swap state */\n\n    /* True if near 100% duty */\n    bool over_limit = (duty_cycle &gt;= period - 3); \n\n    /* Force 0% to avoid glitches near 100% */\n    duty_cycle = over_limit ? 0 : duty_cycle; \n\n    /* Flip outputs only if needed to preserve polarity */\n    bool force_swap = swap_state ^ over_limit; \n\n    /* Write new duty cycle to HRTIM registers */\n    hrtim_duty_cycle_set(pwmX, duty_cycle); \n\n    if (force_swap) {\n        hrtim_output_hot_swap(pwmX); \n        /* Flip the outputs (high \u2194 low) */\n    }\n}\n\n\n\nvoid PwmHAL::setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift)\n{\n    /* modulo */\n    int16_t phase_shift_degree = shift % 360;\n    if (phase_shift_degree &lt; 0)\n        /* case of negative phase */\n        phase_shift_degree += 360;\n    uint16_t period;\n    if (pwmX != PWMB)\n    {\n        period = hrtim_period_get(pwmX);\n        if (hrtim_get_modulation(pwmX) == UpDwn)\n            period = 2 * period;\n    }\n    else if (pwmX == PWMB)\n    {\n        period = hrtim_period_get(PWMA);\n    }\n    uint16_t phase_shift_int = (period * phase_shift_degree) / 360;\n    hrtim_phase_shift_set(pwmX, phase_shift_int);\n}\n\nhrtim_cnt_t PwmHAL::getModulation(hrtim_tu_number_t pwmX) {\n    return hrtim_get_modulation(pwmX);\n}\n\nhrtim_switch_convention_t PwmHAL::getSwitchConvention(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_switch_convention(pwmX);\n}\n\nuint16_t PwmHAL::getPeriod(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get(pwmX);\n}\n\nuint16_t PwmHAL::getPeriodMax(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_max_period(pwmX);\n}\n\nuint16_t PwmHAL::getPeriodMin(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_min_period(pwmX);\n}\n\nvoid PwmHAL::setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio)\n{\n\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_adc_trigger_set_postscaler(pwmX, ps_ratio);\n}\n\nvoid PwmHAL::enableAdcTrigger(hrtim_tu_number_t pwmX)\n{\n    /* Initial trigger value when you enable the adc trigger */\n    uint16_t initial_trigger_value;\n    hrtim_adc_trigger_en(pwmX);\n    if (hrtim_get_modulation(pwmX) == UpDwn)\n    {\n        initial_trigger_value = 0.06 * hrtim_period_get(pwmX);\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n    else\n    {\n        initial_trigger_value = 100;\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n}\n\nvoid PwmHAL::setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    uint16_t trigger_value_int = trig_val * hrtim_period_get(pwmX);\n    hrtim_tu_cmp_set(pwmX, CMP3xR, trigger_value_int);\n}\n\nvoid PwmHAL::disableAdcTrigger(hrtim_tu_number_t tu_number)\n{\n    hrtim_adc_trigger_dis(tu_number);\n}\n\nvoid PwmHAL::configurePeriodEvnt(hrtim_tu_t PWM_tu,\n                                 uint32_t repetition,\n                                 hrtim_callback_t callback)\n{\n    hrtim_PeriodicEvent_configure(PWM_tu, repetition, callback);\n}\n\nvoid PwmHAL::enablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_en(PWM_tu);\n}\n\nvoid PwmHAL::disablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_dis(PWM_tu);\n}\n\nvoid PwmHAL::setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition)\n{\n    hrtim_PeriodicEvent_SetRep(PWM_tu, repetition);\n}\n\nuint32_t PwmHAL::getPeriodEvntRep(hrtim_tu_t PWM_tu)\n{\n    return hrtim_PeriodicEvent_GetRep(PWM_tu);\n}\n\nuint32_t PwmHAL::getPeriodUs(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get_us(pwmX);\n}\n\nvoid PwmHAL::setAdcEdgeTrigger(hrtim_tu_number_t pwmX,\n                               hrtim_adc_edgetrigger_t adc_edge_trigger)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_adc_rollover_set(pwmX, adc_edge_trigger);\n}\n\nhrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger(hrtim_tu_number_t pwmX)\n{\n    return hrtim_adc_rollover_get(pwmX);\n}\n\nvoid PwmHAL::setAdcTrigger(hrtim_tu_number_t pwmX, adc_t adc)\n{\n    // Get trigger depending on ADC number,\n    // and make sure the ADC is correct.\n    hrtim_adc_trigger_t adc_trig;\n    switch(adc)\n    {\n        case ADC_1:\n            adc_trig = ADCTRIG_1;\n            break;\n        case ADC_2:\n            adc_trig = ADCTRIG_3;\n            break;\n        case ADC_3:\n            adc_trig = ADCTRIG_5;\n            break;\n        case ADC_4:\n            adc_trig = ADCTRIG_7;\n            break;\n        case ADC_5:\n            adc_trig = ADCTRIG_9;\n            break;\n        case UNKNOWN_ADC:\n        case DEFAULT_ADC:\n        default:\n            return;\n    }\n\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_adc_trigger_set(pwmX, adc_trig);\n}\n\nadc_t PwmHAL::getAdcTrigger(hrtim_tu_number_t pwmX)\n{\n    hrtim_adc_trigger_t adc_trig = hrtim_adc_trigger_get(pwmX);\n\n    switch(adc_trig)\n    {\n        case ADCTRIG_1:\n            return ADC_1;\n            break;\n        case ADCTRIG_3:\n            return ADC_2;\n            break;\n        case ADCTRIG_5:\n            return ADC_3;\n            break;\n        case ADCTRIG_7:\n            return ADC_4;\n            break;\n        case ADCTRIG_9:\n            return ADC_5;\n            break;\n        default:\n            return UNKNOWN_ADC;\n    }\n}\n\nvoid PwmHAL::setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_pwm_mode_set(pwmX, mode);\n}\n\nhrtim_pwm_mode_t PwmHAL::getMode(hrtim_tu_number_t pwmX)\n{\n    return hrtim_pwm_mode_get(pwmX);\n}\n\nvoid PwmHAL::setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n    hrtim_eev_set(pwmX, eev);\n}\n\nhrtim_external_trigger_t PwmHAL::getEev(hrtim_tu_number_t pwmX)\n{\n    return hrtim_eev_get(pwmX);\n}\n\nvoid PwmHAL::setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation)\n{\n    if (!hrtim_get_status(pwmX))\n    {\n        hrtim_init_default_all(); /* Initialize default parameters before */\n    }\n\n\n    if (decimation &gt; 32)\n        decimation = 32;\n    else if (decimation &lt; 1)\n        decimation = 1;\n    hrtim_adc_trigger_set_postscaler(pwmX, decimation - 1);\n}\n\nvoid PwmHAL::setFrequency(uint32_t frequency_update)\n{\n    if (!hrtim_get_status(PWMA))\n    /* Initialize default parameters before */\n        hrtim_init_default_all();\n\n    hrtim_change_frequency(frequency_update);\n}\n\nuint32_t PwmHAL::getFrequencyMax(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_max_frequency(pwmX);\n}\n\nuint32_t PwmHAL::getFrequencyMin(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_min_frequency(pwmX);\n}\n\nuint32_t PwmHAL::getResolutionPs(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_resolution_ps(pwmX);\n}\n\n\nvoid PwmHAL::initBurstMode()\n{\n    hrtim_burst_mode_init();\n}\n\nvoid PwmHAL::setBurstMode(int bm_cmp, int bm_per)\n{\n    hrtim_burst_set(bm_cmp, bm_per);\n}\n\nvoid PwmHAL::startBurstMode()\n{\n    hrtim_burst_start();\n}\n\nvoid PwmHAL::stopBurstMode()\n{\n    hrtim_burst_stop();\n}\n\nvoid PwmHAL::deInitBurstMode()\n{\n    hrtim_burst_dis();\n}\n</code></pre>"},{"location":"powerAPI/PwmHAL_8h/","title":"File PwmHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/PwmHAL_8h/#classes","title":"Classes","text":"Type Name class PwmHAL Handles all pwm signals for the spin board."},{"location":"powerAPI/PwmHAL_8h/#public-types","title":"Public Types","text":"Type Name enum inverter_modulation_t enum leg_operation_t"},{"location":"powerAPI/PwmHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/PwmHAL_8h/#enum-inverter_modulation_t","title":"enum inverter_modulation_t","text":"<pre><code>enum inverter_modulation_t {\n    unipolar,\n    bipolar\n};\n</code></pre> <p>Inverter leg operation type. </p>"},{"location":"powerAPI/PwmHAL_8h/#enum-leg_operation_t","title":"enum leg_operation_t","text":"<pre><code>enum leg_operation_t {\n    buck,\n    boost\n};\n</code></pre> <p>Switch leg operation type. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/PwmHAL_8h_source/","title":"File PwmHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n#ifndef PWMHAL_H_\n#define PWMHAL_H_\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* ARM lib */\n#include &lt;arm_math.h&gt;\n\n/* OwnTech API */\n#include \"DataAPI.h\"\n#include \"hrtim_enum.h\"\n\ntypedef enum\n{\n     buck,\n     boost\n} leg_operation_t;\n\ntypedef enum\n{\n     unipolar,\n     bipolar\n} inverter_modulation_t;\n\nclass PwmHAL\n{\npublic:\n     /* HRTIM configuration */\n\n     void initUnit(hrtim_tu_number_t pwmX);\n\n     void startDualOutput(hrtim_tu_number_t pwmX);\n\n     void stopDualOutput(hrtim_tu_number_t pwmX);\n\n     void startSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void stopSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation);\n\n     void setSwitchConvention(hrtim_tu_number_t pwmX,\n                              hrtim_switch_convention_t convention);\n\n     void initFixedFrequency(uint32_t fixed_frequency);\n\n     void initVariableFrequency(uint32_t initial_frequency,\n                                uint32_t minimal_frequency);\n\n     void setDeadTime(hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns);\n\n     void setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle);\n\n     void setDutyCycleRaw(hrtim_tu_number_t pwmX, uint16_t duty_cycle);\n\n\n     void setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift);\n\n     void setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode);\n\n     hrtim_pwm_mode_t getMode(hrtim_tu_number_t pwmX);\n\n     void setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev);\n\n     hrtim_external_trigger_t getEev(hrtim_tu_number_t pwmX);\n\n     hrtim_cnt_t getModulation(hrtim_tu_number_t pwmX);\n\n     hrtim_switch_convention_t getSwitchConvention(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriod(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriodMax(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriodMin(hrtim_tu_number_t pwmX);\n\n     void setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio);\n\n     void setAdcTrigger(hrtim_tu_number_t pwmX, adc_t adc);\n\n     adc_t getAdcTrigger(hrtim_tu_number_t pwmX);\n\n     void enableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void disableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val);\n\n     void setAdcEdgeTrigger(hrtim_tu_number_t pwmX,\n                            hrtim_adc_edgetrigger_t adc_edge_trigger);\n\n     hrtim_adc_edgetrigger_t getAdcEdgeTrigger(hrtim_tu_number_t pwmX);\n\n     void setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation);\n\n     void disablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     void setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition);\n\n     uint32_t getPeriodEvntRep(hrtim_tu_t PWM_tu);\n\n     void configurePeriodEvnt(hrtim_tu_t PWM_tu,\n                              uint32_t repetition,\n                              hrtim_callback_t callback);\n\n     void enablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     uint32_t getPeriodUs(hrtim_tu_number_t pwmX);\n\n     void setFrequency(uint32_t frequency_update);\n\n     uint32_t getFrequencyMin(hrtim_tu_number_t pwmX);\n\n     uint32_t getFrequencyMax(hrtim_tu_number_t pwmX);\n\n     uint32_t getResolutionPs(hrtim_tu_number_t pwmX);\n\n     void initBurstMode();\n\n     void setBurstMode(int bm_cmp, int bm_per);\n\n     void startBurstMode();\n\n     void stopBurstMode();\n\n     void deInitBurstMode();\n\nprivate:\n\n     bool swap_state[HRTIM_CHANNELS] = {false};\n     uint16_t period[HRTIM_CHANNELS] = {0};\n\n};\n\n#endif /* PWMHAL_H_ */\n</code></pre>"},{"location":"powerAPI/TimerHAL_8cpp/","title":"File TimerHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * timer3   = <code>DEVICE\\_DT\\_GET(TIMER3\\_DEVICE)</code> const struct device * timer4   = <code>DEVICE\\_DT\\_GET(TIMER4\\_DEVICE)</code>"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/TimerHAL_8cpp/#variable-timer3","title":"variable timer3","text":"<pre><code>const struct device* timer3;\n</code></pre>"},{"location":"powerAPI/TimerHAL_8cpp/#variable-timer4","title":"variable timer4","text":"<pre><code>const struct device* timer4;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.cpp</code></p>"},{"location":"powerAPI/TimerHAL_8cpp_source/","title":"File TimerHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n\n/* Current file header */\n#include \"TimerHAL.h\"\n\n\nstatic const struct device* timer4 = DEVICE_DT_GET(TIMER4_DEVICE);\nstatic const struct device* timer3 = DEVICE_DT_GET(TIMER3_DEVICE);\n\nbool TimerHAL::timer4init    = false;\nbool TimerHAL::timer4started = false;\nbool TimerHAL::timer3init    = false;\nbool TimerHAL::timer3started = false;\n\n\nvoid TimerHAL::Initialize(timernumber_t timer_number)\n{\n    if (timer_number == TIMER4){\n        if (device_is_ready(timer4) == true)\n        {\n            /* Configure timer */\n            struct timer_config_t timer_cfg =\n            {\n                .timer_enable_irq = 0,\n                .timer_enable_encoder = 1,\n                .timer_enc_pin_mode = pull_up\n\n            };\n            timer_config(timer4, &amp;timer_cfg);\n            timer4init = true;\n        }\n    }else{\n        if (device_is_ready(timer3) == true)\n        {\n            /* Configure timer */\n            struct timer_config_t timer_cfg =\n            {\n                .timer_enable_irq = 0,\n                .timer_enable_encoder = 1,\n                .timer_enc_pin_mode = pull_up\n\n            };\n            timer_config(timer3, &amp;timer_cfg);\n            timer3init = true;\n        }\n\n    }\n}\n\nvoid TimerHAL::startLogIncrementalEncoder(timernumber_t timer_number)\n{\n    if(timer_number == TIMER4){\n        if (timer4init == false)\n        {\n            Initialize(TIMER4);\n        }\n\n        if (timer4started == false)\n        {\n            if (device_is_ready(timer4) == true)\n            {\n                timer_start(timer4);\n                timer4started = true;\n            }\n        }\n    }else{\n        if (timer3init == false)\n        {\n            Initialize(TIMER3);\n        }\n\n        if (timer3started == false)\n        {\n            if (device_is_ready(timer3) == true)\n            {\n                timer_start(timer3);\n                timer3started = true;\n            }\n        }\n\n    }\n}\n\nuint32_t TimerHAL::getIncrementalEncoderValue(timernumber_t timer_number)\n{\n    if(timer_number == TIMER4){\n        if (timer4started == true)\n        {\n            return timer_get_count(timer4);\n        }\n        else\n        {\n            return 0;\n        }\n    }else{\n        if (timer3started == true)\n        {\n            return timer_get_count(timer3);\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n}\n</code></pre>"},{"location":"powerAPI/TimerHAL_8h/","title":"File TimerHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8h/#classes","title":"Classes","text":"Type Name class TimerHAL Handles timer 4 for the SPIN board."},{"location":"powerAPI/TimerHAL_8h/#public-types","title":"Public Types","text":"Type Name enum timernumber_t"},{"location":"powerAPI/TimerHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/TimerHAL_8h/#enum-timernumber_t","title":"enum timernumber_t","text":"<pre><code>enum timernumber_t {\n    TIMER3,\n    TIMER4\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/TimerHAL_8h_source/","title":"File TimerHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n#ifndef TIMERHAL_H_\n#define TIMERHAL_H_\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* ARM lib */\n#include &lt;arm_math.h&gt;\n\n/* OwnTech API */\n#include \"timer.h\"\n\n\ntypedef enum\n{\n     TIMER3,\n     TIMER4\n} timernumber_t;\n\n\nclass TimerHAL\n{\npublic:\n\n    void startLogIncrementalEncoder(timernumber_t timer_number);\n\n    uint32_t getIncrementalEncoderValue(timernumber_t timer_number);\n\n\n\nprivate:\n\n    void Initialize(timernumber_t timer_number);\n\n    /* Variables */\n    static bool timer4init;\n    static bool timer4started;\n    static bool timer3init;\n    static bool timer3started;\n\n\n};\n\n\n\n#endif /* TIMERHAL_H_ */\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/","title":"File UartHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name char buf_req bool command_flag   = <code>false</code> const struct device * uart_dev   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(usart1))</code>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _uart_usart1_process_input (const struct device * dev, void * user_data)"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#variable-buf_req","title":"variable buf_req","text":"<pre><code>char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-command_flag","title":"variable command_flag","text":"<pre><code>bool command_flag;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#function-_uart_usart1_process_input","title":"function _uart_usart1_process_input","text":"<pre><code>static void _uart_usart1_process_input (\n    const struct device * dev,\n    void * user_data\n) \n</code></pre> <p>USART 1 private functions </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.cpp</code></p>"},{"location":"powerAPI/UartHAL_8cpp_source/","title":"File UartHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* STM 32 LL */\n#include &lt;stm32_ll_lpuart.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n/* Current file header */\n#include \"UartHAL.h\"\n\n\n#define CONFIG_OWNTECH_SERIAL_TX_BUF_SIZE 5\n#define CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE 5\n#define USART1_DEVICE DT_PROP(DT_NODELABEL(usart1), label)\n\nstatic const struct device* uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart1));\nstatic char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\nstatic bool command_flag = false;\n\n\nstatic void _uart_usart1_process_input(const struct device *dev,\n                                       void* user_data)\n{\n    uint8_t c;\n\n    if (!uart_irq_update(uart_dev)) {\n        printk(\"no data \\n\");\n        return;\n    }\n\n    while (uart_irq_rx_ready(uart_dev) &amp;&amp; command_flag == false) {\n        uart_fifo_read(uart_dev, &amp;c, 1);\n        printk(\"received %c \\n\",c);\n        buf_req[0] = c;\n        command_flag = true;\n    }\n}\n\n\nvoid UartHAL::usart1Init()\n{\n    const struct uart_config usart1_config =\n    {\n        .baudrate  = 9600,\n        .parity    = UART_CFG_PARITY_NONE,\n        .stop_bits = UART_CFG_STOP_BITS_1,\n        .data_bits = UART_CFG_DATA_BITS_8,\n        .flow_ctrl = UART_CFG_FLOW_CTRL_NONE\n    };\n\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_configure(uart_dev, &amp;usart1_config);\n\n        uart_irq_callback_user_data_set(uart_dev,\n                                        _uart_usart1_process_input,\n                                        NULL);\n\n        uart_irq_rx_enable(uart_dev);\n    }\n}\n\nchar UartHAL::usart1ReadChar()\n{\n    if (command_flag){\n        command_flag = false;\n        return buf_req[0];\n    } else {\n        /* returns an x to signal there is no command waiting to be treated */\n        return 'x';\n    }\n}\n\nvoid UartHAL::usart1WriteChar(char data)\n{\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_poll_out(uart_dev,data);\n    }\n}\n\nvoid UartHAL::usart1SwapRxTx()\n{\n    LL_LPUART_Disable(LPUART1);\n    LL_LPUART_SetTXRXSwap(LPUART1, LL_LPUART_TXRX_SWAPPED);\n    LL_LPUART_Enable(LPUART1);\n}\n</code></pre>"},{"location":"powerAPI/UartHAL_8h/","title":"File UartHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8h/#classes","title":"Classes","text":"Type Name class UartHAL Handles USART1 for the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/UartHAL_8h_source/","title":"File UartHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n */\n\n#ifndef UARTHAL_H_\n#define UARTHAL_H_\n\nclass UartHAL\n{\npublic:\n    void usart1Init();\n\n    char usart1ReadChar();\n\n    void usart1WriteChar(char data);\n\n    void usart1SwapRxTx();\n\n\n};\n\n\n\n#endif /* UARTHAL_H_ */\n</code></pre>"},{"location":"powerAPI/dir_5931dfac2e1245380efda5ad202dc380/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data</p>"},{"location":"powerAPI/dir_5931dfac2e1245380efda5ad202dc380/#files","title":"Files","text":"Type Name file data_conversion.cpp file data_conversion.h file data_dispatch.cpp file data_dispatch.h file dma.cpp file dma.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/</code></p>"},{"location":"powerAPI/data__conversion_8cpp/","title":"File data_conversion.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__conversion_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name float32_t * conversion_parameters conversion_type_t conversion_types const uint8_t max_parameters_count   = <code>2</code>"},{"location":"powerAPI/data__conversion_8cpp/#public-functions","title":"Public Functions","text":"Type Name float32_t data_conversion_convert_raw_value (uint8_t adc_num, uint8_t channel_num, uint16_t raw_value) Converts the values of the given raw_value into a physical unit. conversion_type_t data_conversion_get_conversion_type (uint8_t adc_num, uint8_t channel_num) Get the conversion type for a given channel. float32_t data_conversion_get_parameter (uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num) Get a conversion parameter for a given channel. void data_conversion_init () Initialize data conversion. int8_t data_conversion_retrieve_channel_parameters_from_nvs (uint8_t adc_num, uint8_t channel_num) Retrieved previously configured conversion parameters from NVS. void data_conversion_set_conversion_parameters_linear (uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset) Set the conversion type for a given channel to linear and set parameters values. void data_conversion_set_conversion_parameters_therm (uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Set the conversion type for a given channel to therm and set parameters values. int8_t data_conversion_store_channel_parameters_in_nvs (uint8_t adc_num, uint8_t channel_num) Store the currently configured conversion parameters of a given channel in NVS."},{"location":"powerAPI/data__conversion_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name uint8_t _data_conversion_get_parameters_count (conversion_type_t type)"},{"location":"powerAPI/data__conversion_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#variable-conversion_parameters","title":"variable conversion_parameters","text":"<pre><code>float32_t* conversion_parameters[ADC_COUNT][CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/data__conversion_8cpp/#variable-conversion_types","title":"variable conversion_types","text":"<pre><code>conversion_type_t conversion_types[ADC_COUNT][CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/data__conversion_8cpp/#variable-max_parameters_count","title":"variable max_parameters_count","text":"<pre><code>const uint8_t max_parameters_count;\n</code></pre> <p>Includes Local Variables </p>"},{"location":"powerAPI/data__conversion_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_convert_raw_value","title":"function data_conversion_convert_raw_value","text":"<p>Converts the values of the given raw_value into a physical unit. <pre><code>float32_t data_conversion_convert_raw_value (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>raw_value</code> Value to convert</li> </ul> <p>Returns:</p> <p>A float32_t value representing the value in the physical unit of the given channel. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_get_conversion_type","title":"function data_conversion_get_conversion_type","text":"<p>Get the conversion type for a given channel. <pre><code>conversion_type_t data_conversion_get_conversion_type (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>Currently configured conversion type. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_get_parameter","title":"function data_conversion_get_parameter","text":"<p>Get a conversion parameter for a given channel. <pre><code>float32_t data_conversion_get_parameter (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint8_t parameter_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>parameter_num</code> Number of the parameter to retrieve. E.g. for linear parameters, gain is param 1 and offset is param 2.</li> </ul> <p>Returns:</p> <p>Current value of the given parameter. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_init","title":"function data_conversion_init","text":"<p>Initialize data conversion. <pre><code>void data_conversion_init () \n</code></pre></p> <p>API </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_retrieve_channel_parameters_from_nvs","title":"function data_conversion_retrieve_channel_parameters_from_nvs","text":"<p>Retrieved previously configured conversion parameters from NVS. <pre><code>int8_t data_conversion_retrieve_channel_parameters_from_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly retrieved, negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested channel </li> </ul>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_set_conversion_parameters_linear","title":"function data_conversion_set_conversion_parameters_linear","text":"<p>Set the conversion type for a given channel to linear and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_linear (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>gain</code> Gain of the channel </li> <li><code>offset</code> Offset of the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_set_conversion_parameters_therm","title":"function data_conversion_set_conversion_parameters_therm","text":"<p>Set the conversion type for a given channel to therm and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_therm (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>r0</code> Parameter R0 for the channel </li> <li><code>b</code> Parameter B for the channel </li> <li><code>rdiv</code> Parameter RDIV for the channel </li> <li><code>t0</code> Parameter T0 for the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_store_channel_parameters_in_nvs","title":"function data_conversion_store_channel_parameters_in_nvs","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t data_conversion_store_channel_parameters_in_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly stored, -1 if there was an error. </p>"},{"location":"powerAPI/data__conversion_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#function-_data_conversion_get_parameters_count","title":"function _data_conversion_get_parameters_count","text":"<pre><code>static uint8_t _data_conversion_get_parameters_count (\n    conversion_type_t type\n) \n</code></pre> <p>Private functions </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_conversion.cpp</code></p>"},{"location":"powerAPI/data__conversion_8cpp_source/","title":"File data_conversion.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Antoine Boche &lt;antoine.boche@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Thomas Walter &lt;thomas.walter@laas.fr&gt;\n */\n\n\n/* OwnTech API */\n#include \"../DataAPI.h\"\n\n/* Current file header */\n#include \"data_conversion.h\"\n#include \"nvs_storage.h\"\n\n\n\nstatic const uint8_t max_parameters_count = 2;\n\nstatic conversion_type_t conversion_types[ADC_COUNT][CHANNELS_PER_ADC];\nstatic float32_t* conversion_parameters[ADC_COUNT][CHANNELS_PER_ADC];\n\n/* voltage reference from ADC */\n#define VREF 2.048f\n/* ADC resolution */\n#define QUANTUM_MAX 4096.0f\n/* Input voltage in the voltage divider */\n#define Vin_divider 3.3f\n\n\nstatic uint8_t _data_conversion_get_parameters_count(conversion_type_t type)\n{\n    uint8_t parameters_count = 0;\n\n    switch(type)\n    {\n        case conversion_linear:\n            /* Param 0 = gain */\n            /* Param 1 = offset */\n            parameters_count = 2;\n            break;\n        case conversion_therm:\n            /* Param 0 = R0 */\n            /* Param 1 = B */\n            /* Param 2 = RDIV */\n            /* Param 3 = T0 */\n            parameters_count = 4;\n        case no_channel_error:\n            break;\n    }\n\n    return parameters_count;\n}\n\n/* Public functions */\n\nvoid data_conversion_init()\n{\n    /* Make sure all channels have conversion parameters */\n    for (int adc_index = 0 ; adc_index &lt; ADC_COUNT ; adc_index++)\n    {\n        for (int channel_index = 0 ;\n             channel_index &lt; CHANNELS_PER_ADC ;\n             channel_index++)\n        {\n            if (conversion_parameters[adc_index][channel_index] == nullptr)\n            {\n                uint8_t param_count =\n                    _data_conversion_get_parameters_count(\n                        conversion_types[adc_index][channel_index]\n                    );\n\n                conversion_parameters[adc_index][channel_index] =\n                    (float32_t*)k_malloc(param_count*sizeof(float32_t));\n\n                switch(conversion_types[adc_index][channel_index])\n                {\n                    case conversion_linear:\n                        /* For linear conversion, set default gain to 1\n                         * and default offset to 0 */\n                        conversion_parameters[adc_index][channel_index][0]= 1;\n                        conversion_parameters[adc_index][channel_index][1]= 0;\n                        break;\n                    case conversion_therm:\n                        /* For therm conversion, set all parameters to 1\n                         * by default */\n                        conversion_parameters[adc_index][channel_index][0]= 1;\n                        conversion_parameters[adc_index][channel_index][1]= 1;\n                        conversion_parameters[adc_index][channel_index][2]= 1;\n                        conversion_parameters[adc_index][channel_index][3]= 1;\n                        break;\n                    case no_channel_error:\n                        break;\n                }\n            }\n        }\n    }\n}\n\nfloat32_t data_conversion_convert_raw_value(uint8_t adc_num,\n                                            uint8_t channel_num,\n                                            uint16_t raw_value)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    switch(conversion_types[adc_index][channel_index])\n    {\n        case conversion_linear:\n            return (raw_value *\n                    conversion_parameters[adc_index][channel_index][0]) +\n                    (conversion_parameters[adc_index][channel_index][1]);\n            break;\n        case conversion_therm:\n        {\n            /* Retrieves the parameters for the thermo resistor */\n            float32_t local_r0 =\n                    conversion_parameters[adc_index][channel_index][0];\n\n            float32_t local_b =\n                    conversion_parameters[adc_index][channel_index][1];\n\n            float32_t local_rdiv =\n                    conversion_parameters[adc_index][channel_index][2];\n\n            float32_t local_t0 =\n                    conversion_parameters[adc_index][channel_index][3];\n\n            /* converts raw values into voltage */\n            float32_t V_adc = (raw_value/QUANTUM_MAX)*VREF;\n\n            /* uses a bridge divider equation\n             * to estimate the sensor resistance */\n            float32_t R_t = (V_adc/(Vin_divider - V_adc)) * local_rdiv;\n\n            /* original equation R = exp(B*(1/T - 1/T0)) */\n            float32_t T =\n                local_t0 /\n                ( 1 + (float32_t)log(R_t/local_r0) * (local_t0/local_b));\n\n            /* returns value in degree Celsius */\n            return (T - 273.15f);\n            break;\n        }           break;\n        case no_channel_error:\n            return ERROR_CHANNEL_NOT_FOUND;\n            break;\n        default:\n            return ERROR_CHANNEL_NOT_FOUND;\n            break;\n    }\n}\n\nvoid data_conversion_set_conversion_parameters_linear(\n        uint8_t adc_num,\n        uint8_t channel_num,\n        float32_t gain,\n        float32_t offset)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    conversion_types[adc_index][channel_index] = conversion_linear;\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        k_free(conversion_parameters[adc_index][channel_index]);\n    }\n\n    conversion_parameters[adc_index][channel_index] =\n                            (float32_t*)k_malloc(2*sizeof(float32_t));\n\n    conversion_parameters[adc_index][channel_index][0] = gain;\n    conversion_parameters[adc_index][channel_index][1] = offset;\n}\n\nvoid data_conversion_set_conversion_parameters_therm(\n        uint8_t adc_num,\n        uint8_t channel_num,\n        float32_t r0,\n        float32_t b,\n        float32_t rdiv,\n        float32_t t0)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    conversion_types[adc_index][channel_index] = conversion_therm;\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        k_free(conversion_parameters[adc_index][channel_index]);\n    }\n\n    conversion_parameters[adc_index][channel_index] =\n                                    (float32_t*)k_malloc(4*sizeof(float32_t));\n\n    conversion_parameters[adc_index][channel_index][0] = r0;\n    conversion_parameters[adc_index][channel_index][1] = b;\n    conversion_parameters[adc_index][channel_index][2] = rdiv;\n    conversion_parameters[adc_index][channel_index][3] = t0;\n}\n\nconversion_type_t data_conversion_get_conversion_type(\n                    uint8_t adc_num,\n                    uint8_t channel_num)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    return conversion_types[adc_index][channel_index];\n}\n\nfloat32_t data_conversion_get_parameter(\n            uint8_t adc_num,\n            uint8_t channel_num,\n            uint8_t parameter_num)\n{\n    uint8_t adc_index       = adc_num - 1;\n    uint8_t channel_index   = channel_num - 1;\n    uint8_t parameter_index = parameter_num - 1;\n\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        uint8_t param_count =\n                    _data_conversion_get_parameters_count(\n                        conversion_types[adc_index][channel_index]\n                    );\n\n        if (parameter_index &lt; param_count)\n        {\n            return conversion_parameters[adc_index][channel_index][parameter_index];\n        }\n    }\n\n    /* Default case: parameter was not found */\n    return 0;\n}\n\nint8_t data_conversion_store_channel_parameters_in_nvs(uint8_t adc_num,\n                                                       uint8_t channel_num)\n{\n\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n\n\n    uint8_t parameters_count =\n                _data_conversion_get_parameters_count(\n                    conversion_types[adc_index][channel_index]\n                );\n\n    uint8_t* buffer =\n            (uint8_t*)k_malloc(1 + 23 + 1 + 1 + 1 + 4*parameters_count);\n\n    snprintk((char*)(&amp;buffer[1]), 23, \"Spin_ADC_%u_Channel_%u\",\n             adc_num,\n             channel_num);\n\n    uint8_t string_len = strlen((char*)(&amp;buffer[1]));\n\n    buffer[0] = string_len;\n    /* Buffer [1 -&gt; string_len] contains channel name (\\0 will be overwritten) */\n    buffer[string_len + 1] = adc_num;\n    buffer[string_len + 2] = channel_num;\n    buffer[string_len + 3] = conversion_types[adc_index][channel_index];\n    for (int i = 0 ; i &lt; parameters_count ; i++)\n    {\n        *((float32_t*)&amp;buffer[string_len + 4 + 4*i]) =\n                            conversion_parameters[adc_index][channel_index][i];\n    }\n\n    uint16_t channel_ID = ADC_CALIBRATION | (adc_num&amp;0x0F) &lt;&lt; 4 | (channel_num&amp;0x0F);\n\n    int ns = nvs_storage_store_data(\n                channel_ID, buffer,\n                1 + string_len + 1 + 1 + 1 + 4*parameters_count\n            );\n\n    k_free(buffer);\n\n    if (ns &lt; 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint8_t data_conversion_retrieve_channel_parameters_from_nvs(uint8_t adc_num,\n                                                            uint8_t channel_num)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    /* Check that parameters currently stored in NVS are from the same version */\n    uint16_t current_stored_version = nvs_storage_get_version_in_nvs();\n    if (current_stored_version == 0)\n    {\n        return -1;\n    }\n    else if (current_stored_version != nvs_storage_get_current_version())\n    {\n        return -2;\n    }\n\n    uint16_t channel_ID =\n                ADC_CALIBRATION | (adc_num&amp;0x0F) &lt;&lt; 4 | (channel_num&amp;0x0F);\n\n    int buffer_size = 1 + 23 + 1 + 1 + 1 + 4*max_parameters_count;\n    uint8_t* buffer = (uint8_t*)k_malloc(buffer_size);\n\n    int read_size = nvs_storage_retrieve_data(channel_ID, buffer, buffer_size);\n\n    int ret = 0;\n    if (read_size &gt; 0)\n    {\n        uint8_t string_len = buffer[0];\n\n        /* Check that all required values match */\n        if (adc_num != buffer[string_len + 1])\n        {\n            ret = -3;\n        }\n        else if (channel_num != buffer[string_len + 2])\n        {\n            ret = -3;\n        }\n        else\n        {\n            conversion_type_t conversion_type =\n                                (conversion_type_t)buffer[string_len + 3];\n\n            uint8_t parameters_count =\n                    _data_conversion_get_parameters_count(conversion_type);\n\n            conversion_types[adc_index][channel_index] = conversion_type;\n\n            if (conversion_parameters[adc_index][channel_index] != nullptr)\n            {\n                k_free(conversion_parameters[adc_index][channel_index]);\n            }\n            conversion_parameters[adc_index][channel_index] =\n                (float32_t*)k_malloc(parameters_count*sizeof(float32_t));\n\n            for (int i = 0 ; i &lt; parameters_count ; i++)\n            {\n                conversion_parameters[adc_index][channel_index][i] =\n                                *((float32_t*)&amp;buffer[string_len + 4 + 4*i]);\n            }\n        }\n    }\n    else\n    {\n        ret = -4;\n    }\n\n    k_free(buffer);\n    return ret;\n}\n</code></pre>"},{"location":"powerAPI/data__conversion_8h/","title":"File data_conversion.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__conversion_8h/#public-types","title":"Public Types","text":"Type Name enum int8_t conversion_type_t"},{"location":"powerAPI/data__conversion_8h/#public-functions","title":"Public Functions","text":"Type Name float32_t data_conversion_convert_raw_value (uint8_t adc_num, uint8_t channel_num, uint16_t raw_value) Converts the values of the given raw_value into a physical unit. conversion_type_t data_conversion_get_conversion_type (uint8_t adc_num, uint8_t channel_num) Get the conversion type for a given channel. float32_t data_conversion_get_parameter (uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num) Get a conversion parameter for a given channel. void data_conversion_init () Initialize data conversion. int8_t data_conversion_retrieve_channel_parameters_from_nvs (uint8_t adc_num, uint8_t channel_num) Retrieved previously configured conversion parameters from NVS. void data_conversion_set_conversion_parameters_linear (uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset) Set the conversion type for a given channel to linear and set parameters values. void data_conversion_set_conversion_parameters_therm (uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Set the conversion type for a given channel to therm and set parameters values. int8_t data_conversion_store_channel_parameters_in_nvs (uint8_t adc_num, uint8_t channel_num) Store the currently configured conversion parameters of a given channel in NVS."},{"location":"powerAPI/data__conversion_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/data__conversion_8h/#enum-conversion_type_t","title":"enum conversion_type_t","text":"<pre><code>enum conversion_type_t {\n    conversion_linear = 0,\n    conversion_therm = 1,\n    no_channel_error = -5\n};\n</code></pre> <p>Type definitions </p>"},{"location":"powerAPI/data__conversion_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_convert_raw_value","title":"function data_conversion_convert_raw_value","text":"<p>Converts the values of the given raw_value into a physical unit. <pre><code>float32_t data_conversion_convert_raw_value (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>raw_value</code> Value to convert</li> </ul> <p>Returns:</p> <p>A float32_t value representing the value in the physical unit of the given channel. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_get_conversion_type","title":"function data_conversion_get_conversion_type","text":"<p>Get the conversion type for a given channel. <pre><code>conversion_type_t data_conversion_get_conversion_type (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>Currently configured conversion type. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_get_parameter","title":"function data_conversion_get_parameter","text":"<p>Get a conversion parameter for a given channel. <pre><code>float32_t data_conversion_get_parameter (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint8_t parameter_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>parameter_num</code> Number of the parameter to retrieve. E.g. for linear parameters, gain is param 1 and offset is param 2.</li> </ul> <p>Returns:</p> <p>Current value of the given parameter. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_init","title":"function data_conversion_init","text":"<p>Initialize data conversion. <pre><code>void data_conversion_init () \n</code></pre></p> <p>API </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_retrieve_channel_parameters_from_nvs","title":"function data_conversion_retrieve_channel_parameters_from_nvs","text":"<p>Retrieved previously configured conversion parameters from NVS. <pre><code>int8_t data_conversion_retrieve_channel_parameters_from_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly retrieved, negative value if there was an error:</p> <ul> <li><code>-1</code>: NVS is empty</li> <li><code>-2</code>: NVS contains data, but their version doesn't match current version</li> <li><code>-3</code>: NVS data is corrupted</li> <li><code>-4</code>: NVS contains data, but not for the requested channel </li> </ul>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_set_conversion_parameters_linear","title":"function data_conversion_set_conversion_parameters_linear","text":"<p>Set the conversion type for a given channel to linear and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_linear (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>gain</code> Gain of the channel </li> <li><code>offset</code> Offset of the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_set_conversion_parameters_therm","title":"function data_conversion_set_conversion_parameters_therm","text":"<p>Set the conversion type for a given channel to therm and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_therm (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>r0</code> Parameter R0 for the channel </li> <li><code>b</code> Parameter B for the channel </li> <li><code>rdiv</code> Parameter RDIV for the channel </li> <li><code>t0</code> Parameter T0 for the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_store_channel_parameters_in_nvs","title":"function data_conversion_store_channel_parameters_in_nvs","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t data_conversion_store_channel_parameters_in_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly stored, -1 if there was an error. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_conversion.h</code></p>"},{"location":"powerAPI/data__conversion_8h_source/","title":"File data_conversion.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Antoine Boche &lt;antoine.boche@laas.fr&gt;\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Thomas Walter &lt;thomas.walter@laas.fr&gt;\n */\n\n#ifndef DATA_CONVERSION_H_\n#define DATA_CONVERSION_H_\n\n/* adds all the CMSIS library */\n#include &lt;arm_math.h&gt;\n\n\ntypedef enum : int8_t\n{\n    conversion_linear = 0,\n    conversion_therm  = 1,\n    no_channel_error  = -5\n\n} conversion_type_t;\n\n\nvoid data_conversion_init();\n\nfloat32_t data_conversion_convert_raw_value(uint8_t adc_num,\n                                            uint8_t channel_num,\n                                            uint16_t raw_value);\n\nvoid data_conversion_set_conversion_parameters_linear(uint8_t adc_num,\n                                                      uint8_t channel_num,\n                                                      float32_t gain,\n                                                      float32_t offset);\n\nvoid data_conversion_set_conversion_parameters_therm(uint8_t adc_num,\n                                                     uint8_t channel_num,\n                                                     float32_t r0,\n                                                     float32_t b,\n                                                     float32_t rdiv,\n                                                     float32_t t0);\n\nconversion_type_t data_conversion_get_conversion_type(uint8_t adc_num,\n                                                      uint8_t channel_num);\n\nfloat32_t data_conversion_get_parameter(uint8_t adc_num,\n                                        uint8_t channel_num,\n                                        uint8_t parameter_num);\n\nint8_t data_conversion_store_channel_parameters_in_nvs(uint8_t adc_num,\n                                                       uint8_t channel_num);\n\nint8_t data_conversion_retrieve_channel_parameters_from_nvs(uint8_t adc_num,\n                                                            uint8_t channel_num);\n\n\n#endif /* DATA_CONVERSION_H_ */\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/","title":"File data_dispatch.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__dispatch_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint16_t **** adc_channel_buffers   = <code>nullptr</code> uint32_t ** buffers_data_count   = <code>nullptr</code> uint8_t ** current_buffer   = <code>nullptr</code> uint8_t current_dma_buffer   = <code>{0}</code> dispatch_t dispatch_type size_t dma_buffer_sizes   = <code>{0}</code> uint16_t * dma_main_buffers   = <code>{0}</code> uint16_t * dma_secondary_buffers   = <code>{0}</code> uint8_t * enabled_channels_count   = <code>nullptr</code> uint16_t ** peek_memory   = <code>nullptr</code>"},{"location":"powerAPI/data__dispatch_8cpp/#public-functions","title":"Public Functions","text":"Type Name __STATIC_INLINE uint16_t * _data_dispatch_get_buffer (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE uint32_t _data_dispatch_get_count (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE void _data_dispatch_increment_count (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE void _data_dispatch_swap_buffers (uint8_t adc_index, uint8_t channel_index)  void data_dispatch_do_dispatch (uint8_t adc_number) Dispatch function: gets the readings and store them in per-channel arrays. This function is called by DMA callback when the DMA has filled one of its buffers. void data_dispatch_do_full_dispatch () Function to proceed to all chanels dispatch when it is done at uninterruptible task start. uint16_t * data_dispatch_get_acquired_values (uint8_t adc_number, uint8_t channel_rank, uint32_t &amp; number_of_values_acquired) Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. void data_dispatch_init (dispatch_t dispatch_method, uint32_t repetitions) Init function to be called first. uint16_t data_dispatch_peek_acquired_value (uint8_t adc_number, uint8_t channel_rank) Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer."},{"location":"powerAPI/data__dispatch_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__dispatch_8cpp/#variable-adc_channel_buffers","title":"variable adc_channel_buffers","text":"<pre><code>uint16_t**** adc_channel_buffers;\n</code></pre> <p>Array of per-adc/per-channel buffers. adc_channel_buffers[x][y][z][] is ADC x+1 channel y buffer z with z either 0 or 1 as there are two buffers per channel (double buffering) </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-buffers_data_count","title":"variable buffers_data_count","text":"<pre><code>uint32_t** buffers_data_count;\n</code></pre> <p>Number of readings stored in each channel. buffers_data_count[x][y] is the current number of values stored in the currently written buffer of ADC x+1 Channel y </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-current_buffer","title":"variable current_buffer","text":"<pre><code>uint8_t** current_buffer;\n</code></pre> <p>Currently written buffer for each channel. Either 0 or 1. If current_buffer[x][y] is 0, the currently written buffer for ADC x+1 Channel y is buffer 0 and the user buffer is buffer 1 </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-current_dma_buffer","title":"variable current_dma_buffer","text":"<pre><code>uint8_t current_dma_buffer[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dispatch_type","title":"variable dispatch_type","text":"<pre><code>dispatch_t dispatch_type;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_buffer_sizes","title":"variable dma_buffer_sizes","text":"<pre><code>size_t dma_buffer_sizes[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_main_buffers","title":"variable dma_main_buffers","text":"<pre><code>uint16_t* dma_main_buffers[ADC_COUNT];\n</code></pre> <p>DMA buffers: data from the ADC 1/2 are stored in these buffers until dispatch is done (ADC 3/4 won't use DMA). Main buffers are always used, while secondary buffers will only be used when double-buffering is activated. Double buffering is activated in Interrupt mode, while Task mode doesn't need it. </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_secondary_buffers","title":"variable dma_secondary_buffers","text":"<pre><code>uint16_t* dma_secondary_buffers[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-enabled_channels_count","title":"variable enabled_channels_count","text":"<pre><code>uint8_t* enabled_channels_count;\n</code></pre> <p>Local variables </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-peek_memory","title":"variable peek_memory","text":"<pre><code>uint16_t** peek_memory;\n</code></pre> <p>Small memory to retain latest value available to the peek() function after a buffer swap. </p>"},{"location":"powerAPI/data__dispatch_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_get_buffer","title":"function _data_dispatch_get_buffer","text":"<pre><code>__STATIC_INLINE uint16_t * _data_dispatch_get_buffer (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre> <p>Private Functions </p>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_get_count","title":"function _data_dispatch_get_count","text":"<pre><code>__STATIC_INLINE uint32_t _data_dispatch_get_count (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_increment_count","title":"function _data_dispatch_increment_count","text":"<pre><code>__STATIC_INLINE void _data_dispatch_increment_count (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_swap_buffers","title":"function _data_dispatch_swap_buffers","text":"<pre><code>__STATIC_INLINE void _data_dispatch_swap_buffers (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_do_dispatch","title":"function data_dispatch_do_dispatch","text":"<p>Dispatch function: gets the readings and store them in per-channel arrays. This function is called by DMA callback when the DMA has filled one of its buffers. <pre><code>void data_dispatch_do_dispatch (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which data comes. </li> </ul>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_do_full_dispatch","title":"function data_dispatch_do_full_dispatch","text":"<p>Function to proceed to all chanels dispatch when it is done at uninterruptible task start. <pre><code>void data_dispatch_do_full_dispatch () \n</code></pre></p>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_get_acquired_values","title":"function data_dispatch_get_acquired_values","text":"<p>Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. <pre><code>uint16_t * data_dispatch_get_acquired_values (\n    uint8_t adc_number,\n    uint8_t channel_rank,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Accessors </p>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_init","title":"function data_dispatch_init","text":"<p>Init function to be called first. <pre><code>void data_dispatch_init (\n    dispatch_t dispatch_method,\n    uint32_t repetitions\n) \n</code></pre></p> <p>Public API </p>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_peek_acquired_value","title":"function data_dispatch_peek_acquired_value","text":"<p>Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer. <pre><code>uint16_t data_dispatch_peek_acquired_value (\n    uint8_t adc_number,\n    uint8_t channel_rank\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> </ul> <p>Returns:</p> <p>Latest available value from the buffer. Note that if no value has been acquired, returned value will be 0. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_dispatch.cpp</code></p>"},{"location":"powerAPI/data__dispatch_8cpp_source/","title":"File data_dispatch.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* Stdlib */\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n\n/* OwnTech API */\n#include \"adc.h\"\n#include \"SpinAPI.h\"\n\n/* Current module header */\n#include \"dma.h\"\n\n/* Current file header */\n#include \"data_dispatch.h\"\n\n\n/* Number of channels in each ADC (cell i is ADC number i+1) */\nstatic uint8_t* enabled_channels_count = nullptr;\n\nstatic uint16_t**** adc_channel_buffers = nullptr;\n\nstatic uint32_t** buffers_data_count = nullptr;\n\nstatic uint8_t** current_buffer = nullptr;\n\nstatic uint16_t** peek_memory = nullptr;\n\nstatic uint16_t* dma_main_buffers[ADC_COUNT]      = {0};\nstatic uint16_t* dma_secondary_buffers[ADC_COUNT] = {0};\nstatic uint8_t   current_dma_buffer[ADC_COUNT]    = {0};\nstatic size_t    dma_buffer_sizes[ADC_COUNT]      = {0};\n\n/* Dispatch method */\nstatic dispatch_t dispatch_type;\n\n\n__STATIC_INLINE uint16_t* _data_dispatch_get_buffer(uint8_t adc_index,\n                                                    uint8_t channel_index)\n{\n    uint8_t active_buffer = current_buffer[adc_index][channel_index];\n    return adc_channel_buffers[adc_index][channel_index][active_buffer];\n}\n\n__STATIC_INLINE uint32_t _data_dispatch_get_count(uint8_t adc_index,\n                                                  uint8_t channel_index)\n{\n    return buffers_data_count[adc_index][channel_index];\n}\n\n__STATIC_INLINE void _data_dispatch_increment_count(uint8_t adc_index,\n                                                    uint8_t channel_index)\n{\n    uint32_t* current_count = &amp;buffers_data_count[adc_index][channel_index];\n    if ( (*current_count) &lt; CHANNELS_BUFFERS_SIZE)\n    {\n        (*current_count)++;\n    }\n}\n\n__STATIC_INLINE void _data_dispatch_swap_buffers(uint8_t adc_index,\n                                                 uint8_t channel_index)\n{\n    uint8_t* active_buffer = &amp;current_buffer[adc_index][channel_index];\n\n    *active_buffer = ((*active_buffer) == 0) ? 1 : 0;\n    buffers_data_count[adc_index][channel_index] = 0;\n}\n\n\nvoid data_dispatch_init(dispatch_t dispatch_method, uint32_t repetitions)\n{\n    /* Store dispatch method */\n    dispatch_type = dispatch_method;\n\n    /* Prepare arrays for each ADC */\n    enabled_channels_count =\n                (uint8_t*)    k_malloc(ADC_COUNT * sizeof(uint8_t));\n\n    adc_channel_buffers    =\n                (uint16_t****)k_calloc(ADC_COUNT,  sizeof(uint16_t***));\n\n    buffers_data_count     =\n                (uint32_t**)  k_calloc(ADC_COUNT,  sizeof(uint32_t*));\n\n    current_buffer         =\n                (uint8_t**)   k_calloc(ADC_COUNT,  sizeof(uint8_t*));\n\n    peek_memory            =\n                (uint16_t**)  k_calloc(ADC_COUNT,  sizeof(uint16_t*));\n\n    /* Configure DMA 1 channels */\n    for (uint8_t adc_num = 1 ; adc_num &lt;= ADC_COUNT ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n\n        enabled_channels_count[adc_index] =\n                        adc_get_enabled_channels_count(adc_num);\n\n        /* Ignore this ADC if it has no enabled channel */\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            /* Prepare buffers for DMA */\n            size_t dma_buffer_size;\n\n            if (dispatch_type == interrupt)\n            {\n                dma_buffer_size = enabled_channels_count[adc_index];\n\n                /* DMA double-buffering */\n                dma_buffer_size = dma_buffer_size * 2;\n            }\n            else\n            {\n                dma_buffer_size = repetitions;\n\n                if (repetitions % enabled_channels_count[adc_index] != 0)\n                {\n                    dma_buffer_size +=  (enabled_channels_count[adc_index]) -\n                                        (repetitions %\n                                         enabled_channels_count[adc_index]);\n                }\n                else\n                {\n                    dma_buffer_size += enabled_channels_count[adc_index];\n                }\n            }\n\n            dma_buffer_sizes[adc_index] = dma_buffer_size;\n            dma_main_buffers[adc_index] =\n                    (uint16_t*)k_malloc(dma_buffer_size * sizeof(uint16_t));\n\n            if (dispatch_type == interrupt)\n            {\n                dma_secondary_buffers[adc_index] =\n                        dma_main_buffers[adc_index] +\n                        enabled_channels_count[adc_index];\n            }\n\n            /* Initialize DMA */\n            bool disable_interrupts = false;\n            if (dispatch_type == task)\n            {\n                disable_interrupts = true;\n            }\n            dma_configure_adc_acquisition(adc_num,\n                                          disable_interrupts,\n                                          dma_main_buffers[adc_index],\n                                          dma_buffer_size);\n\n            /* Prepare arrays for each channel */\n            adc_channel_buffers[adc_index] =\n                    (uint16_t***)k_malloc(\n                        enabled_channels_count[adc_index] * sizeof(uint16_t**)\n                    );\n\n            buffers_data_count[adc_index] =\n                    (uint32_t*)k_calloc(\n                        enabled_channels_count[adc_index],\n                        sizeof(uint32_t)\n                    );\n\n            current_buffer[adc_index]     =\n                    (uint8_t*) k_calloc(\n                        enabled_channels_count[adc_index],\n                        sizeof(uint8_t)\n                    );\n\n            peek_memory[adc_index]        =\n                    (uint16_t*)k_calloc(\n                        enabled_channels_count[adc_index],\n                        sizeof(uint16_t)\n                    );\n\n            for (int channel_index = 0 ;\n                 channel_index &lt; enabled_channels_count[adc_index] ;\n                 channel_index++)\n            {\n                /* Prepare double buffer */\n                adc_channel_buffers[adc_index][channel_index] =\n                    (uint16_t**)k_malloc(\n                                    sizeof(uint16_t*) * 2\n                                );\n\n                adc_channel_buffers[adc_index][channel_index][0] =\n                    (uint16_t*)k_malloc(\n                                    sizeof(uint16_t) * CHANNELS_BUFFERS_SIZE\n                               );\n\n                adc_channel_buffers[adc_index][channel_index][1] =\n                    (uint16_t*)k_malloc(\n                                    sizeof(uint16_t) * CHANNELS_BUFFERS_SIZE\n                               );\n\n                peek_memory[adc_index][channel_index] = PEEK_NO_VALUE;\n            }\n        }\n    }\n}\n\nvoid data_dispatch_do_dispatch(uint8_t adc_num)\n{\n    uint8_t adc_index = adc_num - 1;\n\n    if (enabled_channels_count[adc_index] == 0)\n        return;\n\n    uint16_t* dma_buffer = dma_main_buffers[adc_index];\n    if (dma_secondary_buffers[adc_index] != nullptr)\n    {\n        if (current_dma_buffer[adc_index] == 0)\n        {\n            current_dma_buffer[adc_index] = 1;\n        }\n        else\n        {\n            dma_buffer = dma_secondary_buffers[adc_index];\n            current_dma_buffer[adc_index] = 0;\n        }\n    }\n\n    size_t data_count_in_dma_buffer;\n    if (dispatch_type == interrupt)\n    {\n        data_count_in_dma_buffer = enabled_channels_count[adc_index];\n    }\n    else\n    {\n        data_count_in_dma_buffer = dma_get_retrieved_data_count(adc_num);\n    }\n\n    for (size_t dma_index = 0 ;\n         dma_index &lt; data_count_in_dma_buffer ;\n         dma_index++)\n    {\n        /* Copy data */\n        size_t dma_buffer_index;\n        if (dispatch_type == interrupt)\n        {\n            dma_buffer_index = dma_index % enabled_channels_count[adc_index];\n        }\n        else\n        {\n            static size_t next_dma_buffer_index[ADC_COUNT] = {0};\n\n            dma_buffer_index = next_dma_buffer_index[adc_index];\n\n            if (next_dma_buffer_index[adc_index] &lt; dma_buffer_sizes[adc_index] - 1)\n            {\n                next_dma_buffer_index[adc_index]++;\n            }\n            else\n            {\n                next_dma_buffer_index[adc_index] = 0;\n            }\n        }\n\n        /* Get info on buffer */\n        size_t channel_index =\n                    dma_buffer_index % enabled_channels_count[adc_index];\n\n        uint16_t* active_buffer =\n                    _data_dispatch_get_buffer(adc_index, channel_index);\n\n        uint32_t  current_count =\n                    _data_dispatch_get_count(adc_index, channel_index);\n\n        active_buffer[current_count] = dma_buffer[dma_buffer_index];\n\n        /* Increment count */\n        _data_dispatch_increment_count(adc_index, channel_index);\n    }\n}\n\nvoid data_dispatch_do_full_dispatch()\n{\n    for (uint8_t adc_num = 1 ; adc_num &lt;= ADC_COUNT ; adc_num++)\n    {\n        data_dispatch_do_dispatch(adc_num);\n    }\n}\n\n\nuint16_t* data_dispatch_get_acquired_values(uint8_t adc_number,\n                                            uint8_t channel_rank,\n                                            uint32_t&amp; number_of_values_acquired)\n{\n    /* Prepare default value */\n    number_of_values_acquired = 0;\n\n    /* Check index */\n    uint8_t adc_index = adc_number-1;\n    if (adc_index &gt;= ADC_COUNT)\n        return nullptr;\n\n    /* Get and check data count */\n    uint8_t channel_index = channel_rank-1;\n    uint32_t current_count =\n                _data_dispatch_get_count(adc_index, channel_index);\n\n    if (current_count == 0)\n        return nullptr;\n\n    /* Get and swap buffer */\n    uint16_t* active_buffer =\n                _data_dispatch_get_buffer(adc_index, channel_index);\n\n    _data_dispatch_swap_buffers(adc_index, channel_index);\n\n    /* Retain latest value for peek() functions */\n    if (current_count &gt; 0)\n    {\n        peek_memory[adc_index][channel_index] = active_buffer[current_count-1];\n    }\n\n    /* Return data */\n    number_of_values_acquired = current_count;\n    return active_buffer;\n}\n\nuint16_t data_dispatch_peek_acquired_value(uint8_t adc_number,\n                                           uint8_t channel_rank)\n{\n    uint8_t adc_index = adc_number-1;\n    uint8_t channel_index = channel_rank-1;\n    if (adc_index &lt; ADC_COUNT)\n    {\n        /* Get info on buffer */\n        uint16_t* active_buffer =\n                        _data_dispatch_get_buffer(adc_index, channel_index);\n\n        uint32_t  current_count =\n                        _data_dispatch_get_count(adc_index, channel_index);\n\n        /* Return data */\n        if (current_count &gt; 0)\n        {\n            return active_buffer[current_count - 1];\n        }\n        else\n        {\n            return peek_memory[adc_index][channel_index];\n        }\n    }\n    else\n    {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/","title":"File data_dispatch.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__dispatch_8h/#public-types","title":"Public Types","text":"Type Name enum dispatch_t"},{"location":"powerAPI/data__dispatch_8h/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t CHANNELS_BUFFERS_SIZE   = <code>32</code> const uint16_t PEEK_NO_VALUE   = <code>0xFFFF</code>"},{"location":"powerAPI/data__dispatch_8h/#public-functions","title":"Public Functions","text":"Type Name void data_dispatch_do_dispatch (uint8_t adc_number) Dispatch function: gets the readings and store them in per-channel arrays. This function is called by DMA callback when the DMA has filled one of its buffers. void data_dispatch_do_full_dispatch () Function to proceed to all chanels dispatch when it is done at uninterruptible task start. uint16_t * data_dispatch_get_acquired_values (uint8_t adc_number, uint8_t channel_rank, uint32_t &amp; number_of_values_acquired) Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. void data_dispatch_init (dispatch_t dispatch_method, uint32_t repetitions) Init function to be called first. uint16_t data_dispatch_peek_acquired_value (uint8_t adc_number, uint8_t channel_rank) Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer."},{"location":"powerAPI/data__dispatch_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#enum-dispatch_t","title":"enum dispatch_t","text":"<pre><code>enum dispatch_t {\n    task,\n    interrupt\n};\n</code></pre> <p>Dispatch method </p>"},{"location":"powerAPI/data__dispatch_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#variable-channels_buffers_size","title":"variable CHANNELS_BUFFERS_SIZE","text":"<pre><code>const uint8_t CHANNELS_BUFFERS_SIZE;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/#variable-peek_no_value","title":"variable PEEK_NO_VALUE","text":"<pre><code>const uint16_t PEEK_NO_VALUE;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_do_dispatch","title":"function data_dispatch_do_dispatch","text":"<p>Dispatch function: gets the readings and store them in per-channel arrays. This function is called by DMA callback when the DMA has filled one of its buffers. <pre><code>void data_dispatch_do_dispatch (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which data comes. </li> </ul>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_do_full_dispatch","title":"function data_dispatch_do_full_dispatch","text":"<p>Function to proceed to all chanels dispatch when it is done at uninterruptible task start. <pre><code>void data_dispatch_do_full_dispatch () \n</code></pre></p>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_get_acquired_values","title":"function data_dispatch_get_acquired_values","text":"<p>Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. <pre><code>uint16_t * data_dispatch_get_acquired_values (\n    uint8_t adc_number,\n    uint8_t channel_rank,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> <li><code>number_of_values_acquired</code> Output parameter: address to a variable that will be updated by the function with the data count. </li> </ul> <p>Returns:</p> <p>Buffer containing the available data. Note that the returned buffer is invalidated by further calls to the function with same adc number/channel rank.</p> <p>Accessors </p>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_init","title":"function data_dispatch_init","text":"<p>Init function to be called first. <pre><code>void data_dispatch_init (\n    dispatch_t dispatch_method,\n    uint32_t repetitions\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dispatch_method</code> Indicates when the dispatch should be done. </li> <li><code>repetitions</code> If dispatch is done at task start, this value represents the number of acquisitions that are done between two execution of the task. Ignored if dispatch is done on interrupt.</li> </ul> <p>Public API </p>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_peek_acquired_value","title":"function data_dispatch_peek_acquired_value","text":"<p>Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer. <pre><code>uint16_t data_dispatch_peek_acquired_value (\n    uint8_t adc_number,\n    uint8_t channel_rank\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> </ul> <p>Returns:</p> <p>Latest available value from the buffer. Note that if no value has been acquired, returned value will be 0. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_dispatch.h</code></p>"},{"location":"powerAPI/data__dispatch_8h_source/","title":"File data_dispatch.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief Data dispatch is intended at dispatching ADCs\n * acquired data from DMA buffers to per-channel buffers.\n * User can then request the data of a specific channel.\n *\n * It uses double-buffering, holding 2 buffers for each\n * enabled channel of each ADC, one being filled and one\n * made available to the user.\n */\n\n#ifndef DATA_DISPATCH_H_\n#define DATA_DISPATCH_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n\n/* Constants */\n\nconst uint16_t PEEK_NO_VALUE = 0xFFFF;\nconst uint8_t CHANNELS_BUFFERS_SIZE = 32;\n\ntypedef enum {task, interrupt} dispatch_t;\n\nvoid data_dispatch_init(dispatch_t dispatch_method, uint32_t repetitions);\n\nvoid data_dispatch_do_dispatch(uint8_t adc_number);\n\nvoid data_dispatch_do_full_dispatch();\n\nuint16_t* data_dispatch_get_acquired_values(uint8_t adc_number,\n                                            uint8_t channel_rank,\n                                            uint32_t&amp; number_of_values_acquired);\n\nuint16_t data_dispatch_peek_acquired_value(uint8_t adc_number,\n                                           uint8_t channel_rank);\n\n\n#endif /* DATA_DISPATCH_H_ */\n</code></pre>"},{"location":"powerAPI/dma_8cpp/","title":"File dma.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dma_8cpp/#classes","title":"Classes","text":"Type Name struct dma_user_data_t"},{"location":"powerAPI/dma_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name size_t buffers_sizes   = <code>{0}</code> const struct device * dma1   = <code>DEVICE\\_DT\\_GET(DT\\_NODELABEL(dma1))</code> const uint32_t source_registers   = <code>/* multi line expression */</code> const uint32_t source_triggers   = <code>/* multi line expression */</code> dma_user_data_t user_data   = <code>{0}</code>"},{"location":"powerAPI/dma_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dma_configure_adc_acquisition (uint8_t adc_number, bool disable_interrupts, uint16_t * buffer, size_t buffer_size) This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. uint32_t dma_get_retrieved_data_count (uint8_t adc_number) Obtain the number of acquired data since last time this function was called."},{"location":"powerAPI/dma_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _dma_callback (const struct device * dev, void * user_data, uint32_t dma_channel, int status)"},{"location":"powerAPI/dma_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/dma_8cpp/#variable-buffers_sizes","title":"variable buffers_sizes","text":"<pre><code>size_t buffers_sizes[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#variable-dma1","title":"variable dma1","text":"<pre><code>const struct device* dma1;\n</code></pre> <p>DT definition </p>"},{"location":"powerAPI/dma_8cpp/#variable-source_registers","title":"variable source_registers","text":"<pre><code>const uint32_t source_registers[5];\n</code></pre> <p>Local variables </p>"},{"location":"powerAPI/dma_8cpp/#variable-source_triggers","title":"variable source_triggers","text":"<pre><code>const uint32_t source_triggers[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#variable-user_data","title":"variable user_data","text":"<pre><code>dma_user_data_t user_data[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/dma_8cpp/#function-dma_configure_adc_acquisition","title":"function dma_configure_adc_acquisition","text":"<p>This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. <pre><code>void dma_configure_adc_acquisition (\n    uint8_t adc_number,\n    bool disable_interrupts,\n    uint16_t * buffer,\n    size_t buffer_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to acquire measures from. </li> <li><code>disable_interrupts</code> Boolean indicating whether interrupts should be disabled. Warning: this override Zephyr DMA driver default behavior. </li> <li><code>buffer</code> Pointer to buffer. </li> <li><code>buffer_size</code> Number of uint16_t words the buffer can contain. </li> </ul>"},{"location":"powerAPI/dma_8cpp/#function-dma_get_retrieved_data_count","title":"function dma_get_retrieved_data_count","text":"<p>Obtain the number of acquired data since last time this function was called. <pre><code>uint32_t dma_get_retrieved_data_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC.</li> </ul> <p>Returns:</p> <p>Number of acquired data modulo buffer size. </p>"},{"location":"powerAPI/dma_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/dma_8cpp/#function-_dma_callback","title":"function _dma_callback","text":"<pre><code>static void _dma_callback (\n    const struct device * dev,\n    void * user_data,\n    uint32_t dma_channel,\n    int status\n) \n</code></pre> <p>DMA callback This callback is called on DMA interrupt. For ADCs with enabled interrupt, is will be called twice: when buffer is half-filled and when buffer is filled. For other ADCs, it will never be called. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.cpp</code></p>"},{"location":"powerAPI/dma_8cpp_source/","title":"File dma.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/dma.h&gt;\n\n/* STM32 LL */\n#include &lt;stm32_ll_dma.h&gt;\n\n/* Current module private functions */\n#include \"data_dispatch.h\"\n\n\nstatic const struct device* dma1 = DEVICE_DT_GET(DT_NODELABEL(dma1));\n\n\nstatic const uint32_t source_registers[5] =\n{\n    (uint32_t)(&amp;(ADC1-&gt;DR)),\n    (uint32_t)(&amp;(ADC2-&gt;DR)),\n    (uint32_t)(&amp;(ADC3-&gt;DR)),\n    (uint32_t)(&amp;(ADC4-&gt;DR)),\n    (uint32_t)(&amp;(ADC5-&gt;DR))\n};\n\nstatic const uint32_t source_triggers[5] =\n{\n    LL_DMAMUX_REQ_ADC1,\n    LL_DMAMUX_REQ_ADC2,\n    LL_DMAMUX_REQ_ADC3,\n    LL_DMAMUX_REQ_ADC4,\n    LL_DMAMUX_REQ_ADC5\n};\n\nstatic size_t buffers_sizes[5] = {0};\n\ntypedef struct\n{\n    bool     has_interrupt;\n    uint32_t src;\n    uint32_t dst;\n    size_t   size;\n    uint32_t channel;\n} dma_user_data_t;\n\nstatic dma_user_data_t user_data[5] = {0};\n\n/* Private API */\n\n\nstatic void _dma_callback(const struct device* dev,\n                          void* user_data,\n                          uint32_t dma_channel,\n                          int status)\n{\n    UNUSED(dev);\n    UNUSED(dma_channel);\n\n    /* Get user data for current channel */\n    dma_user_data_t* my_user_data = (dma_user_data_t*) user_data;\n\n    /* Do dispatch */\n    data_dispatch_do_dispatch(my_user_data-&gt;channel);\n\n    /* Reload DMA on last transaction */\n    if ( (my_user_data-&gt;has_interrupt == true) &amp;&amp;\n         (status == DMA_STATUS_COMPLETE) )\n    {\n        dma_reload(\n            dma1,\n            my_user_data-&gt;channel,\n            my_user_data-&gt;src,\n            my_user_data-&gt;dst,\n            my_user_data-&gt;size\n        );\n    }\n}\n\n/* Public API */\n\nvoid dma_configure_adc_acquisition(uint8_t adc_number,\n                                   bool disable_interrupts,\n                                   uint16_t* buffer,\n                                   size_t buffer_size)\n{\n    /* Check environment */\n    if (device_is_ready(dma1) == false)\n        return;\n\n    uint8_t dma_index = adc_number - 1;\n    uint32_t buffer_size_bytes = (uint32_t) buffer_size * sizeof(uint16_t);\n    buffers_sizes[dma_index] = buffer_size;\n\n    /* Private data for DMA channel */\n    user_data[dma_index].has_interrupt = !disable_interrupts;\n    user_data[dma_index].src           = source_registers[dma_index];\n    user_data[dma_index].dst           = (uint32_t)buffer;\n    user_data[dma_index].size          = buffer_size_bytes;\n    user_data[dma_index].channel       = adc_number;\n\n    /* Configure DMA */\n    struct dma_block_config dma_block_config_s = {0};\n    /* Source: ADC DR register */\n    dma_block_config_s.source_address   = user_data[dma_index].src;\n    /* Destination: buffer in memory */\n    dma_block_config_s.dest_address     = user_data[dma_index].dst;\n    /* Buffer size in bytes */\n    dma_block_config_s.block_size       = user_data[dma_index].size;\n    /* Source: no increment in ADC register */\n    dma_block_config_s.source_addr_adj  = DMA_ADDR_ADJ_NO_CHANGE;\n    /* Destination: increment in memory */\n    dma_block_config_s.dest_addr_adj    = DMA_ADDR_ADJ_INCREMENT;\n    /* Reload destination address on block completion */\n    dma_block_config_s.dest_reload_en   = 1;\n    dma_block_config_s.source_reload_en = 1;\n\n    struct dma_config dma_config_s = {0};\n    /* Trigger source: ADC */\n    dma_config_s.dma_slot            = source_triggers[dma_index];\n    /* From peripheral to memory */\n    dma_config_s.channel_direction   = PERIPHERAL_TO_MEMORY;\n    /* Source: 2 bytes (uint16_t) */\n    dma_config_s.source_data_size    = 2;\n    /* Destination: 2 bytes (uint16_t) */\n    dma_config_s.dest_data_size      = 2;\n    /* Source: No burst */\n    dma_config_s.source_burst_length = 1;\n    /* Destination: No burst */\n    dma_config_s.dest_burst_length   = 1;\n    /* 1 block */\n    dma_config_s.block_count         = 1;\n    /* Block config as defined above */\n    dma_config_s.head_block          = &amp;dma_block_config_s;\n    /* DMA interrupt callback */\n    dma_config_s.dma_callback        = _dma_callback;\n    /* User data provided to callback */\n    dma_config_s.user_data           = &amp;user_data[dma_index];\n\n    /* Use DMA 1 channel x for ADC x */\n    dma_config(dma1, user_data[dma_index].channel, &amp;dma_config_s);\n\n    if (disable_interrupts == true)\n    {\n        LL_DMA_DisableIT_HT(DMA1, dma_index);\n        LL_DMA_DisableIT_TC(DMA1, dma_index);\n    }\n\n    dma_start(dma1, user_data[dma_index].channel);\n}\n\nuint32_t dma_get_retrieved_data_count(uint8_t adc_number)\n{\n    static int32_t previous_dma_latest_data_pointers[5] = {-1, -1, -1, -1, -1};\n\n    /* Get data */\n    uint32_t dma_index = adc_number - 1;\n    uint32_t dma_remaining_data = LL_DMA_GetDataLength(DMA1, dma_index);\n\n    int32_t previous_dma_latest_data_pointer =\n                    previous_dma_latest_data_pointers[dma_index];\n\n    /* Compute pointers */\n    int32_t dma_next_data_pointer =\n                    buffers_sizes[dma_index] - dma_remaining_data;\n\n    int32_t dma_latest_data_pointer = dma_next_data_pointer - 1;\n\n    int32_t corrected_dma_pointer = dma_latest_data_pointer;\n\n    if (dma_latest_data_pointer &lt; previous_dma_latest_data_pointer)\n    {\n        corrected_dma_pointer += buffers_sizes[dma_index];\n    }\n\n    uint32_t retrieved_data =\n                    corrected_dma_pointer - previous_dma_latest_data_pointer;\n\n    previous_dma_latest_data_pointers[dma_index] = dma_latest_data_pointer;\n\n    return retrieved_data;\n}\n</code></pre>"},{"location":"powerAPI/dma_8h/","title":"File dma.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dma_8h/#public-functions","title":"Public Functions","text":"Type Name void dma_configure_adc_acquisition (uint8_t adc_number, bool disable_interrupts, uint16_t * buffer, size_t buffer_size) This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. uint32_t dma_get_retrieved_data_count (uint8_t adc_number) Obtain the number of acquired data since last time this function was called."},{"location":"powerAPI/dma_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/dma_8h/#function-dma_configure_adc_acquisition","title":"function dma_configure_adc_acquisition","text":"<p>This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. <pre><code>void dma_configure_adc_acquisition (\n    uint8_t adc_number,\n    bool disable_interrupts,\n    uint16_t * buffer,\n    size_t buffer_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to acquire measures from. </li> <li><code>disable_interrupts</code> Boolean indicating whether interrupts should be disabled. Warning: this override Zephyr DMA driver default behavior. </li> <li><code>buffer</code> Pointer to buffer. </li> <li><code>buffer_size</code> Number of uint16_t words the buffer can contain. </li> </ul>"},{"location":"powerAPI/dma_8h/#function-dma_get_retrieved_data_count","title":"function dma_get_retrieved_data_count","text":"<p>Obtain the number of acquired data since last time this function was called. <pre><code>uint32_t dma_get_retrieved_data_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC.</li> </ul> <p>Returns:</p> <p>Number of acquired data modulo buffer size. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.h</code></p>"},{"location":"powerAPI/dma_8h_source/","title":"File dma.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief  This file provides DMA configuration to automatically\n *         store ADC acquisitions in a provided buffer.\n *         DMA 1 is used for all acquisitions, with channel n\n *         acquiring values from ADC n.\n */\n\n#ifndef DMA_H_\n#define DMA_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n\nvoid dma_configure_adc_acquisition(uint8_t adc_number,\n                                   bool disable_interrupts,\n                                   uint16_t* buffer,\n                                   size_t buffer_size);\n\nuint32_t dma_get_retrieved_data_count(uint8_t adc_number);\n\n\n#endif /* DMA_H_ */\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/","title":"File hardware_auto_configuration.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * cdc_acm_console   = <code>DEVICE\\_DT\\_GET(CDC\\_ACM\\_DEVICE)</code> const struct device * dac2   = <code>DEVICE\\_DT\\_GET(DAC2\\_DEVICE)</code>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions","title":"Public Functions","text":"Type Name K_WORK_DEFINE (reboot_bootloader_work, reboot_bootloader_task)  SYS_INIT (_vrefbuf_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_dac2_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_console_init, APPLICATION, 89)  SYS_INIT (_img_validation, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  SYS_INIT (_register_cdc_rate_callback, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  SYS_INIT (_swap_usart1_tx_rx, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  void _cdc_rate_callback (const struct device * dev, uint32_t rate) Register the CDC ACM baud rate callback. void reboot_bootloader_task (struct k_work * work) Submit a warm reboot into bootloader mode."},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name int _console_init () Initialize the console backend (e.g., UART). int _dac2_init () Initialize DAC2 in constant voltage mode. int _img_validation () Validate and confirm the current firmware image in MCUBoot. int _register_cdc_rate_callback () Register the CDC ACM baud rate callback. int _swap_usart1_tx_rx () Swap TX and RX lines for USART1 (LPUART1). int _vrefbuf_init () Initialize the internal voltage reference buffer (VREFBUF)."},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-cdc_acm_console","title":"variable cdc_acm_console","text":"<pre><code>const struct device* cdc_acm_console;\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-dac2","title":"variable dac2","text":"<pre><code>const struct device* dac2;\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-k_work_define","title":"function K_WORK_DEFINE","text":"<pre><code>K_WORK_DEFINE (\n    reboot_bootloader_work,\n    reboot_bootloader_task\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _vrefbuf_init,\n    PRE_KERNEL_1,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre> <p>Zephyr macros to automatically run above functions </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_1","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _dac2_init,\n    PRE_KERNEL_2,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_2","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _console_init,\n    APPLICATION,\n    89\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_3","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _img_validation,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_4","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _register_cdc_rate_callback,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_5","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _swap_usart1_tx_rx,\n    PRE_KERNEL_1,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_cdc_rate_callback","title":"function _cdc_rate_callback","text":"<p>Register the CDC ACM baud rate callback. <pre><code>void _cdc_rate_callback (\n    const struct device * dev,\n    uint32_t rate\n) \n</code></pre></p> <p>Used in USB bootloader entry mechanism (e.g., Arduino-style 1200bps trick).</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-reboot_bootloader_task","title":"function reboot_bootloader_task","text":"<p>Submit a warm reboot into bootloader mode. <pre><code>void reboot_bootloader_task (\n    struct k_work * work\n) \n</code></pre></p> <p>Called by the 1200 baud callback to initiate a soft reset into DFU mode.</p> <p>Parameters:</p> <ul> <li><code>work</code> Pointer to work item (unused). </li> </ul>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_console_init","title":"function _console_init","text":"<p>Initialize the console backend (e.g., UART). <pre><code>static int _console_init () \n</code></pre></p> <p>Calls the console_init function defined elsewhere in the system.</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_dac2_init","title":"function _dac2_init","text":"<p>Initialize DAC2 in constant voltage mode. <pre><code>static int _dac2_init () \n</code></pre></p> <p>If DAC2 is ready, this function sets an output value of 2048 (mid-scale), configures it for external output, and starts the DAC.</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_img_validation","title":"function _img_validation","text":"<p>Validate and confirm the current firmware image in MCUBoot. <pre><code>static int _img_validation () \n</code></pre></p> <p>If the image is not yet confirmed, this function writes the confirmation flag. Useful in MCUboot-based systems to prevent rollback after boot.</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_register_cdc_rate_callback","title":"function _register_cdc_rate_callback","text":"<p>Register the CDC ACM baud rate callback. <pre><code>static int _register_cdc_rate_callback () \n</code></pre></p> <p>Used in USB bootloader entry mechanism (e.g., Arduino-style 1200bps trick).</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_swap_usart1_tx_rx","title":"function _swap_usart1_tx_rx","text":"<p>Swap TX and RX lines for USART1 (LPUART1). <pre><code>static int _swap_usart1_tx_rx () \n</code></pre></p> <p>Disables the LPUART1 peripheral, swaps the TX/RX pins, and re-enables it.</p> <p>Used with the O2 board.</p> <p>Returns:</p> <p>Always returns 0 (success). </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_vrefbuf_init","title":"function _vrefbuf_init","text":"<p>Initialize the internal voltage reference buffer (VREFBUF). <pre><code>static int _vrefbuf_init () \n</code></pre></p> <p>Enables the SYSCFG clock, configures the voltage scaling, disables high-impedance mode, and activates the VREFBUF output.</p> <p>Returns:</p> <p>Always returns 0 (success). </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/hardware_auto_configuration.cpp</code></p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp_source/","title":"File hardware_auto_configuration.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2024\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Jean Alinei &lt;jean.alinei@laas.fr&gt;\n *\n * @brief  This file automatically performs some hardware configuration\n *         using Zephyr macros.\n *         Configuration done in this file is low-level peripheral configuration\n *         required for OwnTech board to operate, do not mess with it unless you\n *         are absolutely sure of what you're doing.\n *         This file does not contain any public function.\n */\n\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n/* STM32 LL */\n#include &lt;stm32_ll_bus.h&gt;\n#include &lt;stm32_ll_system.h&gt;\n\n/* Owntech driver */\n#include \"dac.h\"\n\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\n\n/* Functions to be run */\n\nstatic int _vrefbuf_init()\n{\n    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);\n    LL_VREFBUF_SetVoltageScaling(LL_VREFBUF_VOLTAGE_SCALE0);\n    LL_VREFBUF_DisableHIZ();\n    LL_VREFBUF_Enable();\n\n    return 0;\n}\n\nstatic int _dac2_init()\n{\n    if (device_is_ready(dac2) == true)\n    {\n        dac_set_const_value(dac2, 1, 2048U);\n        dac_pin_configure(dac2, 1, dac_pin_external);\n        dac_start(dac2, 1);\n    }\n\n    return 0;\n}\n\nstatic int _console_init()\n{\n    console_init();\n\n    return 0;\n}\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/dfu/mcuboot.h&gt;\n\nstatic int _img_validation()\n{\n    if (boot_is_img_confirmed() == false)\n    {\n        int rc = boot_write_img_confirmed();\n        if (rc != 0)\n        {\n            printk(\"Failed to confirm image\");\n        }\n    }\n\n    return 0;\n}\n#endif /* CONFIG_BOOTLOADER_MCUBOOT */\n\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; \\\n    defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; \\\n    defined(CONFIG_USB_CDC_ACM)\n\n#include &lt;zephyr/retention/bootmode.h&gt;\n#include &lt;zephyr/sys/reboot.h&gt;\n\nvoid reboot_bootloader_task(struct k_work* work)\n{\n    bootmode_set(BOOT_MODE_TYPE_BOOTLOADER);\n    sys_reboot(SYS_REBOOT_WARM);\n}\n\nK_WORK_DEFINE(reboot_bootloader_work, reboot_bootloader_task);\n\nvoid _cdc_rate_callback(const struct device* dev, uint32_t rate)\n{\n    if (rate == 1200)\n    {\n        k_work_submit(&amp;reboot_bootloader_work);\n    }\n}\n\n#include &lt;zephyr/drivers/uart/cdc_acm.h&gt;\n#define CDC_ACM_DEVICE DT_NODELABEL(cdc_acm_uart0)\nstatic const struct device* cdc_acm_console = DEVICE_DT_GET(CDC_ACM_DEVICE);\n\nstatic int _register_cdc_rate_callback()\n{\n    cdc_acm_dte_rate_callback_set(cdc_acm_console, _cdc_rate_callback);\n\n    return 0;\n}\n#endif /* CONFIG_RETENTION_BOOT_MODE &amp;&amp;\n        * CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp;\n        * CONFIG_USB_CDC_ACM */\n\n\n#ifdef CONFIG_SHIELD_O2\n#include &lt;stm32_ll_lpuart.h&gt;\nstatic int _swap_usart1_tx_rx()\n{\n    LL_LPUART_Disable(LPUART1);\n    LL_LPUART_SetTXRXSwap(LPUART1, LL_LPUART_TXRX_SWAPPED);\n    LL_LPUART_Enable(LPUART1);\n\n    return 0;\n}\n#endif /* SHIELD_O2 */\n\n\n/* To be run in the first init phase */\nSYS_INIT(_vrefbuf_init,\n         PRE_KERNEL_1,\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\n/* To be run in the second init phase (depends on DAC driver initialization)*/\nSYS_INIT(_dac2_init,\n         PRE_KERNEL_2,\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\nSYS_INIT(_console_init,\n         APPLICATION,\n         89\n        );\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\nSYS_INIT(_img_validation,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif /* CONFIG_BOOTLOADER_MCUBOOT */\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; \\\n    defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; \\\n    defined(CONFIG_USB_CDC_ACM)\n\nSYS_INIT(_register_cdc_rate_callback,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif /* CONFIG_RETENTION_BOOT_MODE &amp;&amp;\n        * CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp;\n        * CONFIG_USB_CDC_ACM */\n\n#ifdef CONFIG_SHIELD_O2\n/* To be run in the first init phase */\nSYS_INIT(_swap_usart1_tx_rx,\n         PRE_KERNEL_1,\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n#endif /* SHIELD_O2*/\n</code></pre>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/","title":"Dir docs/core/zephyr/modules/owntech_task_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api</p>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/</code></p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr</p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/</code></p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/#files","title":"Files","text":"Type Name file TaskAPI.cpp file TaskAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/TaskAPI_8cpp/","title":"File TaskAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8cpp/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.cpp</code></p>"},{"location":"powerAPI/TaskAPI_8cpp_source/","title":"File TaskAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n\n/* OwnTech Power API */\n#include \"../src/uninterruptible_synchronous_task.h\"\n#include \"../src/asynchronous_tasks.h\"\n\n\n/* Current class header */\n#include \"TaskAPI.h\"\n\n\nconst int TaskAPI::DEFAULT_PRIORITY = 5;\n\n\nTaskAPI task;\n\n/* Public API */\n\n/* Non-interruptable control task */\nint8_t TaskAPI::createCritical(task_function_t periodic_task,\n                               uint32_t task_period_us,\n                               scheduling_interrupt_source_t int_source)\n{\n    scheduling_set_uninterruptible_synchronous_task_interrupt_source(int_source);\n\n    return scheduling_define_uninterruptible_synchronous_task(periodic_task,\n                                                              task_period_us);\n}\n\nvoid TaskAPI::startCritical(bool manage_data_acquisition)\n{\n    scheduling_start_uninterruptible_synchronous_task(manage_data_acquisition);\n}\n\nvoid TaskAPI::stopCritical()\n{\n    scheduling_stop_uninterruptible_synchronous_task();\n}\n\n\n/* Asynchronous tasks */\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\nint8_t TaskAPI::createBackground(task_function_t routine)\n{\n    return scheduling_define_asynchronous_task(routine);\n}\n\nvoid TaskAPI::startBackground(uint8_t task_number)\n{\n    scheduling_start_asynchronous_task(task_number);\n}\n\nvoid TaskAPI::stopBackground(uint8_t task_number)\n{\n    scheduling_stop_asynchronous_task(task_number);\n}\n\n/* Suspend asynchronous tasks */\n\nvoid TaskAPI::suspendBackgroundMs(uint32_t duration_ms)\n{\n    k_sleep(K_MSEC(duration_ms));\n}\n\nvoid TaskAPI::suspendBackgroundUs(uint32_t duration_us)\n{\n    k_sleep(K_USEC(duration_us));\n}\n\n#endif /* CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS */\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/","title":"File TaskAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8h/#classes","title":"Classes","text":"Type Name class TaskAPI"},{"location":"powerAPI/TaskAPI_8h/#public-types","title":"Public Types","text":"Type Name enum scheduling_interrupt_source_t typedef void(* task_function_t"},{"location":"powerAPI/TaskAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#enum-scheduling_interrupt_source_t","title":"enum scheduling_interrupt_source_t","text":"<pre><code>enum scheduling_interrupt_source_t {\n    source_uninitialized,\n    source_hrtim,\n    source_tim6\n};\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/#typedef-task_function_t","title":"typedef task_function_t","text":"<pre><code>typedef void(* task_function_t) ();\n</code></pre> <p>Public types </p>"},{"location":"powerAPI/TaskAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>Public object to interact with the class </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/TaskAPI_8h_source/","title":"File TaskAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n */\n\n#ifndef TASKAPI_H_\n#define TASKAPI_H_\n\n\n/* Stdlib */\n#include &lt;stdint.h&gt;\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n\n\ntypedef void (*task_function_t)();\n\ntypedef enum { source_uninitialized,\n               source_hrtim,\n               source_tim6 }\n               scheduling_interrupt_source_t;\n\n\nclass TaskAPI\n{\npublic:\n    int8_t createCritical(\n                task_function_t periodic_task,\n                uint32_t task_period_us,\n                scheduling_interrupt_source_t int_source = source_hrtim\n            );\n\n    void startCritical(bool manage_data_acquisition = true);\n\n    void stopCritical();\n\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\n    int8_t createBackground(task_function_t routine);\n\n    void startBackground(uint8_t task_number);\n\n    void stopBackground(uint8_t task_number);\n\n    void suspendBackgroundMs(uint32_t duration_ms);\n\n    void suspendBackgroundUs(uint32_t duration_us);\n\n#endif /* CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS */\n\nprivate:\n    static const int DEFAULT_PRIORITY;\n\n};\n\n\nextern TaskAPI task;\n\n\n#endif /* TASKAPI_H_ */\n</code></pre>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver</p>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/</code></p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/#files","title":"Files","text":"Type Name file timer.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/timer_8h/","title":"File timer.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/timer_8h/#classes","title":"Classes","text":"Type Name struct timer_config_t Timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder: set to 1 for timer to act as an incremental coder counter. struct timer_driver_api Driver API structure for timer devices."},{"location":"powerAPI/timer_8h/#public-types","title":"Public Types","text":"Type Name enum pin_mode_t Enumeration for GPIO pin pull configurations. typedef void(* timer_api_config Function pointer type for timer configuration. typedef uint32_t(* timer_api_get_count Function pointer type for reading the timer count value. typedef void(* timer_api_start Function pointer type for starting the timer. typedef void(* timer_api_stop Function pointer type for stopping the timer. typedef void(* timer_callback_t"},{"location":"powerAPI/timer_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void timer_config (const struct device * dev, const struct timer_config_t * config) Configure the timer dev using given configuration structure config. uint32_t timer_get_count (const struct device * dev) Get the current timer counter value. void timer_start (const struct device * dev) Start the timer dev. void timer_stop (const struct device * dev) Stop the timer dev."},{"location":"powerAPI/timer_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/timer_8h/#enum-pin_mode_t","title":"enum pin_mode_t","text":"<p>Enumeration for GPIO pin pull configurations. <pre><code>enum pin_mode_t {\n    no_pull,\n    pull_up,\n    pull_down\n};\n</code></pre></p> <p>This enum defines the available pull modes that can be applied to a GPIO input pin.</p> <ul> <li><code>no_pull</code> disables pull-up or pull-down resistors.</li> <li><code>pull_up</code> enables an internal pull-up resistor.</li> <li><code>pull_down</code> enables an internal pull-down resistor. </li> </ul>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_config","title":"typedef timer_api_config","text":"<p>Function pointer type for timer configuration. <pre><code>typedef void(* timer_api_config) (const struct device *dev, const struct timer_config_t *config);\n</code></pre></p> <p>API </p> <p>This function configures the hardware timer using the provided settings.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to the timer device. </li> <li><code>config</code> Pointer to the timer configuration structure. </li> </ul>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_get_count","title":"typedef timer_api_get_count","text":"<p>Function pointer type for reading the timer count value. <pre><code>typedef uint32_t(* timer_api_get_count) (const struct device *dev);\n</code></pre></p> <p>This function returns the current counter value of the timer.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to the timer device.</li> </ul> <p>Returns:</p> <p>The current timer count. </p>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_start","title":"typedef timer_api_start","text":"<p>Function pointer type for starting the timer. <pre><code>typedef void(* timer_api_start) (const struct device *dev);\n</code></pre></p> <p>This function starts the timer associated with the given device.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to the timer device. </li> </ul>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_stop","title":"typedef timer_api_stop","text":"<p>Function pointer type for stopping the timer. <pre><code>typedef void(* timer_api_stop) (const struct device *dev);\n</code></pre></p> <p>This function stops the timer associated with the given device.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Pointer to the timer device. </li> </ul>"},{"location":"powerAPI/timer_8h/#typedef-timer_callback_t","title":"typedef timer_callback_t","text":"<pre><code>typedef void(* timer_callback_t) ();\n</code></pre> <p>Configuration structure </p>"},{"location":"powerAPI/timer_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/timer_8h/#function-timer_config","title":"function timer_config","text":"<p>Configure the timer dev using given configuration structure config. <pre><code>static inline void timer_config (\n    const struct device * dev,\n    const struct timer_config_t * config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> <li><code>config</code> Configuration holding the timer configuration. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_get_count","title":"function timer_get_count","text":"<p>Get the current timer counter value. <pre><code>static inline uint32_t timer_get_count (\n    const struct device * dev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>Returns:</p> <p>Current value of the timer internal counter. </p>"},{"location":"powerAPI/timer_8h/#function-timer_start","title":"function timer_start","text":"<p>Start the timer dev. <pre><code>static inline void timer_start (\n    const struct device * dev\n) \n</code></pre></p> <p>If timer is configured to provide a periodic interrupt, it will also enable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_stop","title":"function timer_stop","text":"<p>Stop the timer dev. <pre><code>static inline void timer_stop (\n    const struct device * dev\n) \n</code></pre></p> <p>If timer is configured to provide a periodic interrupt, it will also disable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/timer_8h_source/","title":"File timer.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-present LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2022\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n *\n * @brief  This file is the public include file for the\n *         Zephyr Timer driver. It provides basic functionality\n *         to handle STM32 Timers. Is is for now specific\n *         to certain capabilities of G4 series Timers,\n *         and mainly restricted to the use we do of\n *         the timers in the OwnTech project, but it aims\n *         at becoming more generic over time.\n *\n *         This version supports:\n * \n *         * Timer 6 and Timer 7: Periodic call of a callback function\n *           with period ranging from 2 to 6553 \u00b5s.\n * \n *         * Timer 4: Incremental coder acquisition with pinout:\n *           reset=PB3; CH1=PB6; CH2=PB7.\n */\n\n#ifndef TIMER_H_\n#define TIMER_H_\n\n\n/* Zephyr */\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define TIMER3_DEVICE DT_NODELABEL(timers3)\n#define TIMER4_DEVICE DT_NODELABEL(timers4)\n#define TIMER6_DEVICE DT_NODELABEL(timers6)\n#define TIMER7_DEVICE DT_NODELABEL(timers7)\n\n\ntypedef void (*timer_callback_t)();\n\ntypedef enum\n{\n    no_pull,\n    pull_up,\n    pull_down\n} pin_mode_t;\n\nstruct timer_config_t\n{\n    /* Mode */\n    uint32_t         timer_enable_irq     : 1;\n    uint32_t         timer_enable_encoder : 1;\n    /* IRQ options */\n    timer_callback_t timer_irq_callback;\n    uint32_t         timer_irq_t_usec;\n    uint32_t         timer_use_zero_latency : 1;\n    /* Incremental encoder option */\n    pin_mode_t       timer_enc_pin_mode;\n};\n\n\ntypedef void     (*timer_api_config)(\n                        const struct device* dev,\n                        const struct timer_config_t* config\n                  );\n\ntypedef void     (*timer_api_start)    (const struct device* dev);\n\ntypedef void     (*timer_api_stop)     (const struct device* dev);\n\ntypedef uint32_t (*timer_api_get_count)(const struct device* dev);\n\n__subsystem struct timer_driver_api\n{\n    timer_api_config    config;\n    timer_api_start     start;\n    timer_api_stop      stop;\n    timer_api_get_count get_count;\n};\n\n\nstatic inline void timer_config(const struct device* dev,\n                                const struct timer_config_t* config)\n{\n    const struct timer_driver_api* api =\n                                (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;config(dev, config);\n}\n\nstatic inline void timer_start(const struct device* dev)\n{\n    const struct timer_driver_api* api =\n                                (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev);\n}\n\nstatic inline void timer_stop(const struct device* dev)\n{\n    const struct timer_driver_api* api =\n                                (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev);\n}\n\nstatic inline uint32_t timer_get_count(const struct device* dev)\n{\n    const struct timer_driver_api* api =\n                                (const struct timer_driver_api*)(dev-&gt;api);\n\n    return api-&gt;get_count(dev);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* TIMER_H_ */\n</code></pre>"},{"location":"powerAPI/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"powerAPI/classes/","title":"Class Index","text":""},{"location":"powerAPI/classes/#a","title":"a","text":"<ul> <li>adc_hrtim_conf_t</li> <li>AnalogCommunication</li> </ul>"},{"location":"powerAPI/classes/#c","title":"c","text":"<ul> <li>can_control_work_data</li> <li>CanCommunication</li> <li>CommunicationAPI</li> <li>comp_usage_conf_t</li> <li>CompHAL</li> </ul>"},{"location":"powerAPI/classes/#d","title":"d","text":"<ul> <li>dac_driver_api</li> <li>dac_function_config_t</li> <li>DacHAL</li> <li>DataAPI</li> <li>dma_user_data_t</li> </ul>"},{"location":"powerAPI/classes/#g","title":"g","text":"<ul> <li>gpio_conf_t</li> <li>GpioHAL</li> </ul>"},{"location":"powerAPI/classes/#l","title":"l","text":"<ul> <li>LedHAL</li> </ul>"},{"location":"powerAPI/classes/#n","title":"n","text":"<ul> <li>NgndHAL</li> </ul>"},{"location":"powerAPI/classes/#p","title":"p","text":"<ul> <li>phase_shift_conf_t</li> <li>PowerAPI</li> <li>pwm_conf_t</li> <li>PwmHAL</li> </ul>"},{"location":"powerAPI/classes/#r","title":"r","text":"<ul> <li>Rs485Communication</li> </ul>"},{"location":"powerAPI/classes/#s","title":"s","text":"<ul> <li>SafetyAPI</li> <li>sensor_dt_data_t</li> <li>sensor_info_t</li> <li>SensorsAPI</li> <li>ShieldAPI</li> <li>SpinAPI</li> <li>switch_conv_conf_t</li> <li>SyncCommunication</li> </ul>"},{"location":"powerAPI/classes/#t","title":"t","text":"<ul> <li>TaskAPI</li> <li>timer_config_t</li> <li>timer_driver_api</li> <li>timer_hrtim_t</li> <li>TimerHAL</li> </ul>"},{"location":"powerAPI/classes/#u","title":"u","text":"<ul> <li>UartHAL</li> </ul>"},{"location":"powerAPI/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI Main communication API interface. </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class NgndHAL </li> <li>class PowerAPI </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class SafetyAPI </li> <li>class SensorsAPI </li> <li>class ShieldAPI </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class UartHAL Handles USART1 for the SPIN board. </li> <li>struct SensorsAPI::sensor_dt_data_t </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct can_control_work_data </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t Defines the DAC configuration structure. </li> <li>struct dma_user_data_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>struct sensor_info_t </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t Timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder: set to 1 for timer to act as an incremental coder counter. </li> <li>struct timer_driver_api Driver API structure for timer devices. </li> <li>struct timer_hrtim_t Timing unit configuration that aggregates all the structures: </li> </ul>"},{"location":"powerAPI/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"powerAPI/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"powerAPI/class_members/","title":"Class Members","text":""},{"location":"powerAPI/class_members/#a","title":"a","text":"<ul> <li>analog (CommunicationAPI)</li> <li>adcInitialized (DataAPI)</li> <li>available_sensors_count (SensorsAPI)</li> <li>available_sensors_props (SensorsAPI)</li> <li>adc_number (SensorsAPI::sensor_dt_data_t)</li> <li>adc_reg_addr (SensorsAPI::sensor_dt_data_t)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_num (sensor_info_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#b","title":"b","text":"<ul> <li>buildSensorListFromDeviceTree (SensorsAPI)</li> <li>buf (can_control_work_data)</li> <li>buf_len (can_control_work_data)</li> <li>burst_clk (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#c","title":"c","text":"<ul> <li>can (CommunicationAPI)</li> <li>currentModeInit (DacHAL)</li> <li>channels_ranks (DataAPI)</li> <li>configureDiscontinuousMode (DataAPI)</li> <li>configureTriggerSource (DataAPI)</li> <li>convertValue (DataAPI)</li> <li>converted_values_buffer (DataAPI)</li> <li>current_adc (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>connectCapacitor (PowerAPI)</li> <li>connectDriver (PowerAPI)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>conv_type_string_t (SensorsAPI)</li> <li>convertRawValue (SensorsAPI)</li> <li>channel_number (SensorsAPI::sensor_dt_data_t)</li> <li>conversion_type (SensorsAPI::sensor_dt_data_t)</li> <li>comp (SpinAPI)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>channel (dma_user_data_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>channel_num (sensor_info_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#d","title":"d","text":"<ul> <li>disableChannel (DataAPI)</li> <li>dispatch_method (DataAPI)</li> <li>doFullDispatch (DataAPI)</li> <li>disconnectCapacitor (PowerAPI)</li> <li>disconnectDriver (PowerAPI)</li> <li>deInitBurstMode (PwmHAL)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>disableSafetyApi (SafetyAPI)</li> <li>dt_sensors_props (SensorsAPI)</li> <li>default_b (SensorsAPI::sensor_dt_data_t)</li> <li>default_gain (SensorsAPI::sensor_dt_data_t)</li> <li>default_offset (SensorsAPI::sensor_dt_data_t)</li> <li>default_r0 (SensorsAPI::sensor_dt_data_t)</li> <li>default_rdiv (SensorsAPI::sensor_dt_data_t)</li> <li>default_t0 (SensorsAPI::sensor_dt_data_t)</li> <li>dac (SpinAPI)</li> <li>data (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>dst (dma_user_data_t)</li> <li>duty_cycle (pwm_conf_t)</li> <li>duty_max (pwm_conf_t)</li> <li>duty_max_user (pwm_conf_t)</li> <li>duty_max_user_float (pwm_conf_t)</li> <li>duty_min (pwm_conf_t)</li> <li>duty_min_user (pwm_conf_t)</li> <li>duty_min_user_float (pwm_conf_t)</li> <li>duty_swap (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#e","title":"e","text":"<ul> <li>enableAcquisition (DataAPI)</li> <li>enableChannel (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>enableSafetyApi (SafetyAPI)</li> <li>enableDefaultOwnverterSensors (SensorsAPI)</li> <li>enableDefaultTwistSensors (SensorsAPI)</li> <li>enableSensor (SensorsAPI)</li> <li>enabled_sensors (SensorsAPI)</li> <li>external_trigger (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#g","title":"g","text":"<ul> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastEnable (CanCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getStartStopState (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getChannelValues (DataAPI)</li> <li>getConversionParameterType (DataAPI)</li> <li>getConversionParameterValue (DataAPI)</li> <li>getCurrentAdcForPin (DataAPI)</li> <li>getDefaultAdcForPin (DataAPI)</li> <li>getLatestValue (DataAPI, SensorsAPI)</li> <li>getRawValues (DataAPI, SensorsAPI)</li> <li>getValues (DataAPI, SensorsAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getDutyCycleMax (PowerAPI)</li> <li>getDutyCycleMaxRaw (PowerAPI)</li> <li>getDutyCycleMin (PowerAPI)</li> <li>getDutyCycleMinRaw (PowerAPI)</li> <li>getPeriod (PowerAPI, PwmHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getFrequencyMax (PwmHAL)</li> <li>getFrequencyMin (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodMax (PwmHAL)</li> <li>getPeriodMin (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getResolutionPs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>getChannelError (SafetyAPI)</li> <li>getChannelReaction (SafetyAPI)</li> <li>getChannelThresholdMax (SafetyAPI)</li> <li>getChannelThresholdMin (SafetyAPI)</li> <li>getChannelWatch (SafetyAPI)</li> <li>getCalibrationCoefficients (SensorsAPI)</li> <li>getEnabledSensorInfo (SensorsAPI)</li> <li>getLineFromConsole (SensorsAPI)</li> <li>gpio (SpinAPI)</li> <li>getIncrementalEncoderValue (TimerHAL)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#h","title":"h","text":"<ul> <li>has_interrupt (dma_user_data_t)</li> </ul>"},{"location":"powerAPI/class_members/#i","title":"i","text":"<ul> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>initializeAllAdcs (DataAPI)</li> <li>is_started (DataAPI)</li> <li>initBoost (PowerAPI)</li> <li>initBuck (PowerAPI)</li> <li>initMode (PowerAPI)</li> <li>initBurstMode (PwmHAL)</li> <li>initFixedFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initVariableFrequency (PwmHAL)</li> <li>initShield (SafetyAPI)</li> <li>initialized (SensorsAPI)</li> <li>is_differential (SensorsAPI::sensor_dt_data_t)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>Initialize (TimerHAL)</li> </ul>"},{"location":"powerAPI/class_members/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_members/#m","title":"m","text":"<ul> <li>max_frequency (pwm_conf_t)</li> <li>max_period (pwm_conf_t)</li> <li>min_frequency (pwm_conf_t)</li> <li>min_period (pwm_conf_t)</li> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#n","title":"n","text":"<ul> <li>name (SensorsAPI::sensor_dt_data_t)</li> <li>ngnd (ShieldAPI)</li> </ul>"},{"location":"powerAPI/class_members/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#p","title":"p","text":"<ul> <li>peekChannel (DataAPI)</li> <li>peekLatestValue (DataAPI, SensorsAPI)</li> <li>period (PwmHAL, pwm_conf_t)</li> <li>pin_number (SensorsAPI::sensor_dt_data_t)</li> <li>power (ShieldAPI)</li> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>pin_num (sensor_info_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>retrieveConversionParametersFromMemory (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>retrieveThreshold (SafetyAPI)</li> <li>retrieveParametersFromMemory (SensorsAPI)</li> <li>retrieveStoredConversionType (SensorsAPI)</li> <li>retrieveStoredParameterValue (SensorsAPI)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>resolution (pwm_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#s","title":"s","text":"<ul> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastEnable (CanCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>startSlaveDevice (CanCommunication)</li> <li>stopSlaveDevice (CanCommunication)</li> <li>sync (CommunicationAPI)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setConversionParametersLinear (DataAPI, SensorsAPI)</li> <li>setConversionParametersNtcThermistor (DataAPI, SensorsAPI)</li> <li>setDispatchMethod (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>start (DataAPI, PowerAPI, dac_driver_api, timer_driver_api)</li> <li>started (DataAPI)</li> <li>stop (DataAPI, PowerAPI, dac_driver_api, timer_driver_api)</li> <li>storeConversionParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecim (PowerAPI)</li> <li>setDeadTime (PowerAPI, PwmHAL)</li> <li>setDutyCycle (PowerAPI, PwmHAL)</li> <li>setDutyCycleMax (PowerAPI)</li> <li>setDutyCycleMaxRaw (PowerAPI)</li> <li>setDutyCycleMin (PowerAPI)</li> <li>setDutyCycleMinRaw (PowerAPI)</li> <li>setDutyCycleRaw (PowerAPI, PwmHAL)</li> <li>setPhaseShift (PowerAPI, PwmHAL)</li> <li>setSlopeCompensation (PowerAPI)</li> <li>setTriggerValue (PowerAPI)</li> <li>spinNumberToTu (PowerAPI)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setBurstMode (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startBurstMode (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopBurstMode (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>swap_state (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>setChannelReaction (SafetyAPI)</li> <li>setChannelThresholdMax (SafetyAPI)</li> <li>setChannelThresholdMin (SafetyAPI)</li> <li>setChannelWatch (SafetyAPI)</li> <li>storeThreshold (SafetyAPI)</li> <li>setOwnverterTempMeas (SensorsAPI)</li> <li>setTwistSensorsUserCalibrationFactors (SensorsAPI)</li> <li>storeParametersInMemory (SensorsAPI)</li> <li>sensors (ShieldAPI)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogIncrementalEncoder (TimerHAL)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>size (dma_user_data_t)</li> <li>src (dma_user_data_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>sensor_info_t (sensor_info_t)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#t","title":"t","text":"<ul> <li>ts_can_inst (CanCommunication)</li> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL, NgndHAL)</li> <li>turnOn (LedHAL, NgndHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>temp_mux_in_1 (SensorsAPI)</li> <li>temp_mux_in_2 (SensorsAPI)</li> <li>triggerTwistTempMeas (SensorsAPI)</li> <li>timer (SpinAPI)</li> <li>timer3init (TimerHAL)</li> <li>timer3started (TimerHAL)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> <li>timer_use_zero_latency (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_members/#u","title":"u","text":"<ul> <li>unsetChannelWatch (SafetyAPI)</li> <li>uart (SpinAPI)</li> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#v","title":"v","text":"<ul> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> <li>work (can_control_work_data)</li> </ul>"},{"location":"powerAPI/class_member_functions/","title":"Class Member Functions","text":""},{"location":"powerAPI/class_member_functions/#b","title":"b","text":"<ul> <li>buildSensorListFromDeviceTree (SensorsAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#c","title":"c","text":"<ul> <li>currentModeInit (DacHAL)</li> <li>configureDiscontinuousMode (DataAPI)</li> <li>configureTriggerSource (DataAPI)</li> <li>convertValue (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>connectCapacitor (PowerAPI)</li> <li>connectDriver (PowerAPI)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>convertRawValue (SensorsAPI)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#d","title":"d","text":"<ul> <li>disableChannel (DataAPI)</li> <li>doFullDispatch (DataAPI)</li> <li>disconnectCapacitor (PowerAPI)</li> <li>disconnectDriver (PowerAPI)</li> <li>deInitBurstMode (PwmHAL)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>disableSafetyApi (SafetyAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#e","title":"e","text":"<ul> <li>enableAcquisition (DataAPI)</li> <li>enableChannel (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>enableSafetyApi (SafetyAPI)</li> <li>enableDefaultOwnverterSensors (SensorsAPI)</li> <li>enableDefaultTwistSensors (SensorsAPI)</li> <li>enableSensor (SensorsAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#g","title":"g","text":"<ul> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastEnable (CanCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getStartStopState (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getChannelValues (DataAPI)</li> <li>getConversionParameterType (DataAPI)</li> <li>getConversionParameterValue (DataAPI)</li> <li>getCurrentAdcForPin (DataAPI)</li> <li>getDefaultAdcForPin (DataAPI)</li> <li>getLatestValue (DataAPI, SensorsAPI)</li> <li>getRawValues (DataAPI, SensorsAPI)</li> <li>getValues (DataAPI, SensorsAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getDutyCycleMax (PowerAPI)</li> <li>getDutyCycleMaxRaw (PowerAPI)</li> <li>getDutyCycleMin (PowerAPI)</li> <li>getDutyCycleMinRaw (PowerAPI)</li> <li>getPeriod (PowerAPI, PwmHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getFrequencyMax (PwmHAL)</li> <li>getFrequencyMin (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodMax (PwmHAL)</li> <li>getPeriodMin (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getResolutionPs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>getChannelError (SafetyAPI)</li> <li>getChannelReaction (SafetyAPI)</li> <li>getChannelThresholdMax (SafetyAPI)</li> <li>getChannelThresholdMin (SafetyAPI)</li> <li>getChannelWatch (SafetyAPI)</li> <li>getCalibrationCoefficients (SensorsAPI)</li> <li>getEnabledSensorInfo (SensorsAPI)</li> <li>getLineFromConsole (SensorsAPI)</li> <li>getIncrementalEncoderValue (TimerHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/#i","title":"i","text":"<ul> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>initializeAllAdcs (DataAPI)</li> <li>initBoost (PowerAPI)</li> <li>initBuck (PowerAPI)</li> <li>initMode (PowerAPI)</li> <li>initBurstMode (PwmHAL)</li> <li>initFixedFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initVariableFrequency (PwmHAL)</li> <li>initShield (SafetyAPI)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>Initialize (TimerHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/#p","title":"p","text":"<ul> <li>peekChannel (DataAPI)</li> <li>peekLatestValue (DataAPI, SensorsAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#r","title":"r","text":"<ul> <li>retrieveConversionParametersFromMemory (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>retrieveThreshold (SafetyAPI)</li> <li>retrieveParametersFromMemory (SensorsAPI)</li> <li>retrieveStoredConversionType (SensorsAPI)</li> <li>retrieveStoredParameterValue (SensorsAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#s","title":"s","text":"<ul> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastEnable (CanCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>startSlaveDevice (CanCommunication)</li> <li>stopSlaveDevice (CanCommunication)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setConversionParametersLinear (DataAPI, SensorsAPI)</li> <li>setConversionParametersNtcThermistor (DataAPI, SensorsAPI)</li> <li>setDispatchMethod (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>start (DataAPI, PowerAPI)</li> <li>started (DataAPI)</li> <li>stop (DataAPI, PowerAPI)</li> <li>storeConversionParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecim (PowerAPI)</li> <li>setDeadTime (PowerAPI, PwmHAL)</li> <li>setDutyCycle (PowerAPI, PwmHAL)</li> <li>setDutyCycleMax (PowerAPI)</li> <li>setDutyCycleMaxRaw (PowerAPI)</li> <li>setDutyCycleMin (PowerAPI)</li> <li>setDutyCycleMinRaw (PowerAPI)</li> <li>setDutyCycleRaw (PowerAPI, PwmHAL)</li> <li>setPhaseShift (PowerAPI, PwmHAL)</li> <li>setSlopeCompensation (PowerAPI)</li> <li>setTriggerValue (PowerAPI)</li> <li>spinNumberToTu (PowerAPI)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setBurstMode (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startBurstMode (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopBurstMode (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>setChannelReaction (SafetyAPI)</li> <li>setChannelThresholdMax (SafetyAPI)</li> <li>setChannelThresholdMin (SafetyAPI)</li> <li>setChannelWatch (SafetyAPI)</li> <li>storeThreshold (SafetyAPI)</li> <li>setOwnverterTempMeas (SensorsAPI)</li> <li>setTwistSensorsUserCalibrationFactors (SensorsAPI)</li> <li>storeParametersInMemory (SensorsAPI)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogIncrementalEncoder (TimerHAL)</li> <li>sensor_info_t (sensor_info_t)</li> </ul>"},{"location":"powerAPI/class_member_functions/#t","title":"t","text":"<ul> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL, NgndHAL)</li> <li>turnOn (LedHAL, NgndHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>triggerTwistTempMeas (SensorsAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#u","title":"u","text":"<ul> <li>unsetChannelWatch (SafetyAPI)</li> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> </ul>"},{"location":"powerAPI/class_member_variables/","title":"Class Member Variables","text":""},{"location":"powerAPI/class_member_variables/#a","title":"a","text":"<ul> <li>analog (CommunicationAPI)</li> <li>adcInitialized (DataAPI)</li> <li>available_sensors_count (SensorsAPI)</li> <li>available_sensors_props (SensorsAPI)</li> <li>adc_number (SensorsAPI::sensor_dt_data_t)</li> <li>adc_reg_addr (SensorsAPI::sensor_dt_data_t)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_num (sensor_info_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#b","title":"b","text":"<ul> <li>buf (can_control_work_data)</li> <li>buf_len (can_control_work_data)</li> <li>burst_clk (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#c","title":"c","text":"<ul> <li>can (CommunicationAPI)</li> <li>channels_ranks (DataAPI)</li> <li>converted_values_buffer (DataAPI)</li> <li>current_adc (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>channel_number (SensorsAPI::sensor_dt_data_t)</li> <li>conversion_type (SensorsAPI::sensor_dt_data_t)</li> <li>comp (SpinAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>channel (dma_user_data_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>channel_num (sensor_info_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#d","title":"d","text":"<ul> <li>dispatch_method (DataAPI)</li> <li>dt_sensors_props (SensorsAPI)</li> <li>default_b (SensorsAPI::sensor_dt_data_t)</li> <li>default_gain (SensorsAPI::sensor_dt_data_t)</li> <li>default_offset (SensorsAPI::sensor_dt_data_t)</li> <li>default_r0 (SensorsAPI::sensor_dt_data_t)</li> <li>default_rdiv (SensorsAPI::sensor_dt_data_t)</li> <li>default_t0 (SensorsAPI::sensor_dt_data_t)</li> <li>dac (SpinAPI)</li> <li>data (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>dst (dma_user_data_t)</li> <li>duty_cycle (pwm_conf_t)</li> <li>duty_max (pwm_conf_t)</li> <li>duty_max_user (pwm_conf_t)</li> <li>duty_max_user_float (pwm_conf_t)</li> <li>duty_min (pwm_conf_t)</li> <li>duty_min_user (pwm_conf_t)</li> <li>duty_min_user_float (pwm_conf_t)</li> <li>duty_swap (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#e","title":"e","text":"<ul> <li>enabled_sensors (SensorsAPI)</li> <li>external_trigger (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (SpinAPI)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#h","title":"h","text":"<ul> <li>has_interrupt (dma_user_data_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#i","title":"i","text":"<ul> <li>is_started (DataAPI)</li> <li>initialized (SensorsAPI)</li> <li>is_differential (SensorsAPI::sensor_dt_data_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#m","title":"m","text":"<ul> <li>max_frequency (pwm_conf_t)</li> <li>max_period (pwm_conf_t)</li> <li>min_frequency (pwm_conf_t)</li> <li>min_period (pwm_conf_t)</li> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#n","title":"n","text":"<ul> <li>name (SensorsAPI::sensor_dt_data_t)</li> <li>ngnd (ShieldAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#p","title":"p","text":"<ul> <li>period (PwmHAL, pwm_conf_t)</li> <li>pin_number (SensorsAPI::sensor_dt_data_t)</li> <li>power (ShieldAPI)</li> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>pin_num (sensor_info_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>resolution (pwm_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#s","title":"s","text":"<ul> <li>sync (CommunicationAPI)</li> <li>swap_state (PwmHAL)</li> <li>sensors (ShieldAPI)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>start (dac_driver_api, timer_driver_api)</li> <li>stop (dac_driver_api, timer_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>size (dma_user_data_t)</li> <li>src (dma_user_data_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#t","title":"t","text":"<ul> <li>ts_can_inst (CanCommunication)</li> <li>temp_mux_in_1 (SensorsAPI)</li> <li>temp_mux_in_2 (SensorsAPI)</li> <li>timer (SpinAPI)</li> <li>timer3init (TimerHAL)</li> <li>timer3started (TimerHAL)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> <li>timer_use_zero_latency (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#u","title":"u","text":"<ul> <li>uart (SpinAPI)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#v","title":"v","text":"<ul> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#w","title":"w","text":"<ul> <li>work (can_control_work_data)</li> </ul>"},{"location":"powerAPI/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"powerAPI/class_member_enums/","title":"Class Member Enums","text":""},{"location":"powerAPI/class_member_enums/#c","title":"c","text":"<ul> <li>conv_type_string_t (SensorsAPI)</li> </ul>"},{"location":"powerAPI/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"powerAPI/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"powerAPI/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"powerAPI/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"powerAPI/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"powerAPI/functions/","title":"Functions","text":""},{"location":"powerAPI/functions/#a","title":"a","text":"<ul> <li>adc_add_channel (adc.c, adc.h)</li> <li>adc_configure_discontinuous_mode (adc.c, adc.h)</li> <li>adc_configure_trigger_source (adc.c, adc.h)</li> <li>adc_configure_use_dma (adc.c, adc.h)</li> <li>adc_get_enabled_channels_count (adc.c, adc.h)</li> <li>adc_remove_channel (adc.c, adc.h)</li> <li>adc_start (adc.c, adc.h)</li> <li>adc_stop (adc.c, adc.h)</li> <li>adc_trigger_software_conversion (adc.c, adc.h)</li> </ul>"},{"location":"powerAPI/functions/#c","title":"c","text":"<ul> <li>can_control_init (thingset_can.c)</li> <li>can_control_rx_handler (thingset_can.c)</li> <li>can_control_work_handler (thingset_can.c)</li> <li>comparator1_init (comparator.c, comparator.h)</li> <li>comparator3_init (comparator.c, comparator.h)</li> </ul>"},{"location":"powerAPI/functions/#d","title":"d","text":"<ul> <li>dma_channel_init_rx (Rs485.cpp, Rs485.h)</li> <li>dma_channel_init_tx (Rs485.cpp, Rs485.h)</li> <li>dac_function_update_reset (dac.h)</li> <li>dac_function_update_step (dac.h)</li> <li>dac_pin_configure (dac.h)</li> <li>dac_set_const_value (dac.h)</li> <li>dac_set_function (dac.h)</li> <li>dac_start (dac.h)</li> <li>dac_stop (dac.h)</li> <li>DualDAC_init (hrtim.h)</li> <li>data_conversion_convert_raw_value (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_get_conversion_type (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_get_parameter (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_init (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_retrieve_channel_parameters_from_nvs (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_set_conversion_parameters_linear (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_set_conversion_parameters_therm (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_store_channel_parameters_in_nvs (data_conversion.cpp, data_conversion.h)</li> <li>data_dispatch_do_dispatch (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_do_full_dispatch (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_get_acquired_values (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_init (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_peek_acquired_value (data_dispatch.cpp, data_dispatch.h)</li> <li>dma_configure_adc_acquisition (dma.cpp, dma.h)</li> <li>dma_get_retrieved_data_count (dma.cpp, dma.h)</li> </ul>"},{"location":"powerAPI/functions/#h","title":"h","text":"<ul> <li>hrtim_PeriodicEvent_GetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_SetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_configure (hrtim.h)</li> <li>hrtim_PeriodicEvent_dis (hrtim.h)</li> <li>hrtim_PeriodicEvent_en (hrtim.h)</li> <li>hrtim_adc_rollover_get (hrtim.h)</li> <li>hrtim_adc_rollover_set (hrtim.h)</li> <li>hrtim_adc_trigger_dis (hrtim.h)</li> <li>hrtim_adc_trigger_en (hrtim.h)</li> <li>hrtim_adc_trigger_get (hrtim.h)</li> <li>hrtim_adc_trigger_set (hrtim.h)</li> <li>hrtim_adc_trigger_set_postscaler (hrtim.h)</li> <li>hrtim_burst_dis (hrtim.h)</li> <li>hrtim_burst_mode_init (hrtim.h)</li> <li>hrtim_burst_set (hrtim.h)</li> <li>hrtim_burst_start (hrtim.h)</li> <li>hrtim_burst_stop (hrtim.h)</li> <li>hrtim_change_frequency (hrtim.h)</li> <li>hrtim_cmpl_pwm_out (hrtim.h)</li> <li>hrtim_cnt_dis (hrtim.h)</li> <li>hrtim_cnt_en (hrtim.h)</li> <li>hrtim_dt_init (hrtim.h)</li> <li>hrtim_dt_set (hrtim.h)</li> <li>hrtim_duty_cycle_set (hrtim.h)</li> <li>hrtim_eev_get (hrtim.h)</li> <li>hrtim_eev_set (hrtim.h)</li> <li>hrtim_frequency_set (hrtim.h)</li> <li>hrtim_get_apb2_clock (hrtim.h)</li> <li>hrtim_get_max_frequency (hrtim.h)</li> <li>hrtim_get_max_period (hrtim.h)</li> <li>hrtim_get_min_frequency (hrtim.h)</li> <li>hrtim_get_min_period (hrtim.h)</li> <li>hrtim_get_modulation (hrtim.h)</li> <li>hrtim_get_resolution_ps (hrtim.h)</li> <li>hrtim_get_status (hrtim.h)</li> <li>hrtim_get_switch_convention (hrtim.h)</li> <li>hrtim_init_default_all (hrtim.h)</li> <li>hrtim_master_cmp_set (hrtim.h)</li> <li>hrtim_out_dis (hrtim.h)</li> <li>hrtim_out_dis_single (hrtim.h)</li> <li>hrtim_out_en (hrtim.h)</li> <li>hrtim_out_en_single (hrtim.h)</li> <li>hrtim_output_hot_swap (hrtim.h)</li> <li>hrtim_period_Master_get (hrtim.h)</li> <li>hrtim_period_Master_get_us (hrtim.h)</li> <li>hrtim_period_get (hrtim.h)</li> <li>hrtim_period_get_us (hrtim.h)</li> <li>hrtim_phase_shift_set (hrtim.h)</li> <li>hrtim_pwm_mode_get (hrtim.h)</li> <li>hrtim_pwm_mode_set (hrtim.h)</li> <li>hrtim_rst_evt_dis (hrtim.h)</li> <li>hrtim_rst_evt_en (hrtim.h)</li> <li>hrtim_set_modulation (hrtim.h)</li> <li>hrtim_set_switch_convention (hrtim.h)</li> <li>hrtim_tu_cmp_set (hrtim.h)</li> <li>hrtim_tu_gpio_init (hrtim.h)</li> <li>hrtim_tu_init (hrtim.h)</li> </ul>"},{"location":"powerAPI/functions/#i","title":"i","text":"<ul> <li>init_DEmode (Rs485.cpp, Rs485.h)</li> <li>init_usrBaudrate (Rs485.cpp, Rs485.h)</li> <li>init_usrBuffer (Rs485.cpp, Rs485.h)</li> <li>init_usrDataSize (Rs485.cpp, Rs485.h)</li> <li>init_usrFunc (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#k","title":"k","text":"<ul> <li>K_WORK_DEFINE (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#l","title":"l","text":"<ul> <li>LOG_MODULE_REGISTER (thingset_can.c)</li> </ul>"},{"location":"powerAPI/functions/#n","title":"n","text":"<ul> <li>nvs_storage_clear_all_stored_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_current_version (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_version_in_nvs (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_retrieve_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_store_data (nvs_storage.c, nvs_storage.h)</li> <li>ngnd_set (ngnd.h)</li> </ul>"},{"location":"powerAPI/functions/#o","title":"o","text":"<ul> <li>oversamp_set (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#r","title":"r","text":"<ul> <li>reboot_bootloader_task (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#s","title":"s","text":"<ul> <li>serial_init (Rs485.cpp, Rs485.h)</li> <li>serial_start (Rs485.cpp, Rs485.h)</li> <li>serial_stop (Rs485.cpp, Rs485.h)</li> <li>serial_tx_on (Rs485.cpp, Rs485.h)</li> <li>SYS_INIT (thingset_can.c, hardware_auto_configuration.cpp)</li> <li>safety_task (safety_internal.h)</li> </ul>"},{"location":"powerAPI/functions/#t","title":"t","text":"<ul> <li>THINGSET_ADD_GROUP (data_objects.h)</li> <li>THINGSET_ADD_ITEM_BOOL (data_objects.h)</li> <li>THINGSET_ADD_ITEM_FLOAT (data_objects.h)</li> <li>THINGSET_ADD_ITEM_STRING (data_objects.h)</li> <li>THINGSET_ADD_SUBSET (data_objects.h)</li> <li>timer_config (timer.h)</li> <li>timer_get_count (timer.h)</li> <li>timer_start (timer.h)</li> <li>timer_stop (timer.h)</li> </ul>"},{"location":"powerAPI/functions/#_","title":"_","text":"<ul> <li>_dma_callback_rx (Rs485.cpp)</li> <li>_dma_callback_tx (Rs485.cpp)</li> <li>_nvs_storage_init (nvs_storage.c)</li> <li>_nvs_storage_store_version (nvs_storage.c)</li> <li>_uart_usart1_process_input (UartHAL.cpp)</li> <li>_data_conversion_get_parameters_count (data_conversion.cpp)</li> <li>_data_dispatch_get_buffer (data_dispatch.cpp)</li> <li>_data_dispatch_get_count (data_dispatch.cpp)</li> <li>_data_dispatch_increment_count (data_dispatch.cpp)</li> <li>_data_dispatch_swap_buffers (data_dispatch.cpp)</li> <li>_dma_callback (dma.cpp)</li> <li>_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_console_init (hardware_auto_configuration.cpp)</li> <li>_dac2_init (hardware_auto_configuration.cpp)</li> <li>_img_validation (hardware_auto_configuration.cpp)</li> <li>_register_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_swap_usart1_tx_rx (hardware_auto_configuration.cpp)</li> <li>_vrefbuf_init (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"powerAPI/variables/","title":"Variables","text":""},{"location":"powerAPI/variables/#a","title":"a","text":"<ul> <li>adc_discontinuous_mode (adc.c)</li> <li>adc_trigger_sources (adc.c)</li> <li>adc_ev_src_t (adc.h)</li> <li>ADC_COUNT (DataAPI.h)</li> <li>adc_t (DataAPI.h)</li> <li>adc_channel_buffers (data_dispatch.cpp)</li> </ul>"},{"location":"powerAPI/variables/#b","title":"b","text":"<ul> <li>baud (Rs485.cpp)</li> <li>buf_req (UartHAL.cpp)</li> <li>buffers_data_count (data_dispatch.cpp)</li> <li>buffers_sizes (dma.cpp)</li> </ul>"},{"location":"powerAPI/variables/#c","title":"c","text":"<ul> <li>communication (CommunicationAPI.cpp, CommunicationAPI.h)</li> <li>can_work_data (thingset_can.c)</li> <li>current_storage_version (nvs_storage.c)</li> <li>cm_dac_t (power_init.h)</li> <li>CHANNELS_PER_ADC (DataAPI.h)</li> <li>command_flag (UartHAL.cpp)</li> <li>conversion_parameters (data_conversion.cpp)</li> <li>conversion_types (data_conversion.cpp)</li> <li>conversion_type_t (data_conversion.h)</li> <li>current_buffer (data_dispatch.cpp)</li> <li>current_dma_buffer (data_dispatch.cpp)</li> <li>CHANNELS_BUFFERS_SIZE (data_dispatch.h)</li> <li>cdc_acm_console (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/variables/#d","title":"d","text":"<ul> <li>dma1 (Rs485.cpp, dma.cpp)</li> <li>dma_buffer_size (Rs485.cpp)</li> <li>dma_callbackRXfunc_t (Rs485.h)</li> <li>device_type (data_objects.h)</li> <li>dac_api_fn_upd_reset (dac.h)</li> <li>dac_api_fn_upd_step (dac.h)</li> <li>dac_api_pinconfigure (dac.h)</li> <li>dac_api_setconstvalue (dac.h)</li> <li>dac_api_setfunction (dac.h)</li> <li>dac_api_start (dac.h)</li> <li>dac_api_stop (dac.h)</li> <li>dac_function_t (dac.h)</li> <li>dac_pin_config_t (dac.h)</li> <li>dac_polarity_t (dac.h)</li> <li>dac_trigger_t (dac.h)</li> <li>dt_adc (power_init.cpp, power_init.h)</li> <li>dt_adc_decim (power_init.cpp, power_init.h)</li> <li>dt_current_pin (power_init.cpp, power_init.h)</li> <li>dt_edge_trigger (power_init.cpp, power_init.h)</li> <li>dt_falling_deadtime (power_init.cpp, power_init.h)</li> <li>dt_leg_count (power_init.cpp, power_init.h)</li> <li>dt_modulation (power_init.cpp, power_init.h)</li> <li>dt_output1_inactive (power_init.cpp, power_init.h)</li> <li>dt_output2_inactive (power_init.cpp, power_init.h)</li> <li>dt_phase_shift (power_init.cpp, power_init.h)</li> <li>dt_pin_capacitor (power_init.cpp, power_init.h)</li> <li>dt_pin_driver (power_init.cpp, power_init.h)</li> <li>dt_pwm_pin (power_init.cpp, power_init.h)</li> <li>dt_pwm_x1_high (power_init.cpp, power_init.h)</li> <li>dt_rising_deadtime (power_init.cpp, power_init.h)</li> <li>dac1 (DacHAL.cpp)</li> <li>dac2 (DacHAL.cpp, hardware_auto_configuration.cpp)</li> <li>dac3 (DacHAL.cpp)</li> <li>DATA_IS_MISSING (DataAPI.h)</li> <li>DATA_IS_OK (DataAPI.h)</li> <li>DATA_IS_OLD (DataAPI.h)</li> <li>DispatchMethod_t (DataAPI.h)</li> <li>dispatch_type (data_dispatch.cpp)</li> <li>dma_buffer_sizes (data_dispatch.cpp)</li> <li>dma_main_buffers (data_dispatch.cpp)</li> <li>dma_secondary_buffers (data_dispatch.cpp)</li> <li>dispatch_t (data_dispatch.h)</li> </ul>"},{"location":"powerAPI/variables/#e","title":"e","text":"<ul> <li>enable_dma (adc.c)</li> <li>enabled_channels (adc.c)</li> <li>enabled_channels_count (adc.c, data_dispatch.cpp)</li> <li>evt (Rs485.cpp)</li> </ul>"},{"location":"powerAPI/variables/#f","title":"f","text":"<ul> <li>firmware_version (data_objects.h)</li> <li>fs (nvs_storage.c)</li> </ul>"},{"location":"powerAPI/variables/#g","title":"g","text":"<ul> <li>GPIO_A (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_B (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_C (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_D (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#h","title":"h","text":"<ul> <li>hardware_version (data_objects.h)</li> <li>HRTIM_CHANNELS (hrtim_enum.h)</li> <li>HRTIM_MAX_PER_and_CMP_REG_VALUES (hrtim_enum.h)</li> <li>HRTIM_MIN_PER_and_CMP_REG_VALUES (hrtim_enum.h)</li> <li>HRTIM_PRESCALER_RESOLUTION_PS (hrtim_enum.h)</li> <li>hrtim_adc_edgetrigger_t (hrtim_enum.h)</li> <li>hrtim_adc_event_t (hrtim_enum.h)</li> <li>hrtim_adc_source_t (hrtim_enum.h)</li> <li>hrtim_adc_t (hrtim_enum.h)</li> <li>hrtim_adc_trigger_t (hrtim_enum.h)</li> <li>hrtim_burst_clk_t (hrtim_enum.h)</li> <li>hrtim_callback_t (hrtim_enum.h)</li> <li>hrtim_cmp_t (hrtim_enum.h)</li> <li>hrtim_cnt_t (hrtim_enum.h)</li> <li>hrtim_comp_usage_t (hrtim_enum.h)</li> <li>hrtim_external_trigger_t (hrtim_enum.h)</li> <li>hrtim_gpio_clock_number_t (hrtim_enum.h)</li> <li>hrtim_out_t (hrtim_enum.h)</li> <li>hrtim_output_number_t (hrtim_enum.h)</li> <li>hrtim_output_reset_t (hrtim_enum.h)</li> <li>hrtim_output_set_t (hrtim_enum.h)</li> <li>hrtim_output_units_t (hrtim_enum.h)</li> <li>hrtim_pwm_mode_t (hrtim_enum.h)</li> <li>hrtim_reset_trig_t (hrtim_enum.h)</li> <li>hrtim_switch_convention_t (hrtim_enum.h)</li> <li>hrtim_tu_ON_OFF_t (hrtim_enum.h)</li> <li>hrtim_tu_number_t (hrtim_enum.h)</li> <li>hrtim_tu_t (hrtim_enum.h)</li> </ul>"},{"location":"powerAPI/variables/#i","title":"i","text":"<ul> <li>initialized (nvs_storage.c)</li> <li>INPUT (GpioHAL.cpp, GpioHAL.h)</li> <li>INPUT_PULLUP (GpioHAL.cpp, GpioHAL.h)</li> <li>inverter_modulation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#l","title":"l","text":"<ul> <li>live_reporting_enable (CanCommunication.cpp)</li> <li>live_reporting_period (CanCommunication.cpp)</li> <li>leg_t (Power.h)</li> <li>led_pin_spec (LedHAL.cpp)</li> <li>leg_operation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#m","title":"m","text":"<ul> <li>manufacturer (data_objects.h)</li> <li>max_parameters_count (data_conversion.cpp)</li> </ul>"},{"location":"powerAPI/variables/#n","title":"n","text":"<ul> <li>nvs_category_t (nvs_storage.h)</li> <li>ngnd_switch (NgndHAL.cpp)</li> <li>NO_VALUE (DataAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#o","title":"o","text":"<ul> <li>ownverter_temp_sensor_t (Sensors.h)</li> <li>OUTPUT (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#p","title":"p","text":"<ul> <li>PIN_COUNT (DataAPI.h)</li> <li>parameter_t (DataAPI.h)</li> <li>P0 (GpioHAL.h)</li> <li>P1 (GpioHAL.h)</li> <li>P10 (GpioHAL.h)</li> <li>P11 (GpioHAL.h)</li> <li>P12 (GpioHAL.h)</li> <li>P13 (GpioHAL.h)</li> <li>P14 (GpioHAL.h)</li> <li>P15 (GpioHAL.h)</li> <li>P2 (GpioHAL.h)</li> <li>P3 (GpioHAL.h)</li> <li>P4 (GpioHAL.h)</li> <li>P5 (GpioHAL.h)</li> <li>P6 (GpioHAL.h)</li> <li>P7 (GpioHAL.h)</li> <li>P8 (GpioHAL.h)</li> <li>P9 (GpioHAL.h)</li> <li>PA (GpioHAL.h)</li> <li>PB (GpioHAL.h)</li> <li>PC (GpioHAL.h)</li> <li>PD (GpioHAL.h)</li> <li>pin_t (GpioHAL.h)</li> <li>peek_memory (data_dispatch.cpp)</li> <li>PEEK_NO_VALUE (data_dispatch.h)</li> <li>pin_mode_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#r","title":"r","text":"<ul> <li>reference_value (CanCommunication.cpp, data_objects.h)</li> <li>rx_usart_val (Rs485.cpp)</li> <li>rs485_speed_t (Rs485Communication.h)</li> </ul>"},{"location":"powerAPI/variables/#s","title":"s","text":"<ul> <li>start_stop (CanCommunication.cpp, data_objects.h)</li> <li>storage_version_in_nvs (nvs_storage.c)</li> <li>safety (SafetyAPI.cpp, SafetyAPI.h)</li> <li>shield (ShieldAPI.cpp, ShieldAPI.h)</li> <li>sensor_t (Sensors.h)</li> <li>spin (SpinAPI.cpp, SpinAPI.h)</li> <li>source_registers (dma.cpp)</li> <li>source_triggers (dma.cpp)</li> <li>scheduling_interrupt_source_t (TaskAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#t","title":"t","text":"<ul> <li>tx_usart_val (Rs485.cpp)</li> <li>ts (thingset_can.c)</li> <li>tu_channel (hrtim.h)</li> <li>timer_frequency (power_init.cpp, power_init.h)</li> <li>timer_min_frequency (power_init.cpp, power_init.h)</li> <li>trigger_source_t (DataAPI.h)</li> <li>timer3 (TimerHAL.cpp)</li> <li>timer4 (TimerHAL.cpp)</li> <li>timernumber_t (TimerHAL.h)</li> <li>task (TaskAPI.cpp, TaskAPI.h)</li> <li>task_function_t (TaskAPI.h)</li> <li>timer_api_config (timer.h)</li> <li>timer_api_get_count (timer.h)</li> <li>timer_api_start (timer.h)</li> <li>timer_api_stop (timer.h)</li> <li>timer_callback_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#u","title":"u","text":"<ul> <li>uart_cfg (Rs485.cpp)</li> <li>uart_dev (Rs485.cpp, UartHAL.cpp)</li> <li>user_fnc (Rs485.cpp)</li> <li>usart_oversampling_t (Rs485.h)</li> <li>user_data (dma.cpp)</li> </ul>"},{"location":"powerAPI/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"controlLibrary/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,... </li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class Pid Pid in a standard form taking into account saturation. </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class Pr </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RST discrete polynomial regulator taking into account saturations. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir controlLibrary <ul> <li>dir src <ul> <li>file controller.h </li> <li>file filters.h </li> <li>file fir.h </li> <li>file pid.h </li> <li>file pr.h </li> <li>file rst.h </li> <li>file transform.h </li> <li>file trigo.h </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"controlLibrary/classController/","title":"Class Controller","text":"<p>template &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;</p> <p>ClassList &gt; Controller</p> <p>Controller interface for various inherited class like pid, rst, pr,...More...</p> <ul> <li><code>#include &lt;controller.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classController/#public-functions","title":"Public Functions","text":"Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classController/#protected-attributes","title":"Protected Attributes","text":"Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classController/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Guillaume Arthaud. </p> <p>Template parameters:</p> <ul> <li><code>refs_T</code> type of the reference </li> <li><code>meas_T</code> type of the measure </li> <li><code>outputs_T</code> type of the output </li> <li><code>params_T</code> type of the parameter </li> </ul> <p>Parameters:</p> <ul> <li><code>parameters</code> structure including all parameters needs to make calculations.</li> </ul> <p>we assume that outputs_T has already an order relation implemented. </p>"},{"location":"controlLibrary/classController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classController/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Controller::calculate (\n    void\n) = 0\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p>"},{"location":"controlLibrary/classController/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<p>calculate a new command value according the argument values <pre><code>inline virtual outputs_T Controller::calculateWithReturn (\n    refs_T yref,\n    meas_T y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p>"},{"location":"controlLibrary/classController/#function-getoutput","title":"function getOutput","text":"<p>retrieve the last command value calculated. <pre><code>inline virtual outputs_T Controller::getOutput () \n</code></pre></p> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Controller::init (\n    params_T parameters\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p>"},{"location":"controlLibrary/classController/#function-reset","title":"function reset","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void Controller::reset (\n    void\n) = 0\n</code></pre></p>"},{"location":"controlLibrary/classController/#function-saturate","title":"function saturate","text":"<p>limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. <pre><code>inline virtual outputs_T Controller::saturate (\n    outputs_T u\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>u</code> should be a command value. </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-setmeasurement","title":"function setMeasurement","text":"<p>capture a new measurement. <pre><code>inline virtual void Controller::setMeasurement (\n    meas_T measure\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>measure</code> </li> </ul>"},{"location":"controlLibrary/classController/#function-setreference","title":"function setReference","text":"<p>capture a new reference. <pre><code>inline virtual void Controller::setReference (\n    refs_T reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> </li> </ul>"},{"location":"controlLibrary/classController/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"controlLibrary/classController/#variable-_ts","title":"variable _Ts","text":"<pre><code>float32_t Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_Ts;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_lower_bound","title":"variable _lower_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_lower_bound;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_measure","title":"variable _measure","text":"<pre><code>meas_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_measure;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_output","title":"variable _output","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_output;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_reference","title":"variable _reference","text":"<pre><code>refs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_reference;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_upper_bound","title":"variable _upper_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/classFir/","title":"Class Fir","text":"<p>ClassList &gt; Fir</p> <p>a class to implement the Finite Impulse Response filter behaviour More...</p> <ul> <li><code>#include &lt;fir.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classFir/#public-functions","title":"Public Functions","text":"Type Name Fir ()  Fir (const uint8_t nc, const float32_t * coeffs)  uint8_t init (uint8_t nc, const float32_t * coeffs) method to initialize the Fir with its coefficients void reset ()  void setCoeff (uint8_t n, float32_t value)  float32_t update (float32_t new_data)  ~Fir ()"},{"location":"controlLibrary/classFir/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients</li> <li><code>*coeffs</code> pointer to array of coefficients </li> </ul>"},{"location":"controlLibrary/classFir/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classFir/#function-fir-12","title":"function Fir [1/2]","text":"<pre><code>Fir::Fir () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir-22","title":"function Fir [2/2]","text":"<pre><code>Fir::Fir (\n    const uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-init","title":"function init","text":"<p>method to initialize the Fir with its coefficients <pre><code>uint8_t Fir::init (\n    uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients </li> <li><code>coeffs</code> pointer to array of coefficients </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classFir/#function-reset","title":"function reset","text":"<pre><code>void Fir::reset () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-setcoeff","title":"function setCoeff","text":"<pre><code>void Fir::setCoeff (\n    uint8_t n,\n    float32_t value\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-update","title":"function update","text":"<pre><code>float32_t Fir::update (\n    float32_t new_data\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir","title":"function ~Fir","text":"<pre><code>Fir::~Fir () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/","title":"Class LowPassFirstOrderFilter","text":"<p>ClassList &gt; LowPassFirstOrderFilter</p> <p>More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions","title":"Public Functions","text":"Type Name LowPassFirstOrderFilter (float32_t Ts, float32_t tau)  float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t tau)  void reset ()  void reset (float32_t value)"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-lowpassfirstorderfilter","title":"function LowPassFirstOrderFilter","text":"<pre><code>LowPassFirstOrderFilter::LowPassFirstOrderFilter (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t LowPassFirstOrderFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-init","title":"function init","text":"<pre><code>uint8_t LowPassFirstOrderFilter::init (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-12","title":"function reset [1/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset () \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset (\n    float32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classNotchFilter/","title":"Class NotchFilter","text":"<p>ClassList &gt; NotchFilter</p>"},{"location":"controlLibrary/classNotchFilter/#public-functions","title":"Public Functions","text":"Type Name NotchFilter ()  NotchFilter (float32_t Ts, float32_t f0, float32_t bandwidth) its a band stop filter float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t f0, float32_t bandwidth) initialize the band stop filter parameters void reset ()"},{"location":"controlLibrary/classNotchFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-12","title":"function NotchFilter [1/2]","text":"<pre><code>inline NotchFilter::NotchFilter () \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-22","title":"function NotchFilter [2/2]","text":"<p>its a band stop filter <pre><code>NotchFilter::NotchFilter (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t NotchFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-init","title":"function init","text":"<p>initialize the band stop filter parameters <pre><code>uint8_t NotchFilter::init (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop in [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-reset","title":"function reset","text":"<pre><code>void NotchFilter::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPid/","title":"Class Pid","text":"<p>ClassList &gt; Pid</p> <p>Pid in a standard form taking into account saturation.More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPid/#public-functions","title":"Public Functions","text":"Type Name Pid ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (PidParams params) overrideinitialize the standard pid virtual void reset () overridereset internal states and the last command of the controller. void reset (float32_t output)"},{"location":"controlLibrary/classPid/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPid/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPid/#detailed-description","title":"Detailed Description","text":"<p>out = Kp * (error + 1 / Ti * error / s + 1 / (1 + Td / N * s) * Td * s * error )</p> <p>It uses backward euler integration method.</p> <p>Example of use:</p> <p>Pid mypid; PidParams params(Ts, Kp, Ti, Td, N, lower_bound, upper_bound); mypid.init(params); mypid.setMeasurement(y); mypid.setReference(yref); mypid.calculate(); mypid.getOutput(); </p>"},{"location":"controlLibrary/classPid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPid/#function-pid","title":"function Pid","text":"<pre><code>inline Pid::Pid () \n</code></pre>"},{"location":"controlLibrary/classPid/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Pid::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPid/#function-init","title":"function init","text":"<p>initialize the standard pid <pre><code>virtual int8_t Pid::init (\n    PidParams params\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> is a PidParams structure with all the parameters of the Pid. </li> </ul> <p>Returns:</p> <p>0 if ok else -EINVAL </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPid/#function-reset-12","title":"function reset [1/2]","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void Pid::reset () override\n</code></pre></p> <p>Implements Controller::reset</p>"},{"location":"controlLibrary/classPid/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void Pid::reset (\n    float32_t output\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPidParams/","title":"Class PidParams","text":"<p>ClassList &gt; PidParams</p> <p>all parameters of a standard pid More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t N float32_t Td float32_t Ti float32_t Ts float32_t lower_bound float32_t upper_bound"},{"location":"controlLibrary/structPidParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Ti</code> integral time constant</li> <li><code>Td</code> derivative time constant</li> <li><code>N</code> derivative filter coefficient</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPidParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PidParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-n","title":"variable N","text":"<pre><code>float32_t PidParams::N;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-td","title":"variable Td","text":"<pre><code>float32_t PidParams::Td;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ti","title":"variable Ti","text":"<pre><code>float32_t PidParams::Ti;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PidParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PidParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PidParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPllDatas/","title":"Class PllDatas","text":"<p>ClassList &gt; PllDatas</p> <p>datas returned by pll calculations More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes","title":"Public Attributes","text":"Type Name float32_t angle float32_t error float32_t w"},{"location":"controlLibrary/structPllDatas/#detailed-description","title":"Detailed Description","text":"<p>Parameters:</p> <ul> <li><code>w</code> pulsation estimated of the tracked signal [rad/s]</li> <li><code>angle</code> of the tracked signal [rad] </li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPllDatas/#variable-angle","title":"variable angle","text":"<pre><code>float32_t PllDatas::angle;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-error","title":"variable error","text":"<pre><code>float32_t PllDatas::error;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-w","title":"variable w","text":"<pre><code>float32_t PllDatas::w;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPllSinus/","title":"Class PllSinus","text":"<p>ClassList &gt; PllSinus</p>"},{"location":"controlLibrary/classPllSinus/#public-functions","title":"Public Functions","text":"Type Name PllSinus () a software phase lock loop on a sinusoidal signal PllSinus (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  PllDatas calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  void reset (float32_t f0)"},{"location":"controlLibrary/classPllSinus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPllSinus/#function-pllsinus-12","title":"function PllSinus [1/2]","text":"<p>a software phase lock loop on a sinusoidal signal <pre><code>inline PllSinus::PllSinus () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time in [s] </li> <li><code>amplitude</code> amplitude of the signal to track. </li> <li><code>f0</code> mean frequency of the signal to track </li> <li><code>rt</code> rise time of the loop in [s]. </li> </ul>"},{"location":"controlLibrary/classPllSinus/#function-pllsinus-22","title":"function PllSinus [2/2]","text":"<pre><code>PllSinus::PllSinus (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>PllDatas PllSinus::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-init","title":"function init","text":"<pre><code>uint8_t PllSinus::init (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-reset","title":"function reset","text":"<pre><code>void PllSinus::reset (\n    float32_t f0\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPr/","title":"Class Pr","text":"<p>ClassList &gt; Pr</p> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPr/#public-functions","title":"Public Functions","text":"Type Name Pr ()  virtual void calculate (void) calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . virtual int8_t init (PrParams parameters) initialize the controller. virtual void reset (void) calculate a new command value according the argument values"},{"location":"controlLibrary/classPr/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPr/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPr/#function-pr","title":"function Pr","text":"<pre><code>inline Pr::Pr () \n</code></pre>"},{"location":"controlLibrary/classPr/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . <pre><code>virtual void Pr::calculate (\n    void\n) \n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPr/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Pr::init (\n    PrParams parameters\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPr/#function-reset","title":"function reset","text":"<p>calculate a new command value according the argument values <pre><code>virtual void Pr::reset (\n    void\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/structPrParams/","title":"Class PrParams","text":"<p>ClassList &gt; PrParams</p> <p>all parameters to define the proportional resonant controller. More...</p> <ul> <li><code>#include &lt;pr.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t Kr float32_t Ts float32_t lower_bound float32_t phi_prime float32_t upper_bound float32_t w0"},{"location":"controlLibrary/structPrParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Kr</code> resonant gain</li> <li><code>w0</code> pulsation [rad/s]</li> <li><code>phi_prime</code> angle in rad to compensate delays</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPrParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PrParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-kr","title":"variable Kr","text":"<pre><code>float32_t PrParams::Kr;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PrParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PrParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-phi_prime","title":"variable phi_prime","text":"<pre><code>float32_t PrParams::phi_prime;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PrParams::upper_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-w0","title":"variable w0","text":"<pre><code>float32_t PrParams::w0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/classRST/","title":"Class RST","text":"<p>ClassList &gt; RST</p> <p>discrete polynomial regulator taking into account saturations. More...</p> <ul> <li><code>#include &lt;rst.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classRST/#public-functions","title":"Public Functions","text":"Type Name RST ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (RstParams p) overrideinitialize the rst controller virtual void reset (void) overridereset internal states and the last command of the controller."},{"location":"controlLibrary/classRST/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classRST/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classRST/#detailed-description","title":"Detailed Description","text":"<p>It uses 3 Fir : * one on the measurements called R(), * one on the previous command, called S(), * and the last on the reference called T()</p> <p>It mainly allows to add some filtering action on reference or measurements. and sometimes to add some filtering poles which help stabilisation.</p> <p>some classical regulators can be implemented by its way like pid and pr. </p>"},{"location":"controlLibrary/classRST/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classRST/#function-rst","title":"function RST","text":"<pre><code>inline RST::RST () \n</code></pre>"},{"location":"controlLibrary/classRST/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void RST::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classRST/#function-init","title":"function init","text":"<p>initialize the rst controller <pre><code>virtual int8_t RST::init (\n    RstParams p\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> RstParams structure </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL if not </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classRST/#function-reset","title":"function reset","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void RST::reset (\n    void\n) override\n</code></pre></p> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/structRstParams/","title":"Class RstParams","text":"<p>ClassList &gt; RstParams</p> <p>More...</p>"},{"location":"controlLibrary/structRstParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Ts float32_t lower_bound uint8_t nr uint8_t ns uint8_t nt const float32_t * r const float32_t * s const float32_t * t float32_t upper_bound"},{"location":"controlLibrary/structRstParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr Rst parameters </p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>nr</code> number of R coefficients</li> <li><code>r[]</code> array of R coefficients</li> <li><code>ns</code> number of S coefficients</li> <li><code>s[]</code> array of S coefficients</li> <li><code>nt</code> number of t coefficients</li> <li><code>t[]</code> array of T coefficients</li> <li><code>lower_bound</code> minimal value of output</li> <li><code>upper_bound</code> maximal value of output </li> </ul>"},{"location":"controlLibrary/structRstParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structRstParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t RstParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t RstParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nr","title":"variable nr","text":"<pre><code>uint8_t RstParams::nr;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-ns","title":"variable ns","text":"<pre><code>uint8_t RstParams::ns;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nt","title":"variable nt","text":"<pre><code>uint8_t RstParams::nt;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-r","title":"variable r","text":"<pre><code>const float32_t* RstParams::r;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-s","title":"variable s","text":"<pre><code>const float32_t* RstParams::s;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-t","title":"variable t","text":"<pre><code>const float32_t* RstParams::t;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t RstParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/classTransform/","title":"Class Transform","text":"<p>ClassList &gt; Transform</p> <p>static class to group methods helping translation between reference frames More...</p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classTransform/#public-static-functions","title":"Public Static Functions","text":"Type Name clarke_t clarke (three_phase_t Xabc) transform a three_phase_t vector to aclarke_t vector. three_phase_t clarke_inverse (clarke_t Xabo) transform a clarke_t vector to athree_phase_t vector. clarke_t rotation_to_clarke (dqo_t Xdqo, float32_t theta) make a rotation which transform adqo_t vector to aclarke_t vector. dqo_t rotation_to_dqo (clarke_t Xabo, float32_t theta) make a - rotation which transform aclarke_t vector to adqo_t vector. dqo_t to_dqo (three_phase_t Xabc, float32_t theta) transform a three_phase_t vector to adqo_t vector. three_phase_t to_threephase (dqo_t Xdqo, float32_t theta) transform a dqo_t vector to athree_phase_t vector."},{"location":"controlLibrary/classTransform/#detailed-description","title":"Detailed Description","text":"<p>mainly 3 reference frames: * abc :three phase *  : clarke. * d, q, o : direct-quadrature. </p>"},{"location":"controlLibrary/classTransform/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"controlLibrary/classTransform/#function-clarke","title":"function clarke","text":"<p>transform a three_phase_t vector to aclarke_t vector. <pre><code>static clarke_t Transform::clarke (\n    three_phase_t Xabc\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-clarke_inverse","title":"function clarke_inverse","text":"<p>transform a clarke_t vector to athree_phase_t vector. <pre><code>static three_phase_t Transform::clarke_inverse (\n    clarke_t Xabo\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-rotation_to_clarke","title":"function rotation_to_clarke","text":"<p>make a rotation which transform adqo_t vector to aclarke_t vector. <pre><code>static clarke_t Transform::rotation_to_clarke (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-rotation_to_dqo","title":"function rotation_to_dqo","text":"<p>make a - rotation which transform aclarke_t vector to adqo_t vector. <pre><code>static dqo_t Transform::rotation_to_dqo (\n    clarke_t Xabo,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-to_dqo","title":"function to_dqo","text":"<p>transform a three_phase_t vector to adqo_t vector. <pre><code>static dqo_t Transform::to_dqo (\n    three_phase_t Xabc,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-to_threephase","title":"function to_threephase","text":"<p>transform a dqo_t vector to athree_phase_t vector. <pre><code>static three_phase_t Transform::to_threephase (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structclarke__t/","title":"Struct clarke_t","text":"<p>ClassList &gt; clarke_t</p> <p>to keep together \u03b1, \u03b2 and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structclarke__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t alpha float32_t beta float32_t o"},{"location":"controlLibrary/structclarke__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structclarke__t/#variable-alpha","title":"variable alpha","text":"<pre><code>float32_t clarke_t::alpha;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-beta","title":"variable beta","text":"<pre><code>float32_t clarke_t::beta;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-o","title":"variable o","text":"<pre><code>float32_t clarke_t::o;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structdqo__t/","title":"Struct dqo_t","text":"<p>ClassList &gt; dqo_t</p> <p>to keep together d, q and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structdqo__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t d float32_t o float32_t q"},{"location":"controlLibrary/structdqo__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structdqo__t/#variable-d","title":"variable d","text":"<pre><code>float32_t dqo_t::d;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-o","title":"variable o","text":"<pre><code>float32_t dqo_t::o;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-q","title":"variable q","text":"<pre><code>float32_t dqo_t::q;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structthree__phase__t/","title":"Struct three_phase_t","text":"<p>ClassList &gt; three_phase_t</p> <p>to keep together a,b and c phase values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structthree__phase__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t a float32_t b float32_t c"},{"location":"controlLibrary/structthree__phase__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structthree__phase__t/#variable-a","title":"variable a","text":"<pre><code>float32_t three_phase_t::a;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-b","title":"variable b","text":"<pre><code>float32_t three_phase_t::b;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-c","title":"variable c","text":"<pre><code>float32_t three_phase_t::c;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir controlLibrary <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/","title":"Dir docs/controlLibrary","text":"<p>FileList &gt; controlLibrary</p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/</code></p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/","title":"Dir docs/controlLibrary/src","text":"<p>FileList &gt; controlLibrary &gt; src</p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/#files","title":"Files","text":"Type Name file controller.h file filters.h file fir.h file pid.h file pr.h file rst.h file transform.h file trigo.h <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/</code></p>"},{"location":"controlLibrary/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include &lt;zephyr/logging/log.h&gt;</code></li> </ul>"},{"location":"controlLibrary/controller_8h/#classes","title":"Classes","text":"Type Name class Controller &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;Controller interface for various inherited class like pid, rst, pr,... <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include &lt;arm_math.h&gt;\n#ifndef CONTROLLER_H_\n#define CONTROLLER_H_\n#include &lt;zephyr/logging/log.h&gt;\n\ntemplate&lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;\nclass Controller\n{\n    public:\n    virtual int8_t init(params_T parameters) = 0; //ref + mesure\n\n    virtual void reset(void) = 0;\n\n    virtual void calculate(void) = 0; \n    virtual outputs_T calculateWithReturn(refs_T yref, meas_T y) {\n        this-&gt;setReference(yref);\n        this-&gt;setMeasurement(y);\n        this-&gt;calculate();\n        return this-&gt;getOutput();\n    }\n\n    virtual void setReference(refs_T reference) {\n        _reference = reference;\n    }; \n\n    virtual void setMeasurement(meas_T measure) {\n        _measure = measure;\n    }; \n\n    virtual outputs_T getOutput() {\n        return _output;\n    }; \n\n    virtual outputs_T saturate(outputs_T u) {\n        if ( u &gt; _upper_bound) {\n            u = _upper_bound;\n        }\n        if (u &lt; _lower_bound) {\n            u = _lower_bound;\n        }\n        return u;\n    };\nprotected:\n    float32_t _Ts; // sample time\n    outputs_T _lower_bound;\n    outputs_T _upper_bound;\n    // template \n    refs_T _reference;\n    outputs_T _output;\n    meas_T _measure;\n\n};\n\n#endif /* !CONTROLLER_H_ */\n</code></pre>"},{"location":"controlLibrary/filters_8h/","title":"File filters.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"arm_math_types.h\"</code></li> <li><code>#include \"fir.h\"</code></li> <li><code>#include \"pid.h\"</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/filters_8h/#classes","title":"Classes","text":"Type Name class LowPassFirstOrderFilter class NotchFilter class PllDatas datas returned by pll calculations class PllSinus <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/filters_8h_source/","title":"File filters.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n\n#ifndef FILTERS_H_\n#define FILTERS_H_\n#include \"arm_math_types.h\"\n#include \"fir.h\"\n#include \"pid.h\"\n#include \"trigo.h\" \n\nclass LowPassFirstOrderFilter {\npublic:\n    LowPassFirstOrderFilter(float32_t Ts, float32_t tau);\n    uint8_t init(float32_t Ts, float32_t tau);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\n    void reset(float32_t value);\nprivate:\n    float32_t _Ts;\n    float32_t _tau;\n    float32_t _a1;\n    float32_t _b1;\n\n    float32_t _previous_value;\n};\n\nclass NotchFilter {\npublic:\n    NotchFilter() {};\n    NotchFilter(float32_t Ts, float32_t f0, float32_t bandwidth);\n\n    uint8_t init(float32_t Ts, float32_t f0, float32_t bandwidth);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\nprivate:\n    float32_t _Ts;\n    float32_t _f0;\n    float32_t _bandwidth;\n\n    Fir _B; // numerator of the filter\n    Fir _A; // denominator of the filter\n    float32_t _output;\n};\n\nstruct PllDatas {\n    float32_t w;\n    float32_t angle;\n    float32_t error;\n};\n\nclass PllSinus {\npublic:\n    PllSinus() {};\n    PllSinus(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    uint8_t init(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    PllDatas calculateWithReturn(float32_t signal);\n    void reset(float32_t f0);\n\nprivate:\n    float32_t _Ts;\n    float32_t _amplitude;\n    float32_t _f0;\n    float32_t _rt;\n\n    NotchFilter _notch;\n    Pid _pi;\n    float32_t _w;\n    float32_t _angle;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/fir_8h/","title":"File fir.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/fir_8h/#classes","title":"Classes","text":"Type Name class Fir a class to implement the Finite Impulse Response filter behaviour <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/fir_8h_source/","title":"File fir.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef FIR_H_\n#define FIR_H_\n#include &lt;arm_math.h&gt;\n\nclass Fir {\npublic:\n    Fir();\n    Fir(const uint8_t nc, const float32_t *coeffs);\n    uint8_t init(uint8_t nc, const float32_t *coeffs);\n    float32_t update(float32_t new_data);\n    void reset();\n    void setCoeff(uint8_t n, float32_t value);\n    ~Fir();\nprivate:\n    uint8_t nc;\n    float32_t *coeffs;\n    float32_t *datas;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pid_8h/","title":"File pid.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> </ul>"},{"location":"controlLibrary/pid_8h/#classes","title":"Classes","text":"Type Name class Pid Pid in a standard form taking into account saturation. class PidParams all parameters of a standard pid <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/pid_8h_source/","title":"File pid.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef PID_H_\n#define PID_H_\n#include \"controller.h\"\n\nstruct PidParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Ti;\n    float32_t Td;\n    float32_t N;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass Pid: public Controller &lt;float32_t, float32_t, float32_t, PidParams&gt; {\n\npublic:\n    Pid(){};\n\n    int8_t init(PidParams params) override; \n\n    void calculate(void) override;\n\n    void reset() override;\n\n    void reset(float32_t output);\n\nprivate:\n    float32_t _integral;\n    float32_t _Kp;\n    float32_t _Ti;\n    float32_t _Td;\n    float32_t _N;\n    float32_t _previous_f_deriv; // previous filtered derivative value\n    float32_t _previous_error;  // previous error\n\n    float32_t _inverse_Ts;\n    float32_t _inverse_Ti;\n    float32_t _inverse_Kp;\n    float32_t _b1_filter;\n    float32_t _a1_filter;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pr_8h/","title":"File pr.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/pr_8h/#classes","title":"Classes","text":"Type Name class Pr class PrParams all parameters to define the proportional resonant controller. <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/pr_8h_source/","title":"File pr.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n\n#include \"controller.h\"\n#include \"fir.h\"\n\nstruct PrParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Kr;\n    float32_t w0;\n    float32_t phi_prime;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\nclass Pr: public Controller &lt;float32_t, float32_t, float32_t, PrParams&gt; {\n\npublic:\n    Pr() {};\n\n    int8_t init(PrParams p);\n\n    void calculate(void);\n\n\n    void reset(void);\n\nprivate:\n    float32_t _Ts;\n    float32_t _Kp;\n    float32_t _Kr;\n    float32_t _inverse_Kr;\n    Fir _B; // numerator of the resonator\n    Fir _A; // denominator of the resonator\n    float32_t _resonant; // resonator output\n};\n</code></pre>"},{"location":"controlLibrary/rst_8h/","title":"File rst.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/rst_8h/#classes","title":"Classes","text":"Type Name class RST discrete polynomial regulator taking into account saturations. class RstParams <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/rst_8h_source/","title":"File rst.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef RST_H_\n#define RST_H_\n#include \"controller.h\"\n#include \"fir.h\" \n\nstruct RstParams {\n    float32_t Ts;\n    uint8_t nr;\n    const float32_t *r;\n    uint8_t ns;\n    const float32_t *s;\n    uint8_t nt;\n    const float32_t *t;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass RST: public Controller&lt;float32_t, float32_t, float32_t, RstParams&gt; {\npublic:\n    RST() {};\n\n    int8_t init(RstParams p) override;\n\n    void calculate(void) override;\n\n    using Controller&lt;float32_t, float32_t, float32_t, RstParams&gt;::calculate;\n\n    void reset(void) override;\n\nprivate:\n    Fir _R;\n    Fir _Sp;\n    Fir _T;\n    float32_t _inv_s0;\n};\n\n#endif\n</code></pre>"},{"location":"controlLibrary/transform_8h/","title":"File transform.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/transform_8h/#classes","title":"Classes","text":"Type Name class Transform static class to group methods helping translation between reference frames struct clarke_t to keep together \u03b1, \u03b2 and o values. struct dqo_t to keep together d, q and o values. struct three_phase_t to keep together a,b and c phase values."},{"location":"controlLibrary/transform_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t SQRT3_DIV_2   = <code>0.8660254F</code> const float32_t SQRT3_INVERSE   = <code>0.57735026F</code>"},{"location":"controlLibrary/transform_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/transform_8h/#variable-sqrt3_div_2","title":"variable SQRT3_DIV_2","text":"<pre><code>const float32_t SQRT3_DIV_2;\n</code></pre>"},{"location":"controlLibrary/transform_8h/#variable-sqrt3_inverse","title":"variable SQRT3_INVERSE","text":"<pre><code>const float32_t SQRT3_INVERSE;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/transform_8h_source/","title":"File transform.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef TRANSFORM_H_\n#define TRANSFORM_H_\n#include &lt;arm_math.h&gt;\n#include \"trigo.h\"\n\nconst float32_t SQRT3_INVERSE  = 0.57735026F;\nconst float32_t SQRT3_DIV_2    = 0.8660254F;\n\n\n\nstruct three_phase_t {\n    float32_t a;\n    float32_t b;\n    float32_t c;\n\n};\n\nstruct clarke_t {\n    float32_t alpha;\n    float32_t beta;\n    float32_t o;\n};\n\nstruct dqo_t {\n    float32_t d;\n    float32_t q;\n    float32_t o;\n};\n\nclass Transform\n{\npublic:\n    static dqo_t rotation_to_dqo(clarke_t Xabo, float32_t theta);\n    static clarke_t rotation_to_clarke(dqo_t Xdqo, float32_t theta);\n    static clarke_t clarke(three_phase_t Xabc);\n    static three_phase_t clarke_inverse(clarke_t Xabo);\n    static dqo_t to_dqo(three_phase_t Xabc, float32_t theta);\n    static three_phase_t to_threephase(dqo_t Xdqo, float32_t theta);\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/trigo_8h/","title":"File trigo.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/trigo_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t INV_MODULO_RES const float32_t MODULO_RES const uint32_t MODULO_SIZE"},{"location":"controlLibrary/trigo_8h/#public-functions","title":"Public Functions","text":"Type Name float32_t ot_cos (float32_t x)  float32_t ot_modulo_2pi (float32_t theta)  float32_t ot_sin (float32_t x)"},{"location":"controlLibrary/trigo_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/trigo_8h/#variable-inv_modulo_res","title":"variable INV_MODULO_RES","text":"<pre><code>const float32_t INV_MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_res","title":"variable MODULO_RES","text":"<pre><code>const float32_t MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_size","title":"variable MODULO_SIZE","text":"<pre><code>const uint32_t MODULO_SIZE;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/trigo_8h/#function-ot_cos","title":"function ot_cos","text":"<pre><code>float32_t ot_cos (\n    float32_t x\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_modulo_2pi","title":"function ot_modulo_2pi","text":"<pre><code>float32_t ot_modulo_2pi (\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_sin","title":"function ot_sin","text":"<pre><code>float32_t ot_sin (\n    float32_t x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/trigo.h</code></p>"},{"location":"controlLibrary/trigo_8h_source/","title":"File trigo.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n\n\n#include &lt;arm_math.h&gt;\nextern const uint32_t MODULO_SIZE;     \nextern const float32_t INV_MODULO_RES;\nextern const float32_t MODULO_RES; \n\n// TODO: use CORDIC ?\n#ifdef CORDIC \n#include \"stm32g4xx_ll_cordic.h\"\n#endif\n\n\nfloat32_t ot_sin(float32_t x);\nfloat32_t ot_cos(float32_t x);\nfloat32_t ot_modulo_2pi(float32_t theta);\n</code></pre>"},{"location":"controlLibrary/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"controlLibrary/classes/","title":"Class Index","text":""},{"location":"controlLibrary/classes/#c","title":"c","text":"<ul> <li>clarke_t</li> <li>Controller</li> </ul>"},{"location":"controlLibrary/classes/#d","title":"d","text":"<ul> <li>dqo_t</li> </ul>"},{"location":"controlLibrary/classes/#f","title":"f","text":"<ul> <li>Fir</li> </ul>"},{"location":"controlLibrary/classes/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter</li> </ul>"},{"location":"controlLibrary/classes/#n","title":"n","text":"<ul> <li>NotchFilter</li> </ul>"},{"location":"controlLibrary/classes/#p","title":"p","text":"<ul> <li>Pid</li> <li>PidParams</li> <li>PllDatas</li> <li>PllSinus</li> <li>Pr</li> <li>PrParams</li> </ul>"},{"location":"controlLibrary/classes/#r","title":"r","text":"<ul> <li>RST</li> <li>RstParams</li> </ul>"},{"location":"controlLibrary/classes/#t","title":"t","text":"<ul> <li>three_phase_t</li> <li>Transform</li> </ul>"},{"location":"controlLibrary/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,...</li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"controlLibrary/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"controlLibrary/class_members/","title":"Class Members","text":""},{"location":"controlLibrary/class_members/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>coeffs (Fir)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_members/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_members/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_members/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>NotchFilter (NotchFilter)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>r (RstParams)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#u","title":"u","text":"<ul> <li>update (Fir)</li> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/","title":"Class Member Functions","text":""},{"location":"controlLibrary/class_member_functions/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#n","title":"n","text":"<ul> <li>NotchFilter (NotchFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#t","title":"t","text":"<ul> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#u","title":"u","text":"<ul> <li>update (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_variables/","title":"Class Member Variables","text":""},{"location":"controlLibrary/class_member_variables/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#c","title":"c","text":"<ul> <li>coeffs (Fir)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#l","title":"l","text":"<ul> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#p","title":"p","text":"<ul> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#r","title":"r","text":"<ul> <li>r (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#s","title":"s","text":"<ul> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#u","title":"u","text":"<ul> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"controlLibrary/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"controlLibrary/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"controlLibrary/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"controlLibrary/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"controlLibrary/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"controlLibrary/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"controlLibrary/functions/","title":"Functions","text":""},{"location":"controlLibrary/functions/#o","title":"o","text":"<ul> <li>ot_cos (trigo.h)</li> <li>ot_modulo_2pi (trigo.h)</li> <li>ot_sin (trigo.h)</li> </ul>"},{"location":"controlLibrary/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"controlLibrary/variables/","title":"Variables","text":""},{"location":"controlLibrary/variables/#i","title":"i","text":"<ul> <li>INV_MODULO_RES (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#m","title":"m","text":"<ul> <li>MODULO_RES (trigo.h)</li> <li>MODULO_SIZE (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#s","title":"s","text":"<ul> <li>SQRT3_DIV_2 (transform.h)</li> <li>SQRT3_INVERSE (transform.h)</li> </ul>"},{"location":"controlLibrary/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}