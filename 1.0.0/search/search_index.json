{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Matlab/docs/closed_loop_buck/","title":"Closed loop buck","text":"<p>After the open-loop mode, the aim of this tutorial is to show you how you can implement a buck voltage control using simulink and owntech library.</p> <p>You can delete all the data store variable related to the duty_cycle that we have created in the open loop section. Enter inside the block closed_loop_task, and with the association of the block \u201cconstant\u201d, \u201csum\u201d and \u201cdiscrete PID controller\u201d from the simulink library, <code>set leg duty</code> and <code>get data</code> from owntech library you can create the following schema :</p> <p></p> <p>We are fixing the output voltage to 15 volt, as for the PI paramters you should have the same as below\u00a0:</p> <p> </p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code\u00a0:</p> <p></p> <p>When enabling the matlab_mode, the output voltage will be fixed to 15V.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/","title":"First compilation with matlab","text":""},{"location":"Matlab/docs/first_compilation_with_matlab/#owntech-blocksets","title":"Owntech blocksets","text":"<p>There is a set of simulinks blocks ready to be used, to install it first clone this repository and checkout to the branch Ownblock_library_V3. In a console use the commands : </p> <pre><code>git clone https://gitlab.laas.fr/owntech/owntech-matlab.git\ngit checkout Ownblock_library_V3\n</code></pre> <p></p> <p>In the folder where the repository is cloned, you will find a file with the extension .mtltbx which is a matlab toolbox. There are multiple toolbox, choose the one correspondings to your OS and open it with matlab (in matlab press <code>ctrl+o</code> then open the chosen file), and the toolbox will be installed automatically.</p> <p>After the installation you can check that the library has been correctly installed. In simuinks \"Library Brower\" you can see if Owntech Library is present.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#simulink-template","title":"Simulink template","text":"<p>Still in the folder where we cloned the repository checkout to the branch matlab_zephyrV3 :</p> <pre><code>git checkout matlab_zephyrV3\n</code></pre> Resulting folder file structure<pre><code>\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 matlab_file\n\u251c\u2500\u2500 owntech\n\u251c\u2500\u2500 platformio.ini\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 zephyr\n</code></pre> <p></p> <p>Make sure that your working directory in matlab is the folder <code>matlab_file</code>. Browse for the folder in matlab.</p> <p>In matlab_file, there is a simulink file (owntech_template.slx) already set to be used for code generation. Open it and let\u2019s take a look at what is inside :</p> <p></p> <p>Let's see how each of this blocks work, starting by the initialize block.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#initialize-block","title":"Initialize block","text":"<p>This block will generate the initialization step for the hardware and software configuration. You can choose the convention for the legs (buck, boost) and the version of the board.</p> <p></p> <p>You can left it as it is to continue with the default value. </p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#increasedecrease-functions-and-pwr_enable-state","title":"Increase/decrease functions and pwr_enable state","text":"The application task and the control loop  <p>Inside the simulink file, we can see two functions that you can use to increment or decrement variables that you have defined. We will see how to use them later in another section of this tutorial. You can also notice that there is a variable pwr_enable, the state of this variable is used to activate or deactivate the PWM command of the converters.</p> <p></p> <p>We have two blocks here, we will focus on them to generate our code. The first one is the application_loop_task which works at a period of 100ms. Currently it is empty, but it will allow us later to define voltage reference and duty cycle here. </p> <p></p> <p>On the other hand the control_loop_task is faster, and works at 10kHz. We will typically use this block for all the critical tasks (sending the pwm command, PID implementation..). For now, the control_loop blocks contains a block called Interleaved_ON and depending on the value of pwr_enable, this block is supposed to activate the converter drivers. This block is currently commented to not activate the converter, we will uncomment it later on this tutorial.  </p> <p>This concludes the presentation of the simulink template, before generating any code we will need to make some configuration with the serial monitor to visualize data and also send commands.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#serial-monitor-setting","title":"Serial monitor setting","text":"<p>If you check the main file (main.cpp) in the src folder, you will notice that we have essentially two modes :</p> <pre><code>enum serial_interface_menu_mode //LIST OF POSSIBLE MODES FOR THE OWNTECH CONVERTER\n{\n    IDLEMODE =0,\n    MATLABMODE\n};\n</code></pre> <p>The idle mode will turn off the PWM signal sent to the converters, while the matlab mode will execute the generated code. If you look at the loop_communication_task inside the main file, you will see all the commands needed to activate either the idle mode or the matlab mode, but also to use the increase <code>Up_function()</code> and decrease <code>Dwn_function()</code> functions defined in the simulink template. For example, if we send \u201cm\u201d to the serial monitor, we will switch to the matlab mode.</p> different modes and command to send<pre><code>void loop_communication_task()\n{\n    while(1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n            case 'h':\n                //----------SERIAL INTERFACE MENU-----------------------\n                printk(\" ________________________________________\\n\");\n                printk(\"|     Communication task Tutorial        |\\n\");\n                printk(\"|     ------- MENU ---------             |\\n\");\n                printk(\"|     press i : idle mode                |\\n\");\n                printk(\"|     press m : matlab generated code    |\\n\");\n                printk(\"|     press u : increment variable       |\\n\");\n                printk(\"|     press d : decrement variable       |\\n\");\n                printk(\"|________________________________________|\\n\\n\");\n                //------------------------------------------------------\n                break;\n            case 'i':\n                printk(\"idle mode\\n\");\n                mode = IDLEMODE;\n                break;\n            case 'm':\n                printk(\"Matlab generated code\\n\");\n                mode = MATLABMODE;\n                break;\n            case 'u':\n                printk(\"increase!\\n\");\n                Up_function();\n                break; \n            case 'd':\n                printk(\"decrease!\\n\");\n                Dwn_function();\n                break;    \n            default:\n                break;\n        }\n    }\n}\n</code></pre> <p>We will use ownplot as a serial monitor, go to this github page.</p> <p>Then click on release :</p> <p></p> <p>Depending on your OS, choose the correspondig binary file and download it : </p> <p></p> <p>Execute the binary file to launch ownplot, start it and open the \u201csend\u201d tab. First we will set the commands.</p> <p></p> <p>In (1) enter the command\u2019s name (eg: decrease), in (2) the data associated to this command that we will send and finally press (3) to save the command. Repeat this process three time for the other command (idle-i, matlab_mode-m and increase-i).</p> <p></p> <p>In the \u201csetting\u201d tab, check that you have the same parameters.</p> <p></p> <p>With the serial monitor we can visualize current and voltage from the sensor, in the \u201cchart\u201d tab rename the dataset to have the following names in exactly the same order</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#adding-platformio-command-to-the-system-path","title":"Adding platformIO command to the system path","text":"<p>This process depends on your OS: </p> WindowsLinux <p>It is necessary to add C:\\Users\\ user \\.platformio\\penv\\Scripts (user is your user name on the computer) to your system path. We recommend that you follow this guide.</p> <p>You can call this command from matlab command window: <code>setenv(\"PATH\",[getenv(\"PATH\"),':/home/username/.platformio/penv/bin'])</code> Where home is your home directory and username is your user name. If your platformio is installed somewhere else, please change this path.</p> <p>You are now all set to generate your first code !</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#how-to-generate","title":"How to generate","text":"<p>We can try to compile and flash the board with this empty template to make sure that embedded coder work. </p> <p>Go to the app tab and then select Embedded Coder :</p> <p> </p> <p></p> <p>After the code generation, matlab will automatically flash the code to the board. If everything went well, you should see this window appears :</p> <p>If not, make sure that your current working directory is matlab_files, that the board is turned on and connected to your computer or that you have added \u201cC:\\Users\\user.platformio\\penv\\Scripts\u201d to the system path.</p>"},{"location":"Matlab/docs/getting_started/","title":"Gettings started with matlab","text":"<p>Matlab with the Embedded Coder add-on, is employed in the embedded field to generate code directly from Simulink blocksets. By integrating Owntech APIs as blocksets, the Embedded Coder allows you to accelerate the code generation process from your Simulink designs.</p> <p> Image : Example of implementation of PID with Owntech Blockset in Simulink</p> <p>Owntech blocksets might be useful for you if:</p> <ul> <li>You work in fields like research and development, simulation, or other areas where Matlab/Simulink is used regularly.</li> <li>You are interested in quickly generating and deploying code using Simulink blocksets and the Embedded Coder add-on.</li> </ul> <p>Tip</p> <p>It is not required, but you can try to follow first this tutorial to become familiar with owntech hardware and software.</p> <p>Abstract</p> <ul> <li>A TWIST power board</li> <li>A 50V power supply</li> <li>A resistive load (like an electronic load, or a variable resistive load)</li> </ul> <p>Abstract</p> <ul> <li>Matlab-Simulink</li> <li>Embedded coder toolbox</li> <li>Visual Studio Code with PlatformIO</li> </ul>"},{"location":"Matlab/docs/open_loop_buck/","title":"Open loop buck control","text":"<p>This section of the tutorial will show you how you can generate a code to control the converter in open-loop mode with the simulink template.</p> <p></p> <p>First let\u2019s start by creating a variable which will represents the duty cycle. Take a \u201cdata store memory\u201d block from simulink, to the root (where pwr_enable is located).</p> <p></p> <p>Name this data store block duty_cycle, and in the signal attribute tab choose the initial value (0.5 here to have 50% duty cycle) and data type (double or float):</p> <p></p> <p></p> <p>Then enter inside the increase function block, take a \u201cdata store read\u201d and a \u201cdata store write\u201d from simulink library and link them with duty_cycle (name them duty_cycle). With the association of the \u201cconstant\u201d and \u201cadd\u201d block from simulink you can form the following schema.</p> <p></p> <p>You can do the same thing in the decrease function block, instead of an addition it will be a subtraction.</p> <p>You have now the possibility to control the duty_cycle either by increasing or decreasing it, the only thing missing is sending this value to the converters. Inside control_loop_task, we will first uncomment the <code>POWER_ON</code> to activate power : click on the block then press ctrl+shift+x. We will then place a \u201cdata store read\u201d block linked to duty_cycle and a <code>set leg duty</code> block connected together.</p> <p></p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code, use increase and decrease function to control the duty cycle\u00a0:</p> <p></p>"},{"location":"OwnModels/","title":"OwnModels","text":"<p>Repository that gathers all models of the OwnTech foundation.</p>"},{"location":"OwnModels/docs/first_example/","title":"First model example with PLECS","text":"<p>This page shows how to run your first example of a PLECS based OwnTech model.</p>"},{"location":"OwnModels/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> </ul>"},{"location":"OwnModels/docs/first_example/#running-the-open-loop-model-for-the-first-time","title":"Running the open loop model for the first time","text":"<p>We have developed a first model that you can run out-of-the-box. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Open loop folder. Choose the Twist_open_loop.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. At 1 milisecond, the Twist board starts to operate and voltage goes up to around half of the generator voltage, as expected for a 50% duty cycle setup.</p>"},{"location":"OwnModels/docs/first_example/#analyzing-the-model-a-little-further","title":"Analyzing the model a little further","text":"<p>The open loop model will allow you to explore how the twist board operates.</p> <p>The model input is a standard voltage source with an inductive impedence and a bus capacitor.</p> <p>The output is a 1 Ohm resistor.</p> <p>You are now able to run simulations. The next step is to run closed loop simulations using this model.</p>"},{"location":"OwnModels/docs/getting_started/","title":"Gettings started with PLECS","text":"<p>PLECS is a software tool for system-level simualtions of electrical circuits developed by Plexim. It is not open-source, but it remains very accessible, which is a reason why we adopted it as one of the solutions to model our power converters. In this section we will explain to you how to get started with PLECS and run your first simulation.</p>"},{"location":"OwnModels/docs/getting_started/#installing-plecs","title":"Installing PLECS","text":"<p>To install PLECS, go to their website and download the standalone package. Choose your platform and follow the instructions.</p> <p>PLECS LICENSE</p> <p>There are three ways where you can use PLECS. Choose the one of your convenience.</p> Trial licenseDemo modeJCGE 2024 special license <p>PLECS provides a 90 days trial license for its products. Follow their dedicated page to get yours.</p> <p>If you do not want to ask for a license, you can still use PLECS in its demo mode. You will still be able to run the simulations, but you will not be able to modify the model or save its data.</p> <p>During the JCGE 2024 conference we will provide you with a special license that you can get with by clicking here.</p> <p>This License will expire on June 23rd 2024.</p> <p>Once PLECS is installed, you will see its library browser. You are now ready to start working with OwnModels.</p> <p></p>"},{"location":"OwnModels/docs/getting_started/#getting-the-ownmodels-plecs-library","title":"Getting the OwnModels PLECS library","text":"<p>This section will show you how to add the OwnTech library to your PLECS instance.</p> <p>Step 1 - Go to the OwnModels repository of the owntech foundation github. Either clone it locally (if you know how to use git) or download the zip file.</p> <p></p> <p>Step 2 - Unzip the file if you use zip. Keep the path at hand.</p> <p>Step 3 - In PLECS Library Browser go to File-&gt;PLECS Preferences</p> <p></p> <p>Step 4 - In PLECS Preferences click on the Libraries tab. You will see two sub blocks, search path and user libraries.</p> <p></p> <p>Step 5 - In Libraries-&gt;Search path click on the + icon and navigate to the owntech-lib folder. Click on Choose.</p> <p></p> <p></p> <p>Step 7 - In Libraries-&gt;User libraries click on the + icon and navigate to the Owntech_lib.plecs file. Click on Open.</p> <p></p> <p></p> <p>Step 8 - Rename the library name from User Library 1 to OwnTech. Click on Apply and Ok to finish.</p> <p></p> <p></p> <p>Step 9 - Verify that the library is correctly added to the Library Browser.</p> <p></p> <p>You are now ready to run your first PLECS example.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/","title":"Voltage mode simulaton","text":"<p>This page shows how to run a closed loop voltage mode PLECS based OwnTech simulation.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> <li>Successfully Run an open-loop simulation.</li> </ul>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model","title":"Running the closed loop model","text":"<p>The closed loop model is much similar to its open-loop equivalent. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then steadly rises to track its reference of 15 volts.</p> <p>Speed</p> <p>You will notice that this simulation is significantly slower than the open-loop. This is normal as the model used was a switched one. These models are precise, requiring longer to run.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model-averaged-version","title":"Running the closed loop model - AVERAGED version","text":"<p>We will now run the averaged version of the closed loop voltage mode model. The idea here is to show you how a less precise model is much faster.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck_AVG.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then rises to track its reference of 15 volts.</p> <p>Speed</p> <p>Notice how much faster this model is. Using averaged models allows for much faster iteration and study of the system in steady-state conditions. It can also be used whenever the study is much more focused on system-level behavior rather than switching.</p> <p>You are now ready to start working on a droop control example.</p>"},{"location":"OwnPlot/","title":"OwnPlot","text":"<p>OwnPlot is a free and opensource data plotter software designed to work with OwnTech's dev board. </p> <p>However, everybody can use this software as a data plotter with any devboard.</p>"},{"location":"OwnPlot/#why-create-another-plotting-app-from-scratch","title":"Why create another plotting app from scratch","text":"<p>After testing the most popular plotting app, we realized that it was not an easy task to run the app on all systems without tweaking. We also want to add power electronics-specific features in the near future. We are glad to present an easy-to-use and painless installation app.</p> <p>And most of all, it's free! Happy plotting \ud83d\ude01</p>"},{"location":"OwnPlot/#how-to-use-it","title":"How to use it","text":"<p>Go to the settings tab to specify the data format that your devboard is sending. Then select the right port and open it. You can pause both chart and terminal with the top right button. Once you are done, you can close the port (it will close when you close the app anyway).</p> <p>You can custom the chart layout under chart tab. Click on a channel in the legend to change its layout.</p> <p>A record feature is also available. You have to click play under the record tab. Do not forget to download the file !</p> <p>Send command to your devboard through the command tab ! You can add buttons if you have to send the same data regularly.</p>"},{"location":"OwnPlot/#running-the-development-environment","title":"Running the development environment","text":"<p>First of all, open the terminal of your choice. If you are using Windows, we recommand the use of git bash https://www.git-scm.com/downloads</p> <ol> <li> <p>type: \\     <code>node --version</code></p> <ul> <li>If the command prompt tells you node isn't present on your computer, then download and install nodejs thru this website:     https://nodejs.org/en/download/</li> <li>If the version is inferior than version 14.x.x then you'll need to update nodejs. <code>nvm</code> is a great little piece of kit that will make your life a lot easier   https://github.com/nvm-sh/nvm</li> </ul> <p>Note: version <code>18.7.0</code> is recommanded</p> </li> <li> <p>Clone the repository:</p> <ul> <li> <p>If you have a gitlab accound and a ssh key linked to this one, clone with this command instead: \\ <code>git clone git@gitlab.laas.fr:owntech/ownplot.git</code></p> </li> <li> <p>Otherwise use this command: \\ <code>git clone https://gitlab.laas.fr/owntech/ownplot.git</code></p> </li> </ul> </li> <li> <p>Go the the newly created folder: \\ <code>cd ownplot</code></p> </li> <li> <p>Install the decencies: \\ <code>npm install</code></p> </li> <li> <p>Run the development environment: \\ <code>npm start</code></p> </li> </ol> <p>Congrats! \ud83e\udd73 \\ A window should be opened with OwnPlot.</p> <p>If you are experiencing problems during the install, please post an issue and report the problem. This will greatly help us improve the user experience.</p>"},{"location":"OwnPlot/#build-for-your-plateform","title":"Build for your plateform","text":"<p>Run  - <code>npm run pack-win</code> for the <code>.exe</code> installer - <code>npm run pack-linux</code> for the <code>.deb</code>, <code>.rpm</code> and <code>.AppImage</code> - <code>npm run pack-mac-uni</code> for the <code>.dmg</code></p> <p>Note: Only a mac can build all the plateforms.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [owntech@laas.fr]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"OwnPlot/CONTRIBUTE/","title":"Contribute to OwnPlot","text":"<p>Welcome ! Thank you for your interest in OwnPlot. We would greatly appreciate your involvement in the project if you wish.</p> <p>You will find in this file some informations to guide you through the contributing process.</p>"},{"location":"OwnPlot/CONTRIBUTE/#summary","title":"Summary","text":"<ul> <li>Community guidelines</li> <li>Bug Report</li> <li>Suggest Feature</li> <li>Contribute to the code base</li> <li>Contact for further questions</li> </ul>"},{"location":"OwnPlot/CONTRIBUTE/#community-guidelines","title":"Community guidelines","text":"<p>Always be nice to other contributors. Be constructive and understanding when interacting with someone. Read and then follow the Code of Conduct at all times.</p>"},{"location":"OwnPlot/CONTRIBUTE/#bug-report","title":"Bug Report","text":"<p>Please report bugs within the gitlab repository by creating a new issue. Use the bug issue template and try to be as descriptive as possible. Always check first if a similar issue already exists or has been closed.</p>"},{"location":"OwnPlot/CONTRIBUTE/#suggest-feature","title":"Suggest Feature","text":"<p>Feel free to make any suggestion that would improve the user experience. To do so, please use the feature issue template in the gitlab repository.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contribute-to-the-code-base","title":"Contribute to the code base","text":"<p>If you want to get involved further, you can write and modify the existing code base available at the gitlab OwnPlot repository. Your modifications should always be related to an issue. You can submit a feature/bug issue if no one answers your problematic. The code base is clearly not perfectly written so far. Code related improvements are welcomed if they make code easier to understand, more compact, faster to execute. A related issue template is available.</p>"},{"location":"OwnPlot/CONTRIBUTE/#coding-style","title":"Coding Style","text":"<p>Always try to make your code as readable as possible as other people will work on it. Names should be as descriptive as possible. Here is a guide that we try to follow when writing code, so please try to stick to it too. Do not worry if you do not achieve to write a perfect piece of code, just try to be clear about what you are trying to code. Comments are precious friends, but should not be redudant with explicit lines of code. Explicit naming should be your first concern. Other contributors can help you, do not hesitate to ask for help.</p>"},{"location":"OwnPlot/CONTRIBUTE/#submit-your-modifications","title":"Submit your modifications","text":"<p>Please begin with creating a branch, which name should be XXXX_nameOfTheBranch, considering XXXX as the number of the corresponding issue. Then add and commit changes everytime an improvement has been brought to the code, but always ensure that each commit is atomic (brings a full modification and is functionnal). Consider reading this page for a clear explanation of good practice in commits. Finally ask for a pull request that will be examined as soon as possible.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contact-for-further-questions","title":"Contact for further questions","text":"<p>OwnPlot is an open-source software created and maintained by the OwnTech Foundation. It is delivered with the GNU LGPL v2.1 Licence. An overview of our work is available at our website. Contact us at owntech@laas.fr, or join our Discord.</p> <p>Thank you for your involvement. See you soon !</p>"},{"location":"OwnPlot/LICENCE/","title":"Licence","text":"<p>OwnPlot, the OwnTech data plotter. Copyright (C) 2022 OwnTech Foundation.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p> <p>Contact the OwnTech Foundation by email at [owntech@laas.fr].</p> <p>Full licence is available at: https://opensource.org/licenses/LGPL-2.1.</p>"},{"location":"OwnPlot/docs/","title":"Index","text":""},{"location":"OwnPlot/docs/#welcome-to-ownplot","title":"Welcome to OwnPlot!","text":"<p>This documentation will help you use and develop for OwnPlot.</p> OwnPlot is a Free and OpenSource plotter written in Electron"},{"location":"OwnPlot/docs/#documentation","title":"Documentation","text":"<p>The documentation is split between the User Manual and the Developer Manual</p> <p> User Manual</p> <p> Dev Manual</p>"},{"location":"OwnPlot/docs/#user-manual","title":"User Manual","text":"<p>The User Manual will guide you through all of OwnPlot's features.</p>"},{"location":"OwnPlot/docs/#developer-manual","title":"Developer Manual","text":"<p>The Dev Manual will help you understand the architecture and will permit you to add features and contribute to OwnPlot's development.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/","title":"Files description","text":""},{"location":"OwnPlot/docs/dev-manual/arch/#main-files","title":"Main files","text":"<p>These files are located at the root of the repo. - main.js Program Starting Point. This file sets up the windows as well as default configurations.  This also loads user configuration. This file will render index.ejs - index.ejs The main skeleton of OwnPlot. This file includes other .ejs files present in the template folder</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files","title":"Template files","text":"<p>Files used to describe skeletons of the different parts of OwnPlot. - header.ejs This file includes stylesheets and some scripts. description needed - navBar.ejs The navigation hub of OwnPlot. This file permits to change the main view. screenshot of the navbar. - portBar.ejs description needed - tabs.ejs description needed - apps.ejs description needed - myTerminal.ejs description needed - footer.ejs Closing the HTML tag.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files_1","title":"Template files","text":""},{"location":"OwnPlot/docs/dev-manual/home/","title":"Development Manual","text":""},{"location":"OwnPlot/docs/dev-manual/home/#setting-up-a-dev-environment","title":"Setting up a dev environment","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#dev-board-demo-code","title":"Dev board demo code","text":"<p>In order to transmit data to OwnPlot, your device must send data through a serial port. This serial port on dev boards is in most cases USB based.</p> <p>This page will provide you with sample codes that will make those dev boards \"talk\" in the serial port.</p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#sawtooth-demo-code","title":"Sawtooth demo code","text":"<p>This code will generate sawteeth with ASCII formatting.</p> <p>You can change the number of datasets by modifying the <code>#define numberOfTriangles 3</code> statement. The default value is 3.</p>  SPIN Arduino <p>Info</p> <p>If you need to familiarize yourself with OwnTech's SDK, please start here</p> <pre><code>#include \"TaskAPI.h\"\n#include \"SpinAPI.h\"\n#include \"zephyr/console/console.h\"\n\nvoid setup_routine();\nvoid loop_communication_task();\nvoid initTriangles();\nint main();\n\n#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nuint8_t received_serial_char;\nuint8_t state = 1;\n\nvoid setup_routine() {\n    spin.version.setBoardVersion(SPIN_v_1_0);\n    uint32_t com_task_number = task.createBackground(loop_communication_task);\n    task.startBackground(com_task_number);\n}\n\nvoid loop_communication_task()\n{\n    while (1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n        case 's':\n            state ^= 1;\n            break;\n        default:\n            break;\n        }\n        k_msleep(100);\n    }\n}\n\nvoid initTriangles() {\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nint main() {\n    setup_routine();\n    initTriangles();\n    while (1) {\n        if (state) {\n            for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n                printk(\"%d:\", triangles[i]);\n            }\n            printk(\"%d\\n\", triangles[numberOfTriangles - 1]);\n            for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n                triangles[i] = triangles[i] + numberPoints;\n            }\n        }\n        k_msleep(50);\n    }\n    return 0;\n}\n</code></pre> <p>Here is the demo code. Tested on an Arduino Uno and Mega. <pre><code>#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nint incomingByte;\nuint8_t state = 1;\n\nvoid setup() {\n    Serial.begin(115200);\n    initTriangles();\n}\n\nvoid initTriangles() {\nfor (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n    triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nvoid loop() {\nincomingByte = Serial.read();\nif (incomingByte &gt; 0) {\n    if (incomingByte == 's') {\n        state ^= 1;\n    }\n}\nif (state) {\n    for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n        Serial.print(triangles[i]);\n        Serial.print(\":\");\n    }\n    Serial.println(triangles[numberOfTriangles - 1]);\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = triangles[i] + numberPoints;\n    }\n}\ndelay(100);\n}\n</code></pre></p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#result","title":"Result","text":"<p>In either case, you will get the same sawteeth in OwnPlot. To open the port, please refer to this page.</p>"},{"location":"OwnPlot/docs/user-manual/first-steps/","title":"My First Port","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#first-steps","title":"First Steps","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#open-a-port","title":"Open a port","text":"<ol> <li>Select the send tab (This will spawn the graph)</li> <li>Plug in a SPIN or an Arduino talking on the serial port. if you want to test this, sample programs will be available later.</li> <li> <p>Select the corresponding serial port in the port dropdown</p>  Windows macOS Linux <p>The port will start with COM TODO: PIC { width=\"300\" }</p> <p>The port will most likely start with /dev/tty.usbserial but your mileage may vary. </p> <p>The port will most likely start with /dev/tty.usb but your mileage may vary. TODO: PIC { width=\"300\" }</p> </li> <li> <p>Open the port by clicking the \"Open\" button</p> <p></p> </li> <li> <p>You should observe the data coming from the serial port in the terminal and data points should appear on the graph.</p> <p></p> </li> </ol> <p>Troubleshooting</p> <ul> <li>if you have trouble seeing the desired port, check out the troubleshooting guide</li> </ul>"},{"location":"OwnPlot/docs/user-manual/home/","title":"Home","text":""},{"location":"OwnPlot/docs/user-manual/home/#user-manual","title":"User Manual","text":"<p>Welcome to the OwnPlot's user manual. This documentation will help you familiarize yourself with OwnPlot and understand all its features. If you find a mistake or a malfunction of OwnPlot, please report the issue Here .</p>"},{"location":"OwnPlot/docs/user-manual/home/#start-here","title":"Start Here","text":"<p>If you are a new user of OwnPlot, please start here.</p>"},{"location":"OwnPlot/docs/user-manual/home/#download-setup","title":"Download &amp; Setup","text":""},{"location":"OwnPlot/docs/user-manual/home/#dev-board-demo-code","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/home/#my-first-port","title":"My first port","text":""},{"location":"OwnPlot/docs/user-manual/home/#components","title":"Components","text":""},{"location":"OwnPlot/docs/user-manual/home/#tabs","title":"Tabs","text":""},{"location":"OwnPlot/docs/user-manual/home/#terminal","title":"Terminal","text":""},{"location":"OwnPlot/docs/user-manual/home/#plotter","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/setup/","title":"Setup","text":""},{"location":"OwnPlot/docs/user-manual/setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"OwnPlot/docs/user-manual/setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p> <p>Great! Now that you have OwnPlot installed and all setup, we can proceed to your first steps with OwnPlot.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/","title":"Troubleshooting","text":""},{"location":"OwnPlot/docs/user-manual/troubleshooting/#port-finding","title":"Port finding","text":"<p>If you can't see the port you are looking for, try to unplug and plug in the dev board to another port. You can try to reflash the sample program.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#antivirus","title":"Antivirus","text":"<p>It has been reported that some antivirus like Norton Antivirus can cause problems while downloading OwnPlot. If you have trouble downloading OwnPlot, please disable or trust the executable file.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#empty-canvas","title":"Empty canvas","text":"<p>By default, no activities are loaded into OwnPlot (this might change in the future). Select any tab like the send tab to load the graph and terminal</p>"},{"location":"OwnPlot/docs/user-manual/Components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/Components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/Components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"OwnPlot/docs/user-manual/components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"bootloader/","title":"MCUboot","text":"<p>This is MCUboot version 2.1.0-dev</p> <p>MCUboot is a secure bootloader for 32-bits microcontrollers. It defines a common infrastructure for the bootloader and the system flash layout on microcontroller systems, and provides a secure bootloader that enables easy software upgrade.</p> <p>MCUboot is not dependent on any specific operating system and hardware and relies on hardware porting layers from the operating system it works with. Currently, MCUboot works with the following operating systems and SoCs: - Zephyr - Apache Mynewt - Apache NuttX - RIOT - Mbed OS - Espressif - Cypress/Infineon</p> <p>RIOT is supported only as a boot target. We will accept any new port contributed by the community once it is good enough.</p>"},{"location":"bootloader/#mcuboot-how-tos","title":"MCUboot How-tos","text":"<p>See the following pages for instructions on using MCUboot with different operating systems and SoCs: - Zephyr - Apache Mynewt - Apache NuttX - RIOT - Mbed OS - Espressif - Cypress/Infineon</p> <p>There are also instructions for the Simulator.</p>"},{"location":"bootloader/#roadmap","title":"Roadmap","text":"<p>The issues being planned and worked on are tracked using GitHub issues. To give your input, visit MCUboot GitHub Issues.</p>"},{"location":"bootloader/#source-files","title":"Source files","text":"<p>You can find additional documentation on the bootloader in the source files. For more information, use the following links: - boot/bootutil - The core of the bootloader itself. - boot/boot_serial - Support for serial upgrade within the bootloader itself. - boot/zephyr - Port of the bootloader to Zephyr. - boot/mynewt - Bootloader application for Apache Mynewt. - boot/nuttx - Bootloader application and port of MCUboot interfaces for Apache NuttX. - boot/mbed - Port of the bootloader to Mbed OS. - boot/espressif - Bootloader application and MCUboot port for Espressif SoCs. - boot/cypress - Bootloader application and MCUboot port for Cypress/Infineon SoCs. - imgtool - A tool to securely sign firmware images for booting by MCUboot. - sim - A bootloader simulator for testing and regression.</p>"},{"location":"bootloader/#joining-the-project","title":"Joining the project","text":"<p>Developers are welcome!</p> <p>Use the following links to join or see more about the project:</p> <ul> <li>Our developer mailing list</li> <li>Our Slack channel    Get your invite</li> </ul>"},{"location":"bootloader/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"bootloader/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"bootloader/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at mcuboot@groups.io. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"bootloader/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by  Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available  at https://www.contributor-covenant.org/translations.</p>"},{"location":"bootloader/docs/","title":"MCUboot","text":"<p>MCUboot is a secure bootloader for 32-bits microcontrollers.</p>"},{"location":"bootloader/docs/#overview","title":"Overview","text":"<p>MCUboot defines a common infrastructure for the bootloader and the system flash layout on microcontroller systems, and provides a secure bootloader that enables easy software upgrade.</p> <p>MCUboot is not dependent on any specific operating system and hardware and relies on hardware porting layers from the operating system it works with. Currently MCUboot works with the following operating systems and SoCs: - Zephyr - Apache Mynewt - Apache NuttX - RIOT - Mbed OS - Espressif - Cypress/Infineon</p> <p>RIOT is supported only as a boot target. We will accept any new port contributed by the community once it is good enough.</p> <p>MCUboot is an open governance project. See the membership list for current members, and the project charter for more details.</p>"},{"location":"bootloader/docs/#documentation","title":"Documentation","text":"<p>The MCUboot documentation is composed of the following pages:</p> <ul> <li>General - this document</li> <li>Release notes</li> <li>Bootloader design</li> <li>Encrypted images</li> <li>imgtool - image signing and key management</li> <li>ECDSA - information about ECDSA signature formats</li> <li>Serial Recovery - MCUmgr as the serial recovery protocol</li> <li>Usage instructions:</li> <li>Zephyr</li> <li>Apache Mynewt</li> <li>Apache NuttX</li> <li>RIOT</li> <li>Mbed OS</li> <li>Espressif</li> <li>Cypress/Infineon</li> <li>Simulator</li> <li>Testing</li> <li>Zephyr - Zephyr test plan</li> <li>Apache Mynewt - Apache Mynewt test plan</li> <li>Release process</li> <li>Project security policy</li> <li>Patch submission - information   on how to contribute to MCUboot</li> </ul> <p>The documentation page about signed images is currently outdated. Follow the instructions in imgtool instead.</p>"},{"location":"bootloader/docs/#roadmap","title":"Roadmap","text":"<p>The issues being planned and worked on are tracked using GitHub issues. To give your input, visit MCUboot GitHub Issues.</p>"},{"location":"bootloader/docs/#source-files","title":"Source files","text":"<p>You can find additional documentation on the bootloader in the source files. For more information, use the following links: - boot/bootutil - The core of the bootloader itself. - boot/boot_serial - Support for serial upgrade within the bootloader itself. - boot/zephyr - Port of the bootloader to Zephyr. - boot/mynewt - Bootloader application for Apache Mynewt. - boot/nuttx - Bootloader application and port of MCUboot interfaces for Apache NuttX. - boot/mbed - Port of the bootloader to Mbed OS. - boot/espressif - Bootloader application and MCUboot port for Espressif SoCs. - boot/cypress - Bootloader application and MCUboot port for Cypress/Infineon SoCs. - imgtool - A tool to securely sign firmware images for booting by MCUboot. - sim - A bootloader simulator for testing and regression.</p>"},{"location":"bootloader/docs/#joining-the-project","title":"Joining the project","text":"<p>Developers are welcome!</p> <p>Use the following links to join or see more about the project:</p> <ul> <li>Our developer mailing list</li> <li>Our Slack channel    Get your invite</li> <li>Current members</li> <li>Project charter</li> </ul>"},{"location":"bootloader/docs/PORTING/","title":"Porting how-to","text":"<p>This document describes the requirements and necessary steps required to port <code>MCUboot</code> to a new target <code>OS</code>.</p>"},{"location":"bootloader/docs/PORTING/#requirements","title":"Requirements","text":"<ul> <li> <p><code>MCUboot</code> requires a configuration file, which can be included as    mcuboot_config/mcuboot_config.h, which configures various options    (that begin with MCUBOOT_).</p> </li> <li> <p><code>MCUboot</code> requires that the target provides a <code>flash</code> API with ability to   get the flash's minimum write size, and read/write/erase individual sectors.</p> </li> <li> <p><code>MCUboot</code> doesn't bundle a cryptographic library, which means the target   OS must already have it bundled. The supported libraries at the moment are   either <code>Mbed TLS</code> or the set <code>tinycrypt</code> + <code>Mbed TLS</code> (where <code>Mbed TLS</code> is   used to provide functionality not existing in <code>tinycrypt</code>).</p> </li> </ul>"},{"location":"bootloader/docs/PORTING/#steps-to-port","title":"Steps to port","text":""},{"location":"bootloader/docs/PORTING/#main-app-and-calling-the-bootloader","title":"Main app and calling the bootloader","text":"<p>From the perspective of the target OS, the bootloader can be seen as a library, so an entry point must be provided. This is likely a typical <code>app</code> for the target OS, and it must call the following function to run the bootloader:</p> <pre><code>int boot_go(struct boot_rsp *rsp);\n</code></pre> <p>This function is located at <code>boot/bootutil/loader.c</code> and receives a <code>struct boot_rsp</code> pointer. The <code>struct boot_rsp</code> is defined as:</p> <pre><code>struct boot_rsp {\n    /** A pointer to the header of the image to be executed. */\n    const struct image_header *br_hdr;\n\n    /**\n     * The flash offset of the image to execute.  Indicates the position of\n     * the image header.\n     */\n    uint8_t br_flash_id;\n    uint32_t br_image_addr;\n};\n</code></pre> <p>After running the management functions of the bootloader, <code>boot_go</code> returns an initialized <code>boot_rsp</code> which has pointers to the location of the image where the target firmware is located which can be used to jump to.</p>"},{"location":"bootloader/docs/PORTING/#configuration-file","title":"Configuration file","text":"<p>You must provide a file, mcuboot_config/mcuboot_config.h. This is included by several files in the \"library\" portion of MCUboot; it provides preprocessor definitions that configure the library's build.</p> <p>See the file samples/mcuboot_config/mcuboot_config.template.h for a starting point and more information. This is a good place to convert settings in your environment's configuration system to those required by MCUboot. For example, Mynewt uses MYNEWT_VAL() and Zephyr uses Kconfig; these configuration systems are converted to MCUBOOT_ options in the following files:</p> <ul> <li>boot/zephyr/include/mcuboot_config/mcuboot_config.h</li> <li>boot/mynewt/mcuboot_config/include/mcuboot_config/mcuboot_config.h</li> </ul>"},{"location":"bootloader/docs/PORTING/#flash-map","title":"Flash Map","text":"<p>The bootloader requires to be able to address flash regions where the code for MCUboot and images of applications are stored, in system-agnostic way. For that purpose the MCUboot uses ID, which is integer (uint8_t) number that should uniquely identify each flash region. Such flash regions are served by object of <code>const struct flash_area</code> type while layout of these objects is gathered under <code>flash_map</code>. The common code of MCUboot, that is non-system specific, does not directly access contents of that object and never modifies it, instead it calls <code>flash_area_</code> API to perform any actions on that object. This way systems are free to implement internal logic of flash map or define <code>struct flash_area</code> as they wish; the only restriction is that ID should be uniquely tied to region characterized by device, offset and size.</p> <p>Changes to common MCUboot code should not affect system specific internals of flash map, on the other side system specific code, within MCUboot, is is not restricted from directly accessing <code>struct flash_area</code> elements.</p> <p>An implementation of <code>struct flash_area</code> may take form of: <pre><code>struct flash_area {\n    uint8_t  fa_id;         /** The slot/scratch identification */\n    uint8_t  fa_device_id;  /** The device id (usually there's only one) */\n    uint16_t pad16;\n    uint32_t fa_off;        /** The flash offset from the beginning */\n    uint32_t fa_size;       /** The size of this sector */\n};\n</code></pre> The above example of structure hold all information that is currently required by MCUboot, although the MCUboot will not be trying to access them directly, instead a system is required to provide following mandatory getter functions:</p> <pre><code>/*&lt; Obtains ID of the flash area characterized by `fa` */\nint     flash_area_get_id(const struct flash_area *fa);\n/*&lt; Obtains ID of a device the flash area `fa` described region resides on */\nint     flash_area_get_device_id(const struct flash_area *fa)\n/*&lt; Obtains offset, from the beginning of a device, the flash area described\n * region starts at */\nuint32_t flash_area_get_off(const struct flash_area *fa)\n/*&lt; Obtains size, from the offset, of the flash area `fa` characterized region */\nuint32_t flash_area_get_size(const struct flash_area *fa)\n</code></pre> <p>The MCUboot common code uses following defines that should be defined by system specific header files and are used to identify destination of flash area by ID:</p> <p><pre><code>/* Independent from multiple image boot */\n#define FLASH_AREA_BOOTLOADER         0\n#define FLASH_AREA_IMAGE_SCRATCH      3\n</code></pre> <pre><code>/* Flash area IDs of the first image in case of multiple images */\n#define FLASH_AREA_IMAGE_PRIMARY      1\n#define FLASH_AREA_IMAGE_SECONDARY    2\n</code></pre> <pre><code>/* Flash area IDs of the second image in case of multiple images */\n#define FLASH_AREA_IMAGE_PRIMARY      5\n#define FLASH_AREA_IMAGE_SECONDARY    6\n</code></pre></p> <p>The numbers, given above, are provided as an example and depend on system implementation.</p> <p>The main, also required, set of API functions that perform operations on flash characterized by <code>struct flash_area</code> objects is as follows:</p> <pre><code>/*&lt; Opens the area for use. id is one of the `fa_id`s */\nint      flash_area_open(uint8_t id, const struct flash_area **);\nvoid     flash_area_close(const struct flash_area *);\n/*&lt; Reads `len` bytes of flash memory at `off` to the buffer at `dst` */\nint      flash_area_read(const struct flash_area *, uint32_t off, void *dst,\n                         uint32_t len);\n/*&lt; Writes `len` bytes of flash memory at `off` from the buffer at `src` */\nint      flash_area_write(const struct flash_area *, uint32_t off,\n                          const void *src, uint32_t len);\n/*&lt; Erases `len` bytes of flash memory at `off` */\nint      flash_area_erase(const struct flash_area *, uint32_t off, uint32_t len);\n/*&lt; Returns this `flash_area`s alignment */\nuint32_t flash_area_align(const struct flash_area *);\n/*&lt; What is value is read from erased flash bytes. */\nuint8_t  flash_area_erased_val(const struct flash_area *);\n/*&lt; Given flash area ID, return info about sectors within the area. */\nint      flash_area_get_sectors(int fa_id, uint32_t *count,\n                                struct flash_sector *sectors);\n/*&lt; Returns the `fa_id` for slot, where slot is 0 (primary) or 1 (secondary).\n    `image_index` (0 or 1) is the index of the image. Image index is\n    relevant only when multi-image support support is enabled */\nint      flash_area_id_from_multi_image_slot(int image_index, int slot);\n/*&lt; Returns the slot (0 for primary or 1 for secondary), for the supplied\n    `image_index` and `area_id`. `area_id` is unique and is represented by\n    `fa_id` in the `flash_area` struct. */\nint      flash_area_id_to_multi_image_slot(int image_index, int area_id);\n</code></pre> <p>Note</p> <p>As of writing, it is possible that MCUboot will open a flash area multiple times simultaneously (through nested calls to <code>flash_area_open</code>). As a result, MCUboot may call <code>flash_area_close</code> on a flash area that is still opened by another part of MCUboot. As a workaround when porting, it may be necessary to implement a counter of the number of times a given flash area has been opened by MCUboot. The <code>flash_area_close</code> implementation should only fully deinitialize the underlying flash area when the open counter is decremented to 0. See this GitHub PR for a more detailed discussion.</p>"},{"location":"bootloader/docs/PORTING/#memory-management-for-mbed-tls","title":"Memory management for Mbed TLS","text":"<p><code>Mbed TLS</code> employs dynamic allocation of memory, making use of the pair <code>calloc/free</code>. If <code>Mbed TLS</code> is to be used for crypto, your target RTOS needs to provide this pair of function.</p> <p>To configure the what functions are called when allocating/deallocating memory <code>Mbed TLS</code> uses the following call:</p> <pre><code>int mbedtls_platform_set_calloc_free (void *(*calloc_func)(size_t, size_t),\n                                      void (*free_func)(void *));\n</code></pre> <p>For reference see Mbed TLS platform.h. If your system already provides functions with compatible signatures, those can be used directly here, otherwise create new functions that glue to your <code>calloc/free</code> implementations.</p>"},{"location":"bootloader/docs/SECURITY/","title":"Project security policy","text":"<p>The MCUboot team takes security, vulnerabilities, and weaknesses seriously.</p>"},{"location":"bootloader/docs/SECURITY/#reporting-security-issues","title":"Reporting security issues","text":"<p>The preferred way to report security issues with MCUboot is via the \"Report a security vulnerability\" button on the main security page.</p> <p>You can also directly contact the following maintainers of the project:</p> <ul> <li>David Brown: davidb@davidb.org or david.brown@linaro.org</li> <li>Fabio Utzig: utzig@apache.org</li> </ul> <p>If you wish to send an encrypted email, you may use these PGP keys:</p> <pre><code>    pub   rsa4096 2011-10-14 [SC]\n          DAFD760825AE2636AEA9CB19E6BA9F5C5E54DF82\n    uid           [ultimate] David Brown &lt;davidb@davidb.org&gt;\n    uid           [ultimate] David Brown &lt;david.brown@linaro.org&gt;\n    sub   rsa4096 2011-10-14 [E]\n</code></pre> <p>and</p> <pre><code>    pub   rsa4096 2017-07-28 [SC]\n          126087C7E725625BC7E89CC7537097EDFD4A7339\n    uid           [ unknown] Fabio Utzig &lt;utzig@apache.org&gt;\n    uid           [ unknown] Fabio Utzig &lt;utzig@utzig.org&gt;\n    sub   rsa4096 2017-07-28 [E]\n</code></pre> <p>Please include the word \"SECURITY\" as well as \"MCUboot\" in the subject of any message.</p> <p>We will make our best effort to respond in a timely manner. Most vulnerabilities found within published code will undergo an embargo of 90 days to allow time fixes to be developed and deployed.</p>"},{"location":"bootloader/docs/SECURITY/#vulnerability-advisories","title":"Vulnerability advisories","text":"<p>Vulnerability reports and published fixes will be reported as follows:</p> <ul> <li> <p>Issues will be entered into MCUboot's security advisory   system on GitHub, with   the interested parties (including the reporter) added as viewers.</p> </li> <li> <p>The release notes will contain a reference to any allocated CVE(s).</p> </li> <li> <p>When the embargo is lifted, the security advisory page will be made   public, and the public CVE database will be updated with all   relevant information.</p> </li> </ul>"},{"location":"bootloader/docs/SubmittingPatches/","title":"Patch submission","text":"<p>The development of MCUboot takes place in the MCUboot GitHub repository.</p> <p>To submit patches, use GitHub pull requests.</p> <p>Each commit has to have, in the commit message, a \"Signed-off-by\" line that mentions the author (and the committer, if that is different). You must add this line at the end of the commit text, separated by a blank line. You can also add a line linking the commit to a specific GitHub issue, as this section supports multiple lines, similarly to RFC-2822.</p> <p>The supported trailer lines are structured as follows:</p> <ul> <li>A line that indicates that the signer agrees to the \"Developer Certificate of Origin\" located at the bottom of this page:</li> </ul> <pre><code>    Signed-off-by: Developer Name &lt;devname@example.com&gt;\n</code></pre> <ul> <li>A line that links this commit to specific GitHub issues, if present:</li> </ul> <pre><code>Keyword #GH_issue_number\n</code></pre> <p>For more details about linking a GitHub pull request to a GitHub issue,   see this [link]   (https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue).</p>"},{"location":"bootloader/docs/SubmittingPatches/#release-notes","title":"Release notes","text":"<p>To facilitate creating release notes at release time, all non-trivial changes must include a release note snippet in the pull request. This can be either a separate commit, or as part of a single commit (generally, if there are multiple commits to the pull request, the release note snippet should be a separate commit, and a pull request that is a single commit can include the release note snippet in that commit).  In either case, the release notes must be included in the same PR that makes the given change.</p> <p>The release notes should be placed in the <code>docs/release-notes.d</code> directory. Please see the readme file in that directory for specifics.</p>"},{"location":"bootloader/docs/SubmittingPatches/#developer-certificate-of-origin","title":"Developer certificate of origin","text":"<p>The following is the \"Developer Certificate of Origin\":</p> <pre><code>Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n</code></pre>"},{"location":"bootloader/docs/design/","title":"Design","text":""},{"location":"bootloader/docs/design/#bootloader","title":"Bootloader","text":""},{"location":"bootloader/docs/design/#summary","title":"Summary","text":"<p>MCUboot comprises two packages:</p> <ul> <li>The bootutil library (boot/bootutil)</li> <li>The boot application (each port has its own at boot/) <p>The bootutil library performs most of the functions of a bootloader.  In particular, the piece that is missing is the final step of actually jumping to the main image.  This last step is instead implemented by the boot application. Bootloader functionality is separated in this manner to enable unit testing of the bootloader.  A library can be unit tested, but an application can't. Therefore, functionality is delegated to the bootutil library when possible.</p>"},{"location":"bootloader/docs/design/#limitations","title":"Limitations","text":"<p>The bootloader currently only supports images with the following characteristics: * Built to run from flash. * Built to run from a fixed location (i.e., not position-independent).</p>"},{"location":"bootloader/docs/design/#image-format","title":"Image format","text":"<p>The following definitions describe the image format.</p> <pre><code>#define IMAGE_MAGIC                 0x96f3b83d\n\n#define IMAGE_HEADER_SIZE           32\n\nstruct image_version {\n    uint8_t iv_major;\n    uint8_t iv_minor;\n    uint16_t iv_revision;\n    uint32_t iv_build_num;\n};\n\n/** Image header.  All fields are in little endian byte order. */\nstruct image_header {\n    uint32_t ih_magic;\n    uint32_t ih_load_addr;\n    uint16_t ih_hdr_size;           /* Size of image header (bytes). */\n    uint16_t ih_protect_tlv_size;   /* Size of protected TLV area (bytes). */\n    uint32_t ih_img_size;           /* Does not include header. */\n    uint32_t ih_flags;              /* IMAGE_F_[...]. */\n    struct image_version ih_ver;\n    uint32_t _pad1;\n};\n\n#define IMAGE_TLV_INFO_MAGIC        0x6907\n#define IMAGE_TLV_PROT_INFO_MAGIC   0x6908\n\n/** Image TLV header.  All fields in little endian. */\nstruct image_tlv_info {\n    uint16_t it_magic;\n    uint16_t it_tlv_tot;  /* size of TLV area (including tlv_info header) */\n};\n\n/** Image trailer TLV format. All fields in little endian. */\nstruct image_tlv {\n    uint8_t  it_type;   /* IMAGE_TLV_[...]. */\n    uint8_t  _pad;\n    uint16_t it_len;    /* Data length (not including TLV header). */\n};\n\n/*\n * Image header flags.\n */\n#define IMAGE_F_PIC                      0x00000001 /* Not supported. */\n#define IMAGE_F_ENCRYPTED_AES128         0x00000004 /* Encrypted using AES128. */\n#define IMAGE_F_ENCRYPTED_AES256         0x00000008 /* Encrypted using AES256. */\n#define IMAGE_F_NON_BOOTABLE             0x00000010 /* Split image app. */\n#define IMAGE_F_RAM_LOAD                 0x00000020\n\n/*\n * Image trailer TLV types.\n */\n#define IMAGE_TLV_KEYHASH           0x01   /* hash of the public key */\n#define IMAGE_TLV_SHA256            0x10   /* SHA256 of image hdr and body */\n#define IMAGE_TLV_RSA2048_PSS       0x20   /* RSA2048 of hash output */\n#define IMAGE_TLV_ECDSA224          0x21   /* ECDSA of hash output - Not supported anymore */\n#define IMAGE_TLV_ECDSA_SIG         0x22   /* ECDSA of hash output */\n#define IMAGE_TLV_RSA3072_PSS       0x23   /* RSA3072 of hash output */\n#define IMAGE_TLV_ED25519           0x24   /* ED25519 of hash output */\n#define IMAGE_TLV_ENC_RSA2048       0x30   /* Key encrypted with RSA-OAEP-2048 */\n#define IMAGE_TLV_ENC_KW            0x31   /* Key encrypted with AES-KW-128 or\n                                              256 */\n#define IMAGE_TLV_ENC_EC256         0x32   /* Key encrypted with ECIES-P256 */\n#define IMAGE_TLV_ENC_X25519        0x33   /* Key encrypted with ECIES-X25519 */\n#define IMAGE_TLV_DEPENDENCY        0x40   /* Image depends on other image */\n#define IMAGE_TLV_SEC_CNT           0x50   /* security counter */\n</code></pre> <p>Optional type-length-value records (TLVs) containing image metadata are placed after the end of the image.</p> <p>The <code>ih_protect_tlv_size</code> field indicates the length of the protected TLV area. If protected TLVs are present then a TLV info header with magic equal to <code>IMAGE_TLV_PROT_INFO_MAGIC</code> must be present and the protected TLVs (plus the info header itself) have to be included in the hash calculation. Otherwise the hash is only calculated over the image header and the image itself. In this case the value of the <code>ih_protect_tlv_size</code> field is 0.</p> <p>The <code>ih_hdr_size</code> field indicates the length of the header, and therefore the offset of the image itself.  This field provides for backwards compatibility in case of changes to the format of the image header.</p>"},{"location":"bootloader/docs/design/#flash-map","title":"Flash map","text":"<p>A device's flash is partitioned according to its flash map.  At a high level, the flash map maps numeric IDs to flash areas.  A flash area is a region of disk with the following properties: 1. An area can be fully erased without affecting any other areas. 2. A write to one area does not restrict writes to other areas.</p> <p>The bootloader uses the following flash area IDs: <pre><code>/* Independent from multiple image boot */\n#define FLASH_AREA_BOOTLOADER         0\n#define FLASH_AREA_IMAGE_SCRATCH      3\n</code></pre> <pre><code>/* If the bootloader is working with the first image */\n#define FLASH_AREA_IMAGE_PRIMARY      1\n#define FLASH_AREA_IMAGE_SECONDARY    2\n</code></pre> <pre><code>/* If the bootloader is working with the second image */\n#define FLASH_AREA_IMAGE_PRIMARY      5\n#define FLASH_AREA_IMAGE_SECONDARY    6\n</code></pre></p> <p>The bootloader area contains the bootloader image itself. The other areas are described in subsequent sections. The flash could contain multiple executable images therefore the flash area IDs of primary and secondary areas are mapped based on the number of the active image (on which the bootloader is currently working).</p>"},{"location":"bootloader/docs/design/#image-slots","title":"Image slots","text":"<p>A portion of the flash memory can be partitioned into multiple image areas, each contains two image slots: a primary slot and a secondary slot. Normally, the bootloader will only run an image from the primary slot, so images must be built such that they can run from that fixed location in flash (the exception to this is the direct-xip and the ram-load upgrade mode). If the bootloader needs to run the image resident in the secondary slot, it must copy its contents into the primary slot before doing so, either by swapping the two images or by overwriting the contents of the primary slot. The bootloader supports either swap- or overwrite-based image upgrades, but must be configured at build time to choose one of these two strategies.</p>"},{"location":"bootloader/docs/design/#swap-using-scratch","title":"Swap using scratch","text":"<p>When swap-using-scratch algorithm is used, in addition to the slots of image areas, the bootloader requires a scratch area to allow for reliable image swapping. The scratch area must have a size that is enough to store at least the largest sector that is going to be swapped. Many devices have small equally sized flash sectors, eg 4K, while others have variable sized sectors where the largest sectors might be 128K or 256K, so the scratch must be big enough to store that. The scratch is only ever used when swapping firmware, which means only when doing an upgrade. Given that, the main reason for using a larger size for the scratch is that flash wear will be more evenly distributed, because a single sector would be written twice the number of times than using two sectors, for example. To evaluate the ideal size of the scratch for your use case the following parameters are relevant:</p> <ul> <li>the ratio of image size / scratch size</li> <li>the number of erase cycles supported by the flash hardware</li> </ul> <p>The image size is used (instead of slot size) because only the slot's sectors that are actually used for storing the image are copied. The image/scratch ratio is the number of times the scratch will be erased on every upgrade. The number of erase cycles divided by the image/scratch ratio will give you the number of times an upgrade can be performed before the device goes out of spec.</p> <pre><code>num_upgrades = number_of_erase_cycles / (image_size / scratch_size)\n</code></pre> <p>Let's assume, for example, a device with 10000 erase cycles, an image size of 150K and a scratch of 4K (usual minimum size of 4K sector devices). This would result in a total of:</p> <p><code>10000 / (150 / 4) ~ 267</code></p> <p>Increasing the scratch to 16K would give us:</p> <p><code>10000 / (150 / 16) ~ 1067</code></p> <p>There is no best ratio, as the right size is use-case dependent. Factors to consider include the number of times a device will be upgraded both in the field and during development, as well as any desired safety margin on the manufacturer's specified number of erase cycles. In general, using a ratio that allows hundreds to thousands of field upgrades in production is recommended.</p> <p>swap-using scratch algorithm assumes that the primary and the secondary image slot areas sizes are equal. The maximum image size available for the application will be: <pre><code>maximum-image-size = image-slot-size - image-trailer-size\n</code></pre></p> <p>Where:   <code>image-slot-size</code> is the size of the image slot.   <code>image-trailer-size</code> is the size of the image trailer.</p>"},{"location":"bootloader/docs/design/#swap-without-using-scratch","title":"Swap without using scratch","text":"<p>This algorithm is an alternative to the swap-using-scratch algorithm. It uses an additional sector in the primary slot to make swap possible. The algorithm works as follows:</p> <ol> <li>Moves all sectors of the primary slot up by one sector.     Beginning from N=0:</li> <li>Copies the N-th sector from the secondary slot to the N-th sector of the   primary slot.</li> <li>Copies the (N+1)-th sector from the primary slot to the N-th sector of the   secondary slot.</li> <li>Repeats steps 2. and 3. until all the slots' sectors are swapped.</li> </ol> <p>This algorithm is designed so that the higher sector of the primary slot is used only for allowing sectors to move up. Therefore the most memory-size-effective slot layout is when the primary slot is exactly one sector larger than the secondary slot, although same-sized slots are allowed as well. The algorithm is limited to support sectors of the same sector layout. All slot's sectors should be of the same size.</p> <p>When using this algorithm the maximum image size available for the application will be: <pre><code>maximum-image-size = (N-1) * slot-sector-size - image-trailer-sectors-size\n</code></pre></p> <p>Where:   <code>N</code> is the number of sectors in the primary slot.   <code>image-trailer-sectors-size</code> is the size of the image trailer rounded up to   the total size of sectors its occupied. For instance if the image-trailer-size   is equal to 1056 B and the sector size is equal to 1024 B, then   <code>image-trailer-sectors-size</code> will be equal to 2048 B.</p> <p>The algorithm does two erase cycles on the primary slot and one on the secondary slot during each swap. Assuming that receiving a new image by the DFU application requires 1 erase cycle on the secondary slot, this should result in leveling the flash wear between the slots.</p> <p>The algorithm is enabled using the <code>MCUBOOT_SWAP_USING_MOVE</code> option.</p>"},{"location":"bootloader/docs/design/#equal-slots-direct-xip","title":"Equal slots (direct-xip)","text":"<p>When the direct-xip mode is enabled the active image flag is \"moved\" between the slots during image upgrade and in contrast to the above, the bootloader can run an image directly from either the primary or the secondary slot (without having to move/copy it into the primary slot). Therefore the image update client, which downloads the new images must be aware, which slot contains the active image and which acts as a staging area and it is responsible for loading the proper images into the proper slot. All this requires that the images be built to be executed from the corresponding slot. At boot time the bootloader first looks for images in the slots and then inspects the version numbers in the image headers. It selects the newest image (with the highest version number) and then checks its validity (integrity check, signature verification etc.). If the image is invalid MCUboot erases its memory slot and starts to validate the other image. After a successful validation of the selected image the bootloader chain-loads it.</p> <p>An additional \"revert\" mechanism is also supported. For more information, please read the corresponding section. Handling the primary and secondary slots as equals has its drawbacks. Since the images are not moved between the slots, the on-the-fly image encryption/decryption can't be supported (it only applies to storing the image in an external flash on the device, the transport of encrypted image data is still feasible).</p> <p>The overwrite and the direct-xip upgrade strategies are substantially simpler to implement than the image swapping strategy, especially since the bootloader must work properly even when it is reset during the middle of an image swap. For this reason, the rest of the document describes its behavior when configured to swap images during an upgrade.</p>"},{"location":"bootloader/docs/design/#ram-loading","title":"RAM loading","text":"<p>In ram-load mode the slots are equal. Like the direct-xip mode, this mode also selects the newest image by reading the image version numbers in the image headers. But instead of executing it in place, the newest image is copied to the RAM for execution. The load address, the location in RAM where the image is copied to, is stored in the image header. The ram-load upgrade mode can be useful when there is no internal flash in the SoC, but there is a big enough internal RAM to hold the images. Usually in this case the images are stored in an external storage device. Execution from external storage has some drawbacks (lower execution speed, image is exposed to attacks) therefore the image is always copied to the internal RAM before the authentication and execution. Ram-load mode requires the image to be built to be executed from the RAM address range instead of the storage device address range. If ram-load is enabled then platform must define the following parameters:</p> <pre><code>#define IMAGE_EXECUTABLE_RAM_START    &lt;area_base_addr&gt;\n#define IMAGE_EXECUTABLE_RAM_SIZE     &lt;area_size_in_bytes&gt;\n</code></pre> <p>For multiple image load if multiple ram regions are used platform must define the <code>MULTIPLE_EXECUTABLE_RAM_REGIONS</code> flag instead and implement the following function:</p> <pre><code>int boot_get_image_exec_ram_info(uint32_t image_id,\n                                 uint32_t *exec_ram_start,\n                                 uint32_t *exec_ram_size)\n</code></pre> <p>When ram-load is enabled, the <code>--load-addr &lt;addr&gt;</code> option of the <code>imgtool</code> script must also be used when signing the images. This option set the <code>RAM_LOAD</code> flag in the image header which indicates that the image should be loaded to the RAM and also set the load address in the image header.</p> <p>When the encryption option is enabled (<code>MCUBOOT_ENC_IMAGES</code>) along with ram-load the image is checked for encryption. If the image is not encrypted, RAM loading happens as described above. If the image is encrypted, it is copied in RAM at the provided address and then decrypted. Finally, the decrypted image is authenticated in RAM and executed.</p>"},{"location":"bootloader/docs/design/#boot-swap-types","title":"Boot swap types","text":"<p>When the device first boots under normal circumstances, there is an up-to-date firmware image in each primary slot, which MCUboot can validate and then chain-load. In this case, no image swaps are necessary. During device upgrades, however, new candidate image(s) is present in the secondary slot(s), which MCUboot must swap into the primary slot(s) before booting as discussed above.</p> <p>Upgrading an old image with a new one by swapping can be a two-step process. In this process, MCUboot performs a \"test\" swap of image data in flash and boots the new image or it will be executed during operation. The new image can then update the contents of flash at runtime to mark itself \"OK\", and MCUboot will then still choose to run it during the next boot. When this happens, the swap is made \"permanent\". If this doesn't happen, MCUboot will perform a \"revert\" swap during the next boot by swapping the image(s) back into its original location(s) , and attempting to boot the old image(s).</p> <p>Depending on the use case, the first swap can also be made permanent directly. In this case, MCUboot will never attempt to revert the images on the next reset.</p> <p>Test swaps are supported to provide a rollback mechanism to prevent devices from becoming \"bricked\" by bad firmware.  If the device crashes immediately upon booting a new (bad) image, MCUboot will revert to the old (working) image at the next device reset, rather than booting the bad image again. This allows device firmware to make test swaps permanent only after performing a self-test routine.</p> <p>On startup, MCUboot inspects the contents of flash to decide for each images which of these \"swap types\" to perform; this decision determines how it proceeds.</p> <p>The possible swap types, and their meanings, are:</p> <ul> <li> <p><code>BOOT_SWAP_TYPE_NONE</code>: The \"usual\" or \"no upgrade\" case; attempt to boot the   contents of the primary slot.</p> </li> <li> <p><code>BOOT_SWAP_TYPE_TEST</code>: Boot the contents of the secondary slot by swapping   images.  Unless the swap is made permanent, revert back on the next boot.</p> </li> <li> <p><code>BOOT_SWAP_TYPE_PERM</code>: Permanently swap images, and boot the upgraded image   firmware.</p> </li> <li> <p><code>BOOT_SWAP_TYPE_REVERT</code>: A previous test swap was not made permanent;   swap back to the old image whose data are now in the secondary slot.  If the   old image marks itself \"OK\" when it boots, the next boot will have swap type   <code>BOOT_SWAP_TYPE_NONE</code>.</p> </li> <li> <p><code>BOOT_SWAP_TYPE_FAIL</code>: Swap failed because image to be run is not valid.</p> </li> <li> <p><code>BOOT_SWAP_TYPE_PANIC</code>: Swapping encountered an unrecoverable error.</p> </li> </ul> <p>The \"swap type\" is a high-level representation of the outcome of the boot. Subsequent sections describe how MCUboot determines the swap type from the bit-level contents of flash.</p>"},{"location":"bootloader/docs/design/#revert-mechanism-in-direct-xip-mode","title":"Revert mechanism in direct-xip mode","text":"<p>The direct-xip mode also supports a \"revert\" mechanism which is the equivalent of the swap mode's \"revert\" swap. When the direct-xip mode is selected it can be enabled with the MCUBOOT_DIRECT_XIP_REVERT config option and an image trailer must also be added to the signed images (the \"--pad\" option of the <code>imgtool</code> script must be used). For more information on this please read the Image Trailer section and the imgtool documentation. Making the images permanent (marking them as confirmed in advance) is also supported just like in swap mode. The individual steps of the direct-xip mode's \"revert\" mechanism are the following:</p> <ol> <li>Select the slot which holds the newest potential image.</li> <li>Was the image previously selected to run (during a previous boot)?<ul> <li>Yes: Did the image mark itself \"OK\" (was the self-test successful)?<ul> <li>Yes.<ul> <li>Proceed to step 3.</li> </ul> </li> <li>No.<ul> <li>Erase the image from the slot to prevent it from being selected   again during the next boot.</li> <li>Return to step 1 (the bootloader will attempt to select and   possibly boot the previous image if there is one).</li> </ul> </li> </ul> </li> <li>No.<ul> <li>Mark the image as \"selected\" (set the copy_done flag in the trailer).</li> <li>Proceed to step 3.</li> </ul> </li> </ul> </li> <li>Proceed to image validation ...</li> </ol>"},{"location":"bootloader/docs/design/#image-trailer","title":"Image trailer","text":"<p>For the bootloader to be able to determine the current state and what actions should be taken during the current boot operation, it uses metadata stored in the image flash areas. While swapping, some of this metadata is temporarily copied into and out of the scratch area.</p> <p>This metadata is located at the end of the image flash areas, and is called an image trailer. An image trailer has the following structure:</p> <pre><code>     0                   1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    ~                                                               ~\n    ~    Swap status (BOOT_MAX_IMG_SECTORS * min-write-size * 3)    ~\n    ~                                                               ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                 Encryption key 0 (16 octets) [*]              |\n    |                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    0xff padding as needed                     |\n    |  (BOOT_MAX_ALIGN minus 16 octets from Encryption key 0) [*]   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                 Encryption key 1 (16 octets) [*]              |\n    |                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    0xff padding as needed                     |\n    |  (BOOT_MAX_ALIGN minus 16 octets from Encryption key 1) [*]   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                      Swap size (4 octets)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    0xff padding as needed                     |\n    |        (BOOT_MAX_ALIGN minus 4 octets from Swap size)         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |   Swap info   |  0xff padding (BOOT_MAX_ALIGN minus 1 octet)  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |   Copy done   |  0xff padding (BOOT_MAX_ALIGN minus 1 octet)  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |   Image OK    |  0xff padding (BOOT_MAX_ALIGN minus 1 octet)  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    0xff padding as needed                     |\n    |         (BOOT_MAX_ALIGN minus 16 octets from MAGIC)           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                       MAGIC (16 octets)                       |\n    |                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>[*]: Only present if the encryption option is enabled (<code>MCUBOOT_ENC_IMAGES</code>).</p> <p>The offset immediately following such a record represents the start of the next flash area.</p> <p>Note</p> <p>\"min-write-size\" is a property of the flash hardware.  If the hardware allows individual bytes to be written at arbitrary addresses, then min-write-size is 1.  If the hardware only allows writes at even addresses, then min-write-size is 2, and so on.</p> <p>An image trailer contains the following fields:</p> <ol> <li> <p>Swap status: A series of records which records the progress of an image    swap.  To swap entire images, data are swapped between the two image areas    one or more sectors at a time, like this:</p> </li> <li> <p>sector data in the primary slot is copied into scratch, then erased</p> </li> <li>sector data in the secondary slot is copied into the primary slot,      then erased</li> <li>sector data in scratch is copied into the secondary slot</li> </ol> <p>As it swaps images, the bootloader updates the swap status field in a way that allows it to compute how far this swap operation has progressed for each sector.  The swap status field can thus used to resume a swap operation if the bootloader is halted while a swap operation is ongoing and later reset. The <code>BOOT_MAX_IMG_SECTORS</code> value is the configurable maximum number of sectors MCUboot supports for each image; its value defaults to 128, but allows for either decreasing this size, to limit RAM usage, or to increase it in devices that have massive amounts of Flash or very small sized sectors and thus require a bigger configuration to allow for the handling of all slot's sectors. The factor of min-write-size is due to the behavior of flash hardware. The factor of 3 is explained below.</p> <ol> <li> <p>Encryption keys: key-encrypting keys (KEKs).  These keys are needed for    image encryption and decryption.  See the    encrypted images document for more information.</p> </li> <li> <p>Swap size: When beginning a new swap operation, the total size that needs    to be swapped (based on the slot with largest image + TLVs) is written to    this location for easier recovery in case of a reset while performing the    swap.</p> </li> <li> <p>Swap info: A single byte which encodes the following information:</p> <ul> <li>Swap type: Stored in bits 0-3. Indicating the type of swap operation in progress. When MCUboot resumes an interrupted swap, it uses this field to determine the type of operation to perform. This field contains one of the following values in the table below.</li> <li>Image number: Stored in bits 4-7. It has always 0 value at single image boot. In case of multi image boot it indicates, which image was swapped when interrupt happened. The same scratch area is used during in case of all image swap operation. Therefore this field is used to determine which image the trailer belongs to if boot status is found on scratch area when the swap operation is resumed.</li> </ul> </li> </ol> Name Value <code>BOOT_SWAP_TYPE_TEST</code> 2 <code>BOOT_SWAP_TYPE_PERM</code> 3 <code>BOOT_SWAP_TYPE_REVERT</code> 4 <ol> <li> <p>Copy done: A single byte indicating whether the image in this slot is    complete (0x01=done; 0xff=not done).</p> </li> <li> <p>Image OK: A single byte indicating whether the image in this slot has been    confirmed as good by the user (0x01=confirmed; 0xff=not confirmed).</p> </li> <li> <p>MAGIC: A 16-byte field identifying the image trailer layout. It may assume    distinct values depending on the maximum supported write alignment    (<code>BOOT_MAX_ALIGN</code>) of the image, as defined by the following construct:</p> </li> </ol> <p><pre><code>union boot_img_magic_t\n{\n    struct {\n        uint16_t align;\n        uint8_t magic[14];\n    };\n    uint8_t val[16];\n};\n</code></pre>   If <code>BOOT_MAX_ALIGN</code> is 8 bytes, then MAGIC contains the following 16 bytes:</p> <pre><code>const union boot_img_magic_t boot_img_magic = {\n    .val = {\n        0x77, 0xc2, 0x95, 0xf3,\n        0x60, 0xd2, 0xef, 0x7f,\n        0x35, 0x52, 0x50, 0x0f,\n        0x2c, 0xb6, 0x79, 0x80\n    }\n};\n</code></pre> <p>In case <code>BOOT_MAX_ALIGN</code> is defined to any value different than 8, then the maximum   supported write alignment value is encoded in the MAGIC field, followed by a fixed   14-byte pattern:</p> <pre><code>const union boot_img_magic_t boot_img_magic = {\n    .align = BOOT_MAX_ALIGN,\n    .magic = {\n        0x2d, 0xe1,\n        0x5d, 0x29, 0x41, 0x0b,\n        0x8d, 0x77, 0x67, 0x9c,\n        0x11, 0x0f, 0x1f, 0x8a\n    }\n};\n</code></pre> <p>Note Be aware that the image trailers make the ending area of the image slot unavailable for carrying the image data. In particular, the swap status size could be huge. For example, for 128 slot sectors with a 4-byte alignment, it would become 1536 B.</p>"},{"location":"bootloader/docs/design/#image-trailers","title":"Image trailers","text":"<p>At startup, the bootloader determines the boot swap type by inspecting the image trailers.  When using the term \"image trailers\" what is meant is the aggregate information provided by both image slot's trailers.</p>"},{"location":"bootloader/docs/design/#new-swaps-non-resumes","title":"New swaps (non-resumes)","text":"<p>For new swaps, MCUboot must inspect a collection of fields to determine which swap operation to perform.</p> <p>The image trailers records are structured around the limitations imposed by flash hardware. As a consequence, they do not have a very intuitive design, and it is difficult to get a sense of the state of the device just by looking at the image trailers.  It is better to map all the possible trailer states to the swap types described above via a set of tables.  These tables are reproduced below.</p> <p>Note</p> <p>An important caveat about the tables described below is that they must be evaluated in the order presented here. Lower state numbers must have a higher priority when testing the image trailers.</p> <pre><code>    State I\n                     | primary slot | secondary slot |\n    -----------------+--------------+----------------|\n               magic | Any          | Good           |\n            image-ok | Any          | Unset          |\n           copy-done | Any          | Any            |\n    -----------------+--------------+----------------'\n     result: BOOT_SWAP_TYPE_TEST                     |\n    -------------------------------------------------'\n\n\n    State II\n                     | primary slot | secondary slot |\n    -----------------+--------------+----------------|\n               magic | Any          | Good           |\n            image-ok | Any          | 0x01           |\n           copy-done | Any          | Any            |\n    -----------------+--------------+----------------'\n     result: BOOT_SWAP_TYPE_PERM                     |\n    -------------------------------------------------'\n\n\n    State III\n                     | primary slot | secondary slot |\n    -----------------+--------------+----------------|\n               magic | Good         | Unset          |\n            image-ok | 0xff         | Any            |\n           copy-done | 0x01         | Any            |\n    -----------------+--------------+----------------'\n     result: BOOT_SWAP_TYPE_REVERT                   |\n    -------------------------------------------------'\n</code></pre> <p>Any of the above three states results in MCUboot attempting to swap images.</p> <p>Otherwise, MCUboot does not attempt to swap images, resulting in one of the other three swap types, as illustrated by State IV.</p> <pre><code>    State IV\n                     | primary slot | secondary slot |\n    -----------------+--------------+----------------|\n               magic | Any          | Any            |\n            image-ok | Any          | Any            |\n           copy-done | Any          | Any            |\n    -----------------+--------------+----------------'\n     result: BOOT_SWAP_TYPE_NONE,                    |\n             BOOT_SWAP_TYPE_FAIL, or                 |\n             BOOT_SWAP_TYPE_PANIC                    |\n    -------------------------------------------------'\n</code></pre> <p>In State IV, when no errors occur, MCUboot will attempt to boot the contents of the primary slot directly, and the result is <code>BOOT_SWAP_TYPE_NONE</code>. If the image in the primary slot is not valid, the result is <code>BOOT_SWAP_TYPE_FAIL</code>. If a fatal error occurs during boot, the result is <code>BOOT_SWAP_TYPE_PANIC</code>. If the result is either <code>BOOT_SWAP_TYPE_FAIL</code> or <code>BOOT_SWAP_TYPE_PANIC</code>, MCUboot hangs rather than booting an invalid or compromised image.</p> <p>Note</p> <p>An important caveat to the above is the result when a swap is requested and the image in the secondary slot fails to validate, due to a hashing or signing error. This state behaves as State IV with the extra action of marking the image in the primary slot as \"OK\", to prevent further attempts to swap.</p>"},{"location":"bootloader/docs/design/#resumed-swaps","title":"Resumed swaps","text":"<p>If MCUboot determines that it is resuming an interrupted swap (i.e., a reset occurred mid-swap), it fully determines the operation to resume by reading the <code>swap info</code> field from the active trailer and extracting the swap type from bits 0-3. The set of tables in the previous section are not necessary in the resume case.</p>"},{"location":"bootloader/docs/design/#high-level-operation","title":"High-level operation","text":"<p>With the terms defined, we can now explore the bootloader's operation.  First, a high-level overview of the boot process is presented.  Then, the following sections describe each step of the process in more detail.</p> <p>Procedure:</p> <ol> <li> <p>Inspect swap status region; is an interrupted swap being resumed?</p> <ul> <li>Yes: Complete the partial swap operation; skip to step 3.</li> <li>No: Proceed to step 2.</li> </ul> </li> <li> <p>Inspect image trailers; is a swap requested?</p> <ul> <li> <p>Yes:</p> <ol> <li>Is the requested image valid (integrity and security check)?<ul> <li>Yes.     a. Perform swap operation.     b. Persist completion of swap procedure to image trailers.     c. Proceed to step 3.</li> <li>No.     a. Erase invalid image.     b. Persist failure of swap procedure to image trailers.     c. Proceed to step 3.</li> </ul> </li> </ol> </li> <li> <p>No: Proceed to step 3.</p> </li> </ul> </li> <li> <p>Boot into image in primary slot.</p> </li> </ol>"},{"location":"bootloader/docs/design/#multiple-image-boot","title":"Multiple image boot","text":"<p>When the flash contains multiple executable images the bootloader's operation is a bit more complex but similar to the previously described procedure with one image. Every image can be updated independently therefore the flash is partitioned further to arrange two slots for each image. <pre><code>+--------------------+\n| MCUboot            |\n+--------------------+\n        ~~~~~            &lt;- memory might be not contiguous\n+--------------------+\n| Image 0            |\n| primary   slot     |\n+--------------------+\n| Image 0            |\n| secondary slot     |\n+--------------------+\n        ~~~~~            &lt;- memory might be not contiguous\n+--------------------+\n| Image N            |\n| primary   slot     |\n+--------------------+\n| Image N            |\n| secondary slot     |\n+--------------------+\n| Scratch            |\n+--------------------+\n</code></pre> MCUboot is also capable of handling dependencies between images. For example if an image needs to be reverted it might be necessary to revert another one too (e.g. due to API incompatibilities) or simply to prevent from being updated because of an unsatisfied dependency. Therefore all aborted swaps have to be completed and all the swap types have to be determined for each image before the dependency checks. Dependency handling is described in more detail in a following section. The multiple image boot procedure is organized in loops which iterate over all the firmware images. The high-level overview of the boot process is presented below.</p> <ul> <li> <p>Loop 1. Iterate over all images</p> <ol> <li> <p>Inspect swap status region of current image; is an interrupted swap being    resumed?</p> <ul> <li>Yes:<ul> <li>Review the validity of previously determined swap types   of other images.</li> <li>Complete the partial swap operation.</li> <li>Mark the swap type as <code>None</code>.</li> <li>Skip to next image.</li> </ul> </li> <li>No: Proceed to step 2.</li> </ul> </li> <li> <p>Inspect image trailers in the primary and secondary slot; is an image    swap requested?</p> <ul> <li>Yes: Review the validity of previously determined swap types of other        images. Is the requested image valid (integrity and security        check)?<ul> <li>Yes:<ul> <li>Set the previously determined swap type for the current image.</li> <li>Skip to next image.</li> </ul> </li> <li>No:<ul> <li>Erase invalid image.</li> <li>Persist failure of swap procedure to image trailers.</li> <li>Mark the swap type as <code>Fail</code>.</li> <li>Skip to next image.</li> </ul> </li> </ul> </li> <li>No:<ul> <li>Mark the swap type as <code>None</code>.</li> <li>Skip to next image.</li> </ul> </li> </ul> </li> </ol> </li> <li> <p>Loop 2. Iterate over all images</p> <ol> <li>Does the current image depend on other image(s)?<ul> <li>Yes: Are all the image dependencies satisfied?<ul> <li>Yes: Skip to next image.</li> <li>No:<ul> <li>Modify swap type depending on what the previous type was.</li> <li>Restart dependency check from the first image.</li> </ul> </li> </ul> </li> <li>No: Skip to next image.</li> </ul> </li> </ol> </li> <li> <p>Loop 3. Iterate over all images</p> <ol> <li>Is an image swap requested?<ul> <li>Yes:<ul> <li>Perform image update operation.</li> <li>Persist completion of swap procedure to image trailers.</li> <li>Skip to next image.</li> </ul> </li> <li>No: Skip to next image.</li> </ul> </li> </ol> </li> <li> <p>Loop 4. Iterate over all images</p> <ol> <li>Validate image in the primary slot (integrity and security check) or    at least do a basic sanity check to avoid booting into an empty flash    area.</li> </ol> </li> <li> <p>Boot into image in the primary slot of the 0th image position\\   (other image in the boot chain is started by another image).</p> </li> </ul>"},{"location":"bootloader/docs/design/#multiple-image-boot-for-ram-loading-and-direct-xip","title":"Multiple image boot for RAM loading and direct-xip","text":"<p>The operation of the bootloader is different when the ram-load or the direct-xip strategy is chosen. The flash map is very similar to the swap strategy but there is no need for Scratch area.</p> <ul> <li> <p>Loop 1. Until all images are loaded and all dependencies are satisfied</p> <ol> <li> <p>Subloop 1. Iterate over all images</p> <ul> <li>Does any of the slots contain an image?<ul> <li>Yes:<ul> <li>Choose the newer image.</li> <li>Copy it to RAM in case of ram-load strategy.</li> <li>Validate the image (integrity and security check).</li> <li>If validation fails delete the image from flash and try the other   slot. (Image must be deleted from RAM too in case of ram-load   strategy.)</li> </ul> </li> <li>No: Return with failure.</li> </ul> </li> </ul> </li> <li> <p>Subloop 2. Iterate over all images</p> <ul> <li>Does the current image depend on other image(s)?<ul> <li>Yes: Are all the image dependencies satisfied?<ul> <li>Yes: Skip to next image.</li> <li>No:<ul> <li>Delete the image from RAM in case of ram-load strategy, but   do not delete it from flash.</li> <li>Try to load the image from the other slot.</li> <li>Restart dependency check from the first image.</li> </ul> </li> </ul> </li> <li>No: Skip to next image.</li> </ul> </li> </ul> </li> </ol> </li> <li> <p>Loop 2. Iterate over all images</p> <ul> <li>Increase the security counter if needed.</li> <li>Do the measured boot and the data sharing if needed.</li> </ul> </li> <li> <p>Boot the loaded slot of image 0.</p> </li> </ul>"},{"location":"bootloader/docs/design/#image-swapping","title":"Image swapping","text":"<p>The bootloader swaps the contents of the two image slots for two reasons:</p> <ul> <li>User has issued a \"set pending\" operation; the image in the secondary slot     should be run once (state I) or repeatedly (state II), depending on     whether a permanent swap was specified.</li> <li>Test image rebooted without being confirmed; the bootloader should     revert to the original image currently in the secondary slot (state III).</li> </ul> <p>If the image trailers indicates that the image in the secondary slot should be run, the bootloader needs to copy it to the primary slot.  The image currently in the primary slot also needs to be retained in flash so that it can be used later.  Furthermore, both images need to be recoverable if the bootloader resets in the middle of the swap operation.  The two images are swapped according to the following procedure:</p> <ol> <li>Determine if both slots are compatible enough to have their images swapped.    To be compatible, both have to have only sectors that can fit into the    scratch area and if one of them has larger sectors than the other, it must    be able to entirely fit some rounded number of sectors from the other slot.    In the next steps we'll use the terminology \"region\" for the total amount of    data copied/erased because this can be any amount of sectors depending on    how many the scratch is able to fit for some swap operation.</li> <li>Iterate the list of region indices in descending order (i.e., starting    with the greatest index); only regions that are predetermined to be part of    the image are copied; current element = \"index\".<ul> <li>a. Erase scratch area.</li> <li>b. Copy secondary_slot[index] to scratch area.<ul> <li>If this is the last region in the slot, scratch area has a temporary   status area initialized to store the initial state, because the   primary slot's last region will have to be erased. In this case,   only the data that was calculated to amount to the image is copied.</li> <li>Else if this is the first swapped region but not the last region in   the slot, initialize the status area in primary slot and copy the   full region contents.</li> <li>Else, copy entire region contents.</li> </ul> </li> <li>c. Write updated swap status (i).</li> <li>d. Erase secondary_slot[index]</li> <li>e. Copy primary_slot[index] to secondary_slot[index] according to amount      previosly copied at step b.<ul> <li>If this is not the last region in the slot, erase the trailer in the   secondary slot, to always use the one in the primary slot.</li> </ul> </li> <li>f. Write updated swap status (ii).</li> <li>g. Erase primary_slot[index].</li> <li>h. Copy scratch area to primary_slot[index] according to amount      previously copied at step b.<ul> <li>If this is the last region in the slot, the status is read from   scratch (where it was stored temporarily) and written anew in the   primary slot.</li> </ul> </li> <li>i. Write updated swap status (iii).</li> </ul> </li> <li>Persist completion of swap procedure to the primary slot image trailer.</li> </ol> <p>The additional caveats in step 2f are necessary so that the secondary slot image trailer can be written by the user at a later time.  With the image trailer unwritten, the user can test the image in the secondary slot (i.e., transition to state I).</p> <p>Note</p> <p>If the region being copied contains the last sector, then swap status is temporarily maintained on scratch for the duration of this operation, always using the primary slot's area otherwise.</p> <p>Note</p> <p>The bootloader tries to copy only used sectors (based on largest image installed on any of the slots), minimizing the amount of sectors copied and reducing the amount of time required for a swap operation.</p> <p>The particulars of step 3 vary depending on whether an image is being tested, permanently used, reverted or a validation failure of the secondary slot happened when a swap was requested:</p> <pre><code>* test:\n    o Write primary_slot.copy_done = 1\n    (swap caused the following values to be written:\n        primary_slot.magic = BOOT_MAGIC\n        secondary_slot.magic = UNSET\n        primary_slot.image_ok = Unset)\n\n* permanent:\n    o Write primary_slot.copy_done = 1\n    (swap caused the following values to be written:\n        primary_slot.magic = BOOT_MAGIC\n        secondary_slot.magic = UNSET\n        primary_slot.image_ok = 0x01)\n\n* revert:\n    o Write primary_slot.copy_done = 1\n    o Write primary_slot.image_ok = 1\n    (swap caused the following values to be written:\n        primary_slot.magic = BOOT_MAGIC)\n\n* failure to validate the secondary slot:\n    o Write primary_slot.image_ok = 1\n</code></pre> <p>After completing the operations as described above the image in the primary slot should be booted.</p>"},{"location":"bootloader/docs/design/#swap-status","title":"Swap status","text":"<p>The swap status region allows the bootloader to recover in case it restarts in the middle of an image swap operation.  The swap status region consists of a series of single-byte records.  These records are written independently, and therefore must be padded according to the minimum write size imposed by the flash hardware.  In the below figure, a min-write-size of 1 is assumed for simplicity.  The structure of the swap status region is illustrated below.  In this figure, a min-write-size of 1 is assumed for simplicity.</p> <pre><code>     0                   1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec127,state 0 |sec127,state 1 |sec127,state 2 |sec126,state 0 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec126,state 1 |sec126,state 2 |sec125,state 0 |sec125,state 1 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec125,state 2 |                                               |\n    +-+-+-+-+-+-+-+-+                                               +\n    ~                                                               ~\n    ~               [Records for indices 124 through 1              ~\n    ~                                                               ~\n    ~               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    ~               |sec000,state 0 |sec000,state 1 |sec000,state 2 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>The above is probably not helpful at all; here is a description in English.</p> <p>Each image slot is partitioned into a sequence of flash sectors.  If we were to enumerate the sectors in a single slot, starting at 0, we would have a list of sector indices.  Since there are two image slots, each sector index would correspond to a pair of sectors.  For example, sector index 0 corresponds to the first sector in the primary slot and the first sector in the secondary slot. Finally, reverse the list of indices such that the list starts with index <code>BOOT_MAX_IMG_SECTORS - 1</code> and ends with 0.  The swap status region is a representation of this reversed list.</p> <p>During a swap operation, each sector index transitions through four separate states: <pre><code>0. primary slot: image 0,   secondary slot: image 1,   scratch: N/A\n1. primary slot: image 0,   secondary slot: N/A,       scratch: image 1 (1-&gt;s, erase 1)\n2. primary slot: N/A,       secondary slot: image 0,   scratch: image 1 (0-&gt;1, erase 0)\n3. primary slot: image 1,   secondary slot: image 0,   scratch: N/A     (s-&gt;0)\n</code></pre></p> <p>Each time a sector index transitions to a new state, the bootloader writes a record to the swap status region.  Logically, the bootloader only needs one record per sector index to keep track of the current swap state.  However, due to limitations imposed by flash hardware, a record cannot be overwritten when an index's state changes.  To solve this problem, the bootloader uses three records per sector index rather than just one.</p> <p>Each sector-state pair is represented as a set of three records.  The record values map to the above four states as follows</p> <pre><code>            | rec0 | rec1 | rec2\n    --------+------+------+------\n    state 0 | 0xff | 0xff | 0xff\n    state 1 | 0x01 | 0xff | 0xff\n    state 2 | 0x01 | 0x02 | 0xff\n    state 3 | 0x01 | 0x02 | 0x03\n</code></pre> <p>The swap status region can accommodate <code>BOOT_MAX_IMG_SECTORS</code> sector indices. Hence, the size of the region, in bytes, is <code>BOOT_MAX_IMG_SECTORS * min-write-size * 3</code>. The only requirement for the index count is that it is great enough to account for a maximum-sized image (i.e., at least as great as the total sector count in an image slot).  If a device's image slots have been configured with <code>BOOT_MAX_IMG_SECTORS: 128</code> and use less than 128 sectors, the first record that gets written will be somewhere in the middle of the region. For example, if a slot uses 64 sectors, the first sector index that gets swapped is 63, which corresponds to the exact halfway point within the region.</p> <p>Note</p> <p>Since the scratch area only ever needs to record swapping of the last sector, it uses at most min-write-size * 3 bytes for its own status area.</p>"},{"location":"bootloader/docs/design/#reset-recovery","title":"Reset recovery","text":"<p>If the bootloader resets in the middle of a swap operation, the two images may be discontiguous in flash.  Bootutil recovers from this condition by using the image trailers to determine how the image parts are distributed in flash.</p> <p>The first step is determine where the relevant swap status region is located. Because this region is embedded within the image slots, its location in flash changes during a swap operation.  The below set of tables map image trailers contents to swap status location.  In these tables, the \"source\" field indicates where the swap status region is located. In case of multi image boot the images primary area and the single scratch area is always examined in pairs. If swap status found on scratch area then it might not belong to the current image. The swap_info field of swap status stores the corresponding image number. If it does not match then \"source: none\" is returned.</p> <pre><code>              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Good         | Any          |\n    copy-done | 0x01         | N/A          |\n    ----------+--------------+--------------'\n    source: none                            |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Good         | Any          |\n    copy-done | 0xff         | N/A          |\n    ----------+--------------+--------------'\n    source: primary slot                    |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Any          | Good         |\n    copy-done | Any          | N/A          |\n    ----------+--------------+--------------'\n    source: scratch                         |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Unset        | Any          |\n    copy-done | 0xff         | N/A          |\n    ----------+--------------+--------------|\n    source: primary slot                    |\n    ----------------------------------------+------------------------------+\n    This represents one of two cases:                                      |\n    o No swaps ever (no status to read, so no harm in checking).           |\n    o Mid-revert; status in the primary slot.                              |\n    For this reason we assume the primary slot as source, to trigger a     |\n    check of the status area and find out if there was swapping under way. |\n    -----------------------------------------------------------------------'\n</code></pre> <p>If the swap status region indicates that the images are not contiguous, MCUboot determines the type of swap operation that was interrupted by reading the <code>swap info</code> field in the active image trailer and extracting the swap type from bits 0-3 then resumes the operation. In other words, it applies the procedure defined in the previous section, moving image 1 into the primary slot and image 0 into the secondary slot. If the boot status indicates that an image part is present in the scratch area, this part is copied into the correct location by starting at step e or step h in the area-swap procedure, depending on whether the part belongs to image 0 or image 1.</p> <p>After the swap operation has been completed, the bootloader proceeds as though it had just been started.</p>"},{"location":"bootloader/docs/design/#integrity-check","title":"Integrity check","text":"<p>An image is checked for integrity immediately before it gets copied into the primary slot.  If the bootloader doesn't perform an image swap, then it can perform an optional integrity check of the image in the primary slot if <code>MCUBOOT_VALIDATE_PRIMARY_SLOT</code> is set, otherwise it doesn't perform an integrity check.</p> <p>During the integrity check, the bootloader verifies the following aspects of an image:</p> <ul> <li>32-bit magic number must be correct (<code>IMAGE_MAGIC</code>).</li> <li>Image must contain an <code>image_tlv_info</code> struct, identified by its magic     (<code>IMAGE_TLV_PROT_INFO_MAGIC</code> or <code>IMAGE_TLV_INFO_MAGIC</code>) exactly following     the firmware (<code>hdr_size</code> + <code>img_size</code>). If <code>IMAGE_TLV_PROT_INFO_MAGIC</code> is     found then after <code>ih_protect_tlv_size</code> bytes, another <code>image_tlv_info</code>     with magic equal to <code>IMAGE_TLV_INFO_MAGIC</code> must be present.</li> <li>Image must contain a SHA256 TLV.</li> <li>Calculated SHA256 must match SHA256 TLV contents.</li> <li>Image may contain a signature TLV.  If it does, it must also have a     KEYHASH TLV with the hash of the key that was used to sign. The list of     keys will then be iterated over looking for the matching key, which then     will then be used to verify the image contents.</li> </ul> <p>For low performance MCU's where the validation is a heavy process at boot (~1-2 seconds on a arm-cortex-M0), the <code>MCUBOOT_VALIDATE_PRIMARY_SLOT_ONCE</code> could be used. This option will cache the validation result as described above into the magic area of the primary slot. The next boot, the validation will be skipped if the previous validation was succesfull. This option is reducing the security level since if an attacker could modify the contents of the flash after a good image has been validated, the attacker could run his own image without running validation again. Enabling this option should be done with care.</p>"},{"location":"bootloader/docs/design/#security","title":"Security","text":"<p>As indicated above, the final step of the integrity check is signature verification.  The bootloader can have one or more public keys embedded in it at build time.  During signature verification, the bootloader verifies that an image was signed with a private key that corresponds to the embedded KEYHASH TLV.</p> <p>For information on embedding public keys in the bootloader, as well as producing signed images, see: signed_images.</p> <p>If you want to enable and use encrypted images, see: encrypted_images.</p> <p>Note</p> <p>Image encryption is not supported when the direct-xip upgrade strategy is selected.</p>"},{"location":"bootloader/docs/design/#using-hardware-keys-for-verification","title":"Using hardware keys for verification","text":"<p>By default, the whole public key is embedded in the bootloader code and its hash is added to the image manifest as a KEYHASH TLV entry. As an alternative the bootloader can be made independent of the keys by setting the <code>MCUBOOT_HW_KEY</code> option. In this case the hash of the public key must be provisioned to the target device and MCUboot must be able to retrieve the key-hash from there. For this reason the target must provide a definition for the <code>boot_retrieve_public_key_hash()</code> function which is declared in <code>boot/bootutil/include/bootutil/sign_key.h</code>. It is also required to use the <code>full</code> option for the <code>--public-key-format</code> imgtool argument in order to add the whole public key (PUBKEY TLV) to the image manifest instead of its hash (KEYHASH TLV). During boot the public key is validated before using it for signature verification, MCUboot calculates the hash of the public key from the TLV area and compares it with the key-hash that was retrieved from the device. This way MCUboot is independent from the public key(s). The key(s) can be provisioned any time and by different parties.</p>"},{"location":"bootloader/docs/design/#protected-tlvs","title":"Protected TLVs","text":"<p>If the TLV area contains protected TLV entries, by beginning with a <code>struct image_tlv_info</code> with a magic value of <code>IMAGE_TLV_PROT_INFO_MAGIC</code> then the data of those TLVs must also be integrity and authenticity protected. Beyond the full size of the protected TLVs being stored in the <code>image_tlv_info</code>, the size of the protected TLVs together with the size of the <code>image_tlv_info</code> struct itself are also saved in the <code>ih_protected_size</code> field inside the header.</p> <p>Whenever an image has protected TLVs the SHA256 has to be calculated over not just the image header and the image but also the TLV info header and the protected TLVs.</p> <pre><code>A +---------------------+\n  | Header              | &lt;- struct image_header\n  +---------------------+\n  | Payload             |\n  +---------------------+\n  | TLV area            |\n  | +-----------------+ |    struct image_tlv_info with\n  | | TLV area header | | &lt;- IMAGE_TLV_PROT_INFO_MAGIC (optional)\n  | +-----------------+ |\n  | | Protected TLVs  | | &lt;- Protected TLVs (struct image_tlv)\nB | +-----------------+ |\n  | | TLV area header | | &lt;- struct image_tlv_info with IMAGE_TLV_INFO_MAGIC\nC | +-----------------+ |\n  | | SHA256 hash     | | &lt;- hash from A - B (struct image_tlv)\nD | +-----------------+ |\n  | | Keyhash         | | &lt;- indicates which pub. key for sig (struct image_tlv)\n  | +-----------------+ |\n  | | Signature       | | &lt;- signature from C - D (struct image_tlv), only hash\n  | +-----------------+ |\n  +---------------------+\n</code></pre>"},{"location":"bootloader/docs/design/#dependency-check","title":"Dependency check","text":"<p>MCUboot can handle multiple firmware images. It is possible to update them independently but in many cases it can be desired to be able to describe dependencies between the images (e.g. to ensure API compliance and avoid interoperability issues).</p> <p>The dependencies between images can be described with additional TLV entries in the protected TLV area after the end of an image. There can be more than one dependency entry, but in practice if the platform only supports two individual images then there can be maximum one entry which reflects to the other image.</p> <p>At the phase of dependency check all aborted swaps are finalized if there were any. During the dependency check the bootloader verifies whether the image dependencies are all satisfied. If at least one of the dependencies of an image is not fulfilled then the swap type of that image has to be modified accordingly and the dependency check needs to be restarted. This way the number of unsatisfied dependencies will decrease or remain the same. There is always at least 1 valid configuration. In worst case, the system returns to the initial state after dependency check.</p> <p>For more information on adding dependency entries to an image, see: imgtool.</p>"},{"location":"bootloader/docs/design/#downgrade-prevention","title":"Downgrade prevention","text":"<p>Downgrade prevention is a feature which enforces that the new image must have a higher version/security counter number than the image it is replacing, thus preventing the malicious downgrading of the device to an older and possibly vulnerable version of its firmware.</p>"},{"location":"bootloader/docs/design/#software-based-downgrade-prevention","title":"Software-based downgrade prevention","text":"<p>During the software based downgrade prevention the image version numbers are compared. This feature is enabled with the <code>MCUBOOT_DOWNGRADE_PREVENTION</code> option. In this case downgrade prevention is only available when the overwrite-based image update strategy is used (i.e. <code>MCUBOOT_OVERWRITE_ONLY</code> is set).</p>"},{"location":"bootloader/docs/design/#hardware-based-downgrade-prevention","title":"Hardware-based downgrade prevention","text":"<p>Each signed image can contain a security counter in its protected TLV area, which can be added to the image using the <code>-s</code> option of the imgtool script. During the hardware based downgrade prevention (alias rollback protection) the new image's security counter will be compared with the currently active security counter value which must be stored in a non-volatile and trusted component of the device. It is beneficial to handle this counter independently from image version number:</p> <ul> <li>It does not need to increase with each software release,</li> <li>It makes it possible to do software downgrade to some extent: if the     security counter has the same value in the older image then it is accepted.</li> </ul> <p>It is an optional step of the image validation process and can be enabled with the <code>MCUBOOT_HW_ROLLBACK_PROT</code> config option. When enabled, the target must provide an implementation of the security counter interface defined in <code>boot/bootutil/include/security_cnt.h</code>.</p>"},{"location":"bootloader/docs/design/#measured-boot-and-data-sharing","title":"Measured boot and data sharing","text":"<p>MCUboot defines a mechanism for sharing boot status information (also known as measured boot) and an interface for sharing application specific information with the runtime software. If any of these are enabled the target must provide a shared data area between the bootloader and runtime firmware and define the following parameters:</p> <pre><code>#define MCUBOOT_SHARED_DATA_BASE    &lt;area_base_addr&gt;\n#define MCUBOOT_SHARED_DATA_SIZE    &lt;area_size_in_bytes&gt;\n</code></pre> <p>In the shared memory area all data entries are stored in a type-length-value (TLV) format. Before adding the first data entry, the whole area is overwritten with zeros and a TLV header is added at the beginning of the area during an initialization phase. This TLV header contains a <code>tlv_magic</code> field with a value of <code>SHARED_DATA_TLV_INFO_MAGIC</code> and a <code>tlv_tot_len</code> field which is indicating the total length of shared TLV area including this header. The header is followed by the the data TLV entries which are composed from a <code>shared_data_tlv_entry</code> header and the data itself. In the data header there is a <code>tlv_type</code> field which identifies the consumer of the entry (in the runtime software) and specifies the subtype of that data item. More information about the <code>tlv_type</code> field and data types can be found in the <code>boot/bootutil/include/bootutil/boot_status.h</code> file. The type is followed by a <code>tlv_len</code> field which indicates the size of the data entry in bytes, not including the entry header. After this header structure comes the actual data.</p> <pre><code>/** Shared data TLV header.  All fields in little endian. */\nstruct shared_data_tlv_header {\n    uint16_t tlv_magic;\n    uint16_t tlv_tot_len; /* size of whole TLV area (including this header) */\n};\n\n/** Shared data TLV entry header format. All fields in little endian. */\nstruct shared_data_tlv_entry {\n    uint16_t tlv_type;\n    uint16_t tlv_len; /* TLV data length (not including this header). */\n};\n</code></pre> <p>The measured boot can be enabled with the <code>MCUBOOT_MEASURED_BOOT</code> config option. When enabled, the <code>--boot_record</code> argument of the imgtool script must also be used during the image signing process to add a BOOT_RECORD TLV to the image manifest. This TLV contains the following attributes/measurements of the image in CBOR encoded format:</p> <ul> <li>Software type (role of the software component)</li> <li>Software version</li> <li>Signer ID (identifies the signing authority)</li> <li>Measurement value (hash of the image)</li> <li>Measurement type (algorithm used to calculate the measurement value)</li> </ul> <p>The <code>sw_type</code> string that is passed as the <code>--boot_record</code> option's parameter will be the value of the \"Software type\" attribute in the generated BOOT_RECORD TLV. The target must also define the <code>MAX_BOOT_RECORD_SZ</code> macro which indicates the maximum size of the CBOR encoded boot record in bytes. During boot, MCUboot will look for these TLVs (in case of multiple images) in the manifests of the active images (the latest and validated) and copy the CBOR encoded binary data to the shared data area. Preserving all these image attributes from the boot stage for use by later runtime services (such as an attestation service) is known as a measured boot.</p> <p>Setting the <code>MCUBOOT_DATA_SHARING</code> option enables the sharing of application specific data using the same shared data area as for the measured boot. For this, the target must provide a definition for the <code>boot_save_shared_data()</code> function which is declared in <code>boot/bootutil/include/bootutil/boot_record.h</code>. The <code>boot_add_data_to_shared_area()</code> function can be used for adding new TLV entries to the shared data area. Alternatively, setting the <code>MCUBOOT_DATA_SHARING_BOOTINFO</code> option will provide a default function for this which saves information such as the maximum application size, bootloader version (if available), running slot number, if recovery is part of MCUboot and the signature type. Details of the TLVs for this information can be found in <code>boot/bootutil/include/bootutil/boot_status.h</code> with <code>BLINFO_</code> prefixes.</p>"},{"location":"bootloader/docs/design/#testing-in-ci","title":"Testing in CI","text":""},{"location":"bootloader/docs/design/#testing-fault-injection-hardening-fih","title":"Testing Fault Injection Hardening (FIH)","text":"<p>The CI currently tests the Fault Injection Hardening feature of MCUboot by executing instruction skip during execution, and looking at whether a corrupted image was booted by the bootloader or not.</p> <p>The main idea is that instruction skipping can be automated by scripting a debugger to automatically execute the following steps:</p> <ul> <li>Set breakpoint at specified address.</li> <li>Continue execution.</li> <li>On breakpoint hit increase the Program Counter.</li> <li>Continue execution.</li> <li>Detach from target after a timeout reached.</li> </ul> <p>Whether or not the corrupted image was booted or not can be decided by looking for certain entries in the log.</p> <p>As MCUboot is deployed on a microcontroller, testing FI would not make much sense in the simulator environment running on a host machine with different architecture than the MCU's, as the degree of hardening depends on compiler behavior. For example, (a bit counterintuitively) the code produced by gcc with <code>-O0</code> optimisation is more resilient against FI attacks than the code generated with <code>-O3</code> or <code>-Os</code> optimizations.</p> <p>To run on a desired architecture in the CI, the tests need to be executed on an emulator (as real devices are not available in the CI environment). For this implementation QEMU is selected.</p> <p>For the tests MCUboot needs a set of drivers and an implementation of a main function. For the purpose of this test Trusted-Firmware-M has been selected as it supports Armv8-M platforms that are also emulated by QEMU.</p> <p>The tests run in a docker container inside the CI VMs, to make it more easy to deploy build and test environment (QEMU, compilers, interpreters). The CI VMs seems to be using quite old Ubuntu (16.04).</p> <p>The sequence of the testing is the following (pseudo code):</p> <pre><code>fn main()\n  # Implemented in ci/fih-tests_install.sh\n  generate_docker_image(Dockerfile)\n\n  # See details below. Implemented in ci/fih-tests_run.sh.\n  # Calling the function with different parameters is done by Travis CI based on\n  # the values provided in the .travis.yaml\n  start_docker_image(skip_sizes, build_type, damage_type, fih_level)\n\nfn start_docker_image(skip_sizes, build_type, damage_type, fih_level)\n  # implemented in ci/fih_test_docker/execute_test.sh\n  compile_mcuboot(build_type)\n\n  # implemented in ci/fih_test_docker/damage_image.py\n  damage_image(damage_type)\n\n  # implemented in ci/fih_test_docker/run_fi_test.sh\n  ranges = generate_address_ranges()\n  for s in skip_sizes\n    for r in ranges\n      do_skip_in_qemu(s, r) # See details below\n  evaluate_logs()\n\nfn do_skip_in_qemu(size, range)\n  for a in r\n    run_qemu(a, size)  # See details below\n\n# this part is implemented in ci/fih_test_docker/fi_tester_gdb.sh\nfn run_qemu(a, size)\n  script = create_debugger_script(a, size)\n  start_qemu_in_bacground() # logs serial out to a file\n  gdb_attach_to_qemu(script)\n  kill_qemu()\n\n  # This checks the debugger and the quemu logs, and decides whether the tets\n  # was executed successfully, and whether the image is booted or not. Then\n  # emits a yaml fragment on the standard out to be processed by the caller\n  # script\n  evaluate_run(qemu_log_file)\n</code></pre> <p>Further notes:</p> <ul> <li>The image is corrupted by changing its signature.</li> <li>MCUBOOT_FIH_PROFILE_MAX is not tested as it requires TRNG, and the AN521 platform has no support for it. However this profile adds the random execution delay to the code, so should not affect the instruction skip results too much, because break point is placed at exact address. But in practice this makes harder the accurate timing of the attack.</li> <li>The test cases defined in .travis.yml always return <code>passed</code>, if they were executed successfully. A yaml file is created during test execution with the details of the test execution results. A summary of the collected results is printed in the log at the end of the test.</li> </ul> <p>An advantage of having the tests running in a docker image is that it is possible to run the tests on a local machine that has git and docker, without installing any additional software.</p> <p>So, running the test on the host looks like the following (The commands below are issued from the MCUboot source directory):</p> <p><pre><code>$ mkdir docker\n$ ./ci/fih-tests_install.sh\n$ FIH_LEVEL=MEDIUM BUILD_TYPE=RELEASE SKIP_SIZE=2 DAMAGE_TYPE=SIGNATURE \\\n     ./ci/fih-tests_run.sh\n</code></pre> On the travis CI the environment variables in the last command are set based on the configs provided in the <code>.travis.yaml</code></p> <p>This starts the tests, however the shell that it is running in is not interactive, it is not possible to examine the results of the test run. To have an interactive shell where the results can be examined, the following can be done:</p> <ul> <li>The docker image needs to be built with <code>ci/fih-tests_install.sh</code> as described   above.</li> <li>Start the docker image with the following command:   <code>docker run -i -t mcuboot/fih-test</code>.</li> <li>Execute the test with a command similar to the following:   <code>/root/execute_test.sh 8 RELEASE SIGNATURE MEDIUM</code>. After the test finishes,   the shell returns, and it is possible to investigate the results. It is also   possible to stop the test with Ctrl+c. The parameters to the   <code>execute_test.sh</code> are <code>SKIP_SIZE</code>, <code>BUILD_TYPE</code>, <code>DAMAGE_TYPE</code>, <code>FIH_LEVEL</code> in   order.</li> </ul>"},{"location":"bootloader/docs/ecdsa/","title":"ECDSA signature format","text":"<p>When the ECDSA SECP256R1 (EC256) signature support was added to MCUboot, a shortcut was taken, and these signatures were padded to make them always a fixed length. Unfortunately, this padding was done in a way that is not easily reversible. Some crypto libraries (specifically, Mbed TLS) are fairly strict about the formatting of the ECDSA signature.</p> <p>There are two ways to fix this:</p> <ul> <li> <p>Use a reversible padding scheme. This solution requires     at least one pad byte to always be added (to set the length). This     padding would be somewhat incompatible across versions (older     EC256 would work, while newer MCUboot code would reject old     signatures. The EC code would work reliably only in the new     combination).</p> </li> <li> <p>Remove the padding entirely. Depending on the tool used, this solution     requires some rethinking of how TLV generation is implemented so     that the length does not need to be known until the signature is     generated. These tools are usually written in higher-level     languages, so this change should not be difficult.</p> <p>However, this will also break compatibility with older versions, because images generated with newer tools will not work with older versions of MCUboot.</p> </li> </ul> <p>This document proposes a multi-stage approach to give a transition period:</p> <ol> <li> <p>Add a <code>--no-pad-sig</code> argument to the sign command in      <code>imgtool.py</code>.</p> <p>Without this argument, the images are padded with the  existing scheme. With this argument, the ECDSA is encoded  without any padding. The <code>--pad-sig</code> argument is also  accepted, but it is already the default.</p> </li> <li> <p>MCUboot will be modified to allow unpadded signatures right away.      The existing EC256 implementations will still work (with or      without padding), and the existing EC implementation will be able      to accept padded and unpadded signatures.</p> </li> <li> <p>An Mbed TLS implementation of EC256 can be added, but it will require      the <code>--no-pad-sig</code> signature to be able to boot all generated      images. Without the argument, 3 out of 4 images generated will have      padding and will be considered invalid.</p> </li> </ol> <p>After one or more MCUboot release cycles and announcements in the relevant channels, the arguments to <code>imgtool.py</code> will change:</p> <ul> <li> <p><code>--no-pad-sig</code> will still be accepted but will have no effect.</p> </li> <li> <p><code>--pad-sig</code> will now bring back the old padding behavior.</p> </li> </ul> <p>This will require an update to any scripts that will rely on the default behavior, but will not specify a specific version of imgtool.</p> <p>The signature generation in the simulator can be changed at the same time the boot code begins to accept unpadded signatures. The simulator is always run out of the same tree as the MCUboot code, so there should not be any compatibility issues.</p>"},{"location":"bootloader/docs/ecdsa/#background","title":"Background","text":"<p>ECDSA signatures are encoded as ASN.1, notably with the signature itself encoded as follows:</p> <pre><code>    ECDSA-Sig-Value ::= SEQUENCE {\n      r  INTEGER,\n      s  INTEGER\n    }\n</code></pre> <p>Both <code>r</code> and <code>s</code> are 256-bit numbers. Because these are unsigned numbers that are being encoded in ASN.1 as signed values, if the high bit of the number is set, the DER-encoded representation will require 33 bytes instead of 32. This means that the length of the signature will vary by a couple of bytes, depending on whether one or both of these numbers have the high bit set.</p> <p>Originally, MCUboot added padding to the entire signature and just removed any trailing 0 bytes from the data block. This turned out to be fine 255 out of 256 times, each time the last byte of the signature was non-zero, but if the signature ended in a zero, MCUboot would remove too many bytes and render the signature invalid.</p> <p>The correct approach here is to accept that ECDSA signatures are of variable length, and to make sure that we can handle them as such.</p>"},{"location":"bootloader/docs/encrypted_images/","title":"Encrypted images","text":""},{"location":"bootloader/docs/encrypted_images/#encrypted-images","title":"Encrypted images","text":""},{"location":"bootloader/docs/encrypted_images/#rationale","title":"Rationale","text":"<p>To provide confidentiality of image data while in transport to the device or while residing on an external flash, <code>MCUboot</code> has support for encrypting/decrypting images on-the-fly while upgrading.</p> <p>The image header needs to flag this image as <code>ENCRYPTED</code> (0x04) and a TLV with the key must be present in the image. When upgrading the image from the <code>secondary slot</code> to the <code>primary slot</code> it is automatically decrypted (after validation). If swap upgrades are enabled, the image located in the <code>primary slot</code>, also having the <code>ENCRYPTED</code> flag set and the TLV present, is re-encrypted while swapping to the <code>secondary slot</code>.</p>"},{"location":"bootloader/docs/encrypted_images/#threat-model","title":"Threat model","text":"<p>The encrypted image support is supposed to allow for confidentiality if the image is not residing on the device or is written to external storage, eg a SPI flash being used for the secondary slot.</p> <p>It does not protect against the possibility of attaching a JTAG and reading the internal flash memory, or using some attack vector that enables dumping the internal flash in any way.</p> <p>Since decrypting requires a private key (or secret if using symmetric crypto) to reside inside the device, it is the responsibility of the device manufacturer to guarantee that this key is already in the device and not possible to extract.</p>"},{"location":"bootloader/docs/encrypted_images/#design","title":"Design","text":"<p>When encrypting an image, only the payload (FW) is encrypted. The header, TLVs are still sent as plain data.</p> <p>Hashing and signing also remain functionally the same way as before, applied over the un-encrypted data. Validation on encrypted images, checks that the encrypted flag is set and TLV data is OK, then it decrypts each image block before sending the data to the hash routines.</p> <p>The image is encrypted using AES-CTR-128 or AES-CTR-256, with a counter that starts from zero (over the payload blocks) and increments by 1 for each 16-byte block. AES-CTR was chosen for speed/simplicity and allowing for any block to be encrypted/decrypted without requiring knowledge of any other block (allowing for simple resume operations on swap interruptions).</p> <p>The key used is a randomized when creating a new image, by <code>imgtool</code> or <code>newt</code>. This key should never be reused and no checks are done for this, but randomizing a 16-byte block with a TRNG should make it highly improbable that duplicates ever happen.</p> <p>To distribute this AES-CTR key, new TLVs were defined. The key can be encrypted using either RSA-OAEP, AES-KW (128 or 256 bits depending on the AES-CTR key length), ECIES-P256 or ECIES-X25519.</p> <p>For RSA-OAEP a new TLV with value <code>0x30</code> is added to the image, for AES-KW a new TLV with value <code>0x31</code> is added to the image, for ECIES-P256 a new TLV with value <code>0x32</code> is added, and for ECIES-X25519 a newt TLV with value <code>0x33</code> is added. The contents of those TLVs are the results of applying the given operations over the AES-CTR key.</p>"},{"location":"bootloader/docs/encrypted_images/#ecies-encryption","title":"ECIES encryption","text":"<p>ECIES follows a well defined protocol to generate an encryption key. There are multiple standards which differ only on which building blocks are used; for MCUboot we settled on some primitives that are easily found on our crypto libraries. The whole key encryption can be summarized as:</p> <ul> <li>Generate a new private key and derive the public key; when using ECIES-P256   this is a secp256r1 keypair, when using ECIES-X25519 this will be a x25519   keypair. Those keys will be our ephemeral keys.</li> <li>Generate a new secret (DH) using the ephemeral private key and the public key   that corresponds to the private key embedded in the HW.</li> <li>Derive the new keys from the secret using HKDF (built on HMAC-SHA256). We   are not using a <code>salt</code> and using an <code>info</code> of <code>MCUBoot_ECIES_v1</code>, generating   48 bytes of key material.</li> <li>A new random encryption key is generated (for AES). This is   the AES key used to encrypt the images.</li> <li>The key is encrypted with AES-128-CTR or AES-256-CTR and a <code>nonce</code> of 0 using   the first 16 bytes of key material generated previously by the HKDF.</li> <li>The encrypted key now goes through a HMAC-SHA256 using the remaining 32   bytes of key material from the HKDF.</li> </ul> <p>The final TLV is built from the 65 bytes for ECIES-P256 or 32 bytes for ECIES-X25519, which correspond to the ephemeral public key, followed by the 32 bytes of MAC tag and the 16 or 32 bytes of the encrypted key, resulting in a TLV of 113 or 129 bytes for ECIES-P256 and 80 or 96 bytes for ECIES-X25519.</p> <p>The implemenation of ECIES-P256 is named ENC_EC256 in the source code and artifacts while ECIES-X25519 is named ENC_X25519.</p>"},{"location":"bootloader/docs/encrypted_images/#upgrade-process","title":"Upgrade process","text":"<p>When starting a new upgrade process, <code>MCUboot</code> checks that the image in the <code>secondary slot</code> has the <code>ENCRYPTED</code> flag set and has the required TLV with the encrypted key. It then uses its internal private/secret key to decrypt the TLV containing the key. Given that no errors are found, it will then start the validation process, decrypting the blocks before check. A good image being determined, the upgrade consists in reading the blocks from the <code>secondary slot</code>, decrypting and writing to the <code>primary slot</code>.</p> <p>If swap is used for the upgrade process, the encryption happens when copying the sectors of the <code>secondary slot</code> to the scratch area.</p> <p>The <code>scratch</code> area is not encrypted, so it must reside in the internal flash of the MCU to avoid attacks that could interrupt the upgrade and dump the data.</p> <p>Also when swap is used, the image in the <code>primary slot</code> is checked for presence of the <code>ENCRYPTED</code> flag and the key TLV. If those are present the sectors are re-encrypted when copying from the <code>primary slot</code> to the <code>secondary slot</code>.</p> <p>Note</p> <p>Each encrypted image must have its own key TLV that should be unique and used only for this particular image.</p> <p>Also when swap method is employed, the sizes of both images are saved to the status area just before starting the upgrade process, because it would be very hard to determine this information when an interruption occurs and the information is spread across multiple areas.</p>"},{"location":"bootloader/docs/encrypted_images/#creating-your-keys-with-imgtool","title":"Creating your keys with imgtool","text":"<p><code>imgtool</code> can generate keys by using <code>imgtool keygen -k &lt;output.pem&gt; -t &lt;type&gt;</code>,  where type can be one of <code>rsa-2048</code>, <code>rsa-3072</code>, <code>ecdsa-p256</code> or <code>ed25519</code>. This will generate a keypair or private key.</p> <p>To extract the public key in source file form, use <code>imgtool getpub -k &lt;input.pem&gt; -e &lt;encoding&gt;</code>, where <code>encoding</code> can be one of <code>lang-c</code> or <code>lang-rust</code> (defaults to <code>lang-c</code>). To extract a public key in PEM format, use <code>imgtool getpub -k &lt;input.pem&gt; -e pem</code>.</p> <p>If using AES-KW, follow the steps in the next section to generate the required keys.</p>"},{"location":"bootloader/docs/encrypted_images/#creating-your-keys-with-unix-tooling","title":"Creating your keys with Unix tooling","text":"<ul> <li>If using RSA-OAEP, generate a keypair following steps similar to those   described in signed_images to create RSA keys.</li> <li>If using ECIES-P256, generate a keypair following steps similar to those   described in signed_images to create ECDSA256 keys.</li> <li>If using ECIES-X25519, generate a private key passing the option <code>-t x25519</code>   to <code>imgtool keygen</code> command. To generate public key PEM file the following   command can be used: <code>openssl pkey -in &lt;generated-private-key.pem&gt; -pubout</code></li> <li>If using AES-KW (<code>newt</code> only), the <code>kek</code> can be generated with a   command like (change count to 32 for a 256 bit key)   <code>dd if=/dev/urandom bs=1 count=16 | base64 &gt; my_kek.b64</code></li> </ul>"},{"location":"bootloader/docs/getting_started/","title":"Bootloader","text":"<p>OwnTech use its own bootloader in order to be able to flash code using USB without the use of a dedicated debug tool.  It is based on MCUBoot an open source bootloader supported by the zephyr ecosystem. </p>"},{"location":"bootloader/docs/getting_started/#features","title":"Features","text":"<ul> <li>USB compatible</li> <li>Supports Over The Air (OTA) updates</li> <li>Image validation </li> <li>Encryption ready</li> </ul>"},{"location":"bootloader/docs/getting_started/#boot-sequence","title":"Boot sequence","text":"<p>When pressing reset button the following happens :  - Program initiates at 0x80000000, and bootloader is launched. - Bootloader jumps at Image-0 address at 0x8010000.</p>"},{"location":"bootloader/docs/getting_started/#nomal-upload-sequence","title":"Nomal Upload sequence","text":"<p>When pressing upload button the following happens : </p> <p></p> <ul> <li>Image-1 is the memory bank where the program is uploaded using USB. </li> <li>When the USB transfer is complete, a reboot order is sent to the board. </li> </ul> <ul> <li>Image is marked for testing, so a memory swap is performed. Image-1 is sent to memory bank 0 at the address 0x8010000 and Image-0 is sent to memory bank 1 at the address 0x8047800. </li> <li>A boot test is performed. If the initialization is successful, the new program is marked as good and stays in image-0. Otherwise, the image is rejected and the swap action is reverted. </li> <li>Application code is executed from address 0x8010000</li> </ul> <p>Warning</p> <p>Image swapping requires having a valid image at address 0x8010000.  If no image-0 is present normal upload sequence will fail. Use Recovery Mode to upload a valid Image-0 and proceed again.</p>"},{"location":"bootloader/docs/getting_started/#recovery-mode","title":"Recovery Mode","text":"<p>The OwnTech bootloader has a recovery mode in order to flash directly the Image-0 without performing a swap action.  </p> <p>To enter recovery mode, press BOOT button and RESET button simultaneously.  </p> <p>When pressing the upload button in recovery mode the following happens : </p> <p></p> <ul> <li>User program is written at the address 0x8010000 directly. </li> <li>A reboot is performed and the bootloader jumps to user code at address 0x8010000.</li> </ul> <p>Note</p> <p>When entering recovery mode, the user LED should light up</p> <p>Note</p> <p>Recovery mode is significantly slower than Normal Upload Sequence.</p>"},{"location":"bootloader/docs/getting_started/#how-it-works","title":"How it works","text":"<p>USB upload uses what is called a magic baudrate callback. When pressing the upload button:  </p> <ul> <li>The user code is compiled, creating a bin executable.</li> <li>A trailer containing meta-data is added to the bin file, and the executable is marked for testing.  </li> <li>The USB serial disconnects and reconnects using the magic 1200Baud baudrate. </li> <li>That baudrate is detected and it triggers a reboot order to switch in bootloader mode.</li> <li>On the computer side, a small program called MCUMgr is called to upload the user code image to the microcontroller (it is located in owntech/third_party/mcumgr - if it is not present, it will be downloaded automatically.)</li> <li>When upload is finished, a reboot order is sent</li> <li>Bootloader starts and detects the new image trailer marked for testing.</li> <li>Bootloader performs the swap action</li> <li>Bootloader jumps to user application at address 0x8010000 and USB serial is available again.</li> </ul>"},{"location":"bootloader/docs/imgtool/","title":"Image tool","text":"<p>The Python program <code>scripts/imgtool.py</code> can be used to perform the operations that are necessary to manage keys and sign images.  Using this script should be preferred to the manual steps described in <code>doc/signed_images.md</code>.</p> <p>This program is written for Python3, and has several dependencies on Python libraries.  These can be installed using 'pip3':</p> <pre><code>pip3 install --user -r scripts/requirements.txt\n</code></pre>"},{"location":"bootloader/docs/imgtool/#managing-keys","title":"Managing keys","text":"<p>This tool currently supports rsa-2048, rsa-3072, ecdsa-p256 and ed25519 keys. You can generate a keypair for one of these types using the 'keygen' command:</p> <pre><code>./scripts/imgtool.py keygen -k filename.pem -t rsa-2048\n</code></pre> <p>or use rsa-3072, ecdsa-p256, or ed25519 for the type.  The key type used should match what MCUboot is configured to verify.</p> <p>This key file is what is used to sign images, this file should be protected, and not widely distributed.</p> <p>You can add the <code>-p</code> argument to <code>keygen</code>, which will cause it to prompt for a password.  You will need to enter this password in every time you use the private key.</p>"},{"location":"bootloader/docs/imgtool/#incorporating-the-public-key-into-the-code","title":"Incorporating the public key into the code","text":"<p>There is a development key distributed with MCUboot that can be used for testing.  Since this private key is widely distributed, it should never be used for production.  Once you have generated a production key, as described above, you should replace the public key in the bootloader with the generated one.</p> <p>For Zephyr, the keys live in the file <code>boot/zephyr/keys.c</code>.  For mynewt, follow the instructions in <code>doc/signed_images.md</code> to generate the key file.</p> <pre><code>./scripts/imgtool.py getpub -k filename.pem\n</code></pre> <p>will extract the public key from the given private key file, and output it as a C data structure.  You can replace or insert this code into the key file. However, when the <code>MCUBOOT_HW_KEY</code> config option is enabled, this last step is unnecessary and can be skipped.</p>"},{"location":"bootloader/docs/imgtool/#signing-images","title":"Signing images","text":"<p>Image signing takes an image in binary or Intel Hex format intended for the primary slot and adds a header and trailer that the bootloader is expecting:</p> <pre><code>Usage: imgtool.py sign [OPTIONS] INFILE OUTFILE\n\n  Create a signed or unsigned image\n\n  INFILE and OUTFILE are parsed as Intel HEX if the params have .hex\n  extension, otherwise binary format is used\n\nOptions:\n  -k, --key filename\n  --public-key-format [hash|full]\n  --align [1|2|4|8|16|32]       Alignment used by swap update modes.\n  -v, --version TEXT            [required]\n  -s, --security-counter TEXT   Specify the value of security counter. Use\n                                the `auto` keyword to automatically generate\n                                it from the image version.\n  -d, --dependencies TEXT\n  --pad-sig                     Add 0-2 bytes of padding to ECDSA signature\n                                (for MCUboot &lt;1.5)\n  -H, --header-size INTEGER     [required]\n  --pad-header                  Add --header-size zeroed bytes at the\n                                beginning of the image\n  -S, --slot-size INTEGER       Size of the slot where the image will be\n                                written [required]\n  --pad                         Pad image to --slot-size bytes, adding\n                                trailer magic\n  --confirm                     When padding the image, mark it as confirmed\n  -M, --max-sectors INTEGER     When padding allow for this amount of\n                                sectors (defaults to 128)\n  --boot-record sw_type         Create CBOR encoded boot record TLV. The\n                                sw_type represents the role of the software\n                                component (e.g. CoFM for coprocessor\n                                firmware). [max. 12 characters]\n  --overwrite-only              Use overwrite-only instead of swap upgrades\n  -e, --endian [little|big]     Select little or big endian\n  -E, --encrypt filename        Encrypt image using the provided public key\n  --save-enctlv                 When upgrading, save encrypted key TLVs\n                                instead of plain keys. Enable when\n                                BOOT_SWAP_SAVE_ENCTLV config option was set.\n  -L, --load-addr INTEGER       Load address for image when it should run\n                                from RAM.\n  -x, --hex-addr INTEGER        Adjust address in hex output file.\n  -R, --erased-val [0|0xff]     The value that is read back from erased\n                                flash.\n  -h, --help                    Show this message and exit.\n</code></pre> <p>The main arguments given are the key file generated above, a version field to place in the header (1.2.3 for example), the alignment of the flash device in question, and the header size.</p> <p>The header size depends on the operating system and the particular flash device.  For Zephyr, it will be configured as part of the build, and will be a small power of two.  By default, the Zephyr build system will already prepended a zeroed header to the image.  If another build system is in use that does not automatically add this zeroed header, <code>--pad-header</code> can be passed and the <code>--header-size</code> will be added by imgtool. If <code>--pad-header</code> is used with an Intel Hex file, <code>--header-size</code> bytes will be subtracted from the load address (in Intel Hex terms, the Extended Linear Address record) to adjust for the new bytes prepended to the file. The load address of all data existing in the file should not change.</p> <p>The <code>--slot-size</code> argument is required and used to check that the firmware does not overflow into the swap status area (metadata). If swap upgrades are not being used, <code>--overwrite-only</code> can be passed to avoid adding the swap status area size when calculating overflow.</p> <p>The optional <code>--pad</code> argument will place a trailer on the image that indicates that the image should be considered an upgrade.  Writing this image in the secondary slot will then cause the bootloader to upgrade to it.</p> <p>A dependency can be specified in the following way: <code>-d \"(image_id, image_version)\"</code>. The <code>image_id</code> is the number of the image which the current image depends on. The <code>image_version</code> is the minimum version of that image to satisfy compliance. For example <code>-d \"(1, 1.2.3+0)\"</code> means this image depends on Image 1 which version has to be at least 1.2.3+0.</p> <p>The <code>--public-key-format</code> argument can be used to distinguish where the public key is stored for image authentication. The <code>hash</code> option is used by default, in which case only the hash of the public key is added to the TLV area (the full public key is incorporated into the bootloader). When the <code>full</code> option is used instead, the TLV area will contain the whole public key and thus the bootloader can be independent from the key(s). For more information on the additional requirements of this option, see the design document.</p>"},{"location":"bootloader/docs/readme-espressif/","title":"Building and using MCUboot with Espressif's chips","text":"<p>The MCUBoot Espressif's port depends on HAL (Hardware Abstraction Layer) sources based on ESP-IDF or 3rd party frameworks as such as Zephyr-RTOS (<code>zephyrproject-rtos/hal_espressif/</code>) or NuttX RTOS (<code>espressif/esp-hal-3rdparty</code>). Building the MCUboot Espressif's port and its features is platform dependent, therefore, the system environment including toolchains, must be set accordingly. A standalone build version means that ESP-IDF and its toolchain are used as source. For 3rd parties framework, HAL path and toolchain must be set.</p> <p>Documentation about the MCUboot bootloader design, operation and features can be found in the design document.</p>"},{"location":"bootloader/docs/readme-espressif/#soc-support-availability","title":"SoC support availability","text":"<p>The current port is available for use in the following SoCs within the OSes:</p> ESP32 ESP32-S2 ESP32-C3 ESP32-S3 ESP32-C2 ESP32-C6 ESP32-H2 Zephyr Supported Supported Supported Supported In progress In progress In progress NuttX Supported Supported Supported Supported In progress In progress In progress <p>Notice that any customization in the memory layout from the OS application must be done aware of the bootloader own memory layout to avoid overlapping. More information on the section Memory map organization for OS compatibility.</p>"},{"location":"bootloader/docs/readme-espressif/#installing-requirements-and-dependencies","title":"Installing requirements and dependencies","text":"<p>The following instructions considers a MCUboot Espressif port standalone build.</p> <ol> <li> <p>Install additional packages required for development with MCUboot:</p> <pre><code>cd ~/mcuboot  # or to your directory where MCUboot is cloned\n</code></pre> <pre><code>pip3 install --user -r scripts/requirements.txt\n</code></pre> </li> <li> <p>Update the Mbed TLS submodule required by MCUboot:</p> <pre><code>git submodule update --init --recursive ext/mbedtls\n</code></pre> </li> <li> <p>If ESP-IDF is the chosen option for use as HAL layer and the system already have ESP-IDF    installed, ensure that the environment is set:</p> <pre><code>&lt;IDF_PATH&gt;/install.sh\n</code></pre> <pre><code>. &lt;IDF_PATH&gt;/export.sh\n</code></pre> <p>Note</p> <p>If desirable, instructions for ESP-IDF installation can be found here</p> <p>Note</p> <p>The other HALs mentioned above like <code>hal_espressif</code> from Zephyr RTOS or <code>esp-hal-3rdparty</code> from NuttX RTOS environments also can be used for the bootloader standalone build, however as eventually code revision may differ from what is currently expected, it is recommended using them only within their RTOS build system.</p> </li> <li> <p>If ESP-IDF is not installed and will not be used, install <code>esptool</code>:</p> <pre><code>pip3 install esptool\n</code></pre> </li> </ol>"},{"location":"bootloader/docs/readme-espressif/#building-the-bootloader-itself","title":"Building the bootloader itself","text":"<p>The MCUboot Espressif port bootloader is built using the toolchain and tools provided by Espressif. Additional configuration related to MCUboot features and slot partitioning may be made using the <code>port/&lt;TARGET&gt;/bootloader.conf</code> file or passing a custom config file using the <code>-DMCUBOOT_CONFIG_FILE</code> argument on the first step below.</p> <p>Note</p> <p>Replace <code>&lt;TARGET&gt;</code> with the target ESP32 family (like <code>esp32</code>, <code>esp32s2</code> and others).</p> <ol> <li> <p>Compile and generate the BIN:</p> <pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=tools/toolchain-&lt;TARGET&gt;.cmake -DMCUBOOT_TARGET=&lt;TARGET&gt; -DESP_HAL_PATH=&lt;ESP_HAL_PATH&gt; -DMCUBOOT_FLASH_PORT=&lt;PORT&gt; -B build -GNinja\n</code></pre> <pre><code>ninja -C build/\n</code></pre> <p>Note</p> <p>If using ESP-IDF as HAL layer source, <code>ESP_HAL_PATH</code> can be ommited.</p> <p>If desirable, <code>&lt;TOOLCHAIN_BIN_DIR&gt;</code> can be defined with the path for a different compatible toolchain, however it is recommended to actually create a CMake toolchain file and pass it through <code>&lt;CMAKE_TOOLCHAIN_FILE&gt;</code> variable since it may require a distinct set of compilation flags.</p> </li> <li> <p>Flash MCUboot in your device:</p> <pre><code>ninja -C build/ flash\n</code></pre> <p>If <code>MCUBOOT_FLASH_PORT</code> arg was not passed to <code>cmake</code>, the default <code>PORT</code> for flashing will be <code>/dev/ttyUSB0</code>.</p> <p>Alternatively:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b &lt;BAUD&gt; --before default_reset --after no_reset --chip &lt;TARGET&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;BOOTLOADER_FLASH_OFFSET&gt; build/mcuboot_&lt;TARGET&gt;.bin\n</code></pre> <p>Note</p> <p>You may adjust the port <code>&lt;PORT&gt;</code> (like <code>/dev/ttyUSB0</code>) and baud rate <code>&lt;BAUD&gt;</code> (like <code>2000000</code>) according to the connection with your board. You can also skip <code>&lt;PORT&gt;</code> and <code>&lt;BAUD&gt;</code> parameters so that esptool tries to automatically detect it.</p> <p><code>&lt;FLASH_SIZE&gt;</code> can be found using the command below:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b &lt;BAUD&gt; flash_id\n</code></pre> <p>The output contains device information and its flash size:</p> <pre><code>Detected flash size: 4MB\n</code></pre> <p><code>&lt;BOOTLOADER_FLASH_OFFSET&gt;</code> value must follow one of the addresses below:</p> ESP32 ESP32-S2 ESP32-C3 ESP32-S3 ESP32-C2 ESP32-C6 ESP32-H2 0x1000 0x1000 0x0000 0x0000 0x0000 0x0000 0x0000 </li> <li> <p>Reset your device</p> </li> </ol>"},{"location":"bootloader/docs/readme-espressif/#signing-and-flashing-an-application","title":"Signing and flashing an application","text":"<ol> <li> <p>Images can be regularly signed with the <code>scripts/imgtool.py</code> script:</p> <pre><code>imgtool.py sign --align 4 -v 0 -H 32 --pad-header -S &lt;SLOT_SIZE&gt; &lt;BIN_IN&gt; &lt;SIGNED_BIN&gt;\n</code></pre> <p>Note</p> <p><code>&lt;SLOT_SIZE&gt;</code> is the size of the slot to be used. Default slot0 size is <code>0x100000</code>, but it can change as per application flash partitions.</p> <p>For Zephyr images, <code>--pad-header</code> is not needed as it already has the padding for MCUboot header.</p> <p> ATTENTION</p> <p>This is the basic signing needed for adding MCUboot headers and trailers. For signing with a crypto key and guarantee the authenticity of the image being booted, see the section MCUboot image signature verification below.</p> </li> <li> <p>Flash the signed application:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b &lt;BAUD&gt; --before default_reset --after hard_reset --chip &lt;TARGET&gt;  write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;SLOT_OFFSET&gt; &lt;SIGNED_BIN&gt;\n</code></pre> </li> </ol>"},{"location":"bootloader/docs/readme-espressif/#downgrade-prevention","title":"Downgrade prevention","text":"<p>Downgrade prevention (avoid updating of images to an older version) can be enabled using the following configuration:</p> <pre><code>CONFIG_ESP_DOWNGRADE_PREVENTION=y\n</code></pre> <p>MCUboot will then verify and compare the new image version number with the current one before perform an update swap.</p> <p>Version number is added to the image when signing it with <code>imgtool</code> (<code>-v</code> parameter, e.g. <code>-v 1.0.0</code>).</p>"},{"location":"bootloader/docs/readme-espressif/#downgrade-prevention-with-security-counter","title":"Downgrade prevention with security counter","text":"<p>It is also possible to rely on a security counter, also added to the image when signing with <code>imgtool</code> (<code>-s</code> parameter), apart from version number. This allows image downgrade at some extent, since any update must have greater or equal security counter value. Enable using the following configuration:</p> <pre><code>CONFIG_ESP_DOWNGRADE_PREVENTION_SECURITY_COUNTER=y\n</code></pre> <p>E.g.: if the current image was signed using <code>-s 1</code> parameter, an eventual update image must have been signed using security counter <code>-s 1</code> or greater.</p>"},{"location":"bootloader/docs/readme-espressif/#security-chain-on-espressif-port","title":"Security Chain on Espressif port","text":"<p>MCUboot encrypted images do not provide full code confidentiality when only external storage is available (see Threat model) since by MCUboot design the image in Primary Slot, from where the image is executed, is stored plaintext. Espressif chips have off-chip flash memory, so to ensure a security chain along with MCUboot image signature verification, the hardware-assisted Secure Boot and Flash Encryption were made available on the MCUboot Espressif port.</p>"},{"location":"bootloader/docs/readme-espressif/#mcuboot-image-signature-verification","title":"MCUboot image signature verification","text":"<p>The image that MCUboot is booting can be signed with 4 types of keys: RSA-2048, RSA-3072, EC256 and ED25519. In order to enable the feature, the bootloader must be compiled with the following configurations:</p> <p>Note</p> <p>It is strongly recommended to generate a new signing key using <code>imgtool</code> instead of use the existent samples.</p>"},{"location":"bootloader/docs/readme-espressif/#for-ec256-algorithm-use","title":"For EC256 algorithm use","text":"<pre><code>CONFIG_ESP_SIGN_EC256=y\n\n# Use Tinycrypt lib for EC256 or ED25519 signing\nCONFIG_ESP_USE_TINYCRYPT=y\n\nCONFIG_ESP_SIGN_KEY_FILE=&lt;YOUR_SIGNING_KEY.pem&gt;\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#for-ed25519-algorithm-use","title":"For ED25519 algorithm use","text":"<pre><code>CONFIG_ESP_SIGN_ED25519=y\n\n# Use Tinycrypt lib for EC256 or ED25519 signing\nCONFIG_ESP_USE_TINYCRYPT=y\n\nCONFIG_ESP_SIGN_KEY_FILE=&lt;YOUR_SIGNING_KEY.pem&gt;\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#for-rsa-2048-or-3072-algorithm-use","title":"For RSA (2048 or 3072) algorithm use","text":"<pre><code>CONFIG_ESP_SIGN_RSA=y\n# RSA_LEN is 2048 or 3072\nCONFIG_ESP_SIGN_RSA_LEN=&lt;RSA_LEN&gt;\n\n# Use Mbed TLS lib for RSA image signing\nCONFIG_ESP_USE_MBEDTLS=y\n\nCONFIG_ESP_SIGN_KEY_FILE=&lt;YOUR_SIGNING_KEY.pem&gt;\n</code></pre> <p>Notice that the public key will be embedded in the bootloader code, since the hardware key storage is not supported by Espressif port.</p>"},{"location":"bootloader/docs/readme-espressif/#signing-the-image","title":"Signing the image","text":"<p>Now you need to sign the image binary, use the <code>imgtool</code> with <code>-k</code> parameter:</p> <pre><code>imgtool.py sign -k &lt;YOUR_SIGNING_KEY.pem&gt; --pad --pad-sig --align 4 -v 0 -H 32 --pad-header -S 0x00100000 &lt;BIN_IN&gt; &lt;BIN_OUT&gt;\n</code></pre> <p>If signing a Zephyr image, the <code>--pad-header</code> is not needed, as it already have the padding for MCUboot header.</p>"},{"location":"bootloader/docs/readme-espressif/#secure-boot","title":"Secure Boot","text":"<p>The Secure Boot implementation is based on IDF's Secure Boot V2, is hardware-assisted and RSA based - except ESP32-C2 that uses ECDSA signing scheme - and has the role for ensuring that only authorized code will be executed on the device. This is done through bootloader signature checking by the ROM bootloader.</p> <p>Note: ROM bootloader is the First Stage Bootloader, while the Espressif MCUboot port is the Second Stage Bootloader.</p>"},{"location":"bootloader/docs/readme-espressif/#building-bootloader-with-secure-boot","title":"Building bootloader with Secure Boot","text":"<p>In order to build the bootloader with the feature on, the following configurations must be enabled:</p> <pre><code>CONFIG_SECURE_BOOT=1\nCONFIG_SECURE_BOOT_V2_ENABLED=1\nCONFIG_SECURE_SIGNED_ON_BOOT=1\n</code></pre> <p>For the currently supported chips, with exception of ESP32-C2, enable RSA signing scheme:</p> <pre><code>CONFIG_SECURE_SIGNED_APPS_RSA_SCHEME=1\nCONFIG_SECURE_BOOT_SUPPORTS_RSA=1\n</code></pre> <p>For ESP32-C2, enable ECDSA signing scheme and, if working with Flash Encryption too, enable the configuration to burn keys to efuse together:</p> <pre><code>CONFIG_SECURE_SIGNED_APPS_ECDSA_V2_SCHEME=1\n\nCONFIG_SECURE_BOOT_FLASH_ENC_KEYS_BURN_TOGETHER=1\n</code></pre> <p> ATTENTION</p> <p>On development phase is recommended add the following configuration in order to keep the debugging enabled and also to avoid any unrecoverable/permanent state change:</p>"},{"location":"bootloader/docs/readme-espressif/#config_secure_boot_allow_jtag1-config_secure_flash_uart_bootloader_allow_cache1-options-for-enabling-efuse-emulation-in-flash-config_efuse_virtual1-config_efuse_virtual_keep_in_flash1","title":"<pre><code>CONFIG_SECURE_BOOT_ALLOW_JTAG=1\nCONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE=1\n\n# Options for enabling eFuse emulation in Flash\nCONFIG_EFUSE_VIRTUAL=1\nCONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH=1\n</code></pre>","text":"<p> ATTENTION</p> <p>You can disable UART Download Mode by adding the following configuration:</p> <pre><code>CONFIG_SECURE_DISABLE_ROM_DL_MODE=1\n</code></pre> <p>This may be suitable for production builds. After disabling UART Download Mode you will not be able to flash other images through UART.</p> <p>Otherwise, you can switch the UART ROM Download Mode to the Secure Download Mode. It will limit the use of Download Mode functions to simple flash read, write and erase operations.</p> <pre><code>CONFIG_SECURE_ENABLE_SECURE_ROM_DL_MODE=1\n</code></pre> <p>Once the device makes its first full boot, these configurations cannot be reverted</p> <p>Once the bootloader image is built, the resulting binary file is required to be signed with <code>espsecure.py</code> tool.</p> <p>First create a signing key:</p> <pre><code>espsecure.py generate_signing_key --version 2 &lt;BOOTLOADER_SIGNING_KEY.pem&gt;\n</code></pre> <p>Then sign the bootloader image:</p> <pre><code>espsecure.py sign_data --version 2 --keyfile &lt;BOOTLOADER_SIGNING_KEY.pem&gt; -o &lt;BOOTLOADER_BIN_OUT&gt; &lt;BOOTLOADER_BIN_IN&gt;\n</code></pre> <p> ATTENTION</p> <p>Once the bootloader is flashed and the device resets, the first boot will enable Secure Boot and the bootloader and key no longer can be modified. So ENSURE that both bootloader and key are correct and you did not forget anything before flashing.</p> <p>Flash the bootloader as following, with <code>--after no_reset</code> flag, so you can reset the device only when assured:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b 2000000 --after no_reset --chip &lt;ESP_CHIP&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;BOOTLOADER_FLASH_OFFSET&gt; &lt;SIGNED_BOOTLOADER_BIN&gt;\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#secure-boot-process","title":"Secure Boot Process","text":"<p>Secure boot uses a signature block appended to the bootloader image in order to verify the authenticity. The signature block contains the RSA-3072 signature of that image and the RSA-3072 public key.</p> <p>On its first boot the Secure Boot is not enabled on the device eFuses yet, neither the key nor digests. So the first boot will have the following process:</p> <ol> <li>On startup, since it is the first boot, the ROM bootloader will not verify the bootloader image    (the Secure Boot bit in the eFuse is disabled) yet, so it proceeds to execute it (our MCUboot    bootloader port).</li> <li>Bootloader calculates the SHA-256 hash digest of the public key and writes the result to eFuse.</li> <li>Bootloader validates the application images and prepare the booting process (MCUboot phase).</li> <li>Bootloader burns eFuse to enable Secure Boot V2.</li> <li>Bootloader proceeds to load the Primary image.</li> </ol> <p>After that the Secure Boot feature is permanently enabled and on every next boot the ROM bootloader will verify the MCUboot bootloader image. The process of an usual boot:</p> <ol> <li>On startup, the ROM bootloader checks the Secure Boot enable bit in the eFuse. If it is enabled,    the boot will proceed as following.</li> <li>ROM bootloader verifies the bootloader's signature block integrity (magic number and CRC).    Interrupt boot if it fails.</li> <li>ROM bootloader verifies the bootloader image, interrupt boot if any step fails:<ol> <li>Compare the SHA-256 hash digest of the public key embedded in the bootloader\u2019s signature    block with the digest saved in the eFuses.</li> <li>Generate the application image digest and match it with the image digest in the signature    block.</li> <li>Use the public key to verify the signature of the bootloader image, using RSA-PSS with the    image digest calculated from previous step for comparison.</li> </ol> </li> <li>ROM bootloader executes the bootloader image.</li> <li>Bootloader does the usual verification (MCUboot phase).</li> <li>Proceeds to boot the Primary image.</li> </ol>"},{"location":"bootloader/docs/readme-espressif/#flash-encryption","title":"Flash Encryption","text":"<p>The Espressif Flash Encryption is hardware-assisted, transparent to the MCUboot process and is an additional security measure beyond MCUboot existent features. The Flash Encryption implementation is also based on IDF and is intended for encrypting off-chip flash memory contents, so it is protected against physical reading.</p> <p>When enabling the Flash Encryption, the user can encrypt the content either using a device generated key (remains unknown and unreadable) or a host generated key (owner is responsible for keeping the key private and safe). After the flash encryption gets enabled through eFuse burning on the device, all read and write operations are decrypted/encrypted in runtime.</p>"},{"location":"bootloader/docs/readme-espressif/#building-bootloader-with-flash-encryption","title":"Building bootloader with Flash Encryption","text":"<p>In order to build the bootloader with the feature on, the following configurations must be enabled:</p> <p>For release mode:</p> <pre><code>CONFIG_SECURE_FLASH_ENC_ENABLED=1\nCONFIG_SECURE_FLASH_ENCRYPTION_MODE_RELEASE=1\n</code></pre> <p>For development mode:</p> <pre><code>CONFIG_SECURE_FLASH_ENC_ENABLED=1\nCONFIG_SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT=1\n</code></pre> <p> ATTENTION</p> <p>On development phase is strongly recommended adding the following configuration in order to keep the debugging enabled and also to avoid any unrecoverable/permanent state change:</p>"},{"location":"bootloader/docs/readme-espressif/#config_secure_flash_uart_bootloader_allow_enc1-config_secure_flash_uart_bootloader_allow_dec1-config_secure_flash_uart_bootloader_allow_cache1-config_secure_boot_allow_jtag1-options-for-enabling-efuse-emulation-in-flash-config_efuse_virtual1-config_efuse_virtual_keep_in_flash1","title":"<pre><code>CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC=1\nCONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC=1\nCONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE=1\nCONFIG_SECURE_BOOT_ALLOW_JTAG=1\n\n# Options for enabling eFuse emulation in Flash\nCONFIG_EFUSE_VIRTUAL=1\nCONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH=1\n</code></pre>","text":"<p> ATTENTION</p> <p>Unless the recommended flags for DEVELOPMENT MODE were enabled, the actions made by Flash Encryption process are PERMANENT. \\ Once the bootloader is flashed and the device resets, the first boot will enable Flash Encryption, encrypt the flash content including bootloader and image slots, burn the eFuses that no longer can be modified and if device generated the key it will not be recoverable. \\ When on RELEASE MODE, ENSURE that the application with an update agent is flashed before reset the device.</p> <p>In the same way as Secure Boot feature, you can disable UART Download Mode by adding the following configuration:</p> <pre><code>CONFIG_SECURE_DISABLE_ROM_DL_MODE=1\n</code></pre> <p>This may be suitable for production builds. After disabling UART Download Mode you will not be able to flash other images through UART.</p> <p>Otherwise, you can switch the UART Download Mode to the Secure Download Mode. It will limit the use of Download Mode functions to simple flash read, write and erase operations.</p> <pre><code>CONFIG_SECURE_ENABLE_SECURE_ROM_DL_MODE=1\n</code></pre> <p>These configurations cannot be reverted after the device's first boot</p>"},{"location":"bootloader/docs/readme-espressif/#signing-the-image-when-working-with-flash-encryption","title":"Signing the image when working with Flash Encryption","text":"<p>When enabling flash encryption, it is required to signed the image using 32-byte alignment: <code>--align 32 --max-align 32</code>.</p> <p>Command example:</p> <pre><code>imgtool.py sign -k &lt;YOUR_SIGNING_KEY.pem&gt; --pad --pad-sig --align 32 --max-align 32 -v 0 -H 32 --pad-header -S &lt;SLOT_SIZE&gt; &lt;BIN_IN&gt; &lt;BIN_OUT&gt;\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#device-generated-key","title":"Device generated key","text":"<p>First ensure that the application image is able to perform encrypted read and write operations to the SPI Flash. Flash the bootloader and application normally:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b 2000000 --after no_reset --chip &lt;ESP_CHIP&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;BOOTLOADER_FLASH_OFFSET&gt; &lt;BOOTLOADER_BIN&gt;\n</code></pre> <pre><code>esptool.py -p &lt;PORT&gt; -b 2000000 --after no_reset --chip &lt;ESP_CHIP&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;PRIMARY_SLOT_FLASH_OFFSET&gt; &lt;APPLICATION_BIN&gt;\n</code></pre> <p>On the first boot, the bootloader will:</p> <ol> <li>Generate Flash Encryption key and write to eFuse.</li> <li>Encrypt flash in-place including bootloader, image primary/secondary slot and scratch.</li> <li>Burn eFuse to enable Flash Encryption.</li> <li>Reset system to ensure Flash Encryption cache resets properly.</li> </ol>"},{"location":"bootloader/docs/readme-espressif/#host-generated-key","title":"Host generated key","text":"<p>First ensure that the application image is able to perform encrypted read and write operations to the SPI Flash. Also ensure that the UART ROM Download Mode is not disabled - or that the Secure Download Mode is enabled. Before flashing, generate the encryption key using <code>espsecure.py</code> tool:</p> <pre><code>espsecure.py generate_flash_encryption_key &lt;FLASH_ENCRYPTION_KEY.bin&gt;\n</code></pre> <p>Burn the key into the device's eFuse (keep a copy on the host), this action can be done only once:</p> <p> ATTENTION</p> <p>eFuse emulation in Flash configuration options do not have any effect, so if the key burning command below is used, it will actually burn the physical eFuse.</p> <ul> <li>ESP32</li> </ul> <pre><code>espefuse.py --port PORT burn_key flash_encryption &lt;FLASH_ENCRYPTION_KEY.bin&gt;\n</code></pre> <ul> <li>ESP32S2, ESP32C3 and ESP32S3</li> </ul> <pre><code>espefuse.py --port PORT burn_key BLOCK &lt;FLASH_ENCRYPTION_KEY.bin&gt; &lt;KEYPURPOSE&gt;\n</code></pre> <p><code>BLOCK</code> is a free keyblock between <code>BLOCK_KEY0</code> and <code>BLOCK_KEY5</code>. And <code>KEYPURPOSE</code> is either <code>XTS_AES_128_KEY</code>, <code>XTS_AES_256_KEY_1</code>, <code>XTS_AES_256_KEY_2</code> (AES XTS 256 is available only in ESP32S2).</p> <p>Now, similar as the Device generated key, the bootloader and application can be flashed plaintext. The first boot will encrypt the flash content using the host key burned in the eFuse instead of generate a new one.</p> <p>Flashing the bootloader and application:</p> <pre><code>esptool.py -p &lt;PORT&gt; -b 2000000 --after no_reset --chip &lt;ESP_CHIP&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;BOOTLOADER_FLASH_OFFSET&gt; &lt;BOOTLOADER_BIN&gt;\n</code></pre> <pre><code>esptool.py -p &lt;PORT&gt; -b 2000000 --after no_reset --chip &lt;ESP_CHIP&gt; write_flash --flash_mode dio --flash_size &lt;FLASH_SIZE&gt; --flash_freq 40m &lt;PRIMARY_SLOT_FLASH_OFFSET&gt; &lt;APPLICATION_BIN&gt;\n</code></pre> <p>On the first boot, the bootloader will:</p> <ol> <li>Encrypt flash in-place including bootloader, image primary/secondary slot and scratch using the    written key.</li> <li>Burn eFuse to enable Flash Encryption.</li> <li>Reset system to ensure Flash Encryption cache resets properly.</li> </ol> <p>Encrypting data on the host:</p> <ul> <li>ESP32</li> </ul> <pre><code>espsecure.py encrypt_flash_data --keyfile &lt;FLASH_ENCRYPTION_KEY.bin&gt; --address &lt;FLASH_OFFSET&gt; --output &lt;OUTPUT_DATA&gt; &lt;INPUT_DATA&gt;\n</code></pre> <ul> <li>ESP32-S2, ESP32-C3 and ESP32-S3</li> </ul> <pre><code>espsecure.py encrypt_flash_data --aes_xts --keyfile &lt;FLASH_ENCRYPTION_KEY.bin&gt; --address &lt;FLASH_OFFSET&gt; --output &lt;OUTPUT_DATA&gt; &lt;INPUT_DATA&gt;\n</code></pre> <p>Note</p> <p>OTA updates are required to be sent plaintext. The reason is that, as said before, after the Flash Encryption is enabled all read/write operations are decrypted/encrypted in runtime, so as e.g. if pre-encrypted data is sent for an OTA update, it would be wrongly double-encrypted when the update agent writes to the flash.</p> <p>For updating with an image encrypted on the host, flash it through serial using <code>esptool.py</code> as above. UART ROM Download Mode must not be disabled.</p>"},{"location":"bootloader/docs/readme-espressif/#security-chain-scheme","title":"Security Chain scheme","text":"<p>Using the 3 features, Secure Boot, Image signature verification and Flash Encryption, a Security Chain can be established so only trusted code is executed, and also the code and content residing in the off-chip flash are protected against undesirable reading.</p> <p>The overall final process when all features are enabled:</p> <ol> <li>ROM bootloader validates the MCUboot bootloader using RSA signature verification.</li> <li>MCUboot bootloader validates the image using the chosen algorithm EC256/RSA/ED25519. It also    validates an upcoming image when updating.</li> <li>Flash Encryption guarantees that code and data are not exposed.</li> </ol>"},{"location":"bootloader/docs/readme-espressif/#size-limitation","title":"Size Limitation","text":"<p>When all 3 features are enable at same time, the bootloader size may exceed the fixed limit for the ROM bootloader checking on the Espressif chips depending on which algorithm was chosen for MCUboot image signing. The issue https://github.com/mcu-tools/mcuboot/issues/1262 was created to track this limitation.</p>"},{"location":"bootloader/docs/readme-espressif/#multi-image","title":"Multi image","text":"<p>The multi image feature (currently limited to 2 images) allows the images to be updated separately (each one has its own primary and secondary slot) by MCUboot.</p> <p>The Espressif port bootloader handles the boot in two different approaches:</p>"},{"location":"bootloader/docs/readme-espressif/#host-os-boots-second-image","title":"Host OS boots second image","text":"<p>Host OS from the first image is responsible for booting the second image, therefore the bootloader is aware of the second image regions and can update it, however it does not load neither boots it.</p> <p>Configuration example (<code>bootloader.conf</code>):</p> <pre><code>CONFIG_ESP_BOOTLOADER_SIZE=0xF000\nCONFIG_ESP_MCUBOOT_WDT_ENABLE=y\n\n# Enables multi image, if it is not defined, its assumed\n# only one updatable image\nCONFIG_ESP_IMAGE_NUMBER=2\n\n# Example of values to be used when multi image is enabled\n# Notice that the OS layer and update agent must be aware\n# of these regions\nCONFIG_ESP_APPLICATION_SIZE=0x50000\nCONFIG_ESP_IMAGE0_PRIMARY_START_ADDRESS=0x10000\nCONFIG_ESP_IMAGE0_SECONDARY_START_ADDRESS=0x60000\nCONFIG_ESP_IMAGE1_PRIMARY_START_ADDRESS=0xB0000\nCONFIG_ESP_IMAGE1_SECONDARY_START_ADDRESS=0x100000\nCONFIG_ESP_SCRATCH_OFFSET=0x150000\nCONFIG_ESP_SCRATCH_SIZE=0x40000\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#multi-boot","title":"Multi boot","text":"<p>In the multi boot approach the bootloader is responsible for booting two different images in two different CPUs, firstly the second image on the APP CPU and then the first image on the PRO CPU (current CPU), it is also responsible for update both images as well. Thus multi boot will be only supported by Espressif multi core chips - currently only ESP32 is implemented.</p> <p>Note</p> <p>The host OSes in each CPU must handle how the resources are divided/controlled between then.</p> <p>Configuration example:</p> <pre><code>CONFIG_ESP_BOOTLOADER_SIZE=0xF000\nCONFIG_ESP_MCUBOOT_WDT_ENABLE=y\n\n# Enables multi image, if it is not defined, its assumed\n# only one updatable image\nCONFIG_ESP_IMAGE_NUMBER=2\n\n# Enables multi image boot on independent processors\n# (main host OS is not responsible for booting the second image)\n# Use only with CONFIG_ESP_IMAGE_NUMBER=2\nCONFIG_ESP_MULTI_PROCESSOR_BOOT=y\n\n# Example of values to be used when multi image is enabled\n# Notice that the OS layer and update agent must be aware\n# of these regions\nCONFIG_ESP_APPLICATION_SIZE=0x50000\nCONFIG_ESP_IMAGE0_PRIMARY_START_ADDRESS=0x10000\nCONFIG_ESP_IMAGE0_SECONDARY_START_ADDRESS=0x60000\nCONFIG_ESP_IMAGE1_PRIMARY_START_ADDRESS=0xB0000\nCONFIG_ESP_IMAGE1_SECONDARY_START_ADDRESS=0x100000\nCONFIG_ESP_SCRATCH_OFFSET=0x150000\nCONFIG_ESP_SCRATCH_SIZE=0x40000\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#image-version-dependency","title":"Image version dependency","text":"<p>MCUboot allows version dependency check between the images when updating them. As <code>imgtool.py</code> allows a version assigment when signing an image, it is also possible to add the version dependency constraint:</p> <pre><code>imgtool.py sign --align 4 -v &lt;VERSION&gt; -d \"(&lt;IMAGE_INDEX&gt;, &lt;VERSION_DEPENDENCY&gt;)\" -H 32 --pad-header -S &lt;SLOT_SIZE&gt; &lt;BIN_IN&gt; &lt;SIGNED_BIN&gt;\n</code></pre> <ul> <li><code>&lt;VERSION&gt;</code> defines the version of the image being signed.</li> <li><code>\"(&lt;IMAGE_INDEX&gt;, &lt;VERSION_DEPENDENCY&gt;)\"</code> defines the minimum version and from which image is   needed to satisfy the dependency.</li> </ul> <p>Example:</p> <pre><code>imgtool.py sign --align 4 -v 1.0.0 -d \"(1, 0.0.1+0)\" -H 32 --pad-header -S 0x100000 image0.bin image0-signed.bin\n</code></pre> <p>Supposing that the image 0 is being signed, its version is 1.0.0 and it depends on image 1 with version at least 0.0.1+0.</p>"},{"location":"bootloader/docs/readme-espressif/#serial-recovery-mode","title":"Serial recovery mode","text":"<p>Serial recovery mode allows management through MCUMGR (more information and how to install it: https://github.com/apache/mynewt-mcumgr-cli) for communicating and uploading a firmware to the device.</p> <p>Configuration example:</p> <pre><code># Enables the MCUboot Serial Recovery, that allows the use of\n# MCUMGR to upload a firmware through the serial port\nCONFIG_ESP_MCUBOOT_SERIAL=y\n# GPIO used to boot on Serial Recovery\nCONFIG_ESP_SERIAL_BOOT_GPIO_DETECT=32\n# GPIO input type (0 for Pull-down, 1 for Pull-up)\nCONFIG_ESP_SERIAL_BOOT_GPIO_INPUT_TYPE=0\n# GPIO signal value\nCONFIG_ESP_SERIAL_BOOT_GPIO_DETECT_VAL=1\n# Delay time for identify the GPIO signal\nCONFIG_ESP_SERIAL_BOOT_DETECT_DELAY_S=5\n# UART port used for serial communication\nCONFIG_ESP_SERIAL_BOOT_UART_NUM=1\n# GPIO for Serial RX signal\nCONFIG_ESP_SERIAL_BOOT_GPIO_RX=25\n# GPIO for Serial TX signal\nCONFIG_ESP_SERIAL_BOOT_GPIO_TX=26\n</code></pre> <p>When enabled, the bootloader checks the if the GPIO <code>&lt;CONFIG_ESP_SERIAL_BOOT_GPIO_DETECT&gt;</code> configured has the signal value <code>&lt;CONFIG_ESP_SERIAL_BOOT_GPIO_DETECT_VAL&gt;</code> for approximately <code>&lt;CONFIG_ESP_SERIAL_BOOT_DETECT_DELAY_S&gt;</code> seconds for entering the Serial recovery mode. Example: a button configured on GPIO 32 pressed for 5 seconds.</p> <p>Serial mode then uses the UART port configured for communication (<code>&lt;CONFIG_ESP_SERIAL_BOOT_UART_NUM&gt;</code>, pins <code>&lt;CONFIG_ESP_SERIAL_BOOT_GPIO_RX&gt;</code>, <code>&lt;CONFIG_ESP_SERIAL_BOOT_GPIO_RX&gt;</code>).</p>"},{"location":"bootloader/docs/readme-espressif/#serial-recovery-through-usb-jtag-serial-port","title":"Serial Recovery through USB JTAG Serial port","text":"<p>Some chips, like ESP32-C3 and ESP32-S3 have an integrated USB JTAG Serial Controller that implements a serial port (CDC) that can also be used for handling MCUboot Serial Recovery. More information about the USB pins and hardware configuration:</p> <ul> <li>ESP32-C3: https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/usb-serial-jtag-console.html</li> <li>ESP32-S3: https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-guides/usb-serial-jtag-console.html</li> <li>ESP32-C6: https://docs.espressif.com/projects/esp-idf/en/latest/esp32c6/api-guides/usb-serial-jtag-console.html</li> <li>ESP32-H2: https://docs.espressif.com/projects/esp-idf/en/latest/esp32h2/api-guides/usb-serial-jtag-console.html</li> </ul> <p>Configuration example:</p> <pre><code># Use Serial through USB JTAG Serial port for Serial Recovery\nCONFIG_ESP_MCUBOOT_SERIAL_USB_SERIAL_JTAG=y\n# Use sector erasing (recommended) instead of entire image size\n# erasing when uploading through Serial Recovery\nCONFIG_ESP_MCUBOOT_ERASE_PROGRESSIVELY=y\n# GPIO used to boot on Serial Recovery\nCONFIG_ESP_SERIAL_BOOT_GPIO_DETECT=5\n# GPIO input type (0 for Pull-down, 1 for Pull-up)\nCONFIG_ESP_SERIAL_BOOT_GPIO_INPUT_TYPE=0\n# GPIO signal value\nCONFIG_ESP_SERIAL_BOOT_GPIO_DETECT_VAL=1\n# Delay time for identify the GPIO signal\nCONFIG_ESP_SERIAL_BOOT_DETECT_DELAY_S=5\n</code></pre> <p> ATTENTION</p> <p>When working with Flash Encryption enabled, <code>CONFIG_ESP_MCUBOOT_ERASE_PROGRESSIVELY</code> must be disabled, although it is recommended for common Serial Recovery usage</p>"},{"location":"bootloader/docs/readme-espressif/#mcumgr-image-upload-example","title":"MCUMGR image upload example","text":"<p>After entering the Serial recovery mode on the device, MCUMGR can be used as following:</p> <p>Configure the connection: <pre><code>mcumgr conn add esp type=\"serial\" connstring=\"dev=&lt;PORT&gt;,baud=115200,mtu=256\"\n</code></pre></p> <p>Upload the image (the process may take some time): <pre><code>mcumgr -c esp image upload &lt;IMAGE_BIN&gt;\n</code></pre></p> <p>Reset the device: <pre><code>mcumgr -c esp reset\n</code></pre></p> <p> ATTENTION</p> <p>Serial recovery mode uploads the image to the PRIMARY_SLOT, therefore if the upload process gets interrupted the image may be corrupted and unable to boot</p>"},{"location":"bootloader/docs/readme-espressif/#memory-map-organization-for-os-compatibility","title":"Memory map organization for OS compatibility","text":"<p>When adding support for this MCUboot port to an OS or even customizing an already supported application memory layout, it is mandatory for the OS linker script to avoid overlaping on <code>iram_loader_seg</code> and <code>dram_seg</code> bootloader RAM regions. Although part of the RAM becomes initially unavailable, it is reclaimable by the OS after boot as heap.</p> <p>Therefore, the application must be designed aware of the bootloader memory usage.</p> <p>Note</p> <p>Mostly of the Espressif chips have a separation on the address space for the same physical memory ammount: IRAM (accessed by the instruction bus) and DRAM (accessed by the data bus), which means that they need to be accessed by different addresses ranges depending on type, but refer to the same region. More information on the Espressif TRMs.</p> <p>The following diagrams illustrate a memory organization from the bootloader point of view (notice that the addresses and sizes may vary depending on the chip), they reflect the linker script <code>boot/espressif/port/&lt;TARGET&gt;/ld/bootloader.ld</code>:</p>"},{"location":"bootloader/docs/readme-espressif/#esp32","title":"ESP32","text":""},{"location":"bootloader/docs/readme-espressif/#esp32-standard","title":"ESP32 standard","text":"<pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40070000 / --------- - SRAM0 START\n *  |        ^                    |\n *  |        | PRO CPU Cache      |  *NOT CLAIMABLE BY OS RAM\n *  |        v                    |\n *  +--------+--------------+------+ 0x40078000 / ----------\n *  |        ^                    |\n *  |        |                    |  *NOT CLAIMABLE BY OS RAM\n *  |        | iram_loader_seg    |  *Region usable as iram_loader_seg during boot\n *  |        | (APP CPU Cache)    |   as APP CPU is not initialized yet\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40080000 / ----------\n *  |        ^                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        v                    |\n *  +------------------------------+ 0x40090000 / ----------\n *  |        ^                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40099000 / ----------\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +------------------------------+ 0x4009FFFF / ---------- - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +------------------------------+ 0x400A0000 / 0x3FFFFFFF - SRAM1 START\n *  |        ^                    |\n *  |        |                    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        | dram_seg           |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x400AB900 / 0x3FFF4700\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x400BFFFF / 0x3FFE0000 - SRAM1 END\n Note: On ESP32 the SRAM1 addresses are accessed in reverse order comparing Instruction\n bus (IRAM) and Data bus (DRAM), but refer to the same location. See the TRM for more\n information.\n\n  SRAM2\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ ---------- / 0x3FFAE000 - SRAM2 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ ---------- / 0x3FFDFFFF - SRAM2 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-multi-processor-boot","title":"ESP32 Multi Processor Boot","text":"<p>This is the linker script mapping when the <code>CONFIG_ESP_MULTI_PROCESSOR_BOOT</code> is enabled (Multi boot) since APP CPU Cache region cannot be used for <code>iram_loader_seg</code> region as there would be conflict when the bootloader starts the APP CPU before jump to the main application.</p> <pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40070000 / --------- - SRAM0 START\n *  |        ^                    |\n *  |        |                    |\n *  |        | Cache              |  *Used by PRO CPU and APP CPU as Cache\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40080000 / ----------\n *  |        ^                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        v                    |\n *  +------------------------------+ 0x40090000 / ----------\n *  |        ^                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40099000 / ----------\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +------------------------------+ 0x4009FFFF / ---------- - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +------------------------------+ 0x400A0000 / 0x3FFFFFFF - SRAM1 START\n *  |        ^                    |\n *  |        |                    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        | dram_seg           |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x400AB900 / 0x3FFF4700\n *  |        ^                    |\n *  |        |                    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        | iram_loader_seg    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x400B1E00 / 0x3FFEE200\n *  |        ^                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x400BFFFF / 0x3FFE0000 - SRAM1 END\n Note: On ESP32 the SRAM1 addresses are accessed in reverse order comparing Instruction\n bus (IRAM) and Data bus (DRAM), but refer to the same location. See the TRM for more\n information.\n\n  SRAM2\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ ---------- / 0x3FFAE000 - SRAM2 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ ---------- / 0x3FFDFFFF - SRAM2 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-s2","title":"ESP32-S2","text":"<pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40020000 / 0x3FFB0000 - SRAM0 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ 0x40027FFF / 0x3FFB7FFF - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40028000 / 0x3FFB8000 - SRAM1 START\n *  |        ^                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40047000 / 0x3FFD7000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40050000 / 0x3FFE0000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40056000 / 0x3FFE6000\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x4006FFFF / 0x3FFFFFFF - SRAM1 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-s3","title":"ESP32-S3","text":"<pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40370000 / ---------- - SRAM0 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ 0x40377FFF / ---------- - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40378000 / 0x3FC88000 - SRAM1 START\n *  |        ^                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x403B0000 / 0x3FCC0000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403BA000 / 0x3FCCA000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403C0000 / 0x3FCD0000\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x403DFFFF / 0x3FCEFFFF - SRAM1 END\n\n  SRAM2\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ ---------- / 0x3FCF0000 - SRAM2 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ ---------- / 0x3FCFFFFF - SRAM2 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-c2","title":"ESP32-C2","text":"<pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x4037C000 / ---------- - SRAM0 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ 0x4037FFFF / ---------- - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40380000 / 0x3FCA0000 - SRAM1 START\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x403A1370 / 0x3FCC1370\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403A9B70 / 0x3FCC9B70\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403B0B70 / 0x3FCD0B70\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x403BFFFF / 0x3FCDFFFF - SRAM1 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-c3","title":"ESP32-C3","text":"<pre><code>  SRAM0\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x4037C000 / ---------- - SRAM0 START\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  +--------+--------------+------+ 0x4037FFFF / ---------- - SRAM0 END\n\n  SRAM1\n                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40380000 / 0x3FC80000 - SRAM1 START\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x403C7000 / 0x3FCC7000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403D0000 / 0x3FCD0000\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x403D5400 / 0x3FCD5400\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x403DFFFF / 0x3FCDFFFF - SRAM1 END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-c6","title":"ESP32-C6","text":"<pre><code>                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40800000 / 0x40800000 - HP SRAM START\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x40860610 / 0x40860610\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40869610 / 0x40869610\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40870610 / 0x40870610\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x4087FFFF / 0x4087FFFF - HP SRAM END\n</code></pre>"},{"location":"bootloader/docs/readme-espressif/#esp32-h2","title":"ESP32-H2","text":"<pre><code>                                     IRAM ADDR  / DRAM ADDR\n *  +--------+--------------+------+ 0x40800000 / 0x40800000 - HP SRAM START\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | FREE               |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +--------+--------------+------+ 0x408317D0 / 0x408317D0\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_seg           |  *CLAIMABLE BY OS RAM\n *  |        |                    |\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40839FD0 / 0x40839FD0\n *  |        ^                    |\n *  |        |                    |\n *  |        |                    |\n *  |        | iram_loader_seg    |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        |                    |\n *  |        v                    |\n *  +------------------------------+ 0x40840FD0 / 0x40840FD0\n *  |        ^                    |\n *  |        |                    |\n *  |        | dram_seg           |  *** SHOULD NOT BE OVERLAPPED ***\n *  |        |                    |  *** OS CAN RECLAIM IT AFTER BOOT LATER AS HEAP ***\n *  |        v                    |\n *  +--------+--------------+------+ 0x4084FFFF / 0x4084FFFF - HP SRAM END\n</code></pre>"},{"location":"bootloader/docs/readme-mbed/","title":"MCUboot port for Mbed OS","text":"<p>This is an MCUboot port for Mbed OS.</p>"},{"location":"bootloader/docs/readme-mbed/#using-mcuboot","title":"Using MCUboot","text":"<p>Note: The following is a general overview. It does not cover MCUboot or Mbed OS basics.</p> <p>See https://github.com/AGlass0fMilk/mbed-mcuboot-demo as a detailed example.</p>"},{"location":"bootloader/docs/readme-mbed/#basic-configurations","title":"Basic configurations","text":"<p>To use MCUboot, you need to create an Mbed OS project with the following configurations: * <code>\"mcuboot.primary-slot-address\"</code>: address of the primary slot in the internal flash * <code>\"mcuboot.slot-size\"</code>: size of an image slot (only one image, two slots are currently supported) * <code>\"mcuboot.max-img-sectors\"</code>: maximum number of sectors, should be at least the number of sectors in each slot * <code>\"target.restrict_size\"</code>: the maximum size of the bootloader, such that it does not overlap with the primary slot</p> <p>More configurations such as signing algorithm, slot swapping, etc. can be found in mbed_lib.json. Please note that certain features are not currently supported.</p>"},{"location":"bootloader/docs/readme-mbed/#providing-a-secondary-slot","title":"Providing a secondary slot","text":"<p>You need to provide an instance of <code>mbed::BlockDevice</code> as the secondary slot. It can be any types of internal or external storage provided that: * Its size equals the <code>\"mcuboot.slot-size\"</code> you have set * Its minimum supported read and write sizes (granularities) are no larger than 16 byte, which MCUboot's read/write operations are aligned to. If the read size is larger than one byte, you need to set <code>\"mcuboot.read-granularity\"</code> to the read size of the storage - this buffers smaller read operations.</p> <p>In order for MCUboot to access your secondary slot, the interface to implement is <pre><code>mbed::BlockDevice* get_secondary_bd(void);\n</code></pre> which should return an uninitialized instance of BlockDevice.</p>"},{"location":"bootloader/docs/readme-mbed/#building-the-bootloader","title":"Building the bootloader","text":"<p>To build a bootloader based on MCUboot, make sure <code>\"mcuboot.bootloader-build\"</code> is <code>true</code> (already the default) and you have provided configurations and a secondary slot BlockDevice as explained above.</p>"},{"location":"bootloader/docs/readme-mbed/#building-a-user-application","title":"Building a user application","text":"<p>To build a user application, set <code>\"mcuboot.bootloader-build\"</code> to <code>false</code> so MCUboot is built as a library only without a bootloader application. This is useful if your user application needs to confirm the current image with <code>boot_set_confirmed()</code> after an update, or set a new image in the secondary slot as pending with <code>boot_set_pending()</code> in order to trigger an update upon reboot.</p> <p>As your application starts in the primary slots (instead of the beginning of the whole flash), you need to set the start address (<code>\"target.mbed_app_start\"</code>) to be equal to <code>\"mcuboot.primary-slot-address\"</code> + <code>\"mcuboot.header-size\"</code> of your bootloader. And its size (<code>\"target.mbed_app_size\"</code>) must be no larger than <code>\"mcuboot.slot-size\"</code> - <code>\"mcuboot.header-size\"</code>, and some space must be left for the image trailer too (see this).</p>"},{"location":"bootloader/docs/readme-mynewt/","title":"Running mynewt apps with MCUboot","text":"<p>Due to small differences between Mynewt's bundled bootloader and MCUboot, when building an app that will be run with MCUboot as the bootloader and which at the same time requires to use <code>newtmgr</code> to manage images, MCUboot must be added as a new dependency for this app.</p> <p>First you need to add the repo to your <code>project.yml</code>:</p> <pre><code>    project.repositories:\n        - mcuboot\n\n    repository.mcuboot:\n        type: github\n        vers: 0-dev\n        user: mcu-tools\n        repo: mcuboot\n</code></pre> <p>Then update your app's <code>pkg.yml</code> adding the extra dependency:</p> <pre><code>    pkg.deps:\n        - \"@mcuboot/boot/bootutil\"\n</code></pre> <p>Also remove any dependency on <code>boot/bootutil</code> (mynewt's bundled bootloader) which might exist.</p> <p>To configure MCUboot check all the options available in <code>boot/mynewt/mcuboot_config/syscfg.yml</code>.</p> <p>Also, MCUboot uses a different image header struct as well as slightly different TLV structure, so images created by <code>newt</code> have to be generated in this new format. That is done by passing the extra parameter <code>-2</code> as in:</p> <p><code>newt create-image &lt;target&gt; &lt;version&gt; &lt;pubkey&gt; -2</code></p>"},{"location":"bootloader/docs/readme-mynewt/#boot-serial-functionality-with-mynewt","title":"Boot serial functionality with Mynewt","text":"<p>Building with <code>BOOT_SERIAL: 1</code> enables some basic management functionality like listing images and uploading a new image to <code>slot0</code>. The serial bootloader requires that <code>mtu</code> is set to a value that is less than or equal to <code>256</code>. This can be done either by editing <code>~/.newtmgr.cp.json</code> and setting the <code>mtu</code> for the connection profile, or specifying you connection string manually as in:</p> <pre><code>newtmgr --conntype serial --connstring \"dev=/dev/ttyUSB0,mtu=256\" image upload -e blinky.img\n</code></pre> <p>where <code>/dev/ttyUSB0</code> is your serial port.</p>"},{"location":"bootloader/docs/readme-nuttx/","title":"MCUboot port for NuttX","text":""},{"location":"bootloader/docs/readme-nuttx/#description","title":"Description","text":"<p>The NuttX port of MCUboot secure boot library expects that the platform provides a Flash storage with the following partitions: - <code>CONFIG_MCUBOOT_PRIMARY_SLOT_PATH</code>: MTD partition for the application firmware image PRIMARY slot; - <code>CONFIG_MCUBOOT_SECONDARY_SLOT_PATH</code>: MTD partition for the application firmware image SECONDARY slot; - <code>CONFIG_MCUBOOT_SCRATCH_PATH</code>: MTD partition for the Scratch area;</p> <p>Also, these are optional features that may be enabled:</p> <ul> <li><code>CONFIG_MCUBOOT_WATCHDOG</code>: If <code>CONFIG_WATCHDOG</code> is enabled, MCUboot shall reset the watchdog timer indicated by <code>CONFIG_MCUBOOT_WATCHDOG_DEVPATH</code> to the current timeout value, preventing any imminent watchdog timeouts.</li> </ul> <p>The porting layer of MCUboot library consists of the following interfaces: - <code>&lt;flash_map_backend/flash_map_backend.h&gt;</code>, for enabling MCUboot to manage the application firmware image slots in the device storage. - <code>&lt;mcuboot_config/mcuboot_config.h&gt;</code>, for configuration of MCUboot's features. - <code>&lt;mcuboot_config/mcuboot_logging.h&gt;</code>, for providing logging capabilities. - <code>&lt;os/os_malloc.h&gt;</code>, for providing MCUboot access to the OS memory management interfaces. - <code>&lt;sysflash/sysflash.h&gt;</code>, for configuration of the system's flash area organization.</p> <p>The NuttX port of MCUboot is implemented at application-level and requires minimal knowledge about characteristics of the underlying storage device. This is achieved by means of the <code>BCH</code> and <code>FTL</code> subsystems, which enable MCUboot to manage MTD partitions via character device drivers using standard POSIX filesystem operations (e.g. <code>open()</code> / <code>close()</code> / <code>read()</code> / <code>write()</code>).</p>"},{"location":"bootloader/docs/readme-nuttx/#creating-mcuboot-compatible-application-firmware-images","title":"Creating MCUboot-compatible application firmware images","text":"<p>One common use case for MCUboot is to integrate it to a firmware update agent, which is an important component of a secure firmware update subsystem. Through MCUboot APIs an application is able to install a newly received application firmware image and, once this application firmware image is assured to be valid, the application may confirm it as a stable image. In case that application firmware image is deemed bogus, MCUboot provides an API for invalidating that update, which will induce a rollback procedure to the most recent stable application firmware image.</p> <p>The <code>CONFIG_MCUBOOT_UPDATE_AGENT_EXAMPLE</code> example demonstrates this workflow by downloading an application firmware image from a webserver, installing it and triggering the firmware update process for the next boot after a system reset. There is also the <code>CONFIG_MCUBOOT_SLOT_CONFIRM_EXAMPLE</code>, which is a fairly simple example that just calls an MCUboot API for confirming the executing application firmware image as stable.</p>"},{"location":"bootloader/docs/readme-nuttx/#using-mcuboot-on-nuttx-as-a-secure-boot-solution","title":"Using MCUboot on NuttX as a secure boot solution","text":"<p>NuttX port for MCUboot also enables the creation of a secure bootloader application requiring minimal platform-specific implementation. The logical implementation for the secure boot is performed at application-level by the MCUboot library. Once MCUboot validates the application firmware image, it delegates the loading and execution of the application firmware image to a platform-specific routine, which is accessed via <code>boardctl(BOARDIOC_BOOT_IMAGE)</code> call. Each platform must then provide an implementation for the <code>board_boot_image()</code> for executing the required actions in order to boot a new application firmware image (e.g. deinitialize peripherals, load the Program Counter register with the application firmware image entry point address).</p> <p>The MCUboot bootloader application may be enabled by selecting the <code>CONFIG_MCUBOOT_BOOTLOADER</code> option.</p>"},{"location":"bootloader/docs/readme-nuttx/#assumptions","title":"Assumptions","text":""},{"location":"bootloader/docs/readme-nuttx/#ioctl-mtd-commands","title":"IOCTL MTD commands","text":"<p>The implementation of <code>&lt;flash_map_backend/flash_map_backend.h&gt;</code> expects that the MTD driver for a given image partition handles the following <code>ioctl</code> commands: - <code>MTDIOC_GEOMETRY</code>, for retrieving information about the geometry of the MTD, required for the configuration of the size of each flash area. - <code>MTDIOC_ERASESTATE</code>, for retrieving the byte value of an erased cell of the MTD, required for the implementation of <code>flash_area_erased_val()</code> interface.</p>"},{"location":"bootloader/docs/readme-nuttx/#write-access-alignment","title":"Write access alignment","text":"<p>Through <code>flash_area_align()</code> interface MCUboot expects that the implementation provides the shortest data length that may be written via <code>flash_area_write()</code> interface. The NuttX implementation passes through the <code>BCH</code> and <code>FTL</code> layers, which appropriately handle the write alignment restrictions of the underlying MTD. So The NuttX implementation of <code>flash_area_align()</code> is able to return a fixed value of 1 byte, even if the MTD does not support byte operations.</p>"},{"location":"bootloader/docs/readme-nuttx/#limitations","title":"Limitations","text":""},{"location":"bootloader/docs/readme-nuttx/#flash_map_backendflash_map_backendh-functions-are-not-multitasking-safe","title":"<code>&lt;flash_map_backend/flash_map_backend.h&gt;</code> functions are not multitasking-safe","text":"<p>MCUboot's documentation imposes no restrictions regarding the usage of its public interfaces, which doesn't mean they are thread-safe. But, regarding NuttX implementation of the <code>&lt;flash_map_backend/flash_map_backend.h&gt;</code>, it is safe to state that they are not multitasking-safe. NuttX implementation manages the MTD partitions via character device drivers. As file-descriptors cannot be shared between different tasks, if one task calls <code>flash_area_open</code> and another task calls <code>flash_area_&lt;read/write/close&gt;</code> passing the same <code>struct flash_area</code> instance, it will result in failure.</p>"},{"location":"bootloader/docs/readme-riot/","title":"Building and using MCUboot with RIOT","text":"<p>MCUboot began its life as the bootloader for Mynewt.  It has since acquired the ability to be used as a bootloader for RIOT as well. Currently the support is limited to the nrf52dk platform.</p>"},{"location":"bootloader/docs/readme-riot/#building-the-bootloader-itself","title":"Building the bootloader itself","text":"<p>In this first version, a prebuilt Mynewt binary is downloaded at compile time.  This binary was compiled to do an integrity check, but not a signature check. In order to configure the bootloader for signature check it is necessary to re-compile it either with Mynewt or Zephyr, following the provided instructions.</p> <p>In the next version, it is planned to compile MCUboot using RIOT, which should be able to boot any of the supported OS images.</p>"},{"location":"bootloader/docs/readme-riot/#building-applications-for-the-bootloader","title":"Building applications for the bootloader","text":"<p>A compatible MCUboot image can be compiled by typing: <code>make mcuboot</code>.</p> <p>The only variable which needs to be set is <code>IMAGE_VERSION</code> loaded with a valid formatted value. The format is <code>major.minor.patch+other</code> (e.g. <code>export IMAGE_VERSION= 1.1.1+1</code>. This variable can be either exported in the Makefile or manually, prior to the compilation process.</p> <p>The goal is to produce an ELF file which is linked to be flashed at a <code>BOOTLOADER_OFFSET</code> offset rather than the beginning of ROM.  MCUboot also expects an image padded with some specific headers containing the version information, and trailer type-length-value records (TLVs) with hash and signing information. This is done through the imgtool.py application, which is executed automatically by the RIOT build system.</p>"},{"location":"bootloader/docs/readme-riot/#signing-the-application","title":"Signing the application","text":"<p>The application will be automatically signed with the provided key. If no key is provided, a new key will be automatically generated. The default key type is RSA-2048.</p> <p>In order to use your provided key, you need to recompile the bootloader using you public key, either in Zephyr or Mynewt by following the provided procedure for the selected OS.</p>"},{"location":"bootloader/docs/readme-riot/#flashing-the-application","title":"Flashing the application","text":"<p>The application can be flashed by typing: <code>make flash-mcuboot</code>. This will flash both the bootloader and the application.</p>"},{"location":"bootloader/docs/readme-zephyr/","title":"Building and using MCUboot with Zephyr","text":"<p>MCUboot began its life as the bootloader for Mynewt.  It has since acquired the ability to be used as a bootloader for Zephyr as well. There are some pretty significant differences in how apps are built for Zephyr, and these are documented here.</p> <p>Please see the design document for documentation on the design and operation of the bootloader itself. This functionality should be the same on all supported RTOSs.</p> <p>The first step required for Zephyr is making sure your board has flash partitions defined in its device tree. These partitions are:</p> <ul> <li><code>boot_partition</code>: for MCUboot itself</li> <li><code>slot0_partition</code>: the primary slot of Image 0</li> <li><code>slot1_partition</code>: the secondary slot of Image 0</li> </ul> <p>It is not recommended to use the swap-using-scratch algorithm of MCUboot, but if this operating mode is desired then the following flash partition is also needed (see end of this help file for details on creating a scratch partition and how to use the swap-using-scratch algorithm):</p> <ul> <li><code>scratch_partition</code>: the scratch slot</li> </ul> <p>Currently, the two image slots must be contiguous. If you are running MCUboot as your stage 1 bootloader, <code>boot_partition</code> must be configured so your SoC runs it out of reset. If there are multiple updateable images then the corresponding primary and secondary partitions must be defined for the rest of the images too (for example, <code>slot2_partition</code> and <code>slot3_partition</code> for Image 1).</p> <p>The flash partitions are typically defined in the Zephyr boards folder, in a file named <code>boards/&lt;arch&gt;/&lt;board&gt;/&lt;board&gt;.dts</code>. An example <code>.dts</code> file with flash partitions defined is the frdm_k64f's in <code>boards/arm/frdm_k64f/frdm_k64f.dts</code>. Make sure the DT node labels in your board's <code>.dts</code> file match the ones used there.</p>"},{"location":"bootloader/docs/readme-zephyr/#installing-requirements-and-dependencies","title":"Installing requirements and dependencies","text":"<p>Install additional packages required for development with MCUboot:</p> <pre><code>  cd ~/mcuboot  # or to your directory where MCUboot is cloned\n  pip3 install --user -r scripts/requirements.txt\n</code></pre>"},{"location":"bootloader/docs/readme-zephyr/#building-the-bootloader-itself","title":"Building the bootloader itself","text":"<p>The bootloader is an ordinary Zephyr application, at least from Zephyr's point of view.  There is a bit of configuration that needs to be made before building it.  Most of this can be done as documented in the <code>CMakeLists.txt</code> file in boot/zephyr.  There are comments there for guidance.  It is important to select a signature algorithm, and decide if the primary slot should be validated on every boot.</p> <p>To build MCUboot, create a build directory in boot/zephyr, and build it as usual:</p> <pre><code>  cd boot/zephyr\n  west build -b &lt;board&gt;\n</code></pre> <p>In addition to the partitions defined in DTS, some additional information about the flash layout is currently required to build MCUboot itself. All the needed configuration is collected in <code>boot/zephyr/include/target.h</code>. Depending on the board, this information may come from board-specific headers, Device Tree, or be configured by MCUboot on a per-SoC family basis.</p> <p>After building the bootloader, the binaries should reside in <code>build/zephyr/zephyr.{bin,hex,elf}</code>, where <code>build</code> is the build directory you chose when running <code>west build</code>. Use <code>west flash</code> to flash these binaries from the build directory. Depending on the target and flash tool used, this might erase the whole of the flash memory (mass erase) or only the sectors where the bootloader resides prior to programming the bootloader image itself.</p>"},{"location":"bootloader/docs/readme-zephyr/#building-applications-for-the-bootloader","title":"Building applications for the bootloader","text":"<p>In addition to flash partitions in DTS, some additional configuration is required to build applications for MCUboot.</p> <p>This is handled internally by the Zephyr configuration system and is wrapped in the <code>CONFIG_BOOTLOADER_MCUBOOT</code> Kconfig variable, which must be enabled in the application's <code>prj.conf</code> file.</p> <p>The directory <code>samples/zephyr/hello-world</code> in the MCUboot tree contains a simple application with everything you need. You can try it on your board and then just make a copy of it to get started on your own application; see samples/zephyr/README.md for a tutorial.</p> <p>The Zephyr <code>CONFIG_BOOTLOADER_MCUBOOT</code> configuration option documentation provides additional details regarding the changes it makes to the image placement and generation in order for an application to be bootable by MCUboot.</p> <p>With this, build the application as your normally would.</p>"},{"location":"bootloader/docs/readme-zephyr/#signing-the-application","title":"Signing the application","text":"<p>In order to upgrade to an image (or even boot it, if <code>MCUBOOT_VALIDATE_PRIMARY_SLOT</code> is enabled), the images must be signed. To make development easier, MCUboot is distributed with some example keys.  It is important to stress that these should never be used for production, since the private key is publicly available in this repository.  See below on how to make your own signatures.</p> <p>Images can be signed with the <code>scripts/imgtool.py</code> script.  It is best to look at <code>samples/zephyr/Makefile</code> for examples on how to use this.</p>"},{"location":"bootloader/docs/readme-zephyr/#flashing-the-application","title":"Flashing the application","text":"<p>The application itself can flashed with regular flash tools, but will need to be programmed at the offset of the primary slot for this particular target. Depending on the platform and flash tool you might need to manually specify a flash offset corresponding to the primary slot starting address. This is usually not relevant for flash tools that use Intel Hex images (.hex) instead of raw binary images (.bin) since the former include destination address information. Additionally you will need to make sure that the flash tool does not perform a mass erase (erasing the whole of the flash) or else you would be deleting MCUboot. These images can also be marked for upgrade, and loaded into the secondary slot, at which point the bootloader should perform an upgrade.  It is up to the image to mark the primary slot as \"image ok\" before the next reboot, otherwise the bootloader will revert the application.</p>"},{"location":"bootloader/docs/readme-zephyr/#managing-signing-keys","title":"Managing signing keys","text":"<p>The signing keys used by MCUboot are represented in standard formats, and can be generated and processed using conventional tools.  However, <code>scripts/imgtool.py</code> is able to generate key pairs in all of the supported formats.  See the docs for more details on this tool.</p>"},{"location":"bootloader/docs/readme-zephyr/#generating-a-new-keypair","title":"Generating a new keypair","text":"<p>Generating a keypair with imgtool is a matter of running the keygen subcommand:</p> <pre><code>    $ ./scripts/imgtool.py keygen -k mykey.pem -t rsa-2048\n</code></pre> <p>The argument to <code>-t</code> should be the desired key type.  See the the docs for more details on the possible key types.</p>"},{"location":"bootloader/docs/readme-zephyr/#extracting-the-public-key","title":"Extracting the public key","text":"<p>The generated keypair above contains both the public and the private key.  It is necessary to extract the public key and insert it into the bootloader.  Use the <code>CONFIG_BOOT_SIGNATURE_KEY_FILE</code> Kconfig option to provide the path to the key file so the build system can extract the public key in a format usable by the C compiler. The generated public key is saved in <code>build/zephyr/autogen-pubkey.h</code>, which is included by the <code>boot/zephyr/keys.c</code>.</p> <p>Currently, the Zephyr RTOS port limits its support to one keypair at the time, although MCUboot's key management infrastructure supports multiple keypairs.</p> <p>Once MCUboot is built, this new keypair file (<code>mykey.pem</code> in this example) can be used to sign images.</p>"},{"location":"bootloader/docs/readme-zephyr/#using-swap-using-scratch-flash-algorithm","title":"Using swap-using-scratch flash algorithm","text":"<p>To use the swap-using-scratch flash algorithm, a scratch partition needs to be present for the target board which is used for holding the data being swapped from both slots, this section must be at least as big as the largest sector size of the 2 partitions (e.g. if a device has a primary slot in main flash with a sector size of 512 bytes and secondar slot in external off-chip flash with a sector size of 4KB then the scratch area must be at least 4KB in size). The number of sectors must also be evenly divisable by this sector size, e.g. 4KB, 8KB, 12KB, 16KB are allowed, 7KB, 7.5KB are not. This scratch partition needs adding to the .dts file for the board, e.g. for the nrf52dk_nrf52832 board thus would involve updating <code>&lt;zephyr&gt;/boards/arm/nrf52dk_nrf52832/nrf52dk_nrf52832.dts</code> with:</p> <pre><code>    boot_partition: partition@0 {\n        label = \"mcuboot\";\n        reg = &lt;0x00000000 0xc000&gt;;\n    };\n    slot0_partition: partition@c000 {\n        label = \"image-0\";\n        reg = &lt;0x0000C000 0x37000&gt;;\n    };\n    slot1_partition: partition@43000 {\n        label = \"image-1\";\n        reg = &lt;0x00043000 0x37000&gt;;\n    };\n    storage_partition: partition@7a000 {\n        label = \"storage\";\n        reg = &lt;0x0007a000 0x00006000&gt;;\n    };\n</code></pre> <p>Which would make the application size 220KB and scratch size 24KB (the nRF52832 has a 4KB sector size so the size of the scratch partition can be reduced at the cost of vastly reducing flash lifespan, e.g. for a 32KB firmware update with an 8KB scratch area, the scratch area would be erased and programmed 8 times per image upgrade/revert). To configure MCUboot to work in swap-using-scratch mode, the Kconfig value must be set when building it: <code>CONFIG_BOOT_SWAP_USING_SCRATCH=y</code>.</p> <p>Note that it is possible for an application to get into a stuck state when swap-using-scratch is used whereby an application has loaded a firmware update and marked it as test/confirmed but MCUboot will not swap the images and erasing the secondary slot from the zephyr application returns an error because the slot is marked for upgrade.</p>"},{"location":"bootloader/docs/readme-zephyr/#serial-recovery","title":"Serial recovery","text":""},{"location":"bootloader/docs/readme-zephyr/#interface-selection","title":"Interface selection","text":"<p>A serial recovery protocol is available over either a hardware serial port or a USB CDC ACM virtual serial port. The SMP server implementation can be enabled by the <code>CONFIG_MCUBOOT_SERIAL=y</code> Kconfig option. To set a type of an interface, use the <code>BOOT_SERIAL_DEVICE</code> Kconfig choice, and select either the <code>CONFIG_BOOT_SERIAL_UART</code> or the <code>CONFIG_BOOT_SERIAL_CDC_ACM</code> value. Which interface belongs to the protocol shall be set by the devicetree-chosen node: - <code>zephyr,console</code> - If a hardware serial port is used. - <code>zephyr,cdc-acm-uart</code> - If a virtual serial port is used.</p>"},{"location":"bootloader/docs/readme-zephyr/#entering-the-serial-recovery-mode","title":"Entering the serial recovery mode","text":"<p>To enter the serial recovery mode, the device has to initiate rebooting, and a triggering event has to occur (for example, pressing a button).</p> <p>By default, the serial recovery GPIO pin active state enters the serial recovery mode. Use the <code>mcuboot_button0</code> devicetree button alias to assign the GPIO pin to the MCUboot.</p> <p>Alternatively, MCUboot can wait for a limited time to check if DFU is invoked by receiving an MCUmgr command. Select <code>CONFIG_BOOT_SERIAL_WAIT_FOR_DFU=y</code> to use this mode. <code>CONFIG_BOOT_SERIAL_WAIT_FOR_DFU_TIMEOUT</code> option defines the amount of time in milliseconds the device will wait for the trigger.</p>"},{"location":"bootloader/docs/readme-zephyr/#direct-image-upload","title":"Direct image upload","text":"<p>By default, the SMP server implementation will only use the first slot. To change it, invoke the <code>image upload</code> MCUmgr command with a selected image number, and make sure the <code>CONFIG_MCUBOOT_SERIAL_DIRECT_IMAGE_UPLOAD=y</code> Kconfig option is enabled. Note that the <code>CONFIG_UPDATEABLE_IMAGE_NUMBER</code> Kconfig option adjusts the number of image-pairs supported by the MCUboot.</p> <p>The mapping of image number to partition is as follows: * 0 and 1 - image-0, the primary slot of the first image. * 2 - image-1, the secondary slot of the first image. * 3 - image-2. * 4 - image-3.</p> <p>0 is a default upload target when no explicit selection is done.</p>"},{"location":"bootloader/docs/readme-zephyr/#system-specific-commands","title":"System-specific commands","text":"<p>Use the <code>CONFIG_ENABLE_MGMT_PERUSER=y</code> Kconfig option to enable the following additional commands: * Storage erase - This command allows erasing the storage partition (enable with <code>CONFIG_BOOT_MGMT_CUSTOM_STORAGE_ERASE=y</code>). * Custom image list - This command allows fetching version and installation status (custom properties) for all images (enable with <code>CONFIG_BOOT_MGMT_CUSTOM_IMG_LIST=y</code>).</p>"},{"location":"bootloader/docs/readme-zephyr/#more-configuration","title":"More configuration","text":"<p>For details on other available configuration options for the serial recovery protocol, check the Kconfig options  (for example by using <code>menuconfig</code>).</p>"},{"location":"bootloader/docs/release-notes/","title":"MCUboot release notes","text":"<ul> <li>Table of Contents</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-200","title":"Version 2.0.0","text":"<p>Note that this release, 2.0.0 is a new major number, and contains a small API change in the interface between mcuboot and the platform.  All platforms contained within the MCUboot tree have been updated, but any external platforms will have to be adjusted.  The following commit makes the API change, in the function <code>boot_save_shared_data</code>.</p> <pre><code>commit 3016d00cd765e7c09a14af55fb4dcad945e4b982\nAuthor: Jamie McCrae &lt;jamie.mccrae@nordicsemi.no&gt;\nDate:   Tue Mar 14 12:35:51 2023 +0000\n\n    bootutil: Add active slot number and max app size to shared data\n</code></pre>"},{"location":"bootloader/docs/release-notes/#about-this-release","title":"About this release","text":"<ul> <li>Add error when flash device fails to open.</li> <li>Panic bootloader when flash device fails to open.</li> <li>Fixed issue with serial recovery not showing image details for   decrypted images.</li> <li>Fixes issue with serial recovery in single slot mode wrongly   iterating over 2 image slots.</li> <li>CDDL auto-generated function code has been replaced with zcbor function   calls, this now allows the parameters to be supplied in any order.</li> <li>Added currently running slot ID and maximum application size to   shared data function definition.</li> <li>Make the ECDSA256 TLV curve agnostic and rename it to ECDSA_SIG.</li> <li>imgtool: add P384 support along with SHA384.</li> <li>espressif: refactor after removing IDF submodule</li> <li>espressif: add ESP32-C6, ESP32-C2 and ESP32-H2 new chips support</li> <li>espressif: adjustments after IDF v5.1 compatibility, secure boot build and memory map organization</li> <li>Serial recovery image state and image set state optional commands added</li> <li>imgtool: add 'dumpinfo' command for signed image parsing.</li> <li>imgtool: add 'getpubhash' command to dump the sha256 hash of the public key</li> <li>imgtool's getpub can print the output to a file</li> <li>imgtool can dump the raw versions of the public keys</li> <li>Drop ECDSA P224 support</li> <li>Fixed an issue with boot_serial repeats not being processed when   output was sent, this would lead to a divergence of commands   whereby later commands being sent would have the previous command   output sent instead.</li> <li>Fixed an issue with the boot_serial zcbor setup encoder function   wrongly including the buffer address in the size which caused   serial recovery to fail on some platforms.</li> <li>zcbor library files have been updated to version 0.7.0</li> <li>Reworked boot serial extensions so that they can be used by modules   or from user repositories by switching to iterable sections.</li> <li>Removed Zephyr custom img list boot serial extension support.</li> <li>(Zephyr) Adds support for sharing boot information with   application via retention subsystem</li> <li>Zephyr no longer builds in optimize for debug mode, this saves a   significant amount of flash space.</li> <li>Reworked image encryption support for Zephyr, static dummy key files   are no longer in the code, a pem file must be supplied to extract   the private and public keys. The Kconfig menu has changed to only   show a single option for enabling encryption and selecting the key   file.</li> <li>Serial recovery can now read and handle encrypted seondary slot   partitions.</li> <li>Serial recovery with MBEDTLS no longer has undefined operations which   led to usage faults when the secondary slot image was encrypted.</li> <li>espressif: allow the use of a different toolchain for building</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-1100","title":"Version 1.10.0","text":"<p>The 1.10.0 release of MCUboot contains...</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_1","title":"About this release","text":"<ul> <li>Various fixes to boot serial.</li> <li>Various fixes to the mbed target.</li> <li>Various fixes to the Espressif native target.</li> <li>Various fixes to the Zephyr target.</li> <li>Workflow improvements with Zephyr CI.</li> <li>Add multi image support to the espressif esp32 target.</li> <li>Improvements and corrections to the simulator.</li> <li>Improve imgtool, including adding 3rd party signing support.</li> <li>Various fixes to the mynewt target.</li> <li>Various fixes to the nuttx target.</li> <li>Dates to dependencies for doc generation.</li> <li>Add downgrade prevention for modes using swap.</li> <li>Various general fixes to the boot code.</li> <li>Prefer swap move on zephyr if the scratch partition is not enabled.</li> <li>Upgrade fault-injection hardening, improving cases injections are detected.</li> <li>Add a new flash api <code>flash_area_get_sector</code>, along with support for each   target, that replaces <code>flash_area_sector_from_off</code>. This is a step in cleaning   up the flash API used by MCUboot.</li> </ul>"},{"location":"bootloader/docs/release-notes/#security-fixes","title":"Security fixes","text":"<p>There are no security vulnerabilities reported on the MCUboot code for this release. There have been several updates to the dependencies in the Ruby code used to generate the documentation. This should only affect users that generate their own documentation.</p>"},{"location":"bootloader/docs/release-notes/#version-190","title":"Version 1.9.0","text":"<p>The 1.9.0 release of MCUboot contains various bug fixes, improves support on some recent targets, and adds support for devices with a write alignment larger than 8.</p> <p>This change introduces a potentially incompatible change to the format of the image trailer.  If <code>BOOT_MAX_ALIGN</code> is kept at 8, the trailer format does not change.  However, to support larger write alignments, this value can be increased, which will result in a different magic number value.  These targets were previously unsupported in MCUboot, so this change should not affect any existing targets.  The change has been tested with a <code>BOOT_MAX_ALIGN</code> up to 32 bytes.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_2","title":"About this release","text":"<ul> <li>Add native flash encryption to Espressif targets</li> <li>Numerous documentation improvements</li> <li>Increase coverage of large images in the simulator</li> <li>Add stm32 watchdog support</li> <li>Add support for the <code>mimxrt685_evk</code> board</li> <li>Add support for \"partial multi-image booting\"</li> <li>Add support for clear image generation with encryption capability to   imgtool</li> <li>Fix Zephyr when <code>CONFIG_BOOT_ENCRYPTION_KEY_FILE</code> is not defined</li> <li>Remove zephyr example test running in shell.  The Go version is   primary and much more featureful.</li> <li>imgtool: make <code>--max-align</code> default reasonable in most cases.</li> <li>Implement the mcumgr echo command in serial boot mode</li> </ul>"},{"location":"bootloader/docs/release-notes/#security-fixes_1","title":"Security fixes","text":""},{"location":"bootloader/docs/release-notes/#version-180","title":"Version 1.8.0","text":"<p>The 1.8.0 release of MCUboot contains numerous fixes, and adds support for the NuttX RTOS, and the Espressif ESP32 SDK.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_3","title":"About this release","text":"<ul> <li>Add support for the NuttX RTOS.</li> <li>Add support for the Espressif ESP32 SDK.</li> <li><code>boot_serial</code> changed to use cddl-gen, which removes the dependency   on tinycbor.</li> <li>Add various hooks to be able to change how image data is accessed.</li> <li>Cypress supports Mbed TLS for encryption.</li> <li>Support using Mbed TLS for ECDSA.  This can be useful if Mbed TLS is   brought in for another reason.</li> <li>Add simulator support for testing direct-XIP and ramload.</li> <li>Support Mbed TLS 3.0.  Updates the submodule for Mbed TLS to 3.0.</li> <li>Enable direct-xip mode in Mbed-OS port.</li> <li>extract <code>bootutil_public</code> library, a common interface for MCUboot   and the application.</li> <li>Allow to boot primary image if secondary one is unreachable.</li> <li>Add AES256 image encryption support.</li> <li>Add Multiimage boot for direct-xip and ram-load mode.</li> <li>Cargo files moved to top level, now <code>cargo test</code> can be run from the   top level directory.</li> <li>Fault injection tests use updated TF-M.</li> <li>Thingy:53 now supports multi-image DFU.</li> <li>ram load and image encryption can be used together, allowing the   entire contents of flash to always remain encrypted.</li> </ul>"},{"location":"bootloader/docs/release-notes/#security-fixes_2","title":"Security fixes","text":"<ul> <li>GHSA-gcxh-546h-phg4   has been published.  There is not a fix at this time, but a caution   to be sure to follow the instructions carefully, and make sure that   the development keys in the repo are never used in a production   system.</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-170","title":"Version 1.7.0","text":"<p>The 1.7.0 release of MCUboot adds support for the Mbed-OS platform, Equal slots (direct-xip) upgrade mode, RAM loading upgrade mode, hardening against hardware level fault injection and timing attacks and single image mode. There are bug fixes, and associated imgtool updates as well.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_4","title":"About this release","text":"<ul> <li>Initial support for the Mbed-OS platform.</li> <li>Added possibility to enter deep sleep mode after MCUboot app execution   for cypress platform.</li> <li>Added hardening against hardware level fault injection and timing attacks.</li> <li>Introduced Abstract crypto primitives to simplify porting.</li> <li>Added RAM-load upgrade mode.</li> <li>Renamed single-image mode to single-slot mode.</li> <li>Allow larger primary slot in swap-move</li> <li>Fixed boostrapping in swap-move mode.</li> <li>Fixed issue causing that interrupted swap-move operation might brick device   if the primary image was padded.</li> <li>Abstracting MCUboot crypto functions for cleaner porting</li> <li>Droped flash_area_read_is_empty() porting API.</li> <li>boot/zephyr: Added watchdog feed on nRF devices.   See <code>CONFIG_BOOT_WATCHDOG_FEED</code> option.</li> <li>boot/zephyr: Added patch for turning off cache for Cortex M7 before   chain-loading.</li> <li>boot/zephyr: added option to relocate interrupts to application</li> <li>boot/zephyr: clean ARM core configuration only when selected by user</li> <li>boot/boot_serial: allow nonaligned last image data chunk</li> <li>imgtool: added custom TLV support.</li> <li>imgtool: added possibility to set confirm flag for hex files as well.</li> <li>imgtool: Print image digest during verify.</li> </ul>"},{"location":"bootloader/docs/release-notes/#zephyr-rtos-compatibility","title":"Zephyr-RTOS compatibility","text":"<p>This release of MCUboot works with the Zephyr \"main\" at the time of the release. It was tested as of has 7a3b253ce. This version of MCUboot also works with the Zephyr v2.4.0, however it is recommended to enable <code>CONFIG_MCUBOOT_CLEANUP_ARM_CORE</code> while using that version.</p>"},{"location":"bootloader/docs/release-notes/#version-160","title":"Version 1.6.0","text":"<p>The 1.6.0 release of MCUboot adds support for the PSOC6 platform, X25519 encrypted images, rollback protection, hardware keys, and a shared boot record to communicate boot attestation information to later boot stages.  There are bug fixes, and associated imgtool updates as well.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_5","title":"About this release","text":"<ul> <li>Initial support for the Cypress PSOC6 plaformt.  This platform   builds using the Cypress SDK, which has been added as submodules.</li> <li>CBOR decoding in serial recovery replaced by code generated from a   CDDL description.</li> <li>Add support for X25519 encrypted images.</li> <li>Add rollback protection.  There is support for a HW rollback counter   (which must be provided as part of the platform), as well as a SW   solution that protects against some types of rollback.</li> <li>Add an optional boot record in shared memory to communicate boot   attributes to later-run code.</li> <li>Add support for hardware keys.</li> <li>Various fixes to work with the latest Zephyr version.</li> </ul>"},{"location":"bootloader/docs/release-notes/#security-issues-addressed","title":"Security issues addressed","text":"<ul> <li>CVE-2020-7595 \"xmlStringLenDecodeEntities in parser.c in libxml2   2.9.10 has an infinite loop in a certain end-of-file situation.\" Fix   by updating a dependency in documentation generation.</li> </ul>"},{"location":"bootloader/docs/release-notes/#zephyr-rtos-compatibility_1","title":"Zephyr-RTOS compatibility","text":"<p>This release of MCUboot works the Zephyr \"main\" at the time of the release.  It was tested as of has 1a89ca1238.  When Zephyr v2.3.0 is released, there will be a possible 1.6.1 or similar release of Zephyr if needed to address any issues.  There also may be branch releases of MCUboot specifically for the current version of Zephyr, e.g. v1.6.0-zephyr-2.2.1.</p>"},{"location":"bootloader/docs/release-notes/#version-150","title":"Version 1.5.0","text":"<p>The 1.5.0 release of MCUboot adds support for encrypted images using ECIES with secp256r1 as an Elliptic Curve alternative to RSA-OAEP. A new swap method was added which allows for upgrades without using a scratch partition. There are also lots of bug fixes, extra simulator testing coverage and some imgtool updates.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_6","title":"About this release","text":"<ul> <li>TLVs were updated to use 16-bit lengths (from previous 8). This   should work with no changes for little-endian targets, but will   break compatibility with big-endian targets.</li> <li>A benchmark framework was added to Zephyr</li> <li>ed25519 signature validation can now build without using Mbed TLS   by relying on a bundled tinycrypt based sha-512 implementation.</li> <li>imgtool was updated to correctly detect trailer overruns by image.</li> <li>Encrypted image TLVs can be saved in swap metadata during a swap   upgrade instead of the plain AES key.</li> <li>imgtool can dump private keys in C format (getpriv command), which   can be added as decryption keys. Optionally can remove superfluous   fields from the ASN1 by passing it <code>--minimal</code>.</li> <li>Lots of other smaller bugs fixes.</li> <li>Added downgrade prevention feature (available when the overwrite-based   image update strategy is used)</li> </ul>"},{"location":"bootloader/docs/release-notes/#known-issues","title":"Known issues","text":"<ul> <li>TLV size change breaks compatibility with big-endian targets.</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-140","title":"Version 1.4.0","text":"<p>The 1.4.0 release of MCUboot primarily adds support for multi-image booting.  With this release, MCUboot can manage two images that can be updated independently.  With this, it also supports additions to the TLV that allow these dependencies to be specified.</p> <p>Multi-image support adds backward-incompatible changes to the format of the images: specifically adding support for protected TLV entries. If multiple images and dependencies are not used, the images will be compatible with previous releases of MCUboot.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_7","title":"About this release","text":"<ul> <li>Fixed CVE-2019-5477, and CVE-2019-16892.  These fix issue with   dependencies used in the generation of the documentation on github.</li> <li>Numerous code cleanups and refactorings</li> <li>Documentation updates for multi-image features</li> <li>Update imgtool.py to support the new features</li> <li>Updated the Mbed TLS submodule to current stable version 2.16.3</li> <li>Moved the Mbed TLS submodule from within sim/mcuboot-sys to ext.   This will make it easier for other board supports to use this code.</li> <li>Added some additional overflow and bound checks to data in the image   header, and TLV data.</li> <li>Add a <code>-x</code> (or <code>--hex_addr</code>) flag to imgtool to set the base address   written to a hex-format image.  This allows the image to be flashed   at an offset, without having to use additional tools to modify the   image.</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-131","title":"Version 1.3.1","text":"<p>The 1.3.1 release of MCUboot consists mostly of small bug fixes and updates. There are no breaking changes in functionality. This release should work with Mynewt 1.6.0 and up, and any Zephyr <code>main</code> after sha f51e3c296040f73bca0e8fe1051d5ee63ce18e0d.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_8","title":"About this release","text":"<ul> <li>Fixed a revert interruption bug</li> <li>Added ed25519 signing support</li> <li>Added RSA-3072 signing support</li> <li>Allow ec256 to run on CC310 interface</li> <li>Some preparation work was done to allow for multi image support, which   should land in 1.4.0. This includes a simulator update for testing   multi-images, and a new name for slot0/slot1 which are now called   \"primary slot\" and \"secondary slot\".</li> <li>Other minor bugfixes and improvements</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-130","title":"Version 1.3.0","text":"<p>The 1.3.0 release of MCUboot brings in many fixes and updates.  There are no breaking changes in functionality.  Many of the changes are refactorings that will make the code easier to maintain going forward. In addition, support has been added for encrypted images.  See the docs for more information.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_9","title":"About this release","text":"<ul> <li>Modernize the Zephyr build scripts.</li> <li>Add a <code>ptest</code> utility to help run the simulator in different   configurations.</li> <li>Migrate the simulator to Rust 2018 edition.  The sim now requires at   least Rust 1.32 to build.</li> <li>Simulator cleanups.  The simulator code is now built the same way   for every configuration, and queries the MCUboot code for how it was   compiled.</li> <li>Abstract logging in MCUboot.  This was needed to support the new   logging system used in Zephyr.</li> <li>Add multiple flash support.  Allows slot1/scratch to be stored in an   external flash device.</li> <li>Add support for encrypted images.</li> <li>Add support for flash devices that read as '0' when erased.</li> <li>Add support to Zephyr for the <code>nrf52840_pca10059</code>.  This board   supports serial recovery over USB with CDC ACM.</li> <li>imgtool is now also available as a python package on pypi.org.</li> <li>Add an option to erase flash pages progressively during recovery to   avoid possible timeouts (required especially by serial recovery   using USB with CDC ACM).</li> <li>imgtool: big-endian support</li> <li>imgtool: saves in intel-hex format when output filename has <code>.hex</code>   extension; otherwise saves in binary format.</li> </ul>"},{"location":"bootloader/docs/release-notes/#version-120","title":"Version 1.2.0","text":"<p>The 1.2.0 release of MCUboot brings a lot of fixes/updates, where much of the changes were on the boot serial functionality and imgtool utility. There are no breaking changes in MCUboot functionality, but some of the CLI parameters in imgtool were changed (either removed or added or updated).</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_10","title":"About this release","text":"<ul> <li>imgtool accepts .hex formatted input</li> <li>Logging system is now configurable</li> <li>Most Zephyr configuration has been switched to Kconfig</li> <li>Build system accepts .pem files in build system to autogenerate required   key arrays used internally</li> <li>Zephyr build switched to using built-in flash_map and TinyCBOR modules</li> <li>Serial boot has substantially decreased in space usage after refactorings</li> <li>Serial boot build doesn't require newlib-c anymore on Zephyr</li> <li>imgtool updates:</li> <li>\"create\" subcommand can be used as an alias for \"sign\"</li> <li>To allow imgtool to always perform the check that firmware does not     overflow the status area, <code>--slot-size</code> was added and <code>--pad</code> was updated     to act as a flag parameter.</li> <li><code>--overwrite-only</code> can be passed if not using swap upgrades</li> <li><code>--max-sectors</code> can be used to adjust the maximum amount of sectors that     a swap can handle; this value must also be configured for the bootloader</li> <li><code>--pad-header</code> substitutes <code>--included-header</code> with reverted semantics,     so it's not required for firmware built by Zephyr build system</li> </ul>"},{"location":"bootloader/docs/release-notes/#known-issues_1","title":"Known issues","text":"<p>None</p>"},{"location":"bootloader/docs/release-notes/#version-110","title":"Version 1.1.0","text":"<p>The 1.1.0 release of MCUboot brings a lot of fixes/updates to its inner workings, specially to its testing infrastructure which now enables a more thorough quality assurance of many of the available options. As expected of the 1.x.x release cycle, no breaking changes were made. From the tooling perpective the main addition is newt/imgtool support for password protected keys.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_11","title":"About this release","text":"<ul> <li>serial recovery functionality support under Zephyr</li> <li>simulator: lots of refactors were applied, which result in the   simulator now leveraging the Rust testing infrastructure; testing   of ecdsa (secp256r1) was added</li> <li>imgtool: removed PKCS1.5 support, added support for password   protected keys</li> <li>tinycrypt 0.2.8 and the Mbed TLS ASN1 parser are now bundled with   MCUboot (eg secp256r1 is now free of external dependencies!)</li> <li>Overwrite-only mode was updated to erase/copy only sectors that   actually store firmware</li> <li>A lot of small code and documentation fixes and updates.</li> </ul>"},{"location":"bootloader/docs/release-notes/#known-issues_2","title":"Known issues","text":"<p>None</p>"},{"location":"bootloader/docs/release-notes/#version-100","title":"Version 1.0.0","text":"<p>The 1.0.0 release of MCUboot introduces a format change.  It is important to either use the <code>imgtool.py</code> also from this release, or pass the <code>-2</code> to recent versions of the <code>newt</code> tool in order to generate image headers with the new format.  There should be no incompatible format changes throughout the 1.x.y release series.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_12","title":"About this release","text":"<ul> <li>Header format change.  This change was made to move all of the   information about signatures out of the header and into the TLV   block appended to the image.  This allows</li> <li>The signature to be replaced without changing the image.</li> <li>Multiple signatures to be applied.  This can be used, for example,     to sign an image with two algorithms, to support different     bootloader configurations based on these image.</li> <li>The public key is referred to by its SHA1 hash (or a prefix of the     hash), instead of an index that has to be maintained with the     bootloader.</li> <li>Allow new types of signatures in the future.</li> <li>Support for PKCS#1 v1.5 signatures has been dropped.  All RSA   signatures should be made with PSS.  The tools have been changed to   reflect this.</li> <li>The source for Tinycrypt has been placed in the MCUboot tree.  A   recent version of Tinycrypt introduced breaking API changes.  To   allow MCUboot to work across various platforms, we stop using the   Tinycrypt bundled with the OS platform, and use our own version.  A   future release of MCUboot will update the Tinycrypt version.</li> <li>Support for some new targets:</li> <li>Nordic nRF51 and nRF52832 dev kits</li> <li>Hexiwear K64</li> <li>Clearer sample applications have been added under <code>samples</code>.</li> <li>Test plans for zephyr, and   mynewt.</li> <li>The simulator is now able to test RSA signatures.</li> <li>There is an unimplemented <code>load_addr</code> header for future support for   RAM loading in the bootloader.</li> <li>Numerous documentation.</li> </ul>"},{"location":"bootloader/docs/release-notes/#known-issues_3","title":"Known issues","text":"<p>None</p>"},{"location":"bootloader/docs/release-notes/#version-090","title":"Version 0.9.0","text":"<p>This is the first release of MCUboot, a secure bootloader for 32-bit MCUs. It is designed to be operating system-agnostic and works over any transport - wired or wireless. It is also hardware independent, and relies  on hardware porting layers from the operating system it works with. For the first release, we have support for three open source operating systems: Apache Mynewt, Zephyr and RIOT.</p>"},{"location":"bootloader/docs/release-notes/#about-this-release_13","title":"About this release","text":"<ul> <li>This release supports building with and running Apache Mynewt and Zephyr   targets.</li> <li>RIOT is supported as a running target.</li> <li>Image integrity is provided with SHA256.</li> <li>Image originator authenticity is provided supporting the following   signature algorithms:</li> <li>RSA 2048 and RSA PKCS#1 v1.5 or v2.1</li> <li>Elliptic curve DSA with secp224r1 and secp256r1</li> <li>Two firmware upgrade algorithms are provided:</li> <li>An overwrite only which upgrades slot 0 with the image in slot 1.</li> <li>A swapping upgrade which enables image test, allowing for rollback to a     previous known good image.</li> <li>Supports both Mbed TLS and tinycrypt as backend crypto libraries. One of them   must be defined and the chosen signing algorithm will require a particular   library according to this list:</li> <li>RSA 2048 needs Mbed TLS</li> <li>ECDSA secp224r1 needs Mbed TLS</li> <li>ECDSA secp256r1 needs tinycrypt as well as the ASN.1 code from Mbed TLS     (so still needs that present).</li> </ul>"},{"location":"bootloader/docs/release-notes/#known-issues_4","title":"Known issues","text":"<ul> <li>The image header and TLV formats are planned to change with release 1.0:   https://runtimeco.atlassian.net/browse/MCUB-66</li> </ul>"},{"location":"bootloader/docs/release/","title":"Release process","text":"<p>This page describes the release process used with MCUboot.</p>"},{"location":"bootloader/docs/release/#version-numbering","title":"Version numbering","text":"<p>MCUboot uses semantic versioning, where version numbers follow a <code>MAJOR.MINOR.PATCH</code> format with the following guidelines on incrementing the numbers:</p> <ol> <li>MAJOR version when there are incompatible API changes.</li> <li>MINOR version when new functionalities were added in a    backward-compatible manner.</li> <li>PATCH version when there are backward-compatible bug fixes.</li> </ol> <p>We add pre-release tags using the format <code>MAJOR.MINOR.PATCH-rc1</code>.</p> <p>In the documentation, we mark an MCUBoot development version using the format <code>MAJOR.MINOR.PATCH-dev</code>.</p>"},{"location":"bootloader/docs/release/#release-notes","title":"Release notes","text":"<p>Before making a release, update the <code>docs/release-notes.md</code> file to describe the release. This should be a high-level description of the changes, not a list of the git commits.</p> <p>Provided that changes going into the release have followed the contribution guidelines, this should mostly consist of collecting the various snippets in the <code>docs/release-notes.d</code> directory.  After incorporating these snippets into the release notes, the snippet files should be removed to ready the directory for the next release cycle.</p>"},{"location":"bootloader/docs/release/#release-candidates","title":"Release candidates","text":"<p>Before each release, tags are made (see below) for at least one release candidate (a.b.c-rc1, followed by a.b.c-rc2 and the subsequent release candidates, followed by the official a.b.c release). The intent is to freeze the code and allow testing.</p> <p>During the time between the rc1 and the final release, the only changes that should be merged into the main branch are those to fix bugs found in the RC and in the Mynewt metadata, as described in the next section.</p>"},{"location":"bootloader/docs/release/#imgtool-release","title":"Imgtool release","text":"<p>imgtool is released through pypi.org (The Python package index). It requires its version to be updated by editing <code>scripts/imgtool/__init__.py</code> and modifying the exported version: <pre><code>imgtool_version = \"A.B.CrcN\"\n</code></pre></p> <p>This version should match the current release number of MCUboot. The suffix <code>rcN</code> (with no dash) is accepted only for the pre-release versions under test, while numbers are accepted only for the final releases.</p> <p>For more information, see this link.</p>"},{"location":"bootloader/docs/release/#mynewt-release-information","title":"Mynewt release information","text":"<p>On Mynewt, <code>newt</code> always fetches a versioned MCUboot release, so after the RC step is finished, the release needs to be exported by modifying <code>repository.yml</code> in the root directory; it must be updated with the new release version, including updates to the pseudo keys (<code>*-(latest|dev)</code>).</p>"},{"location":"bootloader/docs/release/#zephyr-release-information","title":"Zephyr release information","text":"<p>There is a version file used by Zephyr builds to indicate the version of MCUboot being used which needs to be updated at <code>boot/zephyr/VERSION</code>. For alignment with Zephyr versions, development versions should set <code>PATCHLEVEL</code> to <code>99</code> and <code>EXTRAVERSION</code> to <code>dev</code>, whilst production versions should correctly set <code>PATCHLEVEL</code> and clear <code>EXTRAVERSION</code>.</p>"},{"location":"bootloader/docs/release/#tagging-and-release","title":"Tagging and release","text":"<p>To make a release, make sure your local repo is on the tip version by fetching from origin. Typically, the releaser should create a branch named after the particular release.</p> <p>Create a commit on top of the branch that modifies the version number in the top-level <code>README.md</code>, and create a commit, with just this change, with a commit text similar to \"Bump to version a.b.c\". Having the version bump helps to make the releases easier to find, as each release has a commit associated with it, and not just a tag pointing to another commit.</p> <p>Once this is done, the release should create a signed tag with the appropriate tag name: <pre><code>git tag -s va.b.c-rcn\n</code></pre> The releaser will need to make sure that git is configured to use the proper signing key, and that the public key is signed by enough parties to be trusted.</p> <p>At this point, the tag can be pushed to GitHub to make the actual release happen: <pre><code>git push origin HEAD:refs/heads/main\ngit push origin va.b.c-rcn\n</code></pre></p>"},{"location":"bootloader/docs/release/#branching-after-a-release","title":"Branching after a release","text":"<p>After the final (non-<code>rc</code>) a.b.0 release is made, a new branch must be created and pushed:</p> <pre><code>git checkout va.b.c\ngit checkout -b va.b-branch\ngit push origin va.b-branch\n</code></pre> <p>This branch will be used to generate new incremental <code>PATCH</code> releases for bug fixes or required minor updates (for example, new <code>imgtool</code> features).</p>"},{"location":"bootloader/docs/release/#post-release-actions","title":"Post release actions","text":"<p>Mark the MCUboot version as a development version.</p> <p>The version number used should be specified for the next expected release. It should be larger than the last release version by incrementing the MAJOR or the MINOR number. It is not necessary to define the next version precisely as the next release version might still be different as it might be needed to do:</p> <ul> <li>a patch release</li> <li>a MINOR release while a MAJOR release was expected</li> <li>a MAJOR release while a MINOR release was expected</li> </ul>"},{"location":"bootloader/docs/serial_recovery/","title":"Serial recovery","text":""},{"location":"bootloader/docs/serial_recovery/#serial-recovery","title":"Serial recovery","text":"<p>MCUboot implements a Simple Management Protocol (SMP) server. SMP is a basic transfer encoding for use with the MCUmgr management protocol.  See the Zephyr Device Management documentation for more information about MCUmgr and SMP.</p> <p>MCUboot supports the following subset of the MCUmgr commands: * echo (OS group) * reset (OS group) * image list (IMG group) * image upload (IMG group)</p> <p>It can also support system-specific MCUmgr commands depending on the given mcuboot-port if the <code>MCUBOOT_PERUSER_MGMT_GROUP_ENABLED</code> option is enabled.</p> <p>The serial recovery feature can use any serial interface provided by the platform.</p>"},{"location":"bootloader/docs/serial_recovery/#image-uploading","title":"Image uploading","text":"<p>Uploading an image is targeted to the primary slot by default.</p> <p>An image can be loaded to other slots only when the <code>MCUBOOT_SERIAL_DIRECT_IMAGE_UPLOAD</code> option is enabled for the platform.</p> <p>MCUboot supports progressive erasing of a slot to which an image is uploaded to if the <code>MCUBOOT_ERASE_PROGRESSIVELY</code> option is enabled. As a result, a device can receive images smoothly, and can erase required part of a flash automatically.</p>"},{"location":"bootloader/docs/serial_recovery/#configuration-of-serial-recovery","title":"Configuration of serial recovery","text":"<p>How to enable and configure the serial recovery feature depends on the given mcuboot-port implementation. Refer to the respective documentation and source code for more details.</p>"},{"location":"bootloader/docs/serial_recovery/#entering-serial-recovery-mode","title":"Entering serial recovery mode","text":"<p>Entering the serial recovery mode is usually possible right after a device reset, for instance as a reaction on a GPIO pin state. Refer to the given mcuboot-port details to get information on how to enter the serial recovery mode.</p>"},{"location":"bootloader/docs/serial_recovery/#serial-recovery-mode-usage","title":"Serial recovery mode usage","text":""},{"location":"bootloader/docs/serial_recovery/#mcu-manager-cli-installation","title":"MCU Manager CLI installation","text":"<p>The MCUmgr command line tool can be used as an SMP client for evaluation purposes. The tool is available under the MCU Manager Github page and is described in the Zephyr  MCU Manager CLI documentation.</p> <p>Use the following command to install the MCU Manager CLI tool: <pre><code>go install github.com/apache/mynewt-mcumgr-cli/mcumgr@latest\n</code></pre> Enter serial recovery mode in the device and use an SMP client application for communication with the MCUboot's SMP server.</p>"},{"location":"bootloader/docs/serial_recovery/#connection-configuration","title":"Connection configuration","text":"<p>Use the following command to set the connection configuration, for linux: <pre><code>mcumgr conn add serial_1 type=\"serial\" connstring=\"dev=/dev/ttyACM0,baud=115200\"\n</code></pre> for windows: <pre><code>mcumgr conn add serial_1 type=\"serial\" connstring=\"COM1,baud=115200\"\n</code></pre></p>"},{"location":"bootloader/docs/serial_recovery/#image-management","title":"Image management","text":"<p>The connection configuration must be established to perform the following image-related commands:</p> <ul> <li>Upload the image:   <pre><code>mcumgr image upload &lt;path-to-signed-image-bin-file&gt; -c serial_1\n</code></pre></li> </ul> <p>Once done successfully, the following notification will be displayed:   <pre><code>20.25 KiB / 20.25 KiB [=================================] 100.00% 3.08 KiB/s 6s\nDone\n</code></pre></p> <ul> <li>List all images:   <pre><code>mcumgr image list -c serial_1\n</code></pre>   The terminal will show the response from the module:   <pre><code>Images:\n image=0 slot=0\n    version: 0.0.0.0\n    bootable: false\n    flags: \n    hash: Unavailable\nSplit status: N/A (0)\n</code></pre></li> </ul>"},{"location":"bootloader/docs/serial_recovery/#device-reset","title":"Device reset","text":"<p>Reset your device with the following command: <pre><code>mcumgr reset -c serial_1\n</code></pre> The terminal should respond: <pre><code>Done\n</code></pre></p>"},{"location":"bootloader/docs/signed_images/","title":"Signed images","text":""},{"location":"bootloader/docs/signed_images/#image-signing","title":"Image signing","text":"<p>This signs the image by computing hash over the image, and then signing that hash. Signature is computed by newt tool when it's creating the image. This signature is placed in the image trailer.</p> <p>The public key of this keypair must be included in the bootloader, as it verifies it before allowing the image to run.</p> <p>This facility allows you to use multiple signing keys. This would be useful when you want to prevent production units from booting development images, but want development units to be able to boot both production images and development images.</p> <p>For an alternative solution when the public key(s) doesn't need to be included in the bootloader, see the design document.</p>"},{"location":"bootloader/docs/signed_images/#creating-signing-keys","title":"Creating signing keys","text":"<p>First you need a keypair to use for signing. You can create one with openssl command line tool.</p> <p>openssl genrsa -out image_sign.pem 2048</p> <p>This created a file which contains both the private and public key, and will be used when signing images.</p> <p>Then you need to extract the public key from this to include it in the bootloader. Bootloader need to keep key parsing minimal, so it expects simple key format.</p> <p>openssl rsa -in image_sign.pem -pubout -out image_sign_pub.der -outform DER -RSAPublicKey_out</p> <p>Now the public key is in file called image_sign_pub.der.</p> <p>For ECDSA256 these commands are similar. openssl ecparam -name prime256v1 -genkey -noout -out image_sign.pem openssl ec -in image_sign.pem -pubout -outform DER -out image_sign_pub.der</p>"},{"location":"bootloader/docs/signed_images/#creating-a-key-package","title":"Creating a key package","text":"<p>xxd -i image_sign_pub.der image_sign_pub.c.import</p> <p>Then you need to create a package containing this key, or keys.</p>"},{"location":"bootloader/docs/signed_images/#sample-pkgyml","title":"Sample pkg.yml","text":"<p>This gets bootutil to turn on image signature validation.</p> <pre><code>pkg.name: libs/mykeys\npkg.deps:\n    - \"@apache-mynewt-core/boot/bootutil\"\n</code></pre>"},{"location":"bootloader/docs/signed_images/#sample-source-file","title":"Sample source file","text":"<p>This exports the keys.</p> <pre><code>#include &lt;bootutil/sign_key.h&gt;\n\n#include \"image_sign_pub.c.import\"\n\nconst struct bootutil_key bootutil_keys[] = {\n    [0] = {\n        .key = image_sign_pub_der,\n        .len = &amp;image_sign_pub_der_len,\n    }\n};\n\nconst int bootutil_key_cnt = sizeof(bootutil_keys) / sizeof(bootutil_keys[0]);\n</code></pre>"},{"location":"bootloader/docs/signed_images/#building-the-bootloader","title":"Building the bootloader","text":"<p>Enable the BOOTUTIL_SIGN_RSA syscfg setting in your app or target syscfg.yml file</p> <pre><code>syscfg.vals:\n    BOOTUTIL_SIGN_RSA: 1\n</code></pre> <p>After you've created the key package, you must include it in the build for bootloader. So modify the pkg.yml for apps/boot to include it.</p> <p>The syscfg variable to enable ECDSA256 is BOOTUTIL_SIGN_EC256.</p>"},{"location":"bootloader/docs/testplan-mynewt/","title":"Testplan mynewt","text":""},{"location":"bootloader/docs/testplan-mynewt/#mcuboot-test-plan","title":"MCUboot test plan","text":"<p>The current target for running the tests is the Freedom K64F board.</p>"},{"location":"bootloader/docs/testplan-mynewt/#basic-sign-support-rsaecec256","title":"Basic sign support (RSA/EC/EC256)","text":"<p>For each supported signing algorithm, check that non-signed, and signed with wrong key images are not swapped to, and image signed with correct key is swapped to.</p> <p>For the 3 algorithms supported, rsa, ec and ec256, two files are provided: key_.pem, key_2.pem. And a keys file with the C public key data for key.pem. <p>Build and load MCUboot:</p> <ul> <li><code>newt build k64f_boot_&lt;sign-algo&gt;</code></li> <li><code>newt load k64f_boot_&lt;sign-algo&gt;</code></li> </ul> <p>Build and load good image in slot 0:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1 key_&lt;sign-algo&gt;.pem</code></li> <li><code>newt load k64f_blinky</code></li> </ul> <p>Note</p> <p>If testing RSA/PSS <code>newt create-image</code> needs to be passed in the extra flag <code>--rsa-pss</code> eg:</p> <p><code>newt create-image k64f_blinky 1.0.1 key_rsa.pem --rsa-pss</code></p> <p>Build and load image in slot 1 with no signing, signed with key_2.pem and signed with key.pem. Mark each one as test image and check that swap only happens for image signed with key_.pem. Both others should be erased. <ul> <li><code>newt create-image k64f_blinky2 1.0.2 &lt;one-of-the-sign-keys-or-none&gt;</code></li> <li><code>newtmgr image upload k64f_blinky2</code></li> <li><code>newtmgr image list</code></li> <li><code>newtmgr image test &lt;hash of slot 1&gt;</code></li> </ul>"},{"location":"bootloader/docs/testplan-mynewt/#image-signed-with-more-than-one-key","title":"Image signed with more than one key","text":"<p>FIXME: this is currently not functional, skip this section!</p> <p>Build and load MCUboot:</p> <ul> <li><code>newt build k64f_boot_rsa_ec</code></li> <li><code>newt load k64f_boot_rsa_ec</code></li> </ul> <p>Build and load good image in slot 0:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1 key_rsa.pem</code></li> <li><code>newt load k64f_blinky</code></li> </ul> <p>Build and load image in slot 1 with no signing, signed with key_2.pem and signed with key.pem. Mark each one as test image and check that swap only happens for image signed with key_.pem. Both others should be erased. <p>Use all of this options:</p> <ul> <li><code>newt create-image k64f_blinky2 1.0.2</code></li> </ul> <p>And load</p> <ul> <li><code>newtmgr image upload k64f_blinky2</code></li> <li><code>newtmgr image list</code></li> <li><code>newtmgr image test &lt;hash of slot 1&gt;</code></li> </ul>"},{"location":"bootloader/docs/testplan-mynewt/#overwrite-only-functionality","title":"Overwrite only functionality","text":"<p>Build/load MCUboot:</p> <ul> <li><code>newt build k64f_boot_rsa_noswap</code></li> <li><code>newt load k64f_boot_rsa_noswap</code></li> </ul> <p>Build/load blinky to slot 0:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1 key_rsa.pem</code></li> <li><code>newt load k64f_blinky</code></li> </ul> <p>Build/load blinky2 both with bad and good key, followed by a permanent swap request:</p> <ul> <li><code>newt create-image k64f_blinky2 1.0.2 &lt;bad and good rsa keys&gt;.pem</code></li> <li><code>newtmgr image upload k64f_blinky2</code></li> <li><code>newtmgr image list</code></li> <li><code>newtmgr image confirm &lt;hash of slot 1&gt;</code></li> </ul> <p>This should not swap and delete the image in slot 1 when signed with the wrong key, otherwise the image in slot 1 should be moved to slot 0 and slot 1 should be empty.</p>"},{"location":"bootloader/docs/testplan-mynewt/#validate-slot-0-option","title":"Validate slot 0 option","text":"<p>Build/load MCUboot:</p> <ul> <li><code>newt build k64f_boot_rsa_validate0</code></li> <li><code>newt load k64f_boot_rsa_validate0</code></li> </ul> <p>Build non-signed image:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1</code></li> <li><code>newt load k64f_blinky</code></li> <li>Reset and no image should be run</li> </ul> <p>Build signed image with invalid key:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1 key_rsa_2.pem</code></li> <li><code>newt load k64f_blinky</code></li> <li>Reset and no image should be run</li> </ul> <p>Build signed image with valid key:</p> <ul> <li><code>newt create-image k64f_blinky 1.0.1 key_rsa.pem</code></li> <li><code>newt load k64f_blinky</code></li> <li>Reset and image should run</li> </ul>"},{"location":"bootloader/docs/testplan-mynewt/#swap-with-random-failures","title":"Swap with random failures","text":"<p>DISCLAIMER: be careful with copy/paste of commands, this test uses another target/app!</p> <p>Build/load MCUboot:</p> <ul> <li><code>newt build k64f_boot_rsa</code></li> <li><code>newt load k64f_boot_rsa</code></li> </ul> <p>Build/load slinky to slot 0:</p> <ul> <li><code>newt create-image k64f_slinky 1.0.1 key_rsa.pem</code></li> <li><code>newt load k64f_slinky</code></li> </ul> <p>Build/load slinky2 to slot 1:</p> <ul> <li><code>newt create-image k64f_slinky2 1.0.2 key_rsa.pem</code></li> <li><code>newtmgr image upload k64f_slinky2</code></li> </ul> <p>Confirm that both images are installed, request a permanent request to the image in slot 1 and check that it works.</p> <ul> <li><code>newtmgr image list</code></li> <li><code>newtmgr image confirm &lt;hash of slot 1&gt;</code></li> </ul> <p>If everything works, now proceed with requests for permanent swap to the image in slot 1 and do random swaps (as much as you like!). When the swap finishes confirm that the swap was finished with the previous slot 1 image now in slot 0 and vice-versa.</p>"},{"location":"bootloader/docs/testplan-mynewt/#help","title":"Help","text":"<ul> <li> <p>Mass erase MCU</p> <pre><code>$ pyocd erase --chip\n</code></pre> </li> <li> <p>Flashing image in slot 1:</p> <pre><code>$ pyocd flash -e sector -a 0x80000 ${IMG_FILE} bin\n</code></pre> </li> </ul>"},{"location":"bootloader/docs/testplan-zephyr/","title":"Zephyr test plan","text":"<p>The following roughly describes how MCUboot is tested on Zephyr.  The testing is done with the code in <code>samples/zephyr</code>.  These examples were written using the FRDM-K64F, but other boards should be similar. At this time, however, the partitions are hardcoded in the Makefile targets to flash.</p> <p>Note that the script \"run-tests.sh\" in that directory is helpful for automating the process, and provides simple \"y or n\" prompts for each test case and expected result.</p>"},{"location":"bootloader/docs/testplan-zephyr/#building-and-running","title":"Building and running.","text":"<p>The tests are build using the various <code>test-*</code> targets in <code>samples/zephyr/Makefile</code>.  For each test, invoke <code>make</code> with that target:</p> <pre><code>$ make test-good-rsa\n</code></pre> <p>Begin by doing a full erase, and programming the bootloader itself:</p> <pre><code>$ pyocd erase --chip\n$ make flash_boot\n</code></pre> <p>After it resets, look for \"main: Starting bootloader\", a few debug messages, and lastly: \"main: Unable to find bootable image\".</p> <p>Then, load hello1:</p> <pre><code>$ make flash_hello1\n</code></pre> <p>This should print \"main: Jumping to the first image slot\", and you should get an image \"hello1\".</p> <p>Note that there are comments with each test target describing the intended behavior for each of these steps.  Sometimes an upgrade will happen and sometimes it will not.</p> <pre><code>$ make flash_hello2\n</code></pre> <p>This should print a message: <code>boot_swap_type: Swap type: test</code>, and you should see \"hello2\".</p> <p>Now reset the target::</p> <pre><code>$ pyocd commander -c reset\n</code></pre> <p>And you should see a revert and \"hello1\" running.</p>"},{"location":"bootloader/docs/testplan-zephyr/#testing-that-mark-ok-works","title":"Testing that mark ok works","text":"<p>Repeat this, to make sure we can mark the image as OK, and that a revert doesn't happen:</p> <pre><code>$ make flash_hello1\n$ make flash_hello2\n</code></pre> <p>We should have just booted the hello2.  Mark this as OK:</p> <pre><code>$ pyocd flash -a 0x7ffe8 image_ok.bin\n$ pyocd commander -c reset\n</code></pre> <p>And make sure this stays in the \"hello2\" image.</p> <p>This step doesn't make sense on the tests where the upgrade doesn't happen.</p>"},{"location":"bootloader/docs/testplan-zephyr/#testing-all-configurations","title":"Testing all configurations","text":"<p>Repeat these steps for each of the <code>test-*</code> targest in the Makefile.</p>"},{"location":"controlLibrary/","title":"control_library","text":"<p>Control and dsp algorithms for owntech converters</p> <p>This library has been integrated and tested on TWIST converters using SPIN controller.</p> <p>The integration is based on the dedicated OwnTech Power API.</p> <p>Remarks: The library is currently not optimized to make it easier to read (we hope).</p>"},{"location":"controlLibrary/#features","title":"Features","text":"<p>The library provides the following functionalities mainly through C++ objects :  * <code>Pid()</code>: Standard form of the PID regulator.  * <code>Pr()</code>: Proportional Resonant regulator.  * <code>Rst()</code>: Discrete form of Polynomial regulator.  * <code>PllSinus()</code>: Software PLL (Phased Lock Loop)  * Digital filters: <code>LowPassFirstOrdreFilter()</code>, <code>NotchFilter()</code></p> <p><code>Pid()</code>, <code>Pr()</code> and <code>Rst()</code> inherit from the <code>Controller()</code> class which define the same interface.</p>"},{"location":"controlLibrary/#installation","title":"Installation","text":"<p>We describe here the process to use it with the Power API which has been designed to use PlatformIO.</p> <p>The installation here recall the procedure of using a library in PlatformIO.</p> <p>To use the library, you need to add the line above in the <code>platformio.ini</code> file.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>You can find various examples in the OwnTech examples library </p>"},{"location":"controlLibrary/#links","title":"Links:","text":"<p>Links which inspired this work:</p> <ul> <li>PID:</li> <li>K. Astrom et T. Hagglund, Advanced PID Control.</li> <li>PR:</li> <li>A. G\u00ef, \u00ab\u00a0Digital Resonant Current Controllers For Voltage Source Converters\u00a0\u00bb. Thesis</li> <li>RST:</li> <li>I. D. Landau, C. Cyrot, A. Voda, et D. Rey, \u00ab\u00a0Robust digital control of flexible structures using the combined pole placement/sensitivity function shaping method\u00a0\u00bb, in Proceedings of 1994 American Control Conference - ACC \u201994, Baltimore, MD, USA: IEEE, 1994, p. 283\u2011288. doi: 10.1109/ACC.1994.751743.</li> <li>I. D. Landau et G. Zito, \u00ab\u00a0Digital Control Systems - New edition (I. D. Landau &amp; G. Zito)\u00a0\u00bb, 2020, doi: 10.13140/RG.2.2.19321.49764.</li> <li>PLL:</li> <li>F. D. Freijedo, J. Doval-Gandoy, O. Lopez, et J. Cabaleiro, \u00ab\u00a0Robust phase locked loops optimized for DSP implementation in power quality applications\u00a0\u00bb, in 2008 34th Annual Conference of IEEE Industrial Electronics, Orlando, FL: IEEE, nov. 2008, p. 3052\u20113057. doi: 10.1109/IECON.2008.4758447.</li> </ul>"},{"location":"controlLibrary/#thanks","title":"Thanks","text":"<p>Thanks to the OwnTech contributors:</p> <ul> <li>Luiz</li> <li>Ayoub</li> <li>Guillaume</li> <li>Jean</li> <li>Clement</li> </ul>"},{"location":"controlLibrary/docs/controller/","title":"Controller","text":"<p><code>Controller</code> is an abstract class.</p> <p>The main idea is to fix the interface of a <code>controller</code>.</p> <p>Each type of controller like <code>Pid</code>, <code>RST</code> and <code>Pr</code> have then the same way of life.</p> <p>It has been thinking considering SISO (Single Input Single Output) and sample controller.</p> <p>If you want to implement a new controller type, you should consider to inherit from this class.</p>"},{"location":"controlLibrary/docs/getting-started/","title":"Getting started","text":"<p>Control library has been written in c++, the library is a set of object you can instanciate. </p> <p>Each <code>Controller</code> is in a different file (<code>pid.cpp, rst.cpp, pr.cpp</code>).</p> <p>It has mainly been developped to be used with  The OwnTech Power API based on Zephyr and integrated with PlatformIO.</p>"},{"location":"controlLibrary/docs/getting-started/#installation","title":"Installation","text":"<p>Control library has been designed to be integrated as a PlatformIO library.</p> <p>To use it, you need to add the line below in the <code>platformio.ini</code> file.</p> <p>platformio.ini</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"controlLibrary/docs/getting-started/#using-the-pid-controller","title":"Using the <code>Pid()</code> <code>Controller</code>.","text":"<p>To introduce the control library, we propose to implement a PID regulator.</p> <p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-filters/","title":"Filters module.","text":"<p>In the filters module <code>filters.h</code> there's multiple digital filter.</p> <ul> <li> <p>First Order Low Pass filter</p> <p></p> <p> LowPassFirstOrder</p> </li> <li> <p>Notch Filter</p> <p> </p> <p> Notch filter</p> </li> <li> <p>Phase Locked Loop</p> <p></p> <p> PllSinus</p> </li> </ul>"},{"location":"controlLibrary/docs/use-fir/","title":"Use <code>Fir</code> object.","text":""},{"location":"controlLibrary/docs/use-firstorder/","title":"Use First Order Low Pass Filter","text":""},{"location":"controlLibrary/docs/use-firstorder/#introduction","title":"Introduction.","text":""},{"location":"controlLibrary/docs/use-firstorder/#parameters","title":"Parameters","text":"<p>Here, the transfer function representation of the first order filter (where \\(s\\) is the Laplace variable) :  </p> \\[H(s) = \\dfrac{1}{1+\\tau.s}\\] <p>Where:</p> <ul> <li>\\(\\tau\\) is the constant time in [s].</li> </ul> <p>transfer function is sampled</p> <p>We show here the continuous transfer function of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-firstorder/#discretization","title":"Discretization","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_1.z^{-1}}{1+a_1.z^{-1}} \\\\ \\\\ H(z) = \\dfrac{b_1}{z + a_1} \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> <p>We give here the recurrence equation used to filter the \\(\\text{input}\\) signal.</p> \\[  out_k = b_1 . \\text{in}_k - a_1 . out_{k-1} \\] <p>where:</p> \\[ \\begin{align} a_1 &amp;= -exp\\left(-\\dfrac{Ts}{\\tau}\\right) \\\\ \\\\ b_1 &amp;= 1 + a_1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-firstorder/#use","title":"Use.","text":"<p>3 steps to use the first order filter</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t tau = 1e-3;               // constant time\n    const float32_t Ts = 100e-6;              // sampling time\n    myfilter = LowPassFirstOrderFilter(Ts, tau);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-notchfilter/","title":"Use Notch Filter","text":""},{"location":"controlLibrary/docs/use-notchfilter/#introduction","title":"Introduction.","text":"<p>The notch filter allow to remove a band of frequencies from an input signal.</p> <p> </p>"},{"location":"controlLibrary/docs/use-notchfilter/#parameters","title":"Parameters.","text":"<p>Here, the transfer function representation of the notch filter:</p> \\[H(s) = \\dfrac{s^2 + (2 \\pi f_0)^2}{s^2 + 2 \\pi \\Delta f .s + (2 \\pi f_0)^2}\\] <p>Where:</p> <ul> <li> <p>\\(f_0\\) is the notch frequency,</p> </li> <li> <p>\\(\\Delta f\\) is the bandwidth of the filter.</p> </li> </ul>"},{"location":"controlLibrary/docs/use-notchfilter/#discretization","title":"Discretization.","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_0 + b_1.z^{-1} + b_2.z^{-2}}{ a_0 + a_1.z^{-1}+ a_2.z^{-2}} \\\\ \\\\ H(z) = \\dfrac{b_0.z^2 + b_1.z^{1} + b_2}{ a_0.z^2 + a_1.z^{1}+ a_2} \\\\ \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[ out_k = b_0 . in_k + b_1 . in_{k-1} + b_2 . in_{k-2} - a_1 . out_{k-1} - a_2 . out_{k-2}. \\] <p>Where:</p> \\[ \\begin{align} b_0 &amp;= \\dfrac{1}{1+ \\pi . \\Delta f . T_s} \\\\ \\\\ b_1 &amp;= -2 . b_0 .\\cos(2\\pi.f_0.T_s)  \\\\ \\\\ b_2 &amp;= b_0 \\\\ \\\\ a_1 &amp;= b_1 \\\\ \\\\ a_2 &amp;= 2 b_0 - 1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-notchfilter/#use-of-the-notchfilter-object","title":"Use of the <code>NotchFilter</code> object.","text":"<p>3 steps to use the notchfilter.</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t f0 = 50.0;               // notch frequency [Hz]\n    const float32_t bandwidth = 5.0;         // notch bandwidth [Hz]\n    const float32_t Ts = 100e-6;              // sampling time [s]\n    myfilter = NotchFilter(Ts, f0, bandwidth);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pid/","title":"PID <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-pid/#introduction","title":"Introduction.","text":"<p>The PID  <code>Controller</code> is implemented here in a Standard form.</p> bloc diagram of standard form of a continuous PID with filtered derivative"},{"location":"controlLibrary/docs/use-pid/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the PID.</p> \\[command = K_p . \\left( \\varepsilon + \\dfrac{1}{T_i.s} .  \\varepsilon + \\dfrac{T_d.s}{1 + \\frac{T_d}{N}.s}.\\varepsilon \\right)\\] <p>where:</p> <ul> <li>\\(K_p\\) is the proportionnal gain</li> <li>\\(T_i\\) is the integration time</li> <li>\\(T_d\\) is derivative time</li> <li>\\(N\\) help to filter the derivative (typical values \\(\\in [2, 20]\\)).</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pid/#discretization","title":"Discretization:","text":"<p>This <code>Pid()</code> object is implemented using a backward euler integration method.</p> <p>We have the following discrete equation implemented:</p> \\[  \\begin{align} \\epsilon_k &amp;=  y_{ref_{k}} - y_{meas_{k}} \\\\ \\\\  i_k &amp;= i_{k-1}  + T_s . \\epsilon_k \\\\ \\\\ d_k &amp;= \\dfrac{\\epsilon_k - \\epsilon_{k-1}}{T_s} \\\\ \\\\ f_{d_k} &amp;= (1 - e^{-T_s/\\tau}) . d_k  + e^{-T_s/\\tau} . f_{d_{k-1}} \\end{align} \\] \\[ u_k = K_p .\\left( \\epsilon_k +  \\dfrac{1}{T_i} . i_k + T_d . f_{d_k}\\right) \\]"},{"location":"controlLibrary/docs/use-pid/#use-of-the-pid-controller","title":"Use of the PID <code>Controller</code>.","text":"<p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pid/#example","title":"Example","text":"<p>You can find a pid use with the buck voltage mode example which regulates a DC voltage.</p>"},{"location":"controlLibrary/docs/use-pll/","title":"Use the software Phase Locked Loop.","text":""},{"location":"controlLibrary/docs/use-pll/#introduction","title":"Introduction","text":"<p>The <code>PllSinus</code> is used to track sinusoid and extract angle and pulsation. It is included in the <code>filters.cpp</code> module.</p> <p> block diagram of software phase locked loop <p></p>"},{"location":"controlLibrary/docs/use-pll/#parameters","title":"Parameters:","text":"<ul> <li>We set \\(f_0\\) the frequency of the signal to track linked with \\(\\omega_0=2.\\pi.f_0\\). </li> <li>\\(\\Delta \\omega\\) has been arbitrarily fixed to be 20% of \\(\\omega_0\\).</li> <li>\\(K_p, T_i\\) parameters are computed using the <code>rise_time</code> of the closed loop, which   fix the dynamic of the PLL and we have also to take into account of the <code>amplitude</code> of   the signal.</li> </ul>"},{"location":"controlLibrary/docs/use-pll/#use-of-the-pllsinus-filter","title":"Use of the <code>PllSinus</code> filter.","text":"<p>The use of the `PllSinus is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters declaration.2. Initialization.3. Execution. <p>We define constants used to initialize the parameter structure. <pre><code>#include \"filters.h\"\n\nstatic float32_t amplitude = 16.0F; // amplitude of the voltage sinus to track.\nstatic float32_t f0 = 50.0;               // frequency assumed of the signal to track [Hz]\nstatic float32_t rise_time = 50.e-3F;     // dynamic of the loop [s].\nstatic float32_t Ts = 100.0e-6F;          // sampling time [s]\n</code></pre></p> <p>We define the variable <code>pll</code> which is an instance of <code>PllSinus</code> object. <pre><code>static PllSinus pll;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>PllSinus</code> with its parameters.</p> <pre><code>pll.init(Ts, amplitude, f0, rise_time);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code></p> <pre><code>pll_datas = pll.calculateWithReturn(signal_to_track);\n</code></pre> <p><code>pll_datas</code> is a structure which kept the results of the PllSinus calculation for one step.</p> <p>the PllData structure has 3 fields: <pre><code>struct PllDatas {\n    float32_t w;     // estimated pulsation [rad/s]\n    float32_t angle; // estimated angle [rad]\n    float32_t error; // angle error [rad]\n};\n</code></pre></p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pll/#example","title":"Example","text":"<p>You can find a pll use with the grid following example which requires a synchronisation to inject current in parallel with a voltage source.</p>"},{"location":"controlLibrary/docs/use-pr/","title":"Proportionnal Resonant <code>Controller</code>","text":""},{"location":"controlLibrary/docs/use-pr/#introduction","title":"Introduction.","text":"<p>The Proportionnal Resonant <code>Controller</code> is dedicated to follow a sinusoidal reference.</p> <p>It is design to minimized phase shift and amplitude error.</p> Block diagram of Proportionnal Resonant controller <p>The \\(\\phi'\\) variable is dedicated to reduce delay generated by the calculation and the PWM.</p> Block diagram of Proportionnal Resonant controller including delay compensation"},{"location":"controlLibrary/docs/use-pr/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the Proportionnal resonant.</p> \\[Pr(s)=K_p + K_r \\dfrac{s \\cos(\\phi')-\\omega_0.\\sin(\\phi')}{s^2+w_0^2}\\] <p>Where:</p> <ul> <li>\\(\\omega_0\\)  is the pulsation in [rad/s]</li> <li>\\(\\phi'\\) is the compensation delay in [rad]</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pr/#discretization","title":"Discretization:","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} Pr(z^{-1}) = \\left(K_p + K_r . \\dfrac{b_0 + b_1.z^{-1}}{a_0+a_1.z^{-1}+ a_2.z^{-2}}\\right) \\\\ \\\\ Pr(z) = \\left(K_p + K_r . \\dfrac{b_0 .z^2 + b_1.z^1}{a_0.z^{2}+a_1.z^{1}+ a_2}\\right) \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[  \\begin{align} res_k &amp;= b_0.\\epsilon_k + b_1.\\epsilon_{k-1} - a_1.res_{k-1} - a_2.res_{k-2} \\\\ \\\\ u_k &amp;= K_p . \\epsilon_k + K_r .res_k \\end{align} \\] <p>With:</p> \\[ \\begin{align} a_1 &amp;= -2.\\cos(T_s . \\omega_0)\\\\ a_2 &amp;= 1.0\\\\ b_0 &amp;= T_s . \\cos(\\phi')\\\\ b_1 &amp;= -T_s . \\cos(\\phi' - T_s . \\omega_0)\\\\ \\end{align} \\]"},{"location":"controlLibrary/docs/use-pr/#use-of-the-proportionnal-resonant-controller","title":"Use of the Proportionnal Resonant <code>Controller</code>.","text":"<p>The use of the <code>Pr</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pr.h\"\n\nstatic float32_t Kp = 0.001F;\nstatic float32_t Kr = 300.0F;\nstatic float32_t w0 = 2 * PI * 50.0F;\nstatic float32_t phase_shift = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static  PrParams params = PrParams(Ts, Kp, Kr, w0, phase_shift, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>prop_res</code> which is a <code>Pr</code> object. <pre><code>static Pr prop_res;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pr</code> with its parameters.</p> <pre><code>prop_res.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Remind that the <code>loop_critical_task()</code> is called every 100\u00b5s.</p> <pre><code>new_command = prop_res.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pr calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pr/#example","title":"Example","text":"<p>You can find the use with a grid forming example which generate an AC voltage source.</p>"},{"location":"controlLibrary/docs/use-rst/","title":"Polynomial RST <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-rst/#introduction","title":"Introduction.","text":"<p>The polynomial R-S-T <code>Controller</code> is a two degree of freedom digital controller (allowing to fix a regulation dynamic uncoupling from the setting point dynamic). </p> <p>It allows to implement various digital filters in the measurement part (\\(R\\)) or in the integration part (\\(\\frac{1}{S}\\)).</p> <p> </p>"},{"location":"controlLibrary/docs/use-rst/#parameters","title":"Parameters:","text":"<p>Here the equation of the RST controller.</p> \\[S(q^{-1}).u = T(q^{-1}).y_{ref} - R(q^{-1}).y\\] <p>where:</p> <ul> <li> <p>\\(S(q^{-1}),\\ T(q^{-1})\\ \\text{and}\\ R(q^{-1})\\) are polynomial of delay operator \\(q^{-1}\\)</p> </li> <li> <p>\\(S(q^{-1}) = s_0 + s_1.q^{-1} + ... + s_{ns}.q^{-ns}\\)</p> </li> <li>\\(R(q^{-1}) = r_0 + r_1.q^{-1} + ... + r_{nr}.q^{-nr}\\)</li> <li>\\(T(q^{-1}) = t_0 + t_1.q^{-1} + ... + t_{nt}.q^{-nt}\\)</li> </ul>"},{"location":"controlLibrary/docs/use-rst/#use-of-the-rst-controller","title":"Use of the RST <code>Controller</code>.","text":"<p>The use of the `RST is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"rst.h\"\n\nconst uint8_t nr = 3;\nconst float R[] = { 0.8914, -1.1521, 0.3732 };\n\nconst uint8_t ns = 6;\nconst float S[] = { 0.2, 0.0852, -0.0134, -0.0045, -0.1785, -0.0888 };\n\nconst uint8_t nt = 3;\nconst float T[] = { 1.0, -1.3741, 0.4867 };\n\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\n\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static RstParams params = RstParams(Ts, nr, R, ns, S, nt, T, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>my_rst</code> which is a <code>Rst</code> object. <pre><code>static RST my_rst;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Rst</code> with its parameters.</p> <pre><code>my_rst.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = my_rst.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the rst calculation for one step.</p>"},{"location":"core/","title":"OwnTech Power API","text":"<p>This is the OwnTech Power API Core repository.</p> <p>The Power API is designed to be used with VS Code and PlatformIO. Installing VS Code with PlatformIO.</p> <p>For information about Power API, check out its Documentation.</p>"},{"location":"core/#downloading-owntech-power-api-core","title":"Downloading OwnTech Power API Core","text":"<p>You fisrt need to download the Power API Core repository using the following command:</p> <p><code>git clone https://github.com/owntech-foundation/Core.git owntech_power_api</code></p> <p>Then, open VS Code and, if not already done, install the PlatformIO plugin.</p> <p>Finally, open the newly cloned folder <code>owntech_power_api</code> using menu <code>File &gt; Open Folder...</code></p>"},{"location":"core/#working-with-owntech-power-api","title":"Working with OwnTech Power API","text":"<p>While the project contains many folders and files, all your code goes to the <code>src</code> folder. In the this folder, the file <code>main.cpp</code> is the entry point of the application. Aditionally, some configuration can be done in the <code>platformio.ini</code> file.</p> <p>Other folders and files are used to configure the underlying Zephyr OS and PlatformIO, and are hidden by default.</p>"},{"location":"core/#accessing-owntech-source-code-in-vs-code-for-advanced-developers","title":"Accessing OwnTech source code in VS Code (for advanced developers)","text":"<p>The full hierarchy of the project is as follows:</p> <pre><code>owntech_power_api\n\u2514\u2500 owntech\n|  \u2514\u2500 boards\n|  \u2514\u2500 scripts\n|  \u2514\u2500&gt;pio_extra.ini\n\u2514\u2500 src\n|  \u2514\u2500&gt;main.cpp\n\u2514\u2500 zephyr\n|  \u2514\u2500 boards\n|  \u2514\u2500 dts\n|  \u2514\u2500 modules\n|  \u2514\u2500&gt;CMakeLists.txt\n|  \u2514\u2500&gt;prj.conf\n\u2514\u2500&gt;LICENSE\n\u2514\u2500&gt;platformio.ini\n\u2514\u2500&gt;README.md\n</code></pre> <p>The <code>owntech</code> folder contains scripts and board description for PlatformIO, while the <code>zephyr</code> folder contains board decription and OwnTech's Zephyr modules. By default, these folders (as well as VS Code and PlatformIO folders <code>.vscode</code> and <code>.pio</code>) are hidden when opening the project in VS Code.</p> <p>If you need to access these in VS Code, open the project using your file explorer, then in the <code>.vscode</code> folder, rename file <code>settings.json</code>, e.g. to <code>settings.json.old</code>.</p> <p>Advanced Zephyr configuration can be tweaked by editing <code>zephyr/prj.conf</code>.</p> <p>The OwnTech API source code is located in <code>zephyr/modules</code>. If you need to tailor it to your needs, please checkout the Zephyr documentation.</p>"},{"location":"core/docs/adc/","title":"ADC","text":"<p>An ADC, or Analog-to-Digital Converter, is a device that turns analog signals, like sound or temperature, into digital data that a computer or microcontroller can understand. It measures the analog voltage and converts it into a digital value that can be used by digital systems for processing, storage, or display.</p> <p>Warning</p> <p>The ADC API is an advanced interface provided for users with technical background. For most data acquisition tasks, use the Data API which provides a more user-friendly and higher-level entry point.</p>"},{"location":"core/docs/adc/#pinout","title":"Pinout","text":"<p>SPIN boards have 5 independant ADC units. Each unit can measure multiple analog signals, using a measurment sequence.</p> <p>Capabilities</p> <p>Each ADC channel has : -  12 bit resolution: 0b to 4096b -  Sensing full scale: 0V to 2.048V -  Sampling time down to 42ns</p> SPIN v1.1.0SPIN v1.0.0 <p> </p> <p> </p> <p>Info</p> <ul> <li>ADC12 means that the pin can be used either as ADC1 or ADC2</li> <li>INx means that it is channel x.</li> </ul>"},{"location":"core/docs/adc/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre> Make sure that SPIN API is included to use AdcHAL</p>"},{"location":"core/docs/adc/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Software triggeredHardware triggered <ol> <li>Link an adc trigger event to the ADC <code>spin.adc.configureTriggerSource(ADCx, TRIG)</code></li> <li>Define acquisition sequence by enabling adc channel : <code>spin.adc.enableChannel(ADCx, channelx)</code></li> <li>trigger an adc <code>data.triggerAcquisition()</code></li> <li>Retrieve value : <code>data.getLatest(ADCx, pinx)</code></li> </ol> <p>1. Make sure PWM engine is initialized 2. Link an adc trigger event to the ADC <code>spin.adc.configureTriggerSource(ADCx, TRIG)</code> 3. Set continuous/discontinuous conversion mode. Optional : <code>spin.adc.configureDiscontinuousMode(x, 0/1)</code> 4.  Define acquisition sequence by enabling adc channel : <code>spin.adc.enableChannel(ADCx, channelx)</code> 6. Start data dispatching to get acquired values <code>data.start()</code> 7.  Retrieve value : <code>data.getLatest(ADCx, pinx)</code></p> <p>Example</p> Software triggeredHardware triggered <pre><code>spin.adc.configureTriggerSource(1, software);\nspin.adc.enableChannel(1, 30);\ndata.triggerAcquisition(1);\nfloat32_t adc_value =   data.getLatest(1, 30);\n</code></pre> <pre><code>/* PWM unit initialization */\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n\n/* ADC initialization */\nspin.adc.configureTriggerSource(1, hrtim_eev1);\nspin.adc.configureDiscontinuousMode(1,1);\nspin.adc.enableChannel(1, 30);\ndata.start();\nfloat32_t adc_value =   data.getLatest(1, 30);\n</code></pre>"},{"location":"core/docs/adc/#channel-sequence","title":"Channel sequence","text":"<p>Each ADC unit can measure multiple analog signal. This works by defining an acquisition sequence.</p> <p>Tip</p> <p>By default the aquisition sequence is in continuous mode. It means than one trigger will trigger all the sequence of acquisition. This can be changed using Discontinuous Mode</p> <p>Example</p> 3 channels on ADC1 <p><pre><code>spin.adc.enableChannel(1, 2)\nspin.adc.enableChannel(1, 3)\nspin.adc.enableChannel(1, 1)\n</code></pre> In this example, for each trigger action, the ADC1 will measure channel 2, then channel 3, then channel 1.</p> Single channel <p><code>spin.adc.enableChannel(1, 1)</code></p> <p>In this example, for each trigger, the ADC1 will measure  channel 1.</p> <p>Note</p> <p>Sequence order is given by <code>spin.adc.enableChannel()</code> order.</p>"},{"location":"core/docs/adc/#software-triggered","title":"Software triggered","text":"<p>A software trigger for an ADC is a command or signal generated by the software to start the ADC conversion process. Instead of using a hardware signal or event to initiate the conversion, the ADC is triggered by software instructions, allowing for precise control and synchronization with other software processes or events. For example this trigger command can be generated from a high speed control task.</p> <pre><code>spin.adc.configureTriggerSource(2, software); // ADC 2 configured in software mode\ndata.triggerAcquisition(2); // Send an adc trigger to ADC2 to start conversion\nadc_value = data.getLatest(2, 35); // Get the acquired data\n</code></pre> <p>Example</p> <p>See the following example for an application :</p> <ul> <li>Software trigerred ADC</li> </ul>"},{"location":"core/docs/adc/#synchronous-with-pwms","title":"Synchronous with PWMs","text":"<p>Software triggers is generally speaking not suitable for applications that requires precise timing. Sometimes measurement have to be taken at a specific time, in interaction with the control signal.</p> <p>Info</p> <p>This kind of acquisition have a side benefit. It operates in the background and does not interfer with software. It means that periodical sampling will not interrupt code execution.</p> <p>The trigger is the PWM peripheral, the ADC performs the conversion and place the result in an output buffer, the output buffer is directly placed in memory by a DMA. A rather complex software mechanics execute periodically and serve each measurement in a dedicated memory space. The periodical routine is executed at the beggining of the controlTask.</p> <p>Info</p> <p>Synchronous measurement require having a controlTask running.</p> <p>Tip</p> <p>This page informs on how to parameters the triggering of the measurement To retrieve measurement values please refer to DataAPI</p> <p>The section below explain how to synchronize measurements with control signals.</p> <p>Note</p> <p>These features are available for ADC1 and ADC2.</p>"},{"location":"core/docs/adc/#the-different-event-and-trigger-of-adchrtim","title":"The different event and trigger of ADC/HRTIM","text":"<p>You might have seen that there are differents variables referencing adc trigger : </p> <p><pre><code>spin.adc.configureTriggerSource(1, hrtim_eev1);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n</code></pre> There is <code>hrtim_eevx</code> or <code>ADCTRIG_x</code>, let's see the role of each of them.</p>"},{"location":"core/docs/adc/#adctrig_x","title":"ADCTRIG_x","text":"<p>In the PWM API, four signals can serve as ADC triggers, initiating ADC conversions: ADC_TRIG1, ADC_TRIG2, ADC_TRIG3, and ADC_TRIG4.</p> <p>The PWM is produced by a carrier (see here) by using a comparator to compare a specific constant value with the carrier, we can generate an event when enabling a trigger on the PWM. For instance :  </p> <pre><code>spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p>We are enabling and linking ADCTRIG_1 to PWMA. That means that when the comparator value and the carrier value of the PWMA we can generate an event from ADCTRIG_1 that can be used to start an ADC conversion : </p> <p></p> <p>The comparator value can be adjusted using the function <code>spin.pwm.setAdcTriggerInstant(PWMA, 0.5)</code>. For example, setting it to 0.5 means triggering an event halfway through the switching period, initiating an ADC conversion.</p>"},{"location":"core/docs/adc/#hrtim_eevx","title":"hrtim_eevx","text":"<p>An ADC conversion can be initiated either by software (via a function) or hardware through an external event. Numerous external events exist, but some are specifically related to PWM: <code>hrtim_eev1</code>, <code>hrtim_eev2</code>, <code>hrtim_eev3</code>, and <code>hrtim_eev4</code>.</p> <p>Each of these external events is associated with events generated by ADCTRIG_x. For instance, hrtim_eev1 is linked to ADCTRIG_1, and so on.</p> <p><pre><code>spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.adc.configureTriggerSource(1, hrtim_eev1);\n</code></pre> The above code indicates that we've connected ADC1 to the external event hrtim_eev1, which, in turn, is connected to the event generated by ADCTRIG1 when the comparator (set by the trigger value) matches the carrier of PWMA.</p>"},{"location":"core/docs/adc/#source-adc-and-pwm-channel","title":"Source ADC and PWM channelMkDoxy Error: Incorrect class method configurationMkDoxy Error: Incorrect class configuration","text":"<p>ADC1 and ADC2 can be associated with PWM channels at will.</p> <p>Did not find Class with name: `AdcHAL` and method: `void configureDiscontinuousMode (uint8_t adc_number, uint32_t dicontinuous_count)`</p> Available classes and methods: <pre><code>AnalogCommunication\nCanCommunication\nCommunicationAPI\nCompHAL\nDacHAL\nDataAPI\nGpioHAL\nLedHAL\nPwmHAL\nRs485Communication\nShieldAPI\nSpinAPI\nSyncCommunication\nTaskAPI\nTimerHAL\nUartHAL\nsafety\n</code></pre> Snippet <pre><code>::: doxy.powerAPI.class.method\nname: AdcHAL\nmethod: void configureDiscontinuousMode (uint8_t adc_number, uint32_t dicontinuous_count)\n</code></pre>        === \"ADC1 and PWMA\"     ![left_aligned_ADC_50](images/left_aligned_ADC_50.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>  === \"ADC1 and PWMC\"     ![left_aligned_ADC_PWM_C](images/left_aligned_ADC_PWM_C.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTrigger(PWMC, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMC);\n</code></pre>  ### Modulation impact  !!! note     Hardware trigger depends on PWM modulation.  === \"Left Aligned Modulation\"     ![left_aligned_ADC_50](images/left_aligned_ADC_50.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>  === \"Center aligned modulation\"     ![center_aligned_ADC_rising_edge](images/center_aligned_ADC_rising_edge.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>  ### Rising Edge / Falling edge  !!! note     This only applies to center aligned modulation.  === \"Rising Edge\"     ![center_aligned_ADC_rising_edge](images/center_aligned_ADC_rising_edge.svg){ width=800 }      <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\n    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>  === \"Falling Edge\"     ![center_aligned_ADC_falling_edge](images/center_aligned_ADC_falling_edge.svg){ width=800 }       <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_down);\n    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>   ### Measurment trigger instant  Trigger timing can be defined or changed dynamically.  === \"20% Duty cycle\"     ![left_aligned_ADC_20](images/left_aligned_ADC_20.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.2);\n</code></pre>  === \"80% Duty cycle\"     ![left_aligned_ADC_80](images/left_aligned_ADC_80.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.8);\n</code></pre>  ### Continuous / Discontinuous sequence  !!! note     This is relevant if more than one measurement is taken with the same ADC.  === \"Continuous sequence\"     ![left_aligned_continuous_sampling](images/left_aligned_continuous_sampling.svg){ width=800 }      <pre><code>    spin.adc.configureDiscontinuousMode(1, 0);\n</code></pre>  === \"Discontinuous sequence \"     ![left_aligned_ADC_50](images/left_aligned_ADC_50.svg){ width=800 }      <pre><code>    spin.adc.configureDiscontinuousMode(1, 1);\n</code></pre>   ### Number of PWM period between acquisition  !!! note     This is relevant if more than one measurement is taken with the same ADC.  === \"With 2 periods\"     ![sparse_sampling_2](images/sparse_sampling_2.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 2);\n</code></pre>  === \"With 4 periods\"     ![sparse_sampling_4](images/sparse_sampling_4.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 4);\n</code></pre>  === \"Without interuptions\"     ![left_aligned_continuous_sampling](images/left_aligned_continuous_sampling.svg){ width=800 }      <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 1);\n</code></pre> !!! example     see the following example for an application :      - [PWM trigerred ADC](https://owntech-foundation.github.io/Documentation/examples/SPIN/ADC/adc_hrtim_trigger/)   ## API Reference    <p>Did not find Class with name: `AdcHAL`</p> Available classes: <pre><code>AnalogCommunication\nCanCommunication\nCommunicationAPI\nCompHAL\nDacHAL\nDataAPI\nGpioHAL\nLedHAL\nPwmHAL\nRs485Communication\nShieldAPI\nSpinAPI\nSyncCommunication\nTaskAPI\nTimerHAL\nUartHAL\nsafety\n</code></pre> Snippet <pre><code>::: doxy.powerAPI.class\nname: AdcHAL\n</code></pre>"},{"location":"core/docs/dac/","title":"DAC","text":"<p>A Digital-to-Analog Converter (DAC) transforms digital signals into analog signals by mapping digital values to specific voltages. This process effectively creates continuous analog waveforms from discrete digital data. DACs play a vital role in electronic systems by enabling the generation of diverse waveforms.</p>"},{"location":"core/docs/dac/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>1. First start by calling the initialization function of the DAC <code>spin.dac.initConsValue(DAC_NUM)</code>.  2. Second enter the integer value to send to the DAC <code>spin.dac.setConstValue(DAC_NUM, DAC_CHAN, DAC_VALUE)</code> </p> <p>Example</p> <pre><code>spin.dac.initConstValue(2); // DAC 2 initialization\nspin.dac.setConstValue(2, 1, 2048);\n</code></pre>"},{"location":"core/docs/dac/#conversion-from-numerical-to-analog-value","title":"Conversion from numerical to analog value","text":"<p>The value we can send to the DAC is an integer between 0 and 4096, this value is then converted to voltage between 0 and 2.048V. For example : </p> <p><pre><code>spin.dac.setConstValue(2, 1, 2048);\n</code></pre> Generate a 1.024V signal.</p> <p></p> <p>Example</p> <p>For a pratical example of the DAC see the example :      - Signal generation</p>"},{"location":"core/docs/dac/#api-reference","title":"API Reference","text":""},{"location":"core/docs/dac/#class-dachal","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"core/docs/dac/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src)  void initConstValue (uint8_t dac_number)  void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value)  void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage)"},{"location":"core/docs/dac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/dac/#function-currentmodeinit","title":"function currentModeInit","text":"<pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre>"},{"location":"core/docs/dac/#function-initconstvalue","title":"function initConstValue","text":"<pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre>"},{"location":"core/docs/dac/#function-setconstvalue","title":"function setConstValue","text":"<pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre>"},{"location":"core/docs/dac/#function-slopecompensation","title":"function slopeCompensation","text":"<pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"core/docs/dataAPI/","title":"Data API","text":"<p>Data acquisition is the process of sampling signals that measure real-world physical conditions and converting the resulting samples into digital numeric values that can be manipulated by a computer.</p> <p>In the powerAPI context, the DataAPI helps the user retrieve the values sampled by the ADC.</p> <p>The Data API configures the DMAs to store the ADCs acquisitions for the Spin board, and dispatches them in per-channel buffers that can be read by the user. The module also provides functions to convert the raw values acquired by the sensors into values in the adequate unit.</p> <p>If using a shield such as Twist, channels are automatically made available for configuration and conversions functions are automatically calibrated using the device tree.</p>"},{"location":"core/docs/dataAPI/#include","title":"Include","text":"<p>Note</p> <pre><code>#include &lt;DataAPI.h&gt;\n</code></pre> <p>To use the Data API, include <code>DataAPI.h</code> in your source file. From there, a <code>data</code> object is available to interact with the API.</p>"},{"location":"core/docs/dataAPI/#data-dispatching","title":"Data dispatching","text":"<p>When using the control task (critical task) data are dispatched at the start, which means there are ready to be retrieved.</p> <p></p>"},{"location":"core/docs/dataAPI/#initialization-sequence","title":"Initialization sequence","text":"<p>If you want specific ADC behavior (trigger sources, discontinuous mode, etc.), you may want to configure the ADCs using the lower-level ADC API first. Then, you can enable channels that you want to acquire.</p> <p>After channels have been enabled, the conversion parameters can be set so that raw values can be automatically converted to the relevant unit. This is done using the <code>data.setParameters()</code> function.</p> <p>After channels have been enabled (and optionnally conversion parameters have been set), there are two ways of starting the API, depending on your use of other OwnTech APIs. If your code uses an uninterruptible task, nothing more is required, the Data API will be started automatically when task is started. However, if you do not have an uninterruptible task in your code, you need to manually start the API by calling <code>data.start()</code>.</p> <p>Note</p> Software triggeredHardware triggered <ol> <li>Enable acquisition on the pins you want: <code>data.enableAcquisition()</code></li> <li>Define acquisition conversion parameter: <code>data.setParameters()</code></li> <li>start data dispatching <code>data.start()</code></li> <li>Trigger an initial adc conversion <code>data.triggerAcquisition(ADCx)</code></li> <li>Retrieve values : <code>data.getLatest()</code> or <code>data.getRawValues()</code></li> </ol> <ol> <li>Make sure PWM engine is initialized</li> <li>Enable acquisition on the pins you want: <code>data.enableAcquisition()</code></li> <li>Define acquisition conversion parameter: <code>data.setParameters()</code></li> <li>start data dispatching <code>data.start()</code></li> <li>Retrieve values : <code>data.getLatest()</code> or <code>data.getRawValues()</code></li> </ol> <p>Example</p> Software triggered ADCHardware triggered ADC <pre><code>data.enableAcquisition(1, 5); // ADC 1 ; Pin 5\ndata.triggerAcquisition(1); // ADC 1\nfloat32_t adc_value = data.getLatest(1, 5); // ADC 1 ; Pin 5\n</code></pre> <pre><code>/* PWM unit initialization */\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n\n/* ADC initialization */\nspin.adc.configureTriggerSource(1, hrtim_eev1); // ADC 1 ; HRTIM event 1\nspin.adc.configureDiscontinuousMode(1, 1); // ADC 1 ; acquire 1 pin at each event\ndata.enableAcquisition(1, 5); // ADC 1 ; Pin 5\ndata.start();\nfloat32_t adc_value = data.getLatest(1, 5); // ADC 1 ; Pin 5\n</code></pre>"},{"location":"core/docs/dataAPI/#retrieving-last-value","title":"Retrieving last value","text":"<p>Getting the last measured value to feed the control algorithm is super simple.</p> <p>Example</p> Get last value <p><pre><code>data.getLatest(1, 5)\n</code></pre> This will retrieve the last sampled value of ADC 1 pin 5.</p>"},{"location":"core/docs/dataAPI/#getting-values-with-the-right-unit","title":"Getting values with the right unit","text":"<p>DataAPI contains commodity functions to convert the raw binary measurement values in meaningful units.</p> <p>Example</p> Converting in volts <pre><code>data.setParameters()\n</code></pre>"},{"location":"core/docs/dataAPI/#get-an-array-of-values","title":"Get an array of values","text":"<p>DataAPI contains commodity function to retrieve an array of raw values that can be fed to a post processing filter.</p> <p>Example</p> Retrieve 5 values <pre><code>data.getRawValues()\n</code></pre>"},{"location":"core/docs/dataAPI/#class-dataapi","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p>"},{"location":"core/docs/dataAPI/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (adc_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. void configureTriggerSource (adc_t adc_number, adc_ev_src_t trigger_source) Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. float32_t convertValue (uint8_t pin_number, uint16_t raw_value) Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. int8_t enableAcquisition (uint8_t pin_number, adc_t adc_number=DEFAULT_ADC) This function is used to enable acquisition on a Spin PIN with a given ADC. conversion_type_t getConversionParameterType (uint8_t pin_number) Use this function to get the current conversion type for the chosen channel. float32_t getConversionParameterValue (uint8_t pin_number, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . float32_t getLatestValue (uint8_t pin_number, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. uint16_t * getRawValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t * getValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function converts all values that have been acquired since last call are stored and provide an array containing all of them. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t peekLatestValue (uint8_t pin_number) Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. int8_t retrieveConversionParametersFromMemory (uint8_t pin_number) Retrieved previously configured conversion parameters from persistent memory. void setConversionParametersLinear (uint8_t pin_number, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setConversionParametersNtcThermistor (uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t stop () Stops the module if it is started. int8_t storeConversionParametersInMemory (uint8_t pin_number) Store the currently configured conversion parameters of a given channel in persistent memory. void triggerAcquisition (adc_t adc_number) Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired."},{"location":"core/docs/dataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/dataAPI/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. <pre><code>void DataAPI::configureDiscontinuousMode (\n    adc_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Note:</p> <p>This is an advanced function that requires to understand the way the ADC work. Only for use if you explicitely requires it.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"core/docs/dataAPI/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. <pre><code>void DataAPI::configureTriggerSource (\n    adc_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"core/docs/dataAPI/#function-convertvalue","title":"function convertValue","text":"<p>Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convertValue (\n    uint8_t pin_number,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. If there is an error, returns -5000. </p>"},{"location":"core/docs/dataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t pin_number,\n    adc_t adc_number=DEFAULT_ADC\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisiton: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before Data API is started.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the Spin pin on which to enable acquisition. </li> <li><code>adc_number</code> Number of the ADC on which acquisition is to be done. This parameter can be omitted, in which case:</li> <li>If only one ADC is linked to the given pin, it will be selected.</li> <li>If two ADCs are available for acquisition on the given pin, the ADC with the lowest number will be selected.</li> </ul> <p>Returns:</p> <p>0 if acquisition was correctly enabled, -1 if there was an error. Errors generally indicate that the given pin is not linked to and ADC, and thus can not be used for acquisition. If the adc_number parameter was explicitely provided, it can also indicate that the given ADC is not available for acquisition on the provided pin. </p>"},{"location":"core/docs/dataAPI/#function-getconversionparametertype","title":"function getConversionParameterType","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::getConversionParameterType (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Returns the type of convertion of the given pin. Returns -5 if the channel is not active. </p>"},{"location":"core/docs/dataAPI/#function-getconversionparametervalue","title":"function getConversionParameterValue","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::getConversionParameterValue (\n    uint8_t pin_number,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter. Returns -5000 if the channel is not active. </p>"},{"location":"core/docs/dataAPI/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatestValue (\n    uint8_t pin_number,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.getRawValues() function for the matching channel, as data.getLatestValue() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use data.convertValue() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"core/docs/dataAPI/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. This function converts all values that have been acquired since last call are stored and provide an array containing all of them. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>float32_t * DataAPI::getValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. Calling this function trigger the conversion of all values acquired since the last call. If only the lastet value is required, it is advised to call getLatestValue() instead. If multiple values are required, but not all, it is advised to call getRawValues() instead, then explicitely convert required values using convertValue().</p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"core/docs/dataAPI/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peekLatestValue (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-retrieveconversionparametersfrommemory","title":"function retrieveConversionParametersFromMemory","text":"<p>Retrieved previously configured conversion parameters from persistent memory. <pre><code>int8_t DataAPI::retrieveConversionParametersFromMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retrieved, negative value if there was an error: -1: persistent memory is empty -2: persistent memory contains data, but its version doesn't match current version -3: data in persistent memory is corrupted -4: persistent memory contains data, but not for the requested pin -5000: pin not found. </p>"},{"location":"core/docs/dataAPI/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersLinear (\n    uint8_t pin_number,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"core/docs/dataAPI/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersNtcThermistor (\n    uint8_t pin_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the sensor is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge dividor resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"core/docs/dataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually, it will automatically be started at the same time as the task as their internal behavior are intrinsically linked. If for some reason you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task. In that case, Data Acquisition must be manually started using this function. Note that in taht case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out. No ADC configuration change is allowed after module has been started. If you're using a power shield and are not sure how to initialize ADCs, you can use data.enableShieldDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function. Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when dispatch method is set to be external, but the repetition value has not provided. Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"core/docs/dataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"core/docs/dataAPI/#function-stop","title":"function stop","text":"<p>Stops the module if it is started. <pre><code>int8_t DataAPI::stop () \n</code></pre></p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when trying to stop Data API while it was not started. </p>"},{"location":"core/docs/dataAPI/#function-storeconversionparametersinmemory","title":"function storeConversionParametersInMemory","text":"<p>Store the currently configured conversion parameters of a given channel in persistent memory. <pre><code>int8_t DataAPI::storeConversionParametersInMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly stored, negative value if there was an error: -1: There was an error, -5000: pin not found. </p>"},{"location":"core/docs/dataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired. <pre><code>void DataAPI::triggerAcquisition (\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the at least one channel is enabled on the ADC and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"core/docs/dataAPI/#using-the-data-api-with-a-twist-shield","title":"Using the Data API with a Twist shield","text":"<p>The Data API is optimized for running on Twist shields. It provides variants of the functions that take Twist sensors as parameters instead of pins numbers.</p> <p>To enable the Twist Shield channels, use <code>set(SHIELD twist)</code> in <code>CMakeLists.txt</code>. From there, this module will provide additional functions to acquire and convert Twist channels by name.</p> <p>If you use the Twist sensors, you can use <code>data.enableTwistDefaultChannels()</code> to automatically perform a standard configuration. From there, all current/tension channels of the Twist shields will be enabled as part of the default configuration. Default parameters for the channels are also loaded automatically as part of the process.</p>"},{"location":"core/docs/environment_setup/","title":"Environment Setup","text":"<p>If you use or wish to use Visual Studio Code, follow this tutorial to set up your work environment. It will use a \u201cBlinky\u201d (blinking LED) example which requires no other hardware than you OwnTech board.</p>"},{"location":"core/docs/environment_setup/#requirements","title":"Requirements","text":"<p>Before we start, make sure your machine meets all the requirements below.</p> <p>Required software</p> WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers<ul> <li>The pip package installer is needed. If using the system Python (<code>/usr/bin/python3</code>), <code>pip</code> may not be installed by default.   See Installing pip with Linux Package Managers.</li> <li>The venv module is needed.   Warning if using the system Python: although <code>venv</code> is part of the Python Standard Library, some Linux distributions such as Debian and Ubuntu don't install it by default.   In that case, make sure that the <code>python3-venv</code> package is installed.</li> </ul> </li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>64 bit linux installation</li> <li>Write permission for the serial port (<code>/dev/ttyACM0</code>): See PlatformIO documentation which provides a udev rules file</li> <li>Internet connection</li> </ul>"},{"location":"core/docs/environment_setup/#setup-your-work-environment","title":"Setup your work environment","text":"<p>To use OwnTech's system, we will use:</p> <ul> <li>Visual Studio Code - The platform or Integrated Development Environment we will use to write code.</li> <li>PlatformIO - A Visual Studio Code plugin that is a toolbox for microcontrollers</li> </ul> <p>Required Disk Space</p> <p>Make sure that you have more than 2GB on your hard drive so that PlatformIO can download all the required files without issues.</p> <p>Here is how to setup the work environment:</p>"},{"location":"core/docs/environment_setup/#step-1-empty-folder","title":"Step 1 - Empty folder","text":"<p>Create an empty folder in which you will work throughout the tutorials.</p> <p>Warning</p> Windows <ul> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not linked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> </ul>"},{"location":"core/docs/environment_setup/#step-2-install-visual-studio-code","title":"Step 2 - Install Visual Studio Code","text":"<p>Download  and install Visual Studio Code (\u201cVS Code\u201d for short).</p> <p>An overview of VS Code user interface is available in their official Get Started / User Interface documentation.</p>"},{"location":"core/docs/environment_setup/#step-3-install-platformio","title":"Step 3 - Install PlatformIO","text":"<p>Launch Visual Studio Code.</p> <p>In the \u201cActivity Bar\u201d, located on the far left-hand side, click on the Extensions icon (1) { .annotate } to open the VS Code Extensions manager in the Primary Side Bar.</p> <ol> <li>The icon looks like this: </li> </ol> <p>Using the search box in the Extensions Marketplace, search for the \u201cPlatformIO IDE\u201d extension and install it.</p> <p>Finally, restart Visual Studio Code when you are prompted to do so.</p> <p></p> <p>Once installed, you should see that PlatformIO has appended its \u201calien head\u201d icon (1) { .annotate } to the Activity Bar.</p> <ol> <li>The PlatformIO icon looks like this: </li> </ol> <p>Pro tip</p> <p>If the alien icon does not show up spontaneously, wait for a few more seconds, then press F1 key and type \"platformio home\".</p>"},{"location":"core/docs/environment_setup/#step-4-open-platformio-in-vs-code","title":"Step 4 - Open PlatformIO in VS Code","text":"<p>In VS Code Activity Bar, click on the newly added PlatformIO \u201calien head\u201d icon to open PlatformIO in the Primary Side Bar. It should contain:</p> <ul> <li>\u201cProject Tasks\u201d view, at the top (without any task list at that stage, since you haven\u2019t opened a PlatformIO project at this stage)</li> <li>\u201cQuick Access\u201d view, below</li> </ul>"},{"location":"core/docs/environment_setup/#step-5-clone-our-core-repository","title":"Step 5 - Clone our Core repository","text":"<p>In PlatformIO's \u201cQuick Access\u201d view, select the \u201cMiscelleanous / Clone Git Project\u201d action. This will open a field in which you should enter the following Git reposity address:</p> <pre><code>https://github.com/owntech-foundation/Core\n</code></pre> <p>PlatformIO will then ask you in which folder the project should be cloned. Choose the folder you have created previously. This will start the cloning process (with a progress window popping up in the lower right corner).</p> <p>At the end of the cloning process, VS Code will ask you if you wish to open the cloned repository and you should answer yes (\"Open\" or \"Open in New Window\").</p> <p>Once the project folder is opened, a popup will appear asking if you trust the authors of the files in this folder. You can trust us. </p> <p></p> <p>Once the repository is cloned successfully, make sure you are on the <code>main</code> branch of the Git project. The name of the current branch is displayed on the left side of the Status Bar, at the bottom of the VS Code window, as highlighted in the following screenshot:</p> <p></p> <p>Now the project is successfully opened and you should see two tabs in the Editor area:</p> <ul> <li>the \u201cPIO Home\u201d tab thay we will not use here   (remark: PIO Home\u2019s Devices tab can be used to check that your board is well detected once connected)</li> <li>the <code>platformio.ini</code> Project Configuration File,   which is already well configured for the present example</li> </ul> <p>This first example you have just opened implements a simple \u201cBlinky\u201d (blinking LED) demo. If you wish to understand how it is implemented, open and read through the main C++ code which is <code>main.cpp</code>, located in the <code>src</code> folder. VS Code file Explorer can be opened from the first icon at the top of the Activity Bar.</p>"},{"location":"core/docs/environment_setup/#step-6-build-our-core-code","title":"Step 6 - Build our Core code","text":"<p>In the Status Bar, at the bottom of the VS Code window, click on the Build (<code>\u2713</code>) icon. This will launch the code compilation process.</p> <p></p> <p>Coffee Time</p> <p>During your first build, PlatformIO will download all the necessary dependencies of our code. This may take several minutes depending on your machine and your internet connection.</p> <p>Do not hesitate to go get yourself a coffee.</p> <p>When the compilation is completed, you should see:</p> <p></p> <p>Note</p> <p>If you encounter an error during compilation, please refer to the troubleshooting section below.</p>"},{"location":"core/docs/environment_setup/#step-7-prepare-your-hardware","title":"Step 7 - Prepare your hardware","text":"<p>Before running the code, make sure that you meet the following requirements:</p> <p>Requirements for running the code on a board</p> <ul> <li>Have your VS Code Environment already set up</li> <li>Run your first compilation successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> </ul> <p></p> <ul> <li>Connect the SPIN board to your computer via the USB.</li> <li>Notice that the LED PWR must turn on.</li> <li>Here you see the connection of a SPIN board embedded onto a TWIST board.</li> </ul>"},{"location":"core/docs/environment_setup/#step-8-upload-our-core-code-in-your-spin-board","title":"Step 8 - Upload our Core code in your SPIN board","text":"<p>Now it is time to run a Blinky (i.e. blinking LED) example on the board.</p> <p>This requires uploading (or flashing) the compiled code to the SPIN controller board. To do so, press the Upload icon (<code>\u2192</code>, just to the right of the Build icon <code>\u2713</code>).</p> <p>Pro tip</p> <p>The Build and Upload action buttons are also available in the top right corner of the Editor area</p> <p>Coffee time 2</p> <p>During your first upload, PlatformIO will automatically download the necessary depencies to send data to the SPIN board. Depending on your machine and your internet connection, this might take some time.</p> <p>Time to pour another coffee.</p> Known bug - mcumgr macOS <p>The upload requires a software called mcumgr.</p> <p>As of the time of writing, we have experienced issues with some macOS devices in finding it.</p> <p>Please refer to the ongoing issue to handle it if you have the error below.</p> <p></p> <p>If everything goes well, you will get a success as in the image below.</p> <p></p> <p>Finally, allowing a few extra seconds for the board to reboot, you will see the <code>LED</code> LED blink.</p> <p>  Success</p> <p>Congratulations! You have uploaded your first code!</p> <p>If you want to make sure you really master this first example, you can change the blinking frequency. The blinking period is set at the last line of the <code>loop_background_task()</code> routine in the <code>main.cpp</code> file (<code>1000</code> by default, expressed in ms). After saving the modified code, you will need to redo the Build and Upload steps.</p>"},{"location":"core/docs/environment_setup/#troubleshooting","title":"Troubleshooting","text":"<p>From our exeprience, there are multiple types of errors that can block your compilation.</p> <p>Check the list below of possible issues</p> Troubleshooting WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not liked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connectin is up and running</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connectin is up and running</li> <li>If you have a problem with <code>mcumgr</code>, please refer to the ongoing issue to handle it.</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Check that your Linux is 64bits</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connectin is up and running</li> </ul> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.07.11: Pierre Haessig</li> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/first_example/","title":"First Example","text":"<p>The best way \"to owntech\" is to use our examples.</p> <p>In this section we will show you how to use our example interface.</p>"},{"location":"core/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Run your first compilation successfully.</li> <li>Run your first upload successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/first_example/#using-the-example-interface","title":"Using the example interface","text":"<p>We have developed an automatic method to use the examples available in our github example repository within our environment.</p> <p>Here are the steps to use it.</p>"},{"location":"core/docs/first_example/#step-1-open-project-tasks","title":"Step 1 - Open project tasks","text":"<p>Click on the PlatformIO alien icon. (1)</p> <ol> <li>The alien icon looks like this </li> </ol> <p>There are three group of tasks:</p> <ul> <li>Default:</li> <li>STLink:</li> <li>USB: These are the tasks we will work with</li> </ul> <p>Environments</p> <p>These three groups of tasks are called \"environments\" in PlatformIO.</p> <ul> <li>Default is given by PlatformIO itself and we do not use it.</li> <li>STLink is the environment that supports using an STLink when interacting to the SPIN board.</li> <li>USB is the default environment which uses an USB cable to interact with the SPIN board.</li> </ul> <p>We will work with different environments in later more advanced examples.</p>"},{"location":"core/docs/first_example/#step-2-open-the-usb-tasks","title":"Step 2 - Open the USB tasks","text":"<p>There are multiple folders on the USB tasks.</p> <ul> <li>From General to Msciellaneous are tasks by default that we don not use</li> <li>OwnTech: are tasks that can be used for more advanced users.</li> <li>Examples TWIST: are the examples dedicated to the TWIST board which we will see later.</li> <li>Examples SPIN: groups all the examples related to the SPIN board.</li> </ul>"},{"location":"core/docs/first_example/#step-3-open-the-examples-spin-folder","title":"Step 3 - Open the Examples SPIN folder","text":"<p>Click on the Examples SPIN folder.</p> <p>You will see multiple examples on this folder.</p> <ul> <li>Blinky LED: Your trusted companion.</li> <li>Setting PWM: An example to create a single PWM signal</li> <li>Setting multiple PWM: An example for creating multiple PWM signals</li> <li>Setting PWM phase shift: An example for shifting two PWM signals</li> <li>DAC signal: An example for generating an analog signal from digital data</li> <li>Software triggered ADC: An example to activate</li> <li>HRTIM triggered ADC: An example to active an ADC measuremente using a hardware trigger</li> <li>Incremental encoder: An example on how to interface an incremental encoder to the SPIN board</li> </ul>"},{"location":"core/docs/first_example/#step-4-get-your-example","title":"Step 4 - Get your example","text":"<p>Click on the Setting PWM duty cycle example.</p> <p>The file will be automatically downloaded and replace your <code>main.cpp</code>.</p>"},{"location":"core/docs/first_example/#step-5-build-the-example","title":"Step 5 - Build the example","text":"<p>Go back to your VSCode Explorer tab.(1)</p> <ol> <li>The explorer tab icon looks like this: </li> </ol> <p>Notice that an <code>old/old0/src</code> folder has been created.  You will find your previous <code>main.cpp</code> in this folder.  This way you can access your old code anytime.</p> <p>In the <code>src</code> folder, notice that an <code>Image</code> folder has been created and that the <code>readme.md</code> of the example was downloaded.</p> <p>You can click on the new <code>main.cpp</code> file to explore the newly downloaded example.</p> <p>When you are ready to build, click on the build icon. (1)</p> <ol> <li>The build icon looks like this: </li> </ol>"},{"location":"core/docs/first_example/#step-6-upload-the-example","title":"Step 6 - Upload the example","text":"<p>If the build is successful, connect your SPIN board and click on the flash icon. (1)</p> <ol> <li>The flash icon looks like this: </li> </ol> <p>Connect your SPIN board</p> <p>Remember to connect your SPIN board to your computer to allow you to upload the new example.</p> <p></p> <p>Once the upload is completed, the LED will stop blinking.</p> <p>You can connect to the serial port by cliking on its icon. (1)</p> <ol> <li>The serial icon looks like this: </li> </ol> <p>VSCode will open a <code>TERMINAL</code> window and show what the SPIN board is writing on the console.</p> <p>You should see a <code>0.300000</code> which represents a duty cycle of 30%.</p> <p>If you click on the terminal and push the <code>d</code> key on your keyboard, the value will go <code>DOWN</code> and decrease to <code>0.250000</code>.</p> <p>If you push the <code>u</code> key on your key board, the value will go <code>UP</code> and increase back to <code>0.300000</code>.</p> <p>Congratulations! you have uploaded your fist example. Do not hesitate to explore more examples either via our interface or our repository.</p> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/gpio/","title":"GPIO","text":"<p>A GPIO, or General Purpose Input/Output, is a pin on a microcontroller or processor that can be programmed to function either as an input or an output. As an input, it can read the state of an external electrical signal, such as a switch or a sensor. As an output, it can send an electrical signal, such as a high or low logic level, to an external component, such as an LED.</p>"},{"location":"core/docs/gpio/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Set the output pinReset the output pinRead the input pin <p>1. Configure the pin in output mode. 2. Set the pin.  </p> <p>1. Configure the pin in output mode. 2. Reset the pin  </p> <p>1. Configure the pin in input mode. 2. Read the pin input.  </p> <p>Example</p> Set the output pinReset the output pinRead the input pin <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.setPin(9);  </p> <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.resetPin(9);  </p> <p>spin.gpio.configurePin(9, INPUT); uint8_t return_gpio = spin.gpio.readPin(9);  </p>"},{"location":"core/docs/gpio/#api-reference","title":"API Reference","text":""},{"location":"core/docs/gpio/#class-gpiohal","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p>"},{"location":"core/docs/gpio/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"core/docs/gpio/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/gpio/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>flags</code> Pin configuration flags. Authorized values:</li> <li>INPUT</li> <li>INPUT_PULLUP</li> <li>OUTPUT </li> </ul>"},{"location":"core/docs/gpio/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"core/docs/gpio/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <ul> <li>if pin value is 1, it will be set to 0</li> <li>if pin value is 0, it will be set to 1.</li> </ul> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"core/docs/ownplot_setup/","title":"OwnPlot Setup","text":"<p>OwnPlot is the software we have developed to easily visualize data. Here we will show you how to install and use it.</p>"},{"location":"core/docs/ownplot_setup/#requirements","title":"Requirements","text":"<p>Before you start, make sure you meet the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Have your first PWM example uploaded.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready and connected to your computer (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/ownplot_setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"core/docs/ownplot_setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"core/docs/ownplot_setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"core/docs/ownplot_setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p>"},{"location":"core/docs/powerAPI/","title":"Home","text":"<p>PowerAPI is a comprehensive software API for demanding applications. </p> <ul> <li> <p> Blazing Fast</p> <p>Get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Application oriented</p> <p>Focus on your application and generate your real time control</p> <p> Examples</p> </li> </ul>"},{"location":"core/docs/powerAPI/#browse-the-documentation","title":"Browse the documentation","text":"<ul> <li> <p> Real time tasks</p> <p>Generate accurate periodic actions and handle background tasks</p> <p> API Reference</p> </li> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> HAL Reference</p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> HAL Reference </p> <p> API Reference</p> </li> <li> <p> Analog accelerated control loops</p> <p>Use internal analog hardware to control your application</p> <p> HAL Reference</p> </li> <li> <p> Real time synchronization</p> <p>Synchronize multiple SPIN boards down to 10 of ns </p> <p> API Reference</p> </li> <li> <p> Real time communication</p> <p>Send critical data, at real time pace.</p> <p> Digital communication API </p> <p> Analog communication API</p> </li> </ul>"},{"location":"core/docs/pwm/","title":"PWM","text":"<p>PWM, or Pulse Width Modulation, is a method used in electronics to control the power supplied to devices like motors, LEDs, and heaters. Instead of changing the voltage or current level, PWM changes the amount of time the power is on (the pulse width) compared to the time it's off.</p> <p>In power electronics, PWM is super important because it allows us to control the average power delivered to a load by varying the duty cycle of the pulse. This means we can regulate the speed of motors or the brightness of LEDs.</p>"},{"location":"core/docs/pwm/#features","title":"Features","text":"<ul> <li>Up to 5 pairs of PWMs possible (PWMA, PWC, PWMD, PWME, PWMF)</li> <li>Each PWM unit has a miminum resolution of 184ps.</li> </ul> <p>Note</p> <p>The resolution of a PWM signal defines the maximum number of steps that can be present in a single PWM period. In other words, it determines how finely you can adjust the pulse width of the signal. A higher resolution means you can make smaller and more precise adjustments to the pulse width.</p> <ul> <li>Frequencies in the range of 650Hz to 1Ghz theorically possible. Tests were made from 2kHz up to 10MHz.</li> </ul> <p>Warning</p> <p>Only 200Khz was tested with TWIST</p> <ul> <li>Two different modulation mode possible : left aligned, and center aligned</li> <li>Two ADC linkable to two differents PWM unit for precise measurement instant</li> <li>Compatible for peak current control with the internal analog comparator</li> <li>Positive and negative dead time set via software</li> <li>Phase shift possible for interleaved operations</li> </ul>"},{"location":"core/docs/pwm/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre> Make sure that SPIN API is included to use PwmHAL </p>"},{"location":"core/docs/pwm/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>Function to call before initializing the PWM unit.</p> Software triggeredHardware triggered <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set wich output (1 or 2) will be controlled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 3.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 4.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code> </p> <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set ow which edge (up/down) to trigger adc conversion <code>spin.pwm.setAdcEdgeTrigger(PWMx, edgeTrigUp/edgeTrigDwn)</code> 3. Set the division of the number of trigger in a fixed period <code>spin.pwm.setAdcDecimation(PWMx, DecimValue)</code> 4. Set wich output (1 or 2) will be constrolled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 5.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 6.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code> </p> <p>Note</p> <p>Function to call after initializing PWM unit.</p> Software triggeredHardware triggered <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code> </li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code> </li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code> </li> <li>if ADC hardware triggered : follow ADC init sequence </li> </ol> <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code> </li> <li>Set wich ADC trigger to link to PWM unit <code>spin.pwm.setAdcTrigger(PWMx, ADCtrig)</code> </li> <li>Enable the adc trigger <code>spin.pwm.enableAdcTrigger</code> </li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code> </li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code> </li> <li>if ADC hardware triggered : follow ADC init sequence </li> </ol> <p>Example</p> Software triggeredHardware triggered <pre><code>spin.pwm.initFixedFrequency(frequency); \nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre> <pre><code>spin.pwm.initFixedFrequency(frequency); \nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/pwm/#how-it-works","title":"How it works","text":"<p>To generate a PWM you need two signals, a variable high frequency signals called the carrier and a constant signal called the duty cycle. </p>"},{"location":"core/docs/pwm/#carrier-signal-and-pwm-resolution","title":"Carrier signal and PWM resolution","text":"<p>The carrier signal is usually a counter in the form of a sawtooth or triangle wave. The frequency of the PWM is given by the max value of that counter. It means that the minimal duty cycle step of phase step, is proportional to the frequency of the signal.</p> <p>Example</p> <p>Here is a counter incrementing from 0 to 27200. </p> <p>The increment between each step is made at the PWM resolution which is here 184ps, so the carrier gets from 0 to 27200 in 5\u00b5s so a frequency of 200kHz. In other words the smallest step is 1/27200 or 0.0037% of the period. </p>"},{"location":"core/docs/pwm/#duty-cycle","title":"Duty cycle","text":"<p>The duty cycle is a constant value compared to the carrier. </p> <p></p> <p>When the carrier is superior to the duty cycle, the logic output is at high level. On the contrary, when the carrier is inferior to the duty cycle the the output logic is low level. A PWM signal is thus a sqarewave signal with a frequency (the switching frequency) being fixed by the carrier.</p> <p>Varying the duty cycle is how to vary the output of the PWM.</p>"},{"location":"core/docs/pwm/#snippet-examples","title":"Snippet examples","text":""},{"location":"core/docs/pwm/#frequency","title":"Frequency","text":"200kHz frequency400kHz frequency <pre><code>    spin.pwm.setFixedFrequency(200000);\n</code></pre> <pre><code>    spin.pwm.setFixedFrequency(400000);\n</code></pre>"},{"location":"core/docs/pwm/#singledual-output","title":"Single/Dual Output","text":"Single OutputSingle Output PWMx2Dual Output <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT1);    \n</code></pre> <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT2);    \n</code></pre> <pre><code>    spin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/pwm/#duty-cycle_1","title":"Duty Cycle","text":"20% Duty cycle80% Duty cycleHow it works <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.2);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre>"},{"location":"core/docs/pwm/#phase-shift","title":"Phase Shift","text":"<p>Tip</p> <p>PWMA is defined as the phase reference. It can not be phase shifted.  If you are not using PWMA, you can define any PWM channel as the reference by setting its phase shift to 0\u00b0 NB: Phase reference is 0\u00b0.</p> 20% Phase Shift80% Phase ShiftHow it works <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  72);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  288);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMA,  288);\n</code></pre>"},{"location":"core/docs/pwm/#dead-time","title":"Dead Time","text":"2% Dead Time8% Dead TimeAsymetric Dead Time leading edgeAsymetric Dead Time trailing edge <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  100);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  100);\n</code></pre>"},{"location":"core/docs/pwm/#modulation-type","title":"Modulation Type","text":"Left AlignedCenter Aligned <pre><code>    spin.pwm.setModulation(PWMA, Lft_aligned);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <pre><code>    spin.pwm.setModulation(PWMA, UpDwn);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <p>Example</p> <p>See this examples for more details :  </p> <ul> <li> <p>How to control duty cycle of a PWM unit </p> </li> <li> <p>How to set the trigger instant by linking adc trigger to PWM unit </p> </li> <li> <p>Managing phase shift between two PWM units</p> </li> </ul>"},{"location":"core/docs/pwm/#class-pwmhal","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"core/docs/pwm/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. hrtim_adc_trigger_t getAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. uint32_t getFrequencyMax (hrtim_tu_number_t pwmX) This function returns the maximum frequency of the selected timer in Hz. uint32_t getFrequencyMin (hrtim_tu_number_t pwmX) This function returns the minimum frequency of the selected timer in Hz. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint16_t getPeriodMax (hrtim_tu_number_t pwmX) This function returns the maximum period of the selected timing unit. uint16_t getPeriodMin (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. uint32_t getResolutionPs (hrtim_tu_number_t pwmX) This function returns the resolution of the timing unit in picoseconds. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initFixedFrequency (uint32_t fixed_frequency) This function initialize the PWM for fixed frequency applications. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void initVariableFrequency (uint32_t initial_frequency, uint32_t minimal_frequency) This functions initializes the PWM for variable frequency applications. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startDualOutput (hrtim_tu_number_t pwmX) This fonction starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"core/docs/pwm/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"core/docs/pwm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/pwm/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> function to call each interupt </li> </ul>"},{"location":"core/docs/pwm/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"core/docs/pwm/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Warning:</p> <p>call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"core/docs/pwm/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both </p>"},{"location":"core/docs/pwm/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>hrtim_adc_trigger_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4 </p>"},{"location":"core/docs/pwm/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9 </p>"},{"location":"core/docs/pwm/#function-getfrequencymax","title":"function getFrequencyMax","text":"<p>This function returns the maximum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-getfrequencymin","title":"function getFrequencyMin","text":"<p>This function returns the minimum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWM mode - VOLTAGE_MODE or CURRENT_MODE</p> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"core/docs/pwm/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Lft_aligned or UpDwn (center aligned) </p>"},{"location":"core/docs/pwm/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/pwm/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"core/docs/pwm/#function-getperiodmax","title":"function getPeriodMax","text":"<p>This function returns the maximum period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/pwm/#function-getperiodmin","title":"function getPeriodMin","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"core/docs/pwm/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-getresolutionps","title":"function getResolutionPs","text":"<p>This function returns the resolution of the timing unit in picoseconds. <pre><code>uint32_t PwmHAL::getResolutionPs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Note:</p> <p>The resolution of the PWM depends on the prescaler that is automatically calculated when the master unit is initialized. For an HRTIM frequency of =170MHz: PRSCL = 0 : fHRTIM x 32 = 4.608 GHz - Res: 184 ps - Min PWM f: 83.0 kHz PRSCL = 1 : fHRTIM x 16 = 2.304 GHz - Res: 368 ps - Min PWM f: 41.5 kHz PRSCL = 2 : fHRTIM x 8 = 1.152 GHz - Res: 735 ps - Min PWM f: 20.8 kHz PRSCL = 3 : fHRTIM x 4 = 576 MHz - Res: 1470 ps - Min PWM f: 10.4 kHz PRSCL = 4 : fHRTIM x 2 = 288 MHz - Res: 2940 ps - Min PWM f: 5.2 kHz PRSCL = 5 : fHRTIM X 1 = 144 MHz - Res: 5880 ps - Min PWM f: 2.6 kHz   PRSCL = 6 : fHRTIM / 2 = 72 MHz - Res:11760 ps - Min PWM f: 1.3 kHz PRSCL = 7 : fHRTIM / 4 = 36 MHz - Res:23530 ps - Min PWM f: 0.65 kHz </p>"},{"location":"core/docs/pwm/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWMx1 (high side convention) or PWMx2 (low-side convention) </p>"},{"location":"core/docs/pwm/#function-initfixedfrequency","title":"function initFixedFrequency","text":"<p>This function initialize the PWM for fixed frequency applications. <pre><code>void PwmHAL::initFixedFrequency (\n    uint32_t fixed_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fixed_frequency</code> frequency to be fixed in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing any timing unit. The frequency will not vary during the operation of the power device. Use it for fixed frequencies only. </p>"},{"location":"core/docs/pwm/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"core/docs/pwm/#function-initvariablefrequency","title":"function initVariableFrequency","text":"<p>This functions initializes the PWM for variable frequency applications. <pre><code>void PwmHAL::initVariableFrequency (\n    uint32_t initial_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>initial_frequency</code> The initial value of the frequency in Hz </li> <li><code>minimal_frequency</code> The minimal value of the frequency in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing any timing unit. The user can vary the frequency during the operation of the power device. This may compromise the resolution of the PWM. you can check your resolution with the getResolutionPS function. </p>"},{"location":"core/docs/pwm/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>decimation</code> decimation/post-scaler - a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_edge_trigger</code> Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_trig</code> adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4</li> </ul> <p>Warning:</p> <p>Call this function BEFORE enabling the adc trigger and AFTER initializing the selected timer </p>"},{"location":"core/docs/pwm/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>trig_val</code> a value between 0 and 1 </li> </ul>"},{"location":"core/docs/pwm/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>this function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"core/docs/pwm/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"core/docs/pwm/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>eev</code> external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9</li> </ul> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"core/docs/pwm/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step Use it AFTER the initialization of the timing unit. </p>"},{"location":"core/docs/pwm/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>modulation</code> PWM Modulation - Lft_aligned or UpDwn</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"core/docs/pwm/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"core/docs/pwm/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>shift</code> phase shift value \u00b0 between -360 and 360</li> </ul> <p>Warning:</p> <p>use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"core/docs/pwm/#function-startdualoutput","title":"function startDualOutput","text":"<p>This fonction starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul>"},{"location":"core/docs/pwm/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"core/docs/scheduling/","title":"Task API","text":"<p>PowerAPI is meant to deploy easily Real-time programs that must guarantee response within specified time constraints. In that context, scheduling is the action of asigning computing ressources to perform tasks.</p>"},{"location":"core/docs/scheduling/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;TaskAPI.h&gt;\n</code></pre> Make sure that Task API is included</p>"},{"location":"core/docs/scheduling/#deploying-a-real-time-control-task","title":"Deploying a real time control task","text":"<p>Having a periodical code execution is key to real time applications. It is easy to spawn one using the TaskAPI.</p>"},{"location":"core/docs/scheduling/#the-control-task-sources","title":"The control task sources","text":"<p>You can have different source calling the control task.</p> <p>The control task is synchronous, it means that it is called at fixed period. So we need some kind of timer calling the control, this timer is considered as the source. There are two sources :  - The PWM carrier - An independant timer   </p>"},{"location":"core/docs/scheduling/#the-pwm-carrier","title":"The PWM carrier","text":"<p>The carrier has a period called the switching period, we can use it to call the control task after a fixed number of switching period. </p> <p></p> <p>On the figure above, the switching period is 5\u00b5s (200Khz) and we call the control every 10 switching cycle so 50\u00b5s (20Khz).</p> <p>Warning</p> <p>There are limitations when using this method :      - You need to start the a PWM to start the control task     - You can only have control period which are multiple of the switching period     - You can not have a control period inferior to the switching period  </p> <p>Tip</p> <p>Synchronizing the control task period with PWM period can be usefull when you try to synchronize PWM between several SPIN or TWIST, in that case the control task is also synchronized between the board.  </p>"},{"location":"core/docs/scheduling/#independant-timer","title":"Independant timer","text":"<p>A simple timer not related to the PWM can be used to compute the control task period. We choose one of the MCU timer (the <code>timer 6</code>), to which we give our control period and this timer will call the control task each period.  </p> <p></p> <p>Tip</p> <p>With an independant timer you can choose any value in \u00b5s as the control period, there is not the same limitation as the PWM source.  </p> <p>Warning</p> <p>The disavantage of such method is that since it is independant from the PWM you can't have synchronization between several control task modules.</p>"},{"location":"core/docs/scheduling/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Periodic task based on PWM sourcePeriodic task based on Timer6 <p>1. Create the critical task and link it to the function to be called and choose hrtim as the source source. <code>task.createCritical(critical_function, control_period, source_hrtim);</code> 2. Start the critical function.  <code>task.startCritical()</code> </p> <p>1. Create the critical task and link it to the function to be called and choose tim6 as the source.  <code>task.createCritical(critical_function, control_period, source_tim6);</code> 2. Start the critical function.  <code>task.startCritical()</code> </p> <p>Example</p> 20kHz Periodic task based on PWM10kHz Periodic task based on Timer6 <pre><code>    task.createCritical(my_critical_function, 50, source_hrtim); \n    task.startCritical();\n</code></pre> <pre><code>    task.createCritical(my_critical_function, 100, source_tim6);\n    task.startCritical();\n</code></pre> <p>Tip</p> <p>Having a control Task is required for synchronous measurements to work correctly.</p>"},{"location":"core/docs/scheduling/#non-time-critical-tasks","title":"Non time critical tasks","text":"<p>In the powerAPI, non time critical tasks are refered as background tasks.</p>"},{"location":"core/docs/scheduling/#priority-between-critical-and-non-critical-task","title":"Priority between critical and non-critical task","text":"<p>The control task has priority over any other task. It will preempts any background task. The control task can not be preempted. That is why it is also refered as an uninteruptible task.</p> <p></p>"},{"location":"core/docs/scheduling/#pseudo-periodicity-of-non-critical-task","title":"Pseudo periodicity of non-critical task","text":"<p>Non-critical tasks aren't synchronous, meaning they're not recurring at regular intervals. Instead, they operate in a pseudo-periodic manner: we can temporarily halt them for a specific duration, during which they remain inactive.  Below, in the illustration we suspend the background task for a period of 500ms. After 500ms we can execute again the background task, but we need to end the control task to do that (the critical task is uninteruptible).</p> <p></p>"},{"location":"core/docs/scheduling/#initialization-sequence_1","title":"Initialization sequence","text":"<p>Note</p> <p>1. Create the background task and link it to the function to be called. <code>task.createBackground(function)</code>  2. Start the background function. <code>task.startCritical()</code> </p> <p>Example</p> Spawning a background taskMaking it pseudo periodic <p><pre><code>    void my_background_function(){\n        do_stuff();\n    }\n    task.createBackground(my_background_function);\n</code></pre> In that case <code>do_stuff()</code> will execute continuously each time the processor is not occupied by the critical task.</p> <p><pre><code>    void my_background_function(){\n        do_stuff();\n        suspendBackgroundUs(500);\n    }\n</code></pre> In that case after executing <code>do_stuff();</code> the task will be suspended for 500us and resumed after. It creates a pseudo periodical task, runs every 500us + the time taken to execute <code>do_stuff()</code>.</p>"},{"location":"core/docs/scheduling/#class-taskapi","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p>"},{"location":"core/docs/scheduling/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"core/docs/scheduling/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/scheduling/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"core/docs/scheduling/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Note:</p> <p>If the HRTIM is used to trigger the task (which is the default behavior), then the HRTIM must have been configured before calling this function.</p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically. </li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is HRTIM, this value must be an integer multiple of the HRTIM period. </li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the HRTIM is the source, but this optional parameter can be provided to set TIM6 as the source in case the HRTIM is not used or if the task can't be correlated to an HRTIM event. Allowed values are source_hrtim and source_tim6. </li> </ul> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error defining the task. An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"core/docs/scheduling/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/scheduling/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"core/docs/scheduling/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/scheduling/#function-stopcritical","title":"function stopCritical","text":"<pre><code>void TaskAPI::stopCritical () \n</code></pre>"},{"location":"core/docs/scheduling/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"core/docs/scheduling/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"core/docs/twistAPI/","title":"TWIST API","text":"<p>This API is designed to work with the TWIST hardware, providing a set of functions to manage and control the output power.</p>"},{"location":"core/docs/twistAPI/#features","title":"Features","text":"<p> - Versatile Control Modes: The API supports both voltage and peak current control modes, allowing you to choose the best option for your specific application. - Independent Leg Operation: Each of the two legs can operate independently with different topologies, such as boost or buck, offering greater flexibility in power management. - Configure different paramaters for power electronics (dead time, phase shift) - Simplified ADC value retrieval - Refer to TWIST hardware specifications for more detail on TWIST board.  </p>"},{"location":"core/docs/twistAPI/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>twist.initAllBuck()</code>, <code>twist.initAllBoost()</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setAllAdcDecim(decim)</code>  4. Set the dead time <code>twist.setAllDeadTime(rise_deadTime_ns, fall_deadTime_ns)</code>  5. Set the phase shift in degree <code>twist.setAllPhaseShift(ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the duty cycle to control output voltage <code>twist.setAllDutyCycle(duty_cycle)</code>  8. Then start the converters <code>twist.startAll()</code> </p> <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost <code>twist.initLegBuck(LEG1/LEG2)</code>, <code>twist.initLegBoost(LEG1/LEG2)</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setLegAdcDecim(LEG1/LEG2, decim)</code> 4. Set the dead time <code>twist.setLegDeadTime(LEG1/LEG2,rise_deadTime_ns, fall_deadTime_ns)</code> 5. Set the phase shift in degree <code>twist.setLegPhaseShift(LEG1/LEG2, ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the duty cycle to control output voltage <code>twist.setLegDutyCycle(LEG1/LEG2, duty_cycle)</code> 8. Then start the converters <code>twist.startLeg(LEG1/LEG2)</code> </p> <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>twist.initAllBuck(CURRENT_MODE)</code>, <code>twist.initAllBoost()</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setAllAdcDecim(decim)</code>  4. Set the dead time <code>twist.setAllDeadTime(rise_deadTime_ns, fall_deadTime_ns)</code>  5. Set the phase shift in degree <code>twist.setAllPhaseShift(ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the slope compensation to control the output current<code>twist.setAllSlopeCompensation(1.4, 1.0)</code>  8. Then start the converters <code>twist.startAll()</code> </p> <p>Warning</p> <p>Only buck topology is supported for current mode control currently.</p> <p>Example</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initAllBuck();\ntwist.setAllAdcDecim(1);\ntwist.setAllDeadTime(200,200);\ntwist.setAllPhaseShift(180);\ndata.enableTwistDefaultChannels();\ntwist.setAllDutyCycle(0.5);\ntwist.startAll();\n</code></pre> <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initLegBuck(LEG1);\ntwist.setLegAdcDecim(LEG1, 1);\ntwist.setLegDeadTime(LEG1, 200,200);\ntwist.setLegPhaseShift(LEG1, 180);\ndata.enableTwistDefaultChannels();\ntwist.setLegDutyCycle(LEG1, 0.5);\ntwist.startLeg(LEG1);\n</code></pre> <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initAllBuck(CURRENT_MODE);\ntwist.setAllAdcDecim(1);\ntwist.setAllDeadTime(200,200);\ntwist.setAllPhaseShift(180);\ndata.enableTwistDefaultChannels();\ntwist.setAllSlopeCompensation(1.4, 1.0);\ntwist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#voltage-mode-and-current-mode","title":"Voltage mode and Current mode","text":"<p>There is two different way to control the power delivered by TWIST : voltage and current mode. </p>"},{"location":"core/docs/twistAPI/#voltage-mode","title":"Voltage mode","text":"<p>Voltage mode is a traditional and widely-used approach in power electronics, where the output voltage is regulated by controlling the duty cycle. The duty cycle is a crucial parameter that determines the proportion of time a switch (such as a transistor) is active during a complete switching period. By adjusting the duty cycle, you can effectively manage the power delivered to a load.</p> <p>A higher duty cycle indicates that the switch remains on for a more extended period, resulting in increased power delivery to the load. Conversely, a lower duty cycle means the switch is on for a shorter duration, thereby reducing the power supplied. Consequently, the average power and voltage applied to the load can be precisely controlled by fine-tuning the duty cycle.</p>  Voltage mode PWM schematic  Voltage mode PWM waveform  <p></p> <p></p>"},{"location":"core/docs/twistAPI/#current-mode","title":"Current mode","text":"<p>In peak current mode control,  we monitors the current flowing through the power switch. Once the current reaches a predetermined peak value, we promptly turns off the power switch. This mechanism helps maintain a constant output voltage by regulating the current flow.</p> <p>In this setup, a clock signal determines the switching frequency and triggers the switch to close. The controller then sends a reference peak current value. When the inductor's current reaches this reference value, the switch opens.</p>  Current mode schematic  Current mode waveform  <p> </p> <p> </p> <p>However, using a constant peak current reference can lead to subharmonic oscillations. To prevent this issue, we employ a technique called slope compensation. Instead of a constant value, the peak current reference is a sawtooth waveform. The final schematic with slope compensation is shown below:</p>  Final current mode schematic Final current mode waveform  <p> </p> <p></p> <p>The sawtooth signal <code>Slope compensation</code> is generated with the function <code>twist.setAllSlopeCompensation</code> or <code>twist.setLegSlopeCompensation</code>. These functions set the slope compensation based on the input parameters.  for example <code>twist.setAllSlopeCompensation(1.4, 1.0)</code> generates a sawtooth signal ranging from 1.4V to 1.0V. You can create a sawtooth signal between 2.048V and 0V as well.</p> <p>This sawtooth signal is then compared with the ADC's current value. When selecting the sawtooth parameters, it's essential to consider the conversion of current to voltage.</p> <p>On the TWIST board, a voltage value of 1.024V on the ADC corresponds to a current of 0A. The system has a gain of 100mV per ampere, meaning that for each ampere increase in current, the voltage value increases by 100 millivolts. </p>"},{"location":"core/docs/twistAPI/#snippets-examples","title":"Snippets examples","text":""},{"location":"core/docs/twistAPI/#buck-topology","title":"Buck topology","text":""},{"location":"core/docs/twistAPI/#2-legs-with-the-same-configuration","title":"2 legs with the same configuration","text":"Connection  Schematic  <pre><code>    twist.initAllBuck();\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#2-independant-leg-operations","title":"2 independant leg operations","text":"Connection  Schematic  <pre><code>    twist.initLegBuck(LEG1);\n    twist.initLegBuck(LEG2);\n    twist.setLegDutyCycle(LEG1, 0.3);\n    twist.setLegDutyCycle(LEG2, 0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#boost-topology","title":"Boost topology","text":"Connection  Schematic  <pre><code>    twist.initAllBoost();\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#inverter-topology","title":"Inverter topologyMkDoxy Error: Incorrect class configuration","text":"Connection  Schematic  <pre><code>    twist.initLegBuck(LEG1);\n    twist.initLegBoost(LEG2);\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre> <p>Example</p> <p>Check the following examples for an application :     - Voltage mode buck     - Current mode buck     - Voltage mode boost </p> <p>Did not find Class with name: `TwistAPI`</p> Available classes: <pre><code>AnalogCommunication\nCanCommunication\nCommunicationAPI\nCompHAL\nDacHAL\nDataAPI\nGpioHAL\nLedHAL\nPwmHAL\nRs485Communication\nShieldAPI\nSpinAPI\nSyncCommunication\nTaskAPI\nTimerHAL\nUartHAL\nsafety\n</code></pre> Snippet <pre><code>::: doxy.powerAPI.class\nname: TwistAPI\n</code></pre>"},{"location":"core/owntech/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board for PlatformIO.</p> <p>The <code>boards_dir</code> variable is defined in <code>platformio.ini</code>, making this the board directory for PlatformIO, which will use its file <code>spin.json</code>.</p> <p>Help link: - PlatformIO Custom Boards</p>"},{"location":"core/zephyr/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board and Twist shield for Zephyr.</p> <p>As per location (within <code>Zephyr</code> folder), this is the default board directory for Zephyr OS, which will use its sub-directories <code>arm/spin</code> and <code>shields/twist</code>.</p> <p>Help links: - Zephyr OS Board Porting Guide - Zephyr OS Application Development Custom Board</p>"},{"location":"examples/","title":"Index","text":"<p>Welcome to the owntech examples repository.</p> <p>Here you can find ready to be used example for spin and twist.</p>"},{"location":"examples/#example-for-twist","title":"Example for TWIST","text":"<ul> <li> <p>DC DC topology examples</p> <ul> <li>Buck voltage mode</li> <li>Buck current mode</li> <li>Boost voltage mode</li> <li>Interleaved Buck</li> </ul> </li> <li> <p>Microgrid examples</p> <ul> <li>AC client server</li> <li>AC peer to peer</li> <li>DC client server</li> <li>DC droop</li> </ul> </li> <li> <p>DC AC topology examples</p> <ul> <li>Grid forming</li> <li>Grid following</li> </ul> </li> </ul>"},{"location":"examples/#example-for-spin","title":"Example for SPIN","text":"<ul> <li> <p>ADC use examples</p> <ul> <li>Software trigerred ADC</li> <li>HRTIM trigerred ADC</li> </ul> </li> <li> <p>DAC use examples</p> <ul> <li>Signal generation</li> </ul> </li> <li> <p>LED use examples</p> <ul> <li>Blinky</li> </ul> </li> <li> <p>PWM use examples</p> <ul> <li>PWM duty cycle control</li> <li>PWM phase shift control</li> <li>Multiple PWM operation</li> </ul> </li> <li> <p>TIMER</p> <ul> <li>Incremental encoder</li> </ul> </li> </ul>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/","title":"Triggering measure from ADC via HRTIM trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>The spin uses the stm32G4 MCU, which has a high resolution timer (HRTIM) which can produce high resolution PWM. This example will show you how to use the HRTIM in order to trigger the measures. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#software-setup","title":"Software setup","text":"<p>The HRTIM has 6 differents timer (A,B,C,D,E,F) but you can choose up to two of them to trigger the measures. In this example we'll show you how you can use one of them the timer A.</p> <p>On the picture below, you can see the waveform of the timer A pwm, the carrier, the duty cycle and the colored zone represents the timing where the measures is trigerred. </p> <p> figure 2</p> <p>The measure is triggered with the same frequency as the switching frequency, the measure is done around the trough of the carrier on the positive slope. We will explain here which functions to call to setup the ADC trigger. </p> <p>First of all, we start by initializing the PWMA : </p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMA, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> The function <code>setAdcEdgeTrigger</code> allows us to choose where we want to trigger the measures : on the positive slope (EdgeTrigger_up) of the carrier like in fig.2, or the negative slope (EdgeTrigger_down) of the carrier.</p> <p>After the initialization of the PWM, we can link it to a trigger : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMA, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMA); // enable the trigger\n</code></pre> We are linking PWMA to a trigger, here ADCTRIG_1. There is a total of 4 trigger possible ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4. However, there is only two that works for data acquisition currently : ADCTRIG_1 and ADCTRIG_3.</p> <p><code>setAdcTriggerInstant</code> will set the moment when we trigger a measure with a parameter between 0 (corresponding to the trough of the carrier)and 1 (corresponding to the crest of the carrier). Here we took 0.06, so we'll get the data around the trough of the carrier (as we have seen on fig.2)</p> <p>And finally, we set the ADC2 to be set by the ADCTRIG_1, hrtim_ev1 means hrtim external event 1 which is ADCTRIG_1. </p> <p><pre><code>    spin.adc.configureTriggerSource(2, hrtim_ev1); // ADC 2 configured to be triggered by the PWM\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can also use ADCTRIG_3 to have PWMC trigger another ADC and get another measure. Below, we reproduce the same step but by using the ADC1 channel 2 localized on PA1 (pin number 30).</p> <p>start PWMC :</p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMC, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMC, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMC); // timer initialization\n</code></pre> link ADCTRIG_3 to PWMC : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMC, ADCTRIG_3); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMC, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMC); // enable the trigger\n</code></pre> then set ADC1 channel 5 to be trigerred by ADCTRIG_3 : </p> <pre><code>    spin.adc.configureTriggerSource(1, hrtim_ev3); // ADC 2 configured to be triggered by the PWM\n    data.enableAcquisition(1, 30); // ADC 2 enabled\n</code></pre> <p>Finally you can retrieve data from the ADC : </p> <pre><code>    data.triggerAcquisition(1);\n    adc_value = data.getLatest(1, 30);\n</code></pre>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/","title":"Triggering measure from ADC via software trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>This example will show you how to get measures from the ADC by calling a function that will trigger the measures : this is what we call a software trigger.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#software-setup","title":"Software setup","text":"<p>The ADC 2 is used here, it is initialized like this : </p> <p><pre><code>    spin.adc.configureTriggerSource(2, software); // ADC 2 configured in software mode\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can configure any of the above ADC with same steps.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/DAC/signal_generation/","title":"Generating waveform with DAC","text":"<p>A DAC, or Digital-to-Analog Converter, converts digital signals into corresponding analog signals. It achieves this by assigning digital values to specific voltage, effectively generating continuous analog waveforms from discrete digital data. This functionality makes DACs essential for generating various waveforms in electronic systems.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>An oscilloscope to watch the DAC output</li> </ul> <p>Connect the oscilloscope to gpio PA6 (the DAC output).</p>"},{"location":"examples/SPIN/DAC/signal_generation/#software-setup","title":"Software setup","text":"<p>In this example we will use DAC 2 channel 1 to output a sawtooth signal. </p> <p>We start by initializing the DAC :</p> <pre><code>    spin.dac.initConstValue(2); // DAC 2 initialization\n    spin.dac.setConstValue(2, 1, 0); // Setting DAC 2 channel 1 to 0\n</code></pre> <p>The function <code>setConstValue</code> will convert numerical value (from 0 to 4096) to a voltage (between 0 and 2.048) with the DAC. </p> <p>In the background task (called every 100ms), is increasing the value send to the DAC : </p> <pre><code>    dac_value = (dac_value + 100)%4096;\n    spin.dac.setConstValue(2, 1, dac_value);\n</code></pre> <p>You can also reproduce the same step to use DAC1 channel 1 localized in gpio PA4.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#expected-result","title":"Expected result","text":"<p>You should see a sawtooth on the DAC output.</p>"},{"location":"examples/SPIN/LED/blinky/","title":"Blinking a led","text":"<p>Here is a simple example to start with SPIN : making a led blink.</p>"},{"location":"examples/SPIN/LED/blinky/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> </ul>"},{"location":"examples/SPIN/LED/blinky/#software-setup","title":"Software setup","text":"<p>The led is toggled in the background task called each 1s, which means the leed will blink at the rate of 1s : </p> <pre><code>    spin.led.toggle();\n</code></pre>"},{"location":"examples/SPIN/LED/blinky/#expected-result","title":"Expected result","text":"<p>Visual result : the led should turn on and off. </p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/","title":"Setting the duty cycle","text":"<p>In the context of Pulse Width Modulation (PWM), the duty cycle refers to the proportion of time that a signal is in the \"on\" state compared to the total period of the signal. It represents the percentage of time during which the signal is at its maximum level.</p> <p>In power electronics, such as motor control, power supplies, and voltage regulation, PWM is a widely used technique for controlling the amount of power delivered to a load. The duty cycle of the PWM signal determines the average power delivered to the load. By adjusting the duty cycle, engineers can control the speed of motors, regulate voltage levels, and efficiently manage power consumption.</p> <p>In this example we'll see how to generate a PWM, an control the duty cycle.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with one of them : PWMA.</p> <p> Figure 1</p> <p>PWMA has two complementary channels :</p> <ul> <li>PWMA1 on gpio A8</li> <li>PWMA2 on gpio A9</li> </ul> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#software-setup","title":"Software setup","text":"<p>First we start by initializing the PWMA :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n</code></pre> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe two complementary PWM and their evolution when you increase/decrease the duty cycle.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/","title":"Working with multiple PWM","text":"<p>The spin has a total of 5 PWM channels with 2 complementary output each. In this example, we'll detail how to use each of them.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch :</p> <p>-PWMA1 on gpio A8 -PWMC1 on gpio B12 -PWMD1 on gpio B14 -PWME1 on gpio C8 -PWMF1 on gpio C6</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#software-setup","title":"Software setup","text":"<p>This example is initializing every PWM, and making a phase shift 77\u00b0 (= 360/5\u00b0) as if we working in interleaved mode. See the  phase shift  example for more details.</p> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#expected-result","title":"Expected result","text":"<p>You should observe 5 PWM with a phaseshift of 77\u00b0 between them.</p>"},{"location":"examples/SPIN/PWM/phase_shift/","title":"Phase shifting PWM","text":"<p>Phase shift in Pulse Width Modulation (PWM) refers to the intentional offset of the timing between multiple PWM signals. This offset alters the switching instants of the signals, affecting the distribution of power delivery and minimizing ripple in power electronic systems.</p> <p>Phase shifting PWM is used in interleaved topology for power electronics. In this example we'll show you how setup a phase shift for a 2 leg interleaved configuration for example.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with two of them in phase shifted mode : PWMA and PWMB.</p> <p> Figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch PWMA1 on gpio A8 and PWMC1 on gpio B12.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#software-setup","title":"Software setup","text":"<p>We start by initializing PWMA and PWMC :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    /* PWM A initialization */\n    spin.pwm.initUnit(PWMA); // timer initialization\n    spin.pwm.startDualOutput(PWMA); // Start PWM\n\n    /* PWM C initialization */\n    spin.pwm.initUnit(PWMC); // timer initialization\n    spin.pwm.setPhaseShift(PWMC, 180); // Phase shift of 180\u00b0 for 2 legs interleaved configuration\n    spin.pwm.startDualOutput(PWMC); // Start PWM\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>PWMC is shifted of 180\u00b0 from PWMA.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n    spin.pwm.setDutyCycle(PWMC, duty_cycle);\n</code></pre> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe that PWMC1 is phase shifted of 180\u00b0 from PWMA1 (which means they are complementary).</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/","title":"Using the spin with an incremental encoder","text":"<p>An incremental encoder is a device that converts mechanical motion into digital signals. It typically consists of a rotating disk with evenly spaced slots and a sensor that detects these slots as the disk turns. The sensor generates electrical pulses corresponding to the motion, which can be used to track position, speed, or direction.</p> <p>in this example we'll see how to use an incremental encoder with spin.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>A rotary incremental encoder</li> </ul> <p>Connect output A (clk) to gpio B6 and output B (dt) to gpio B7.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#software-setup","title":"Software setup","text":"<p>We initialize the incremental encoder :</p> <p><pre><code>    spin.timer.startLogTimer4IncrementalEncoder();\n</code></pre> The value from the incremental encoder is updated in the background task (called every 100ms). This value is displayed in the serial monitor.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#expected-result","title":"Expected result","text":"<p>You should see the value in the serial monitor either increasing or decresing depending on how you turning the rotary incremental encoder (clokc-wise or not).</p>"},{"location":"examples/TWIST/DC_AC/grid_following/","title":"Ac current source follower","text":"<p>In this example you need to have a first Twist with the Grid Forming example.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 15 \\Omega\\).</li> </ul> <p>In the second Twist we use a software phase locked loop ( \"PLL\" ). By this way we are synchronised with the grid voltage and we can then inject current with a power factor of one. The current is regulated using a proportional resonant (\"PR\") regulator.</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_following/#import-a-library","title":"Import a library","text":"<p>the \"pll\" and \"pr\" are provided by the OwnTech control library which must be included  in the file <code>platfomio.ini</code>.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#define-a-regulator","title":"Define a regulator","text":"<p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.2F;\nstatic float32_t Kr = 3000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#configure-the-pll","title":"Configure the PLL","text":"<p>You have to define a PLL: <pre><code>static PllSinus pll;\nstatic PllDatas pll_datas;\n</code></pre></p> <p>Then initialize it: <pre><code>float32_t rise_time = 50e-3;\npll.init(Ts, Vgrid_amplitude, f0, rise_time);\n</code></pre></p> <p>and use it: <pre><code>pll_datas = pll.calculateWithReturn(V1_low_value - V2_low_value);\n</code></pre></p> <p>The calculation return a structure with 3 fields:</p> <ol> <li>the pulsation <code>w</code> in [rad/s]</li> <li>the angle <code>angle</code> in [rad]</li> <li>the angle error <code>error</code> in [rad/s]</li> </ol>"},{"location":"examples/TWIST/DC_AC/grid_following/#link-between-voltage-output-and-duty-cycle","title":"Link between voltage output and duty cycle","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#retrieve-recorded-datas","title":"Retrieve recorded datas","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/","title":"Ac Voltage Source","text":"<p>In this example we build an AC voltage source using a Twist and supply a resistor.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 30 \\Omega\\).</li> </ul>"},{"location":"examples/TWIST/DC_AC/grid_forming/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_forming/#import-libraries","title":"Import libraries","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#define-a-regulator","title":"Define a regulator","text":"<p>The voltage regulation will be done by a proportional resonant regulator. This component is provided by the OwnTech control library <code>control_lib</code>.</p> <p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.02F;\nstatic float32_t Kr = 4000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\nstatic float32_t Udc = 40.0F;\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_forming/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#link-between-voltage-reference-and-duty-cycles","title":"Link between voltage reference and duty cycles.","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/","title":"Boost with PID controlled output voltage","text":"<p>A voltage mode boost converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps up voltage levels, making it useful in various electronic devices such as converting photovoltaic panel voltage.</p> <p>This example will implement a voltage mode boost converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (max 10V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import the OwnTech control library with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static Pid pid; // define a pid controller\n\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/","title":"Buck current mode","text":""},{"location":"examples/TWIST/DC_DC/buck_current_mode/#overview","title":"Overview","text":"<p>A buck converter is a type of DC-DC converter used to efficiently regulate voltage levels. It works by converting a higher input voltage to a lower output voltage.</p> <p>Peak current control mode is a technique used in DC-DC converters to regulate the output voltage. In this mode, the converter controls the output voltage by monitoring the peak current flowing through the inductor. During each switching period when the peak current reaches a set limit, the converter switches off. This mode helps maintain stable output voltage by adjusting the duty cycle of the switching signal based on the peak current level, ensuring efficient and reliable power conversion.</p> <p>Currently only buck configuration is supported for current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#control-diagram","title":"Control diagram","text":"<p>The general implementation of the current mode follow this model.</p> <p> Source : STM32 AN5497</p> <p>check stm32 application note for more informations about current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#requirement-and-schematic","title":"Requirement and schematic","text":"<p>You will need :</p> <ul> <li>1 twist</li> <li>A DC power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#code-overview","title":"Code overview","text":"<p>We initialize the leg control in buck current mode with the lines above: </p> <pre><code> /* Initialize buck with current mode*/\n    twist.initAllBuck(CURRENT_MODE);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#important-functions","title":"Important functions","text":"<p>For current mode, there are two specific functions to control the current of both legs.</p> <pre><code>twist.setLegSlopeCompensation(LEG1, 1.4, 1.0);\ntwist.setLegSlopeCompensation(LEG2, 1.4, 1.0);\n</code></pre> <p>It sets in volt the higher and lower point of the sawtooth used for the slope compensation.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/","title":"Buck with PID controlled output voltage","text":"<p>A voltage mode buck converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps down voltage levels, making it useful in various electronic devices like phone battery charger.</p> <p>This example will implement a voltage mode buck converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (20-60V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import control_pid library with src/owntech.ini via the line :</p> <pre><code>lib_deps=\n    control_pid = https://gitlab.laas.fr/owntech/power-api/opalib-control-pid.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>opalib_control_init_interleaved_pid(kp, ki, kd, control_task_period);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static float32_t kp = 0.000215;\nstatic float32_t ki = 2.86;\nstatic float32_t kd = 0.0;\nstatic uint32_t control_task_period = 100;\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/","title":"Interleaved operation","text":""},{"location":"examples/TWIST/DC_DC/interleaved/#overview","title":"Overview","text":"<p>In the case of a two-phase interleaved buck converter, the term \"interleaved\" implies that there are two power stages operating, and they are out of phase by 180 degrees. This means that while one power stage is in its on-state (conducting), the other is in its off-state (non-conducting), and vice versa.</p> <p>The 180-degree phase shift ensures that there is always at least one power stage active, reducing the overall ripple and improving the efficiency of the buck converter. The interleaved operation helps distribute the load more evenly, minimizing the stress on individual components and resulting in a more efficient power conversion process.</p> <p></p> <p></p> <p>This example will implement interleaved operation using the two legs of the TWIST.</p>"},{"location":"examples/TWIST/DC_DC/interleaved/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need :</p> <ul> <li>1 TWIST</li> <li>A DC voltage power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/interleaved/#expected-results","title":"Expected results","text":"<p>The voltage reference is initially 15V, but you can increase/decrease it with the serial monitor with 'u' and 'd' on you keyboard.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/","title":"Client/Server control AC/DC","text":""},{"location":"examples/TWIST/Microgrid/AC_client_server/#overview","title":"Overview","text":"<p>In a dual inverter setup with one inverter designated as the \"SERVER\" and the other as the \"CLIENT,\" the SERVER inverter is responsible for sending a current reference and frequency signal to the CLIENT inverter. The CLIENT inverter, in turn, has the task of tracking the current reference from the SERVER and generating an output current that is in phase with the SERVER.</p> <p>SERVER Inverter Operation:</p> <p>The SERVER inverter is considered the primary control unit in the system. The SERVER inverter sets the output voltage, then it generates a reference signal for both the desired current magnitude (amplitude) and frequency to send to the CLIENT.</p> <p>CLIENT Inverter Operation:</p> <p>The CLIENT inverter receives the current reference and frequency signals from the SERVER. It compares the received current reference with the actual output current it is producing. The CLIENT inverter then adjusts its output voltage and frequency to match the reference signal provided by the SERVER. The goal is to ensure that the current generated by the CLIENT is in sync (in phase) with the current produced by the SERVER.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>you will need :</p> <ul> <li>Two Twist</li> <li>A 40V DC power supply</li> <li>A 30\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#instruction-to-flash-the-code-and-use-python-script","title":"Instruction to flash the code, and use python script","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the server or the client.</p> <p>To flash the server, choose :</p> <pre><code>#define server\n</code></pre> <p>To flash the client, choose :</p> <pre><code>#define client\n</code></pre> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p> <p>There is also a current gain to control the current reference sent to the CLIENT :</p> <pre><code>tx_data.consigne.Iref_fromSERVER = k_gain*I1_low_value;\n</code></pre> <p>This allows you to increase or deacrese the current of the CLIENT. To increase the current gain, in the serial monitor press <code>l</code> to decrease it press <code>m</code>.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#expected-result","title":"Expected result","text":"<p>If you set up correctly the project, you should have server and client output current in phase together.</p> <p></p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/","title":"Peer to peer AC control with an inverter and a synchronous rectifier","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#overview","title":"Overview","text":"<p>Peer-to-peer communication in power electronics involves two converters, a DC/AC converter producing a certain power and informing an AC/DC converter that it can consume this reference power.</p> <p></p> <p>DC/AC Converter (single phase inverter): This converter is responsible for converting direct current (DC) power into alternating current (AC) power. It may be connected to renewable energy sources (such as solar panels or wind turbines) or batteries, which produce DC power. The DC/AC converter's task is to generate AC power for use in the electrical network.</p> <p>AC/DC Converter (single phase synchronous rectifier): This converter performs the opposite function. It converts AC power back into DC power. This conversion is necessary when the electrical network requires DC power for various applications, such as charging batteries or powering DC devices.</p> <p>In a peer-to-peer communication system, these converters communicate with each other to optimize power exchange. The DC/AC converter informs the AC/DC converter of the available power it can deliver. This information includes details like the power's magnitude and frequency.</p> <p>An important aspect of this exchange is that the DC/AC converter must maintain an alternating current in phase opposition (180 degrees phase shift) with the input alternating voltage. This phase opposition ensures that power is effectively delivered to the load.</p> <p>A proportional resonant is used to keep the input alternative current in phase opposition with the Vac, a PI is used to control the output voltage Vdc.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>You will need :</p> <ul> <li>Two Twist</li> <li>A 50V DC power supply (input voltage for the inverter)</li> <li>A 6V DC power supply (external sensors/drivers suply for the synchronous rectifier)</li> <li>A 115\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul> <p>It is important to check that the boards you are using have the correct voltage and current measures since they'll be used to compute the duty cycle.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#instruction-to-flash-the-code-and-view-some-results","title":"Instruction to flash the code, and view some results","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-flash-the-code","title":"To flash the code","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the inverter or the synchronous rectifier.</p> <p>To flash the inverter, choose :</p> <pre><code>#define SERVER\n</code></pre> <p>To flash the synchronous rectifier, choose :</p> <pre><code>#define CLIENT\n</code></pre> <p>Here P_ref = 19W to have a 47V output DC voltage. You can change this value in line 87 of src/main.cpp file.</p> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#expected-results","title":"Expected results","text":"<p>If everything goes well you'll have 47V delivered to the resistor.</p> <p>Here are some results for Vdc and Idc : </p> <p>And for Vac and Iac : </p> <p>By using the python script you can also watch MCU internal variables :</p> <p></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/","title":"Current Control Experiment with Analog Communication - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#overview","title":"Overview","text":"<p>This code example demonstrates a current control experiment utilizing analog communication between a master board and multiple slave boards. The master board operates in voltage control mode and sends current references to the slave boards, which work in current control mode. The goal is to regulate and synchronize current injection into an electrical network.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Two boards are used: a master board and one or more slave boards.</li> <li>The master board generates current references and communicates them to the slave boards via analog communication. Communication Current Mode</li> <li>Synchronization modules ensure coordination of PWM signals between master and slave boards.</li> <li>Compensation control is utilized to equilibrate current between different legs of the system. compensation control</li> </ul> Connexion diagram Microgrid structure <p>To run this example you would need: 1. a Voltage Source fixed at ~30V  2. 2 Twist boards  3. 1 RJ45 cable to make the communication link between boards. 4. A variable resistive load between approximatively 6 and 12 Ohm.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#communication-modules","title":"Communication Modules","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#1-analog-communication","title":"1. Analog Communication","text":"<p>Analog communication facilitates the exchange of peak current references from the master board to the slave boards. This communication allows for current regulation and control within the system.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#2-synchronization","title":"2. Synchronization","text":"<p>Synchronization modules ensure that PWM signals are aligned and coordinated between the master and slave boards. This synchronization is crucial for maintaining accurate current control and injection.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#code-usage","title":"Code Usage","text":"<ol> <li>Upload <code>src/main.cpp</code> to the master board and each slave board.</li> <li>In the <code>main.cpp</code> file, navigate to line 114 to find the macro definition:</li> </ol> <pre><code>#define MASTER\n</code></pre> <p>Replace this macro with one of the following options based on the board you are flashing:</p> <p>For a slave board:    <pre><code>#define SLAVE\n</code></pre></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#example-workflow","title":"Example Workflow","text":"<ol> <li>Master Board Operation:</li> <li>The master board operates in voltage control mode.</li> <li>It generates current references within the 0-4000 range.</li> <li> <p>Using analog communication, it sends these references to the slave board(s).</p> </li> <li> <p>Slave Board Operation:</p> </li> <li>Each slave board operates in current control mode.</li> <li>It continuously monitors the analog communication from the master board.</li> <li>The slave board extracts the current reference and injects it into the electrical network.</li> <li> <p>Compensation control ensures balanced current distribution among the system's legs.</p> </li> <li> <p>Synchronization:</p> </li> <li>The synchronization modules guarantee that PWM signals are coordinated between the master and slave boards.</li> <li>This synchronization is vital for maintaining accurate and synchronized current injection.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#conclusion","title":"Conclusion","text":"<p>This code example showcases a current control experiment that employs analog communication between a master board and multiple slave boards. By following the provided instructions and flashing the appropriate code, you can simulate and observe the regulation and synchronization of current injection into an electrical network. The combination of voltage control, current control, analog communication, and synchronization modules results in an efficient and coordinated system for current regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/","title":"Parallel Power Conversion Experiment - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_droop/#overview","title":"Overview","text":"<p>This code example demonstrates an experiment involving three power converters connected in parallel to power a DC bus without communication. Each converter performs power conversion in buck mode and is programmed with a distinct droop factor (1.2, 1.1, and 1.6 respectively). The experiment aims to explore the behavior of parallel power conversion and observe the impact of different droop factors on the voltage regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Three power converters are connected in parallel to the DC bus.</li> <li>Each power converter operates in voltage control mode and performs power conversion in buck mode.</li> <li>Individual droop factors of 1.2, 1.1, and 1.6 are programmed for the respective cards.</li> </ul> Connexion diagram Microgrid structure"},{"location":"examples/TWIST/Microgrid/DC_droop/#code-usage","title":"Code Usage","text":"<ol> <li>Flash <code>src/main.cpp</code> to each of the power converters.</li> <li>In the <code>main.cpp</code> file, go to line 80 to find the macro definition:</li> </ol> <pre><code>#define DROOP\n</code></pre> <p>Replace this macro with the relevant option for the board you are flashing:</p> <p>For a different board:    <pre><code>#define DROOP1\n</code></pre></p> <p>or</p> <pre><code>#define DROOP2\n</code></pre>"},{"location":"examples/TWIST/Microgrid/DC_droop/#example-workflow","title":"Example Workflow","text":"<ol> <li>Parallel Power Conversion:</li> <li>Three power converters are interconnected in parallel to supply power to the DC bus.</li> <li>Each converter performs power conversion using a buck mode.</li> <li> <p>Individual droop factors (1.2, 1.1, and 1.6) are applied to each converter.</p> </li> <li> <p>Voltage Regulation:</p> </li> <li>Monitor the behavior of the parallel power conversion system and observe how it manages voltage regulation under different conditions.</li> <li>Analyze the role of each card's droop factor in distributing the load and regulating the voltage on the DC bus.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_droop/#conclusion","title":"Conclusion","text":"<p>By following the provided guidelines and uploading the code to the power cards, you can emulate and study the dynamics of parallel power conversion in buck mode. This experiment allows you to investigate the impact of varied droop factors on voltage regulation and observe how the power cards work together in parallel to provide power to the DC bus. The combination of voltage control, buck mode operation, and unique droop factors contributes to an efficient and synchronized power conversion system.</p>"},{"location":"examples/docs/home/","title":"Home","text":"<p>Opening a fully featured example is often the best way to get started.</p> <p>Tip</p> <p>Need help to launch an example ? Here it is !</p>"},{"location":"examples/docs/home/#browse-spin-examples","title":"Browse SPIN examples","text":"<p>Get on track using featured examples : </p> <ul> <li> <p> Blinky</p> <p>Get up and running in minutes</p> <p> Blinky</p> </li> <li> <p> Multiple PWM</p> <p>Lets play, lets do PWMs !</p> <p> Examples</p> </li> </ul> <ul> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> Duty Cycle control  Phase Shift control </p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> Software Triggered Measures  Real Time Measurments</p> </li> </ul>"},{"location":"examples/docs/home/#browse-twist-examples","title":"Browse TWIST examples","text":""},{"location":"examples/docs/home/#dc-to-dc-applications","title":"DC to DC applications","text":"<ul> <li> <p> Buck</p> <p>Good starting point to deploy your first power application. </p> <p> Buck voltage mode </p> <p>Leverage embedded analog hardware, go for current mode !</p> <p> Buck current mode </p> <p>Interleaving, made easy</p> <p> Interleaved Buck </p> </li> <li> <p> Boost</p> <p>Need a boost ? Here you go !</p> <p> Boost voltage mode.</p> </li> </ul>"},{"location":"examples/docs/home/#dc-to-ac-applications","title":"DC to AC applications","text":"<ul> <li> <p> Grid forming Inverter</p> <p>Good starting point to discover AC world. </p> <p> Grid Forming Inverter  </p> </li> <li> <p> Grid Following Inverter</p> <p>Get in sync with the grid !</p> <p> Grid Following Inverter </p> </li> </ul>"},{"location":"examples/docs/home/#microgrid-applications","title":"Microgrid Applications","text":"<ul> <li> <p> DC Droop</p> <p>Sometimes, a simple droop is enough </p> <p> DC Droop  </p> </li> <li> <p> DC with communication</p> <p>Introduction to communication based DC microgrid</p> <p> Client - Server DC </p> </li> <li> <p> AC Client/Server</p> <p>Sharing the load is caring ! </p> <p> AC Client/Server  </p> </li> <li> <p> AC Peer2Peer</p> <p>Doing.. Legal Peer2Peer !</p> <p> AC Peer2Peer </p> </li> </ul>"},{"location":"powerAPI/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class ShieldAPI </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class UartHAL Handles usart 1 for the SPIN board. </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t </li> <li>struct dma_user_data_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>class safety </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t </li> <li>struct timer_driver_api </li> <li>struct timer_hrtim_t Timinig unit configuration - aggregates all the structures. </li> </ul>"},{"location":"powerAPI/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir core <ul> <li>dir zephyr <ul> <li>dir modules <ul> <li>dir owntech_adc_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file adc.c </li> <li>file adc.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_communication <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file CommunicationAPI.cpp </li> <li>file CommunicationAPI.h </li> </ul> </li> <li>dir src <ul> <li>file AnalogCommunication.cpp </li> <li>file AnalogCommunication.h </li> <li>file CanCommunication.cpp </li> <li>file CanCommunication.h </li> <li>file Rs485.cpp </li> <li>file Rs485.h </li> <li>file Rs485Communication.cpp </li> <li>file Rs485Communication.h </li> <li>file SyncCommunication.cpp </li> <li>file SyncCommunication.h </li> <li>file data_objects.cpp </li> <li>file data_objects.h Handling of ThingSet data objects. </li> <li>file thingset_isotp.cpp </li> <li>file thingset_pub_sub.cpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_comparator_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file comparator.c </li> <li>file comparator.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_dac_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file dac.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_flash_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file nvs_storage.c </li> <li>file nvs_storage.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_hrtim_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file hrtim.h </li> <li>file hrtim_enum.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_ngnd_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file ngnd.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_safety_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SafetyAPI.cpp </li> <li>file SafetyAPI.h </li> <li>file safety_internal.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_shield_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file ShieldAPI.cpp </li> <li>file ShieldAPI.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_spin_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SpinAPI.cpp </li> <li>file SpinAPI.h </li> </ul> </li> <li>dir src <ul> <li>file CompHAL.cpp </li> <li>file CompHAL.h </li> <li>file DacHAL.cpp </li> <li>file DacHAL.h </li> <li>file DataAPI.cpp </li> <li>file DataAPI.h </li> <li>file GpioHAL.cpp </li> <li>file GpioHAL.h </li> <li>file LedHAL.cpp </li> <li>file LedHAL.h </li> <li>file PwmHAL.cpp </li> <li>file PwmHAL.h </li> <li>file TimerHAL.cpp </li> <li>file TimerHAL.h </li> <li>file UartHAL.cpp </li> <li>file UartHAL.h </li> <li>dir data <ul> <li>file data_conversion.cpp </li> <li>file data_conversion.h </li> <li>file data_dispatch.cpp </li> <li>file data_dispatch.h </li> <li>file dma.cpp </li> <li>file dma.h </li> </ul> </li> <li>file hardware_auto_configuration.cpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_task_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file TaskAPI.cpp </li> <li>file TaskAPI.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_timer_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file timer.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"powerAPI/classAnalogCommunication/","title":"Class AnalogCommunication","text":"<p>ClassList &gt; AnalogCommunication</p>"},{"location":"powerAPI/classAnalogCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name float32_t getAnalogCommValue () Get the analog value. void init () Initializing analog communication (ADC and DAC) void setAnalogCommValue (uint32_t analog_bus_value) Set the analog value, the DAC output."},{"location":"powerAPI/classAnalogCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classAnalogCommunication/#function-getanalogcommvalue","title":"function getAnalogCommValue","text":"<p>Get the analog value. <pre><code>static float32_t AnalogCommunication::getAnalogCommValue () \n</code></pre></p> <p>Returns:</p> <p>Analog value (A value between 0 and 4096) </p>"},{"location":"powerAPI/classAnalogCommunication/#function-init","title":"function init","text":"<pre><code>static void AnalogCommunication::init () \n</code></pre>"},{"location":"powerAPI/classAnalogCommunication/#function-setanalogcommvalue","title":"function setAnalogCommValue","text":"<p>Set the analog value, the DAC output. <pre><code>static void AnalogCommunication::setAnalogCommValue (\n    uint32_t analog_bus_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>analog_bus_value</code> A value between 0 and 4096 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/classCanCommunication/","title":"Class CanCommunication","text":"<p>ClassList &gt; CanCommunication</p>"},{"location":"powerAPI/classCanCommunication/#public-functions","title":"Public Functions","text":"Type Name void enableCan () Enable can."},{"location":"powerAPI/classCanCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name uint16_t getBroadcastPeriod () Get the broadcast period. uint16_t getCanNodeAddr () Get the CAN node address. uint16_t getControlPeriod () Get the control period. bool getCtrlEnable () Get the control enable status. float32_t getCtrlReference () Get the control reference value. void setBroadcastPeriod (uint16_t time_100_ms) Set the broadcast period. void setCanNodeAddr (uint16_t addr) Set the CAN node address. void setControlPeriod (uint16_t time_100_ms) Set the control period. void setCtrlEnable (bool enable) Set the control enable status. void setCtrlReference (float32_t reference) Set the control reference value."},{"location":"powerAPI/classCanCommunication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classCanCommunication/#function-enablecan","title":"function enableCan","text":"<pre><code>void CanCommunication::enableCan () \n</code></pre>"},{"location":"powerAPI/classCanCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classCanCommunication/#function-getbroadcastperiod","title":"function getBroadcastPeriod","text":"<p>Get the broadcast period. <pre><code>static uint16_t CanCommunication::getBroadcastPeriod () \n</code></pre></p> <p>Returns:</p> <p>The broadcast period in 100 ms units. </p>"},{"location":"powerAPI/classCanCommunication/#function-getcannodeaddr","title":"function getCanNodeAddr","text":"<p>Get the CAN node address. <pre><code>static uint16_t CanCommunication::getCanNodeAddr () \n</code></pre></p> <p>Returns:</p> <p>The CAN node address. </p>"},{"location":"powerAPI/classCanCommunication/#function-getcontrolperiod","title":"function getControlPeriod","text":"<p>Get the control period. <pre><code>static uint16_t CanCommunication::getControlPeriod () \n</code></pre></p> <p>Returns:</p> <p>The control period in 100 ms units. </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlenable","title":"function getCtrlEnable","text":"<p>Get the control enable status. <pre><code>static bool CanCommunication::getCtrlEnable () \n</code></pre></p> <p>Returns:</p> <p>True if control is enabled, false otherwise. </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlreference","title":"function getCtrlReference","text":"<p>Get the control reference value. <pre><code>static float32_t CanCommunication::getCtrlReference () \n</code></pre></p> <p>Returns:</p> <p>The control reference value. </p>"},{"location":"powerAPI/classCanCommunication/#function-setbroadcastperiod","title":"function setBroadcastPeriod","text":"<p>Set the broadcast period. <pre><code>static void CanCommunication::setBroadcastPeriod (\n    uint16_t time_100_ms\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_100_ms</code> The broadcast period (in multiple of 100 ms) to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcannodeaddr","title":"function setCanNodeAddr","text":"<p>Set the CAN node address. <pre><code>static void CanCommunication::setCanNodeAddr (\n    uint16_t addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> The CAN node address to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcontrolperiod","title":"function setControlPeriod","text":"<p>Set the control period. <pre><code>static void CanCommunication::setControlPeriod (\n    uint16_t time_100_ms\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_100_ms</code> The control period (in multiple of 100 ms) to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlenable","title":"function setCtrlEnable","text":"<p>Set the control enable status. <pre><code>static void CanCommunication::setCtrlEnable (\n    bool enable\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> True to enable control, false to disable it. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlreference","title":"function setCtrlReference","text":"<p>Set the control reference value. <pre><code>static void CanCommunication::setCtrlReference (\n    float32_t reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> The control reference value to set. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/classCommunicationAPI/","title":"Class CommunicationAPI","text":"<p>ClassList &gt; CommunicationAPI</p>"},{"location":"powerAPI/classCommunicationAPI/#public-attributes","title":"Public Attributes","text":"Type Name AnalogCommunication analog Contains all the function for analog communication. CanCommunication can Contains all the function for can communication. Rs485Communication rs485 Contains all the function for rs485 communication. SyncCommunication sync Contains all the function for sync communication."},{"location":"powerAPI/classCommunicationAPI/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/classCommunicationAPI/#variable-analog","title":"variable analog","text":"<pre><code>AnalogCommunication CommunicationAPI::analog;\n</code></pre>"},{"location":"powerAPI/classCommunicationAPI/#variable-can","title":"variable can","text":"<pre><code>CanCommunication CommunicationAPI::can;\n</code></pre>"},{"location":"powerAPI/classCommunicationAPI/#variable-rs485","title":"variable rs485","text":"<pre><code>Rs485Communication CommunicationAPI::rs485;\n</code></pre>"},{"location":"powerAPI/classCommunicationAPI/#variable-sync","title":"variable sync","text":"<pre><code>SyncCommunication CommunicationAPI::sync;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/classCompHAL/","title":"Class CompHAL","text":"<p>ClassList &gt; CompHAL</p> <p>Handles comparator 1 and 3 of the SPIN board. More...</p> <ul> <li><code>#include &lt;CompHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classCompHAL/#public-functions","title":"Public Functions","text":"Type Name void initialize (uint8_t comparator_number) Initializes a comparator for the current mode control."},{"location":"powerAPI/classCompHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call the initialization function of either comparator </p>"},{"location":"powerAPI/classCompHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classCompHAL/#function-initialize","title":"function initialize","text":"<p>Initializes a comparator for the current mode control. <pre><code>void CompHAL::initialize (\n    uint8_t comparator_number\n) \n</code></pre></p> <p>Note:</p> <p>Current mode control deploys a comparator together with a DAC. This function must be called after setting up the DAC linked to the comparator. Note that comparator 1 is linked with DAC3 and comparator 3 with DAC1. Comparator 1 is linked with ilow1 and comparator 3 is linked with ilow2.</p> <p>Parameters:</p> <ul> <li><code>comparator_number</code> can be either 1 or 3</li> </ul> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/classDacHAL/","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"powerAPI/classDacHAL/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src)  void initConstValue (uint8_t dac_number)  void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value)  void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage)"},{"location":"powerAPI/classDacHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDacHAL/#function-currentmodeinit","title":"function currentModeInit","text":"<pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-initconstvalue","title":"function initConstValue","text":"<pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-setconstvalue","title":"function setConstValue","text":"<pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-slopecompensation","title":"function slopeCompensation","text":"<pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/classDataAPI/","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p>"},{"location":"powerAPI/classDataAPI/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (adc_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. void configureTriggerSource (adc_t adc_number, adc_ev_src_t trigger_source) Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. float32_t convertValue (uint8_t pin_number, uint16_t raw_value) Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. int8_t enableAcquisition (uint8_t pin_number, adc_t adc_number=DEFAULT_ADC) This function is used to enable acquisition on a Spin PIN with a given ADC. conversion_type_t getConversionParameterType (uint8_t pin_number) Use this function to get the current conversion type for the chosen channel. float32_t getConversionParameterValue (uint8_t pin_number, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . float32_t getLatestValue (uint8_t pin_number, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. uint16_t * getRawValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t * getValues (uint8_t pin_number, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function converts all values that have been acquired since last call are stored and provide an array containing all of them. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t peekLatestValue (uint8_t pin_number) Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. int8_t retrieveConversionParametersFromMemory (uint8_t pin_number) Retrieved previously configured conversion parameters from persistent memory. void setConversionParametersLinear (uint8_t pin_number, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setConversionParametersNtcThermistor (uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t stop () Stops the module if it is started. int8_t storeConversionParametersInMemory (uint8_t pin_number) Store the currently configured conversion parameters of a given channel in persistent memory. void triggerAcquisition (adc_t adc_number) Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired."},{"location":"powerAPI/classDataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDataAPI/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. <pre><code>void DataAPI::configureDiscontinuousMode (\n    adc_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Note:</p> <p>This is an advanced function that requires to understand the way the ADC work. Only for use if you explicitely requires it.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. <pre><code>void DataAPI::configureTriggerSource (\n    adc_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-convertvalue","title":"function convertValue","text":"<p>Use this function to convert values obtained using matching data.getRawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convertValue (\n    uint8_t pin_number,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. If there is an error, returns -5000. </p>"},{"location":"powerAPI/classDataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t pin_number,\n    adc_t adc_number=DEFAULT_ADC\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisiton: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before Data API is started.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the Spin pin on which to enable acquisition. </li> <li><code>adc_number</code> Number of the ADC on which acquisition is to be done. This parameter can be omitted, in which case:</li> <li>If only one ADC is linked to the given pin, it will be selected.</li> <li>If two ADCs are available for acquisition on the given pin, the ADC with the lowest number will be selected.</li> </ul> <p>Returns:</p> <p>0 if acquisition was correctly enabled, -1 if there was an error. Errors generally indicate that the given pin is not linked to and ADC, and thus can not be used for acquisition. If the adc_number parameter was explicitely provided, it can also indicate that the given ADC is not available for acquisition on the provided pin. </p>"},{"location":"powerAPI/classDataAPI/#function-getconversionparametertype","title":"function getConversionParameterType","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::getConversionParameterType (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Returns the type of convertion of the given pin. Returns -5 if the channel is not active. </p>"},{"location":"powerAPI/classDataAPI/#function-getconversionparametervalue","title":"function getConversionParameterValue","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::getConversionParameterValue (\n    uint8_t pin_number,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter. Returns -5000 if the channel is not active. </p>"},{"location":"powerAPI/classDataAPI/#function-getlatestvalue","title":"function getLatestValue","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatestValue (\n    uint8_t pin_number,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.getRawValues() function for the matching channel, as data.getLatestValue() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-getrawvalues","title":"function getRawValues","text":"<p>Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use data.convertValue() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"powerAPI/classDataAPI/#function-getvalues","title":"function getValues","text":"<p>Function to access the acquired data for specified pin. This function converts all values that have been acquired since last call are stored and provide an array containing all of them. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>float32_t * DataAPI::getValues (\n    uint8_t pin_number,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Warning:</p> <p>This is an expensive function. Calling this function trigger the conversion of all values acquired since the last call. If only the lastet value is required, it is advised to call getLatestValue() instead. If multiple values are required, but not all, it is advised to call getRawValues() instead, then explicitely convert required values using convertValue().</p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the array returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to an array in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"powerAPI/classDataAPI/#function-peeklatestvalue","title":"function peekLatestValue","text":"<p>Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peekLatestValue (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-retrieveconversionparametersfrommemory","title":"function retrieveConversionParametersFromMemory","text":"<p>Retrieved previously configured conversion parameters from persistent memory. <pre><code>int8_t DataAPI::retrieveConversionParametersFromMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retrieved, negative value if there was an error: -1: persistent memory is empty -2: persistent memory contains data, but its version doesn't match current version -3: data in persistent memory is corrupted -4: persistent memory contains data, but not for the requested pin -5000: pin not found. </p>"},{"location":"powerAPI/classDataAPI/#function-setconversionparameterslinear","title":"function setConversionParametersLinear","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersLinear (\n    uint8_t pin_number,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setconversionparametersntcthermistor","title":"function setConversionParametersNtcThermistor","text":"<p>Use this function to set the conversion values for any NTC thermistor sensor if default values are not accurate enough. <pre><code>void DataAPI::setConversionParametersNtcThermistor (\n    uint8_t pin_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the sensor is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>pin_number</code> Number of the pin from which to obtain values. </li> <li><code>r0</code> The NTC resistance at a reference temperature. </li> <li><code>b</code> The sensibility coefficient of the resistance to temperature. </li> <li><code>rdiv</code> The bridge dividor resistance used to condition the NTC. </li> <li><code>t0</code> The reference temperature of the thermistor. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually, it will automatically be started at the same time as the task as their internal behavior are intrinsically linked. If for some reason you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task. In that case, Data Acquisition must be manually started using this function. Note that in taht case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out. No ADC configuration change is allowed after module has been started. If you're using a power shield and are not sure how to initialize ADCs, you can use data.enableShieldDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function. Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when dispatch method is set to be external, but the repetition value has not provided. Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"powerAPI/classDataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"powerAPI/classDataAPI/#function-stop","title":"function stop","text":"<p>Stops the module if it is started. <pre><code>int8_t DataAPI::stop () \n</code></pre></p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when trying to stop Data API while it was not started. </p>"},{"location":"powerAPI/classDataAPI/#function-storeconversionparametersinmemory","title":"function storeConversionParametersInMemory","text":"<p>Store the currently configured conversion parameters of a given channel in persistent memory. <pre><code>int8_t DataAPI::storeConversionParametersInMemory (\n    uint8_t pin_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin_number</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correctly stored, negative value if there was an error: -1: There was an error, -5000: pin not found. </p>"},{"location":"powerAPI/classDataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired. <pre><code>void DataAPI::triggerAcquisition (\n    adc_t adc_number\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the at least one channel is enabled on the ADC and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"powerAPI/classGpioHAL/","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p>"},{"location":"powerAPI/classGpioHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"powerAPI/classGpioHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classGpioHAL/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>flags</code> Pin configuration flags. Authorized values:</li> <li>INPUT</li> <li>INPUT_PULLUP</li> <li>OUTPUT </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"powerAPI/classGpioHAL/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <ul> <li>if pin value is 1, it will be set to 0</li> <li>if pin value is 0, it will be set to 1.</li> </ul> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/classLedHAL/","title":"Class LedHAL","text":"<p>ClassList &gt; LedHAL</p>"},{"location":"powerAPI/classLedHAL/#public-functions","title":"Public Functions","text":"Type Name void toggle ()  void turnOff ()  void turnOn ()"},{"location":"powerAPI/classLedHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classLedHAL/#function-toggle","title":"function toggle","text":"<pre><code>void LedHAL::toggle () \n</code></pre>"},{"location":"powerAPI/classLedHAL/#function-turnoff","title":"function turnOff","text":"<pre><code>void LedHAL::turnOff () \n</code></pre>"},{"location":"powerAPI/classLedHAL/#function-turnon","title":"function turnOn","text":"<pre><code>void LedHAL::turnOn () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/classPwmHAL/","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classPwmHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. hrtim_adc_trigger_t getAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. uint32_t getFrequencyMax (hrtim_tu_number_t pwmX) This function returns the maximum frequency of the selected timer in Hz. uint32_t getFrequencyMin (hrtim_tu_number_t pwmX) This function returns the minimum frequency of the selected timer in Hz. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint16_t getPeriodMax (hrtim_tu_number_t pwmX) This function returns the maximum period of the selected timing unit. uint16_t getPeriodMin (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. uint32_t getResolutionPs (hrtim_tu_number_t pwmX) This function returns the resolution of the timing unit in picoseconds. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initFixedFrequency (uint32_t fixed_frequency) This function initialize the PWM for fixed frequency applications. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void initVariableFrequency (uint32_t initial_frequency, uint32_t minimal_frequency) This functions initializes the PWM for variable frequency applications. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startDualOutput (hrtim_tu_number_t pwmX) This fonction starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"powerAPI/classPwmHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"powerAPI/classPwmHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classPwmHAL/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> function to call each interupt </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Warning:</p> <p>call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both </p>"},{"location":"powerAPI/classPwmHAL/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>hrtim_adc_trigger_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4 </p>"},{"location":"powerAPI/classPwmHAL/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9 </p>"},{"location":"powerAPI/classPwmHAL/#function-getfrequencymax","title":"function getFrequencyMax","text":"<p>This function returns the maximum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getfrequencymin","title":"function getFrequencyMin","text":"<p>This function returns the minimum frequency of the selected timer in Hz. <pre><code>uint32_t PwmHAL::getFrequencyMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWM mode - VOLTAGE_MODE or CURRENT_MODE</p> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Lft_aligned or UpDwn (center aligned) </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodmax","title":"function getPeriodMax","text":"<p>This function returns the maximum period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMax (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodmin","title":"function getPeriodMin","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriodMin (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in number of clock cycles </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getresolutionps","title":"function getResolutionPs","text":"<p>This function returns the resolution of the timing unit in picoseconds. <pre><code>uint32_t PwmHAL::getResolutionPs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Note:</p> <p>The resolution of the PWM depends on the prescaler that is automatically calculated when the master unit is initialized. For an HRTIM frequency of =170MHz: PRSCL = 0 : fHRTIM x 32 = 4.608 GHz - Res: 184 ps - Min PWM f: 83.0 kHz PRSCL = 1 : fHRTIM x 16 = 2.304 GHz - Res: 368 ps - Min PWM f: 41.5 kHz PRSCL = 2 : fHRTIM x 8 = 1.152 GHz - Res: 735 ps - Min PWM f: 20.8 kHz PRSCL = 3 : fHRTIM x 4 = 576 MHz - Res: 1470 ps - Min PWM f: 10.4 kHz PRSCL = 4 : fHRTIM x 2 = 288 MHz - Res: 2940 ps - Min PWM f: 5.2 kHz PRSCL = 5 : fHRTIM X 1 = 144 MHz - Res: 5880 ps - Min PWM f: 2.6 kHz   PRSCL = 6 : fHRTIM / 2 = 72 MHz - Res:11760 ps - Min PWM f: 1.3 kHz PRSCL = 7 : fHRTIM / 4 = 36 MHz - Res:23530 ps - Min PWM f: 0.65 kHz </p>"},{"location":"powerAPI/classPwmHAL/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWMx1 (high side convention) or PWMx2 (low-side convention) </p>"},{"location":"powerAPI/classPwmHAL/#function-initfixedfrequency","title":"function initFixedFrequency","text":"<p>This function initialize the PWM for fixed frequency applications. <pre><code>void PwmHAL::initFixedFrequency (\n    uint32_t fixed_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fixed_frequency</code> frequency to be fixed in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing any timing unit. The frequency will not vary during the operation of the power device. Use it for fixed frequencies only. </p>"},{"location":"powerAPI/classPwmHAL/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classPwmHAL/#function-initvariablefrequency","title":"function initVariableFrequency","text":"<p>This functions initializes the PWM for variable frequency applications. <pre><code>void PwmHAL::initVariableFrequency (\n    uint32_t initial_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>initial_frequency</code> The initial value of the frequency in Hz </li> <li><code>minimal_frequency</code> The minimal value of the frequency in Hz</li> </ul> <p>Warning:</p> <p>This function must be called BEFORE initialiazing any timing unit. The user can vary the frequency during the operation of the power device. This may compromise the resolution of the PWM. you can check your resolution with the getResolutionPS function. </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>decimation</code> decimation/post-scaler - a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_edge_trigger</code> Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_trig</code> adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4</li> </ul> <p>Warning:</p> <p>Call this function BEFORE enabling the adc trigger and AFTER initializing the selected timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>trig_val</code> a value between 0 and 1 </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>this function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"powerAPI/classPwmHAL/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>eev</code> external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9</li> </ul> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step Use it AFTER the initialization of the timing unit. </p>"},{"location":"powerAPI/classPwmHAL/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>modulation</code> PWM Modulation - Lft_aligned or UpDwn</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>shift</code> phase shift value \u00b0 between -360 and 360</li> </ul> <p>Warning:</p> <p>use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"powerAPI/classPwmHAL/#function-startdualoutput","title":"function startDualOutput","text":"<p>This fonction starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/classRs485Communication/","title":"Class Rs485Communication","text":"<p>ClassList &gt; Rs485Communication</p>"},{"location":"powerAPI/classRs485Communication/#public-functions","title":"Public Functions","text":"Type Name void configure (uint8_t * transmission_bufer, uint8_t * reception_buffer, uint16_t data_size, void(*)() user_function, rs485_speed_t data_speed=SPEED_10M) configuration for RS485 communication using a 10Mbit/s speed void configureCustom (uint8_t * transmission_bufer, uint8_t * reception_buffer, uint16_t data_size, void(*)(void) user_function, uint32_t baudrate, bool oversampling_8) Custom configuration for RS485 communication to choose the communication speed. void startTransmission () start a transmission i.e. you send what is contained in the transmission buffer void turnOffCommunication () Turn off the RS485. void turnOnCommunication () Turn on the RS485 communication."},{"location":"powerAPI/classRs485Communication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classRs485Communication/#function-configure","title":"function configure","text":"<p>configuration for RS485 communication using a 10Mbit/s speed <pre><code>void Rs485Communication::configure (\n    uint8_t * transmission_bufer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)() user_function,\n    rs485_speed_t data_speed=SPEED_10M\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the recevied buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>data_speed</code> Transmission speed (by default to 10Mbits/s) </li> <li>SPEED_2M </li> <li>SPEED_5M </li> <li>SPEED_10M </li> <li>SPEED_20M</li> </ul> <p>Warning:</p> <p>the size of transmission_buffer and reception_buffer must be the same</p> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classRs485Communication/#function-configurecustom","title":"function configureCustom","text":"<p>Custom configuration for RS485 communication to choose the communication speed. <pre><code>void Rs485Communication::configureCustom (\n    uint8_t * transmission_bufer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)(void) user_function,\n    uint32_t baudrate,\n    bool oversampling_8\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the recevied buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>baudrate</code> communication speed in bit/s </li> <li><code>oversampling_8</code> True for oversampling (and multiply communication speed by 2), false if you want to keep the normal speed communication</li> </ul> <p>Warning:</p> <p>the size of transmission_buffer and reception_buffer must be the same </p>"},{"location":"powerAPI/classRs485Communication/#function-starttransmission","title":"function startTransmission","text":"<pre><code>void Rs485Communication::startTransmission () \n</code></pre>"},{"location":"powerAPI/classRs485Communication/#function-turnoffcommunication","title":"function turnOffCommunication","text":"<pre><code>void Rs485Communication::turnOffCommunication () \n</code></pre>"},{"location":"powerAPI/classRs485Communication/#function-turnoncommunication","title":"function turnOnCommunication","text":"<p>Turn on the RS485 communication. <pre><code>void Rs485Communication::turnOnCommunication () \n</code></pre></p> <p>Remark:</p> <p>The RS485 is automatically turned on when initializing with configureDefault or configure, no need to call this function </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/classShieldAPI/","title":"Class ShieldAPI","text":"<p>ClassList &gt; ShieldAPI</p>"},{"location":"powerAPI/classShieldAPI/#public-static-attributes","title":"Public Static Attributes","text":"Type Name NgndHAL ngnd Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. PowerAPI power Contains all the functions to drive shield power capabilities. SensorsAPI sensors Contains all the functions to interact with shield sensors."},{"location":"powerAPI/classShieldAPI/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/classShieldAPI/#variable-ngnd","title":"variable ngnd","text":"<pre><code>NgndHAL ShieldAPI::ngnd;\n</code></pre>"},{"location":"powerAPI/classShieldAPI/#variable-power","title":"variable power","text":"<pre><code>PowerAPI ShieldAPI::power;\n</code></pre>"},{"location":"powerAPI/classShieldAPI/#variable-sensors","title":"variable sensors","text":"<pre><code>SensorsAPI ShieldAPI::sensors;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.h</code></p>"},{"location":"powerAPI/classSpinAPI/","title":"Class SpinAPI","text":"<p>ClassList &gt; SpinAPI</p> <p>Contains all the elements linked to peripherals of the spin board. </p> <ul> <li><code>#include &lt;SpinAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classSpinAPI/#public-static-attributes","title":"Public Static Attributes","text":"Type Name CompHAL comp Contains all the function of the STM32 comparator used with the current mode. DacHAL dac Contains all the function of the STM32 DAC used to generate signals and handle the current mode. DataAPI data Data acquisition from SPIN ADCs. GpioHAL gpio Contains all the functions for the spin gpio. LedHAL led Contains all the function of the embedded LED. PwmHAL pwm Contains all the function of the STM32 hrtim PWM generator. TimerHAL timer Contains all the function of the STM32 Timer4 functions that handle the encoder. UartHAL uart Contains all the function of the STM32 Usart1 functions."},{"location":"powerAPI/classSpinAPI/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/classSpinAPI/#variable-comp","title":"variable comp","text":"<pre><code>CompHAL SpinAPI::comp;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-dac","title":"variable dac","text":"<pre><code>DacHAL SpinAPI::dac;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-data","title":"variable data","text":"<pre><code>DataAPI SpinAPI::data;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-gpio","title":"variable gpio","text":"<pre><code>GpioHAL SpinAPI::gpio;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-led","title":"variable led","text":"<pre><code>LedHAL SpinAPI::led;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-pwm","title":"variable pwm","text":"<pre><code>PwmHAL SpinAPI::pwm;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-timer","title":"variable timer","text":"<pre><code>TimerHAL SpinAPI::timer;\n</code></pre>"},{"location":"powerAPI/classSpinAPI/#variable-uart","title":"variable uart","text":"<pre><code>UartHAL SpinAPI::uart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/classSyncCommunication/","title":"Class SyncCommunication","text":"<p>ClassList &gt; SyncCommunication</p>"},{"location":"powerAPI/classSyncCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name void initMaster () initialization synchronization as MASTER, the master send the synchronization pulsle. void initSlave () initialization synchronization as SLAVE, the slave receive the synchronization pulsle."},{"location":"powerAPI/classSyncCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classSyncCommunication/#function-initmaster","title":"function initMaster","text":"<p>initialization synchronization as MASTER, the master send the synchronization pulsle. <pre><code>static void SyncCommunication::initMaster () \n</code></pre></p> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classSyncCommunication/#function-initslave","title":"function initSlave","text":"<pre><code>static void SyncCommunication::initSlave () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/classTaskAPI/","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p>"},{"location":"powerAPI/classTaskAPI/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"powerAPI/classTaskAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTaskAPI/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"powerAPI/classTaskAPI/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Note:</p> <p>If the HRTIM is used to trigger the task (which is the default behavior), then the HRTIM must have been configured before calling this function.</p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically. </li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is HRTIM, this value must be an integer multiple of the HRTIM period. </li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the HRTIM is the source, but this optional parameter can be provided to set TIM6 as the source in case the HRTIM is not used or if the task can't be correlated to an HRTIM event. Allowed values are source_hrtim and source_tim6. </li> </ul> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error defining the task. An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"powerAPI/classTaskAPI/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopcritical","title":"function stopCritical","text":"<pre><code>void TaskAPI::stopCritical () \n</code></pre>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/classTimerHAL/","title":"Class TimerHAL","text":"<p>ClassList &gt; TimerHAL</p> <p>Handles timer 4 for the SPIN board. More...</p> <ul> <li><code>#include &lt;TimerHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classTimerHAL/#public-functions","title":"Public Functions","text":"Type Name uint32_t getTimer4IncrementalEncoderValue () Gets the encoder step value. void startLogTimer4IncrementalEncoder () Launches the timer4 which is adapted for reading an encoder."},{"location":"powerAPI/classTimerHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize timer 4 and use it with an incremental encoder </p>"},{"location":"powerAPI/classTimerHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTimerHAL/#function-gettimer4incrementalencodervalue","title":"function getTimer4IncrementalEncoderValue","text":"<p>Gets the encoder step value. <pre><code>uint32_t TimerHAL::getTimer4IncrementalEncoderValue () \n</code></pre></p> <p>Returns:</p> <p>An uint32 value of the counter which corresponds to the step of the system. </p>"},{"location":"powerAPI/classTimerHAL/#function-startlogtimer4incrementalencoder","title":"function startLogTimer4IncrementalEncoder","text":"<pre><code>void TimerHAL::startLogTimer4IncrementalEncoder () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/classUartHAL/","title":"Class UartHAL","text":"<p>ClassList &gt; UartHAL</p> <p>Handles usart 1 for the SPIN board. More...</p> <ul> <li><code>#include &lt;UartHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classUartHAL/#public-functions","title":"Public Functions","text":"Type Name void usart1Init () Library initialization function for the usart communication. This function is declared on the private section of the .c file. char usart1ReadChar () This function sends back a single character waiting to be treated from the usart1. void usart1SwapRxTx () This function swaps the usart RX and TX pins. It should be called in conjunction with a board version setup. void usart1WriteChar (char data) This function transmits a single character through the usart 1."},{"location":"powerAPI/classUartHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize and send messages via usart 1 </p>"},{"location":"powerAPI/classUartHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classUartHAL/#function-usart1init","title":"function usart1Init","text":"<pre><code>void UartHAL::usart1Init () \n</code></pre>"},{"location":"powerAPI/classUartHAL/#function-usart1readchar","title":"function usart1ReadChar","text":"<p>This function sends back a single character waiting to be treated from the usart1. <pre><code>char UartHAL::usart1ReadChar () \n</code></pre></p> <p>Returns:</p> <p>This function returns a single char which is waiting to be treated if no char is waiting it returns an 'x' which should be treated as an error </p>"},{"location":"powerAPI/classUartHAL/#function-usart1swaprxtx","title":"function usart1SwapRxTx","text":"<pre><code>void UartHAL::usart1SwapRxTx () \n</code></pre>"},{"location":"powerAPI/classUartHAL/#function-usart1writechar","title":"function usart1WriteChar","text":"<p>This function transmits a single character through the usart 1. <pre><code>void UartHAL::usart1WriteChar (\n    char data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> single char to be sent out </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/structadc__hrtim__conf__t/","title":"Struct adc_hrtim_conf_t","text":"<p>ClassList &gt; adc_hrtim_conf_t</p> <p>Structure containing information to setup adc events, adc source links and adc triggers. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_adc_event_t adc_event hrtim_adc_edgetrigger_t adc_rollover hrtim_adc_source_t adc_source hrtim_adc_trigger_t adc_trigger"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_event","title":"variable adc_event","text":"<pre><code>hrtim_adc_event_t adc_hrtim_conf_t::adc_event;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_rollover","title":"variable adc_rollover","text":"<pre><code>hrtim_adc_edgetrigger_t adc_hrtim_conf_t::adc_rollover;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_source","title":"variable adc_source","text":"<pre><code>hrtim_adc_source_t adc_hrtim_conf_t::adc_source;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_trigger","title":"variable adc_trigger","text":"<pre><code>hrtim_adc_trigger_t adc_hrtim_conf_t::adc_trigger;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structcomp__usage__conf__t/","title":"Struct comp_usage_conf_t","text":"<p>ClassList &gt; comp_usage_conf_t</p> <p>Structure containing the status of the usage of comparators and their values. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_comp_usage_t cmp1 uint16_t cmp1_value hrtim_comp_usage_t cmp2 uint16_t cmp2_value hrtim_comp_usage_t cmp3 uint16_t cmp3_value hrtim_comp_usage_t cmp4 uint16_t cmp4_value"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1","title":"variable cmp1","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp1;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1_value","title":"variable cmp1_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp1_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2","title":"variable cmp2","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp2;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2_value","title":"variable cmp2_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp2_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3","title":"variable cmp3","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp3;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3_value","title":"variable cmp3_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp3_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4","title":"variable cmp4","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp4;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4_value","title":"variable cmp4_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp4_value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structdac__driver__api/","title":"Struct dac_driver_api","text":"<p>ClassList &gt; dac_driver_api</p>"},{"location":"powerAPI/structdac__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name dac_api_fn_upd_reset fn_upd_reset dac_api_fn_upd_step fn_upd_step dac_api_pinconfigure pinconfigure dac_api_setconstvalue setconstvalue dac_api_setfunction setfunction dac_api_start start dac_api_stop stop"},{"location":"powerAPI/structdac__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_reset","title":"variable fn_upd_reset","text":"<pre><code>dac_api_fn_upd_reset dac_driver_api::fn_upd_reset;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_step","title":"variable fn_upd_step","text":"<pre><code>dac_api_fn_upd_step dac_driver_api::fn_upd_step;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-pinconfigure","title":"variable pinconfigure","text":"<pre><code>dac_api_pinconfigure dac_driver_api::pinconfigure;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setconstvalue","title":"variable setconstvalue","text":"<pre><code>dac_api_setconstvalue dac_driver_api::setconstvalue;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setfunction","title":"variable setfunction","text":"<pre><code>dac_api_setfunction dac_driver_api::setfunction;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-start","title":"variable start","text":"<pre><code>dac_api_start dac_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>dac_api_stop dac_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structdac__function__config__t/","title":"Struct dac_function_config_t","text":"<p>ClassList &gt; dac_function_config_t</p>"},{"location":"powerAPI/structdac__function__config__t/#public-attributes","title":"Public Attributes","text":"Type Name dac_function_t dac_function dac_polarity_t polarity uint32_t reset_data dac_trigger_t reset_trigger_source uint32_t step_data dac_trigger_t step_trigger_source"},{"location":"powerAPI/structdac__function__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__function__config__t/#variable-dac_function","title":"variable dac_function","text":"<pre><code>dac_function_t dac_function_config_t::dac_function;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-polarity","title":"variable polarity","text":"<pre><code>dac_polarity_t dac_function_config_t::polarity;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_data","title":"variable reset_data","text":"<pre><code>uint32_t dac_function_config_t::reset_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_trigger_source","title":"variable reset_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::reset_trigger_source;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_data","title":"variable step_data","text":"<pre><code>uint32_t dac_function_config_t::step_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_trigger_source","title":"variable step_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::step_trigger_source;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structdma__user__data__t/","title":"Struct dma_user_data_t","text":"<p>ClassList &gt; dma_user_data_t</p>"},{"location":"powerAPI/structdma__user__data__t/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t channel uint32_t dst bool has_interrupt size_t size uint32_t src"},{"location":"powerAPI/structdma__user__data__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdma__user__data__t/#variable-channel","title":"variable channel","text":"<pre><code>uint32_t dma_user_data_t::channel;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-dst","title":"variable dst","text":"<pre><code>uint32_t dma_user_data_t::dst;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-has_interrupt","title":"variable has_interrupt","text":"<pre><code>bool dma_user_data_t::has_interrupt;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-size","title":"variable size","text":"<pre><code>size_t dma_user_data_t::size;\n</code></pre>"},{"location":"powerAPI/structdma__user__data__t/#variable-src","title":"variable src","text":"<pre><code>uint32_t dma_user_data_t::src;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.cpp</code></p>"},{"location":"powerAPI/structgpio__conf__t/","title":"Struct gpio_conf_t","text":"<p>ClassList &gt; gpio_conf_t</p> <p>Structure containing all the information of the gpio linked to a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structgpio__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_output_units_t OUT_H hrtim_output_units_t OUT_L LL_GPIO_InitTypeDef switch_H LL_GPIO_InitTypeDef switch_L hrtim_gpio_clock_number_t tu_gpio_CLK GPIO_TypeDef * unit"},{"location":"powerAPI/structgpio__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structgpio__conf__t/#variable-out_h","title":"variable OUT_H","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-out_l","title":"variable OUT_L","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_h","title":"variable switch_H","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_l","title":"variable switch_L","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-tu_gpio_clk","title":"variable tu_gpio_CLK","text":"<pre><code>hrtim_gpio_clock_number_t gpio_conf_t::tu_gpio_CLK;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-unit","title":"variable unit","text":"<pre><code>GPIO_TypeDef* gpio_conf_t::unit;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structphase__shift__conf__t/","title":"Struct phase_shift_conf_t","text":"<p>ClassList &gt; phase_shift_conf_t</p> <p>Structure containing all the data regarding phase shifting for a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_tu_t compare_tu hrtim_reset_trig_t reset_trig uint16_t value"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structphase__shift__conf__t/#variable-compare_tu","title":"variable compare_tu","text":"<pre><code>hrtim_tu_t phase_shift_conf_t::compare_tu;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-reset_trig","title":"variable reset_trig","text":"<pre><code>hrtim_reset_trig_t phase_shift_conf_t::reset_trig;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-value","title":"variable value","text":"<pre><code>uint16_t phase_shift_conf_t::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structpwm__conf__t/","title":"Struct pwm_conf_t","text":"<p>ClassList &gt; pwm_conf_t</p> <p>Structure containing all the data regarding the pwm of a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structpwm__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t ckpsc uint16_t duty_cycle hrtim_external_trigger_t external_trigger uint16_t fall_dead_time uint32_t frequency uint32_t max_frequency uint16_t max_period uint32_t min_frequency uint16_t min_period hrtim_cnt_t modulation uint16_t period hrtim_pwm_mode_t pwm_mode hrtim_tu_t pwm_tu uint32_t resolution uint16_t rise_dead_time hrtim_tu_ON_OFF_t unit_on"},{"location":"powerAPI/structpwm__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structpwm__conf__t/#variable-ckpsc","title":"variable ckpsc","text":"<pre><code>uint8_t pwm_conf_t::ckpsc;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_cycle","title":"variable duty_cycle","text":"<pre><code>uint16_t pwm_conf_t::duty_cycle;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-external_trigger","title":"variable external_trigger","text":"<pre><code>hrtim_external_trigger_t pwm_conf_t::external_trigger;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-fall_dead_time","title":"variable fall_dead_time","text":"<pre><code>uint16_t pwm_conf_t::fall_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-frequency","title":"variable frequency","text":"<pre><code>uint32_t pwm_conf_t::frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-max_frequency","title":"variable max_frequency","text":"<pre><code>uint32_t pwm_conf_t::max_frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-max_period","title":"variable max_period","text":"<pre><code>uint16_t pwm_conf_t::max_period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-min_frequency","title":"variable min_frequency","text":"<pre><code>uint32_t pwm_conf_t::min_frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-min_period","title":"variable min_period","text":"<pre><code>uint16_t pwm_conf_t::min_period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-modulation","title":"variable modulation","text":"<pre><code>hrtim_cnt_t pwm_conf_t::modulation;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-period","title":"variable period","text":"<pre><code>uint16_t pwm_conf_t::period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_mode","title":"variable pwm_mode","text":"<pre><code>hrtim_pwm_mode_t pwm_conf_t::pwm_mode;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_tu","title":"variable pwm_tu","text":"<pre><code>hrtim_tu_t pwm_conf_t::pwm_tu;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-resolution","title":"variable resolution","text":"<pre><code>uint32_t pwm_conf_t::resolution;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-rise_dead_time","title":"variable rise_dead_time","text":"<pre><code>uint16_t pwm_conf_t::rise_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-unit_on","title":"variable unit_on","text":"<pre><code>hrtim_tu_ON_OFF_t pwm_conf_t::unit_on;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/classsafety/","title":"Class safety","text":"<p>ClassList &gt; safety</p>"},{"location":"powerAPI/classsafety/#public-functions","title":"Public Functions","text":"Type Name void disableSafetyApi () disable the safet API fault detection task void enableSafetyApi () enable the safet API fault detection task bool getChannelError (sensor_t sensors_error) check if the sensor faced an error (went over/under threshold) safety_reaction_t getChannelReaction () returns the reaction to do when encoutering an error. float32_t getChannelThresholdMax (sensor_t sensors_threshold) get the maximum threshold of the selected sensor float32_t getChannelThresholdMin (sensor_t sensors_threshold) get the minimum threshold of the selected sensor bool getChannelWatch (sensor_t sensors_watch) check if a sensor is being monitored or not. void init_shield () Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the sensors will be monitored to detect potential faults in voltage/current. void init_shield (sensor_t * sensors_watch, uint8_t sensors_watch_number) Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the sensors will be monitored to detect potential faults in voltage/current. int8_t retrieveThreshold (sensor_t sensor_threshold_retrieve) store the current minimum and maximum threshold in the flash (non volatile memory) void setChannelReaction (safety_reaction_t sensors_reaction) Set the reaction to do if an error has been detected. Choose either open-circuit (both switches are opened and no power flows in the output) or short-circuit (high-side switch is opened, and low-side is closed maintaining the output in short-circuit) int8_t setChannelThresholdMax (sensor_t * sensors_threshold, float32_t * threshold_max, uint8_t sensors_threshold_number) set the maximum threshold for the sensors present in the list safety_sensors. int8_t setChannelThresholdMin (sensor_t * sensors_threshold, float32_t * threshold_min, uint8_t sensors_threshold_number) set the minimum threshold for the sensors present in the list safety_sensors. int8_t setChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Enables the monitoring of the selected sensors for safety. int8_t storeThreshold (sensor_t sensor_threshold_store) store the current minimum and maximum threshold in the flash (non volatile memory) int8_t unsetChannelWatch (sensor_t * sensors_watch, uint8_t sensors_watch_number) Disables the monitoring of the selected sensors for safety."},{"location":"powerAPI/classsafety/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classsafety/#function-disablesafetyapi","title":"function disableSafetyApi","text":"<p>disable the safet API fault detection task <pre><code>void safety::disableSafetyApi () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-enablesafetyapi","title":"function enableSafetyApi","text":"<p>enable the safet API fault detection task <pre><code>void safety::enableSafetyApi () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-getchannelerror","title":"function getChannelError","text":"<p>check if the sensor faced an error (went over/under threshold) <pre><code>bool safety::getChannelError (\n    sensor_t sensors_error\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_error</code> the sensor to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>true if the sensor faced an error, false if not </p>"},{"location":"powerAPI/classsafety/#function-getchannelreaction","title":"function getChannelReaction","text":"<p>returns the reaction to do when encoutering an error. <pre><code>safety_reaction_t safety::getChannelReaction () \n</code></pre></p> <p>Returns:</p> <p>Open_Circuit or Short_Circuit </p>"},{"location":"powerAPI/classsafety/#function-getchannelthresholdmax","title":"function getChannelThresholdMax","text":"<p>get the maximum threshold of the selected sensor <pre><code>float32_t safety::getChannelThresholdMax (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>the maximum threshold </p>"},{"location":"powerAPI/classsafety/#function-getchannelthresholdmin","title":"function getChannelThresholdMin","text":"<p>get the minimum threshold of the selected sensor <pre><code>float32_t safety::getChannelThresholdMin (\n    sensor_t sensors_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> the sensor to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>the minimum threshold </p>"},{"location":"powerAPI/classsafety/#function-getchannelwatch","title":"function getChannelWatch","text":"<p>check if a sensor is being monitored or not. <pre><code>bool safety::getChannelWatch (\n    sensor_t sensors_watch\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> the sensor to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>true if the sensor is being monitored, false if not </p>"},{"location":"powerAPI/classsafety/#function-init_shield-12","title":"function init_shield [1/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the sensors will be monitored to detect potential faults in voltage/current. <pre><code>void safety::init_shield () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-init_shield-22","title":"function init_shield [2/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the sensors will be monitored to detect potential faults in voltage/current. <pre><code>void safety::init_shield (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-retrievethreshold","title":"function retrieveThreshold","text":"<p>store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t safety::retrieveThreshold (\n    sensor_t sensor_threshold_retrieve\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_retrieve</code> the sensor for which we store the threshold in the NVS </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested sensor </p>"},{"location":"powerAPI/classsafety/#function-setchannelreaction","title":"function setChannelReaction","text":"<p>Set the reaction to do if an error has been detected. Choose either open-circuit (both switches are opened and no power flows in the output) or short-circuit (high-side switch is opened, and low-side is closed maintaining the output in short-circuit) <pre><code>void safety::setChannelReaction (\n    safety_reaction_t sensors_reaction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_reaction</code> the reaction to do </li> <li>Open_Circuit </li> <li>Short_Circuit</li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-setchannelthresholdmax","title":"function setChannelThresholdMax","text":"<p>set the maximum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t safety::setChannelThresholdMax (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_max,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to set the threshold. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>threshold_max</code> A list of the maximum threshold to apply to the sensors in safety_sensors. </li> <li><code>sensors_threshold_number</code> the number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if not. </p>"},{"location":"powerAPI/classsafety/#function-setchannelthresholdmin","title":"function setChannelThresholdMin","text":"<p>set the minimum threshold for the sensors present in the list safety_sensors. <pre><code>int8_t safety::setChannelThresholdMin (\n    sensor_t * sensors_threshold,\n    float32_t * threshold_min,\n    uint8_t sensors_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_threshold</code> A list of the sensors to set the threshold. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>threshold_min</code> A list of the minimum threshold to apply to the sensors in safety_sensors. </li> <li><code>sensors_threshold_number</code> the number of sensors present in the list sensor_threshold</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if not. </p>"},{"location":"powerAPI/classsafety/#function-setchannelwatch","title":"function setChannelWatch","text":"<p>Enables the monitoring of the selected sensors for safety. <pre><code>int8_t safety::setChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to watch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if there was an error </p>"},{"location":"powerAPI/classsafety/#function-storethreshold","title":"function storeThreshold","text":"<p>store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t safety::storeThreshold (\n    sensor_t sensor_threshold_store\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_threshold_store</code> the sensor for which we store the threshold in the NVS </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, -1 if there was an error. </p>"},{"location":"powerAPI/classsafety/#function-unsetchannelwatch","title":"function unsetChannelWatch","text":"<p>Disables the monitoring of the selected sensors for safety. <pre><code>int8_t safety::unsetChannelWatch (\n    sensor_t * sensors_watch,\n    uint8_t sensors_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensors_watch</code> A list of the sensors to unwatch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>sensors_watch_number</code> The number of sensors present in the list sensors_watch.</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if there was an error </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/structswitch__conv__conf__t/","title":"Struct switch_conv_conf_t","text":"<p>ClassList &gt; switch_conv_conf_t</p> <p>Structure describing the switching convention of a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_switch_convention_t convention uint32_t reset_H uint32_t reset_L uint32_t set_H uint32_t set_L"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structswitch__conv__conf__t/#variable-convention","title":"variable convention","text":"<pre><code>hrtim_switch_convention_t switch_conv_conf_t::convention;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_h","title":"variable reset_H","text":"<pre><code>uint32_t switch_conv_conf_t::reset_H[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_l","title":"variable reset_L","text":"<pre><code>uint32_t switch_conv_conf_t::reset_L[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_h","title":"variable set_H","text":"<pre><code>uint32_t switch_conv_conf_t::set_H[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_l","title":"variable set_L","text":"<pre><code>uint32_t switch_conv_conf_t::set_L[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structtimer__config__t/","title":"Struct timer_config_t","text":"<p>ClassList &gt; timer_config_t</p> <p>More...</p> <ul> <li><code>#include &lt;timer.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__config__t/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t timer_enable_encoder uint32_t timer_enable_irq pin_mode_t timer_enc_pin_mode timer_callback_t timer_irq_callback uint32_t timer_irq_t_usec uint32_t timer_use_zero_latency"},{"location":"powerAPI/structtimer__config__t/#detailed-description","title":"Detailed Description","text":"<p>timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder: set to 1 for timer to act as an incremental coder counter.</p> <p>*** IRQ mode (ignored if timer_enable_irq=0) *** * timer_irq_callback : pointer to a void(void) function that will be called on timer overflow. * timer_irq_t_usec : period of the interrupt in microsecond (2 to 6553 \u00b5s) * timer_use_zero_latency: for tasks, use zero-latency interrupts. Only used by Task API, end-user should set this one to false.</p> <p>*** Incremental encoder mode (ignored if timer_enable_encoder=0) *** * timer_pin_mode : Pin mode for incremental coder interface.</p> <p>NOTE: At this time, only irq mode is supported on TIM6/TIM7, and only incremental coder mode is suppported on TIM4, which makes this configuration structure almost pointless (except for callback definition). However, it is built this way with future evolutions of the driver in mind. </p>"},{"location":"powerAPI/structtimer__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_encoder","title":"variable timer_enable_encoder","text":"<pre><code>uint32_t timer_config_t::timer_enable_encoder;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_irq","title":"variable timer_enable_irq","text":"<pre><code>uint32_t timer_config_t::timer_enable_irq;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enc_pin_mode","title":"variable timer_enc_pin_mode","text":"<pre><code>pin_mode_t timer_config_t::timer_enc_pin_mode;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_callback","title":"variable timer_irq_callback","text":"<pre><code>timer_callback_t timer_config_t::timer_irq_callback;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_t_usec","title":"variable timer_irq_t_usec","text":"<pre><code>uint32_t timer_config_t::timer_irq_t_usec;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_use_zero_latency","title":"variable timer_use_zero_latency","text":"<pre><code>uint32_t timer_config_t::timer_use_zero_latency;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__driver__api/","title":"Struct timer_driver_api","text":"<p>ClassList &gt; timer_driver_api</p>"},{"location":"powerAPI/structtimer__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name timer_api_config config timer_api_get_count get_count timer_api_start start timer_api_stop stop"},{"location":"powerAPI/structtimer__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__driver__api/#variable-config","title":"variable config","text":"<pre><code>timer_api_config timer_driver_api::config;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-get_count","title":"variable get_count","text":"<pre><code>timer_api_get_count timer_driver_api::get_count;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-start","title":"variable start","text":"<pre><code>timer_api_start timer_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>timer_api_stop timer_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__hrtim__t/","title":"Struct timer_hrtim_t","text":"<p>ClassList &gt; timer_hrtim_t</p> <p>Timinig unit configuration - aggregates all the structures. </p> <ul> <li><code>#include &lt;hrtim.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes","title":"Public Attributes","text":"Type Name adc_hrtim_conf_t adc_hrtim comp_usage_conf_t comp_usage gpio_conf_t gpio_conf phase_shift_conf_t phase_shift pwm_conf_t pwm_conf switch_conv_conf_t switch_conv"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__hrtim__t/#variable-adc_hrtim","title":"variable adc_hrtim","text":"<pre><code>adc_hrtim_conf_t timer_hrtim_t::adc_hrtim;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-comp_usage","title":"variable comp_usage","text":"<pre><code>comp_usage_conf_t timer_hrtim_t::comp_usage;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-gpio_conf","title":"variable gpio_conf","text":"<pre><code>gpio_conf_t timer_hrtim_t::gpio_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-phase_shift","title":"variable phase_shift","text":"<pre><code>phase_shift_conf_t timer_hrtim_t::phase_shift;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-pwm_conf","title":"variable pwm_conf","text":"<pre><code>pwm_conf_t timer_hrtim_t::pwm_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-switch_conv","title":"variable switch_conv","text":"<pre><code>switch_conv_conf_t timer_hrtim_t::switch_conv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/","title":"Dir docs/core","text":"<p>FileList &gt; core</p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/</code></p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/","title":"Dir docs/core/zephyr","text":"<p>FileList &gt; core &gt; zephyr</p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/#directories","title":"Directories","text":"Type Name dir modules <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/</code></p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/","title":"Dir docs/core/zephyr/modules","text":"<p>FileList &gt; core &gt; zephyr &gt; modules</p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/#directories","title":"Directories","text":"Type Name dir owntech_adc_driver dir owntech_communication dir owntech_comparator_driver dir owntech_dac_driver dir owntech_flash_driver dir owntech_hrtim_driver dir owntech_ngnd_driver dir owntech_safety_api dir owntech_shield_api dir owntech_spin_api dir owntech_task_api dir owntech_timer_driver <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/</code></p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver</p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/</code></p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/#files","title":"Files","text":"Type Name file adc.c file adc.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/adc_8c/","title":"File adc.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t adc_discontinuous_mode   = = {0} adc_ev_src_t adc_trigger_sources   = = {0} bool enable_dma   = = {0} uint32_t enabled_channels   = = {0} uint32_t enabled_channels_count   = = {0}"},{"location":"powerAPI/adc_8c/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the triger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/adc_8c/#variable-adc_discontinuous_mode","title":"variable adc_discontinuous_mode","text":"<pre><code>uint32_t adc_discontinuous_mode[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-adc_trigger_sources","title":"variable adc_trigger_sources","text":"<pre><code>adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enable_dma","title":"variable enable_dma","text":"<pre><code>bool enable_dma[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels","title":"variable enabled_channels","text":"<pre><code>uint32_t enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels_count","title":"variable enabled_channels_count","text":"<pre><code>uint32_t enabled_channels_count[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8c/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the triger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>triggger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8c/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_start","title":"function adc_start","text":"<pre><code>void adc_start () \n</code></pre>"},{"location":"powerAPI/adc_8c/#function-adc_stop","title":"function adc_stop","text":"<pre><code>void adc_stop () \n</code></pre>"},{"location":"powerAPI/adc_8c/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.c</code></p>"},{"location":"powerAPI/adc_8c_source/","title":"File adc.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// STM32 LL\n#include &lt;stm32_ll_adc.h&gt;\n\n// Current module private functions\n#include \"../src/adc_core.h\"\n\n// Current file header\n#include \"adc.h\"\n\n\n// Constants\n\n#define NUMBER_OF_ADCS 5\n#define NUMBER_OF_CHANNELS_PER_ADC 16\n\n\n// Local variables\n\nstatic adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS]    = {0};\nstatic uint32_t     adc_discontinuous_mode[NUMBER_OF_ADCS] = {0};\nstatic uint32_t     enabled_channels_count[NUMBER_OF_ADCS] = {0};\nstatic bool         enable_dma[NUMBER_OF_ADCS]             = {0};\n\nstatic uint32_t     enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC] = {0};\n\n\n// Public API\n\nvoid adc_configure_trigger_source(uint8_t adc_number, adc_ev_src_t trigger_source)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_trigger_sources[adc_number-1] = trigger_source;\n\n}\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number, uint32_t discontinuous_count)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_discontinuous_mode[adc_number-1] = discontinuous_count;\n}\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    if (enabled_channels_count[adc_index] == NUMBER_OF_CHANNELS_PER_ADC)\n        return;\n\n    enabled_channels[adc_index][enabled_channels_count[adc_index]] = channel;\n    enabled_channels_count[adc_index]++;\n}\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    for (int i = 0 ; i &lt; NUMBER_OF_CHANNELS_PER_ADC ; i++)\n    {\n        if (enabled_channels[adc_index][i] == channel)\n        {\n            for (int j = i ; j &lt; NUMBER_OF_CHANNELS_PER_ADC-1 ; j++)\n            {\n                enabled_channels[adc_index][i] = enabled_channels[adc_index][i+1];\n            }\n            enabled_channels[adc_index][NUMBER_OF_CHANNELS_PER_ADC-1] = 0;\n\n            enabled_channels_count[adc_index]--;\n\n            break;\n        }\n    }\n}\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return 0;\n\n    uint8_t adc_index = adc_number-1;\n\n    return enabled_channels_count[adc_index];\n}\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    enable_dma[adc_number-1] = use_dma;\n}\n\nvoid adc_start()\n{\n    // Initialize ADCs\n\n    adc_core_init();\n\n    // Pre-enable configuration\n\n    // Nothing here for now.\n\n    // If some channels have to be set as differential,\n    // or ADCs have to be set as dual mode,\n    // this shoud be done here.\n\n    // Enable ADCs\n\n    for (int adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        adc_core_enable(adc_num);\n    }\n\n    // Post-enable configuration\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            for (int channel_index = 0 ; channel_index &lt; NUMBER_OF_CHANNELS_PER_ADC ; channel_index++)\n            {\n                if (enabled_channels[adc_index][channel_index] == 0)\n                    break;\n\n                adc_core_configure_channel(adc_num, enabled_channels[adc_index][channel_index], channel_index+1);\n            }\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_dma_mode(adc_num, enable_dma[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_discontinuous_mode(adc_num, adc_discontinuous_mode[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            // Convert to LL constants\n            uint32_t trig;\n            switch (adc_trigger_sources[adc_index])\n            {\n            case hrtim_ev1:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG1;\n                break;\n            case hrtim_ev2:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG2;\n                break;\n            case hrtim_ev3:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG3;\n                break;\n            case hrtim_ev4:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG4;\n                break;\n            case software:\n            default:\n                trig = LL_ADC_REG_TRIG_SOFTWARE;\n                break;\n            }\n\n            adc_core_configure_trigger_source(adc_num, LL_ADC_REG_TRIG_EXT_RISING, trig);\n        }\n    }\n\n    // Start ADCs\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp; (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_start(adc_num, enabled_channels_count[adc_index]);\n        }\n    }\n}\n\nvoid adc_stop()\n{\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp; (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_stop(adc_num);\n        }\n    }\n}\n\nvoid adc_trigger_software_conversion(uint8_t adc_number, uint8_t number_of_acquisitions)\n{\n    adc_core_start(adc_number, number_of_acquisitions);\n}\n</code></pre>"},{"location":"powerAPI/adc_8h/","title":"File adc.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8h/#public-types","title":"Public Types","text":"Type Name enum adc_ev_src_t"},{"location":"powerAPI/adc_8h/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the triger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/adc_8h/#enum-adc_ev_src_t","title":"enum adc_ev_src_t","text":"<pre><code>enum adc_ev_src_t {\n    software = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4\n};\n</code></pre>"},{"location":"powerAPI/adc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8h/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the triger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>triggger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8h/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_start","title":"function adc_start","text":"<pre><code>void adc_start () \n</code></pre>"},{"location":"powerAPI/adc_8h/#function-adc_stop","title":"function adc_stop","text":"<pre><code>void adc_stop () \n</code></pre>"},{"location":"powerAPI/adc_8h/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.h</code></p>"},{"location":"powerAPI/adc_8h_source/","title":"File adc.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef ADC_H_\n#define ADC_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public enums\n\ntypedef enum\n{\n    software  = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4,\n} adc_ev_src_t;\n\n\n// Public API\n\nvoid adc_configure_trigger_source(uint8_t adc_number, adc_ev_src_t trigger_source);\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number, uint32_t discontinuous_count);\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel);\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel);\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number);\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma);\n\n\nvoid adc_start();\n\nvoid adc_stop();\n\nvoid adc_trigger_software_conversion(uint8_t adc_number, uint8_t number_of_acquisitions);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // ADC_H_\n</code></pre>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/","title":"Dir docs/core/zephyr/modules/owntech_communication","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication</p>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/</code></p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr</p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/</code></p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/#files","title":"Files","text":"Type Name file CommunicationAPI.cpp file CommunicationAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp/","title":"File CommunicationAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8cpp/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.cpp</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp_source/","title":"File CommunicationAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"CommunicationAPI.h\"\n\nCommunicationAPI communication;\n</code></pre>"},{"location":"powerAPI/CommunicationAPI_8h/","title":"File CommunicationAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8h/#classes","title":"Classes","text":"Type Name class CommunicationAPI"},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8h/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/CommunicationAPI_8h_source/","title":"File CommunicationAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMMUNICATIONAPI_H\n#define COMMUNICATIONAPI_H\n\n#include \"../src/AnalogCommunication.h\"\n#include \"../src/CanCommunication.h\"\n#include \"../src/Rs485Communication.h\"\n#include \"../src/SyncCommunication.h\"\n\nclass CommunicationAPI\n{\n    public : \n        AnalogCommunication analog;\n\n        CanCommunication can;\n\n        Rs485Communication rs485;\n\n        SyncCommunication sync;\n\n};\n\nextern CommunicationAPI communication;\n\n#endif // COMMUNICATIONAPI_H\n</code></pre>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/#files","title":"Files","text":"Type Name file AnalogCommunication.cpp file AnalogCommunication.h file CanCommunication.cpp file CanCommunication.h file Rs485.cpp file Rs485.h file Rs485Communication.cpp file Rs485Communication.h file SyncCommunication.cpp file SyncCommunication.h file data_objects.cpp file data_objects.h Handling of ThingSet data objects. file thingset_isotp.cpp file thingset_pub_sub.cpp <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp/","title":"File AnalogCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.cpp</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp_source/","title":"File AnalogCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* Header */\n#include \"AnalogCommunication.h\"\n\n/* OwnTech Power API */\n#include \"ShieldAPI.h\"\n#include \"SpinAPI.h\"\n\n/* LL drivers */\n#include \"stm32_ll_gpio.h\"\n\n#define ADC_NUM ADC_2\n#define DAC_NUM 2\n#define DAC_CHAN 1\n\nvoid AnalogCommunication::init()\n{\n    /* Initialize the GPIO PC4 (pin number 35) to analog mode\n       to use the ADC */\n    LL_GPIO_SetPinMode      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_MODE_ANALOG);\n    LL_GPIO_SetPinSpeed     (GPIOC, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_PULL_NO);\n\n    shield.sensors.enableSensor(ANALOG_COMM, ADC_NUM);\n\n    /* Initialize the DAC */\n    spin.dac.initConstValue(ADC_NUM);\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, 0);\n}\n\nfloat32_t AnalogCommunication::getAnalogCommValue()\n{\n    float32_t ret =  shield.sensors.getLatestValue(ANALOG_COMM);\n    return ret;\n}\n\nvoid AnalogCommunication::setAnalogCommValue(uint32_t analog_bus_value)\n{\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, analog_bus_value);\n}\n</code></pre>"},{"location":"powerAPI/AnalogCommunication_8h/","title":"File AnalogCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/AnalogCommunication_8h/#classes","title":"Classes","text":"Type Name class AnalogCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/AnalogCommunication_8h_source/","title":"File AnalogCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef ANALOGCOMMUNICATION_H_\n#define ANALOGCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n\n// Static class definition\n\nclass AnalogCommunication\n{\n\npublic:\n    static void init();\n\n    static float32_t getAnalogCommValue();\n\n    static void setAnalogCommValue(uint32_t analog_bus_value);\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG\n\n#endif // ANALOGCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/CanCommunication_8cpp/","title":"File CanCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t broadcast_time uint16_t control_time"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CanCommunication_8cpp/#variable-broadcast_time","title":"variable broadcast_time","text":"<pre><code>uint16_t broadcast_time;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/CanCommunication_8cpp/#variable-control_time","title":"variable control_time","text":"<pre><code>uint16_t control_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.cpp</code></p>"},{"location":"powerAPI/CanCommunication_8cpp_source/","title":"File CanCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* Header */\n#include \"CanCommunication.h\"\n#include \"data_objects.h\"\n\n/* Zephyr driver*/\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n// Extern variable defined in this module\n\nextern uint16_t broadcast_time;\nextern uint16_t control_time;\n\n\nuint16_t CanCommunication::getCanNodeAddr()\n{\n    return can_node_addr;\n}\n\nbool CanCommunication::getCtrlEnable()\n{\n    return ctrl_enable;\n}\n\nfloat32_t CanCommunication::getCtrlReference()\n{\n    return reference_value;\n}\n\nuint16_t CanCommunication::getBroadcastPeriod()\n{\n    return broadcast_time;\n}\n\nuint16_t CanCommunication::getControlPeriod()\n{\n    return control_time;\n}\n\n\nvoid CanCommunication::setCanNodeAddr(uint16_t addr)\n{\n    can_node_addr = addr;\n}\n\nvoid CanCommunication::setCtrlEnable(bool enable)\n{\n    ctrl_enable = enable;\n}\n\nvoid CanCommunication::setCtrlReference(float32_t reference)\n{\n    reference_value = reference;\n}\n\nvoid CanCommunication::setBroadcastPeriod(uint16_t time_100_ms)\n{\n    broadcast_time = time_100_ms;\n}\n\nvoid CanCommunication::setControlPeriod(uint16_t time_100_ms)\n{\n    control_time = time_100_ms;\n}\n\nvoid CanCommunication::enableCan()\n{\n    const struct gpio_dt_spec can_standby_spec = GPIO_DT_SPEC_GET(CAN_STANDBY_DEVICE, gpios);\n    gpio_pin_configure_dt(&amp;can_standby_spec, GPIO_OUTPUT_INACTIVE);\n}\n</code></pre>"},{"location":"powerAPI/CanCommunication_8h/","title":"File CanCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8h/#classes","title":"Classes","text":"Type Name class CanCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/CanCommunication_8h_source/","title":"File CanCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef CANCOMMUNICATION_H_\n#define CANCOMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n#define CAN_STANDBY_DEVICE DT_CHILD(DT_PATH(can_standby_switch), can_standby_gpio_pin)\n\n// Static class definition\n\nclass CanCommunication\n{\n\npublic:\n    static uint16_t getCanNodeAddr();\n\n    static bool getCtrlEnable();\n\n    static float32_t getCtrlReference();\n\n    static uint16_t getBroadcastPeriod();\n\n    static uint16_t getControlPeriod();\n\n    static void setCanNodeAddr(uint16_t addr);\n\n    static void setCtrlEnable(bool enable);\n\n    static void setCtrlReference(float32_t reference);\n\n    static void setBroadcastPeriod(uint16_t time_100_ms);\n\n    static void setControlPeriod(uint16_t time_100_ms);\n\n    void enableCan();\n};\n\n#endif // CANCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/","title":"File Rs485.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name struct uart_event evt struct uart_config uart_cfg"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t baud   = = 21250000 / (2) const struct device * dma1   = = DEVICE_DT_GET(DT_NODELABEL(dma1)) uint16_t dma_buffer_size uint8_t * rx_usart_val uint8_t * tx_usart_val const struct device * uart_dev   = = DEVICE_DT_GET(DT_NODELABEL(usart3)) dma_callbackRXfunc_t user_fnc   = = NULL"},{"location":"powerAPI/Rs485_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () initialize dma 1 channel 7 for receiving data in circular mode void dma_channel_init_tx () initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. void init_usrBaudrate (uint32_t usr_baud) initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) initialize user transmission and reception buffer void init_usrDataSize (uint16_t size) initialize DMA data size to send and receive void init_usrFunc (dma_callbackRXfunc_t fnc_callback) initialize user function called every RX callback void oversamp_set (usart_oversampling_t oversampling) set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. void serial_init (void) initialize USART3 void serial_start () enable usart void serial_stop () disable usart void serial_tx_on () reload dma buffer TX"},{"location":"powerAPI/Rs485_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _dma_callback_rx ()  void _dma_callback_tx (const struct device * dev, void * user_data, uint32_t channel, int status)"},{"location":"powerAPI/Rs485_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-evt","title":"variable evt","text":"<pre><code>struct uart_event evt;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_cfg","title":"variable uart_cfg","text":"<pre><code>struct uart_config uart_cfg;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-baud","title":"variable baud","text":"<pre><code>uint32_t baud;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma1","title":"variable dma1","text":"<pre><code>const struct device* dma1;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma_buffer_size","title":"variable dma_buffer_size","text":"<pre><code>uint16_t dma_buffer_size;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-rx_usart_val","title":"variable rx_usart_val","text":"<pre><code>uint8_t* rx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-tx_usart_val","title":"variable tx_usart_val","text":"<pre><code>uint8_t* tx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-user_fnc","title":"variable user_fnc","text":"<pre><code>dma_callbackRXfunc_t user_fnc;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>initialize dma 1 channel 7 for receiving data in circular mode <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_demode","title":"function init_DEmode","text":"<p>initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>initialize user transmission and reception buffer <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>initialize DMA data size to send and receive <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>initialize user function called every RX callback <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8cpp/#function-oversamp_set","title":"function oversamp_set","text":"<p>set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_init","title":"function serial_init","text":"<p>initialize USART3 <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_start","title":"function serial_start","text":"<p>enable usart <pre><code>void serial_start () \n</code></pre></p> <p>to start or restart communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_stop","title":"function serial_stop","text":"<p>disable usart <pre><code>void serial_stop () \n</code></pre></p> <p>to stop communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>reload dma buffer TX <pre><code>void serial_tx_on () \n</code></pre></p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p>"},{"location":"powerAPI/Rs485_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_rx","title":"function _dma_callback_rx","text":"<pre><code>static void _dma_callback_rx () \n</code></pre> <p>DMA callback RX clear reception flag, then call user functions </p>"},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_tx","title":"function _dma_callback_tx","text":"<pre><code>static void _dma_callback_tx (\n    const struct device * dev,\n    void * user_data,\n    uint32_t channel,\n    int status\n) \n</code></pre> <p>DMA callback TX clear transmission flag, and disabled DMA channel TX. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.cpp</code></p>"},{"location":"powerAPI/Rs485_8cpp_source/","title":"File Rs485.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* ll drivers */\n#include &lt;stm32_ll_dma.h&gt;\n#include &lt;stm32_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n/* Zephyr drivers */\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/drivers/dma.h&gt;\n\n/* Header */\n#include \"Rs485.h\"\n\n#define DMA_USART DMA1 // DMA used\n\n#define STM32_DMA_HAL_OVERRIDE 0x7F\n\n/* Warning : if you change the channels number, you'll have to change some code line manually*/\n#define ZEPHYR_DMA_CHANNEL_TX 6 // transmission dma channel for zephyr driver\n#define ZEPHYR_DMA_CHANNEL_RX 7 // reception dma channel for zephyr driver\n\n/* Warning : if you change the channels, you'll have to change some code line manually*/\n#define LL_DMA_CHANNEL_TX LL_DMA_CHANNEL_6 // transmission dma channel for LL driver\n#define LL_DMA_CHANNEL_RX LL_DMA_CHANNEL_7 // reception dma channel for LL driver\n\n/* DT definitions */\nstatic const struct device *dma1 = DEVICE_DT_GET(DT_NODELABEL(dma1));\nstatic const struct device *uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart3));\n\n/* USART initialization parameters */\nstatic uint32_t baud = 21250000 / (2); /* initial baudrate to  10.625Mhz */\nstruct uart_config uart_cfg;\nstruct uart_event evt;\n\n/* DMA buffer for transmission and reception */\nstatic uint8_t* tx_usart_val;\nstatic uint8_t* rx_usart_val;\n\nstatic uint16_t dma_buffer_size;\n\nstatic dma_callbackRXfunc_t user_fnc = NULL; // user function to call in RX callback\n\n\nstatic void _dma_callback_tx(const struct device *dev, void *user_data, uint32_t channel, int status)\n{\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // Disable DMA channel after sending datas\n\n    LL_USART_ClearFlag_TXFE(USART3);\n    LL_USART_ClearFlag_TC(USART3); // clear transmission complete flag USART\n    LL_DMA_ClearFlag_TC6(DMA_USART); // clear transmission complete dma channel TX\n}\n\nstatic void _dma_callback_rx()\n{\n    LL_DMA_ClearFlag_TC7(DMA_USART); // clear transmission complete flag\n\n    if(user_fnc != NULL){\n        user_fnc();\n    }\n}\n\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer)\n{\n    tx_usart_val = tx_buffer;\n    rx_usart_val = rx_buffer;\n}\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback)\n{\n    user_fnc = fnc_callback;\n}\n\nvoid init_usrBaudrate(uint32_t usr_baud)\n{\n    baud = usr_baud;\n}\n\nvoid init_usrDataSize(uint16_t size)\n{\n    dma_buffer_size = size;\n}\n\nvoid serial_init(void)\n{\n    uart_config_get(uart_dev, &amp;uart_cfg);\n    uart_cfg.baudrate = baud;\n    uart_cfg.flow_ctrl = UART_CFG_FLOW_CTRL_NONE;\n    uart_cfg.data_bits = UART_CFG_DATA_BITS_8;\n    uart_cfg.parity = UART_CFG_PARITY_NONE;\n    uart_cfg.stop_bits = UART_CFG_STOP_BITS_1;\n\n    uart_configure(uart_dev, &amp;uart_cfg);\n\n    LL_USART_ConfigAsyncMode(USART3);\n\n    /* Enable DMA request*/\n    LL_USART_EnableDMAReq_TX(USART3);\n    LL_USART_EnableDMAReq_RX(USART3);\n\n    // disable Interrupts for TX (not used for DMA)\n    LL_USART_DisableIT_TC(USART3);         // Disable Transmission Complete Interrupt\n    LL_USART_DisableIT_TXE_TXFNF(USART3);  // Disable Transmission Data Register Empty Interrupt for DMA to provide data\n                                           //  disable interrupts for RX (not used with DMA)\n    LL_USART_DisableIT_RXNE_RXFNE(USART3); // Disable Receiver Data Register Not Empty Interrupt for DMA to fetch data\n\n    LL_USART_Enable(USART3);\n}\n\nvoid init_DEmode(void)\n{\n    LL_USART_Disable(USART3);\n\n    LL_GPIO_InitTypeDef GPIO_InitStruct = {0}; // GPIO initialization\n\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB); // Enable GPIO clock\n\n    /* Set GPIO_InitStruct */\n    GPIO_InitStruct.Pin = LL_GPIO_PIN_14;\n    GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\n    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\n    GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\n    GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\n    LL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);\n\n    LL_USART_EnableDEMode(USART3); // Enable DE mode\n\n    LL_USART_SetDESignalPolarity(USART3, LL_USART_DE_POLARITY_HIGH); // Polarity is high ie. PB14 will be at high level when sending datas\n\n    /* Assertion time is set to maximum */\n    LL_USART_SetDEAssertionTime(USART3, 31);\n    LL_USART_SetDEDeassertionTime(USART3, 31);\n\n    LL_USART_Enable(USART3);\n}\n\n\nvoid oversamp_set(usart_oversampling_t oversampling)\n{\n    LL_USART_Disable(USART3);\n    LL_USART_SetOverSampling(USART3, oversampling);\n    LL_USART_Enable(USART3);\n}\n\nvoid dma_channel_init_tx()\n{\n    /*Configure DMA */\n    struct dma_config dma_config_s = {0};\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    dma_config_s.dma_callback = _dma_callback_tx;          // Callback\n    dma_config_s.linked_channel = STM32_DMA_HAL_OVERRIDE;  // Hal override\n\n    /* DMA configuration with LL drivers */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;TDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(tx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_TX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    dma_config(dma1, ZEPHYR_DMA_CHANNEL_TX, &amp;dma_config_s); // Indicates Callback function to zephyr driver\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // Disabling channel for initial set-up\n\n    /* initialize DMA */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size); // DMA data size\n    LL_DMA_SetChannelPriorityLevel(DMA_USART, LL_DMA_CHANNEL_TX, LL_DMA_PRIORITY_VERYHIGH); // DMA channel priority\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_TX, &amp;DMA_InitStruct);\n\n    /* Clearing flag */\n    LL_DMA_ClearFlag_TC6(DMA_USART);\n    LL_DMA_ClearFlag_HT6(DMA_USART);\n\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_TX); // Enable transfert complete interruption\n\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_TX); // Disable half-transfert interruption\n}\n\n\nvoid dma_channel_init_rx()\n{\n    /* Configure DMA */\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    /* Initialization of DMA */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;RDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(rx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_RX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    IRQ_DIRECT_CONNECT(17, 0, _dma_callback_rx, IRQ_ZERO_LATENCY);\n    irq_enable(17);\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_RX); // Disabling channel for initial set-up\n\n     /* initialize DMA */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_RX, dma_buffer_size); // DMA data size\n    LL_DMA_SetChannelPriorityLevel(DMA_USART, LL_DMA_CHANNEL_RX, LL_DMA_PRIORITY_VERYHIGH); // DMA channel priority\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_RX, &amp;DMA_InitStruct);\n\n    /* Clearing flag */\n    LL_DMA_ClearFlag_TC7(DMA_USART);\n    LL_DMA_ClearFlag_HT7(DMA_USART);\n\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_RX); // Enabling channel\n\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_RX); // Enable transfert complete interruption\n\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_RX); // Disable half-transfert interruption\n}\n\n\nvoid serial_tx_on()\n{\n    LL_DMA_ClearFlag_TC6(DMA_USART); // Making sure the flag is cleared before transmission\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // disable channel to reload TX buffer\n\n    /* reloading TX buffer */\n    LL_DMA_SetMemoryAddress(DMA_USART, LL_DMA_CHANNEL_TX, (uint32_t)(tx_usart_val));\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size);\n\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // re-enable the channel\n}\n\nvoid serial_stop()\n{\n    LL_USART_Disable(USART3);\n}\n\nvoid serial_start()\n{\n    LL_USART_Enable(USART3);\n}\n</code></pre>"},{"location":"powerAPI/Rs485_8h/","title":"File Rs485.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dma_callbackRXfunc_t enum usart_oversampling_t"},{"location":"powerAPI/Rs485_8h/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () initialize dma 1 channel 7 for receiving data in circular mode void dma_channel_init_tx () initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. void init_usrBaudrate (uint32_t usr_baud) initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) initialize user transmission and reception buffer void init_usrDataSize (uint16_t size) initialize DMA data size to send and receive void init_usrFunc (dma_callbackRXfunc_t fnc_callback) initialize user function called every RX callback void oversamp_set (usart_oversampling_t oversampling) set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. void serial_init (void) initialize USART3 void serial_start () enable usart void serial_stop () disable usart void serial_tx_on () reload dma buffer TX"},{"location":"powerAPI/Rs485_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485_8h/#typedef-dma_callbackrxfunc_t","title":"typedef dma_callbackRXfunc_t","text":"<pre><code>typedef void(* dma_callbackRXfunc_t) ();\n</code></pre>"},{"location":"powerAPI/Rs485_8h/#enum-usart_oversampling_t","title":"enum usart_oversampling_t","text":"<pre><code>enum usart_oversampling_t {\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n};\n</code></pre>"},{"location":"powerAPI/Rs485_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>initialize dma 1 channel 7 for receiving data in circular mode <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_demode","title":"function init_DEmode","text":"<p>initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>usr_baud</code> baud in bits per second </li> </ul> <p>Note:</p> <p>baudrate is initialized by default to 10Mbps if this function is not used</p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>initialize user transmission and reception buffer <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tx_buffer</code> transmission buffer </li> <li><code>rx_buffer</code> reception buffer</li> </ul> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>initialize DMA data size to send and receive <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> size of the data in byte (max 65535)</li> </ul> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>initialize user function called every RX callback <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fnc_callback</code> void function with no parameters, use NULL if there is no function to call</li> </ul> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8h/#function-oversamp_set","title":"function oversamp_set","text":"<p>set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>oversampling</code> choice of oversampling </li> <li>OVER8 oversampling_8 </li> <li>OVER16 oversampling_16</li> </ul> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_init","title":"function serial_init","text":"<p>initialize USART3 <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_start","title":"function serial_start","text":"<p>enable usart <pre><code>void serial_start () \n</code></pre></p> <p>to start or restart communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_stop","title":"function serial_stop","text":"<p>disable usart <pre><code>void serial_stop () \n</code></pre></p> <p>to stop communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>reload dma buffer TX <pre><code>void serial_tx_on () \n</code></pre></p> <p>Note:</p> <p>after reloading the buffer, usart will start sending datas</p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.h</code></p>"},{"location":"powerAPI/Rs485_8h_source/","title":"File Rs485.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef RS485_H_\n#define RS485_H_\n\n#include &lt;zephyr/kernel.h&gt;\n\n#include &lt;stm32_ll_usart.h&gt;\n\ntypedef void (*dma_callbackRXfunc_t)();\n\ntypedef enum{\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n}usart_oversampling_t;\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer);\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback);\n\nvoid init_usrBaudrate(uint32_t usr_baud);\n\nvoid init_usrDataSize(uint16_t size);\n\nvoid serial_init(void);\n\nvoid init_DEmode(void);\n\nvoid oversamp_set(usart_oversampling_t oversampling);\n\nvoid dma_channel_init_tx();\n\nvoid dma_channel_init_rx();\n\nvoid serial_tx_on();\n\nvoid serial_stop();\n\nvoid serial_start();\n\n#endif // RS485_H_\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8cpp/","title":"File Rs485Communication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.cpp</code></p>"},{"location":"powerAPI/Rs485Communication_8cpp_source/","title":"File Rs485Communication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"Rs485.h\"\n#include \"Rs485Communication.h\"\n\nvoid Rs485Communication::configure(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(), rs485_speed_t data_speed)\n{\n    init_usrBuffer(transmission_bufer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n\n    switch(data_speed)\n    {\n        case SPEED_2M:\n            init_usrBaudrate(2656250);\n            break;\n        case SPEED_5M:\n            init_usrBaudrate(5312500);\n            break;\n        case SPEED_10M:\n            init_usrBaudrate(10625000);\n            break;\n        default:\n            init_usrBaudrate(10625000);\n            break;\n    }\n    init_usrBaudrate(10625000);\n\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n\n    if(data_speed == SPEED_20M) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::configureCustom(uint8_t* transmission_bufer, uint8_t* reception_buffer, uint16_t data_size, void (*user_function)(void), uint32_t baudrate, bool oversampling_8)\n{\n    init_usrBuffer(transmission_bufer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n    init_usrBaudrate(baudrate);\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n    if(oversampling_8 == true) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::startTransmission()\n{\n    serial_tx_on();\n}\n\nvoid Rs485Communication::turnOnCommunication()\n{\n    serial_start();\n}\n\nvoid Rs485Communication::turnOffCommunication()\n{\n    serial_stop();\n}\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8h/","title":"File Rs485Communication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485Communication_8h/#classes","title":"Classes","text":"Type Name class Rs485Communication"},{"location":"powerAPI/Rs485Communication_8h/#public-types","title":"Public Types","text":"Type Name enum rs485_speed_t"},{"location":"powerAPI/Rs485Communication_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485Communication_8h/#enum-rs485_speed_t","title":"enum rs485_speed_t","text":"<pre><code>enum rs485_speed_t {\n    SPEED_2M,\n    SPEED_5M,\n    SPEED_10M,\n    SPEED_20M\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/Rs485Communication_8h_source/","title":"File Rs485Communication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef RS485COMMUNICATION_H_\n#define RS485COMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485\n\ntypedef enum {\n    SPEED_2M,  // 2Mbits/s speed communication\n    SPEED_5M,  // 5Mbits/s speed communication\n    SPEED_10M, // 10Mbits/s speed communication\n    SPEED_20M, // 20Mbits/s speed communication\n}rs485_speed_t;\n\n// Static class definition\n\nclass Rs485Communication\n{\n    public :\n        void configure(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(), \n                            rs485_speed_t data_speed = SPEED_10M);\n\n        void configureCustom(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(void), uint32_t baudrate, bool oversampling_8);\n\n        void startTransmission();\n\n        void turnOnCommunication();\n\n        void turnOffCommunication();\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485\n\n#endif // RS485COMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8cpp/","title":"File SyncCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.cpp</code></p>"},{"location":"powerAPI/SyncCommunication_8cpp_source/","title":"File SyncCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// LL driver\n#include \"stm32_ll_hrtim.h\"\n#include \"stm32_ll_gpio.h\"\n#include \"stm32g4xx_ll_bus.h\"\n\n// Header\n#include \"SyncCommunication.h\"\n\nvoid SyncCommunication::initMaster()\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_A);\n\n    // SYNCOUT[1:0] and SYNCSRC[1:0] bitfield configuration in HRTIM_MCR\n    LL_HRTIM_ConfigSyncOut(HRTIM1, LL_HRTIM_SYNCOUT_POSITIVE_PULSE, LL_HRTIM_SYNCOUT_SRC_TIMA_START);\n\n    // HRTIM_SCOUT pin configuration\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n    // the SyncIN pin is disabled here, it will be enabled in the ctrl task to ensure synchronization between master and slave.\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_1, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_1, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_1, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_1, LL_GPIO_AF_13);\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_A);\n}\n\nvoid SyncCommunication::initSlave()\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    //  HRTIM synchronization input source\n    LL_HRTIM_SetSyncInSrc(HRTIM1, LL_HRTIM_SYNCIN_SRC_EXTERNAL_EVENT);\n\n    // Enable the master timer reset when receiving a synchronization input event\n    LL_HRTIM_TIM_EnableResetOnSync(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    // HRTIM_SCIN pin configuration\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n#ifdef CONFIG_SHIELD_TWIST_V1_4_1\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_2, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_2, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_2, LL_GPIO_AF_13);\n#else\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_6, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_6, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_6, LL_GPIO_AF_12);\n#endif\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n}\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8h/","title":"File SyncCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SyncCommunication_8h/#classes","title":"Classes","text":"Type Name class SyncCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/SyncCommunication_8h_source/","title":"File SyncCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SYNCCOMMUNICATION_H_\n#define SYNCCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC\n\n#include &lt;stdint.h&gt;\n\n// OWNTECH API\n#include \"SpinAPI.h\"\n\n\n// Static class definition\n\nclass SyncCommunication\n{\n\npublic:\n\n    static void initMaster();\n\n    static void initSlave();\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC\n\n#endif // SYNCCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/","title":"File data_objects.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__objects_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr   = = 0x60 bool ctrl_enable   = = false char device_id   = =\"Twist\" const char device_type   = = \"Synchronous Buck\" const char firmware_version   = = \"0.0.1\" const char hardware_version   = = \"0.9\" float32_t i1_low_value   = = 0 float32_t i2_low_value   = = 0 float32_t i_high_value   = = 0 const char manufacturer   = = \"OwnTech\" float32_t reference_value   = = 0 float32_t temp_value   = = 0 float32_t v1_low_value   = = 0 float32_t v2_low_value   = = 0 float32_t v_high_value   = = 0"},{"location":"powerAPI/data__objects_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name ThingSetDataObject data_objects"},{"location":"powerAPI/data__objects_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dataObjectsUpdateMeasures ()  ThingSet ts (data_objects, sizeof(data_objects)/sizeof(ThingSetDataObject))"},{"location":"powerAPI/data__objects_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-ctrl_enable","title":"variable ctrl_enable","text":"<pre><code>bool ctrl_enable;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-device_id","title":"variable device_id","text":"<pre><code>char device_id[9];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-device_type","title":"variable device_type","text":"<pre><code>const char device_type[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-firmware_version","title":"variable firmware_version","text":"<pre><code>const char firmware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-hardware_version","title":"variable hardware_version","text":"<pre><code>const char hardware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i1_low_value","title":"variable i1_low_value","text":"<pre><code>float32_t i1_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i2_low_value","title":"variable i2_low_value","text":"<pre><code>float32_t i2_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i_high_value","title":"variable i_high_value","text":"<pre><code>float32_t i_high_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-manufacturer","title":"variable manufacturer","text":"<pre><code>const char manufacturer[];\n</code></pre> <p>Author:</p> <p>Martin J\u00e4ger martin@libre.solar </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p>"},{"location":"powerAPI/data__objects_8cpp/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-temp_value","title":"variable temp_value","text":"<pre><code>float32_t temp_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v1_low_value","title":"variable v1_low_value","text":"<pre><code>float32_t v1_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v2_low_value","title":"variable v2_low_value","text":"<pre><code>float32_t v2_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v_high_value","title":"variable v_high_value","text":"<pre><code>float32_t v_high_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#variable-data_objects","title":"variable data_objects","text":"<pre><code>ThingSetDataObject data_objects[];\n</code></pre> <p>Thing Set Data Objects (see thingset.io for specification) </p>"},{"location":"powerAPI/data__objects_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#function-dataobjectsupdatemeasures","title":"function dataObjectsUpdateMeasures","text":"<pre><code>void dataObjectsUpdateMeasures () \n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#function-ts","title":"function ts","text":"<pre><code>ThingSet ts (\n    data_objects,\n    sizeof(data_objects)/sizeof(ThingSetDataObject)\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/data_objects.cpp</code></p>"},{"location":"powerAPI/data__objects_8cpp_source/","title":"File data_objects.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include \"data_objects.h\"\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;soc.h&gt;\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include \"thingset.h\"\n#include \"DataAcquisition.h\"\n\n\n// can be used to configure custom data objects in separate file instead\n// (e.g. data_nodes_custom.cpp)\n\nconst char manufacturer[] = \"OwnTech\";\nconst char device_type[] = \"Synchronous Buck\";\nconst char hardware_version[] = \"0.9\";\nconst char firmware_version[] = \"0.0.1\";\nchar device_id[9]=\"Twist\";\n\nfloat32_t v1_low_value = 0; //store value of V1_low (app task)\nfloat32_t v2_low_value = 0; //store value of V2_low (app task)\nfloat32_t v_high_value = 0; //store value of Vhigh (app task)\n\nfloat32_t i1_low_value = 0; //store value of i1_low (app task)\nfloat32_t i2_low_value = 0; //store value of i2_low (app task)\nfloat32_t i_high_value = 0; //store value of ihigh (app task)\n\nfloat32_t temp_value = 0; //store value of temperature (app task)\n\nfloat32_t reference_value = 0; //store value of reference (master-slave mode)\n\nbool ctrl_enable = false; //store value of the enable (master-slave mode)\n\nuint16_t can_node_addr = 0x60;\n\n\n\nvoid dataObjectsUpdateMeasures()\n{\n    if (dataAcquisition.started() == true)\n    {\n        v1_low_value = dataAcquisition.peek(V1_LOW);\n        v2_low_value = dataAcquisition.peek(V2_LOW);\n        v_high_value = dataAcquisition.peek(V_HIGH);\n        i1_low_value = dataAcquisition.peek(I1_LOW);\n        i2_low_value = dataAcquisition.peek(I2_LOW);\n        i_high_value = dataAcquisition.peek(I_HIGH);\n        // Do not update this value for now, as the measure is not enabled\n        //temp_value = peekTemperature();\n    }\n}\n\n/* clang-format off */\nstatic ThingSetDataObject data_objects[] = {\n\n    TS_GROUP(ID_DEVICE, \"Device\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Manufacturer\"\n            }\n        }*/\n        TS_ITEM_STRING(0x20, \"cManufacturer\", manufacturer, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Device Type\"\n            }\n        }*/\n        TS_ITEM_STRING(0x21, \"cType\", device_type, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Hardware Version\"\n            }\n        }*/\n        TS_ITEM_STRING(0x22, \"cHardwareVersion\", hardware_version, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Firmware Version\"\n            }\n        }*/\n        TS_ITEM_STRING(0x23, \"cFirmwareVersion\", firmware_version, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        TS_SUBSET(0x0B, \"mCAN\", SUBSET_CAN, ID_ROOT, TS_ANY_RW),\n\n\n    TS_GROUP(ID_MEASUREMENTS, \"Measurements\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 1 Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x31, \"rMeas_V1_low_V\", &amp;v1_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 2 Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x32, \"rMeas_V2_low_V\", &amp;v2_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"High Side Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x33, \"rMeas_V_high_V\", &amp;v_high_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 1 Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x34, \"rMeas_I1_low_A\", &amp;i1_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 2 Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x35, \"rMeas_I2_low_A\", &amp;i2_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"High Side Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x36, \"rMeas_I_high_A\", &amp;i_high_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Temperature Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x37, \"rMeas_temp_degC\", &amp;temp_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n\n\n\n    /*\n     * Control parameters (IDs &gt;= 0x8000)\n     *\n     */\n    TS_GROUP(ID_CTRL, \"Control\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Current control target\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x8001, \"zCtrl_Reference\", &amp;reference_value, 1,\n            ID_CTRL, TS_ANY_RW, SUBSET_CTRL),\n\n        /*{\n            \"title\": {\n                \"en\": \"Enable/Disable signal\"\n            }\n        }*/\n        TS_ITEM_BOOL(0x8002, \"zCtrl_Enable\", &amp;ctrl_enable,\n            ID_CTRL, TS_ANY_RW, SUBSET_CTRL),\n};\n/* clang-format on */\n\nThingSet ts(data_objects, sizeof(data_objects) / sizeof(ThingSetDataObject));\n</code></pre>"},{"location":"powerAPI/data__objects_8h/","title":"File data_objects.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the source code of this file</p> <p>Handling of ThingSet data objects. </p>"},{"location":"powerAPI/data__objects_8h/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr bool ctrl_enable float32_t reference_value"},{"location":"powerAPI/data__objects_8h/#public-functions","title":"Public Functions","text":"Type Name void dataObjectsUpdateMeasures ()"},{"location":"powerAPI/data__objects_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8h/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-ctrl_enable","title":"variable ctrl_enable","text":"<pre><code>bool ctrl_enable;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__objects_8h/#function-dataobjectsupdatemeasures","title":"function dataObjectsUpdateMeasures","text":"<pre><code>void dataObjectsUpdateMeasures () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/data_objects.h</code></p>"},{"location":"powerAPI/data__objects_8h_source/","title":"File data_objects.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef DATA_OBJECTS_H_\n#define DATA_OBJECTS_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;arm_math.h&gt;\n\n/*\n * Groups / first layer data object IDs\n */\n\n#define ID_ROOT         0x00\n#define ID_DEVICE       0x01\n#define ID_MEASUREMENTS 0x08\n#define ID_PUB          0x100\n#define ID_CTRL         0x8000\n\n/*\n * Subset definitions for statements and publish/subscribe\n */\n#define SUBSET_SER  (1U &lt;&lt; 0)   // UART serial\n#define SUBSET_CAN  (1U &lt;&lt; 1)   // CAN bus\n#define SUBSET_CTRL (1U &lt;&lt; 3)   // control data sent and received via CAN\n\n/*\n * Exposed variables\n */\n\nextern bool      ctrl_enable;\nextern uint16_t  can_node_addr;\nextern float32_t reference_value;\n\n/*\n * Modifiers\n */\n\nvoid dataObjectsUpdateMeasures();\n\n\n#endif // DATA_OBJECTS_H_\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/","title":"File thingset_isotp.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_isotp.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr const struct isotp_fc_opts fc_opts   = = { .bs = 8, .stmin = 1 } struct isotp_msg_id rx_addr   = = { .id_type = CAN_EXTENDED_IDENTIFIER, .use_ext_addr = 0, .use_fixed_addr = 1, } ThingSet ts struct isotp_msg_id tx_addr   = = { .id_type = CAN_EXTENDED_IDENTIFIER, .use_ext_addr = 0, .use_fixed_addr = 1, }"},{"location":"powerAPI/thingset__isotp_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * can_dev   = = DEVICE_DT_GET(DT_NODELABEL(can1)) struct isotp_recv_ctx recv_ctx struct isotp_send_ctx send_ctx"},{"location":"powerAPI/thingset__isotp_8cpp/#public-functions","title":"Public Functions","text":"Type Name K_THREAD_DEFINE (can_isotp, RX_THREAD_STACK_SIZE, can_isotp_thread, NULL, NULL, NULL, RX_THREAD_PRIORITY, 0, 1500)  void can_isotp_thread ()  void send_complete_cb (int error_nr, void * arg)"},{"location":"powerAPI/thingset__isotp_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-fc_opts","title":"variable fc_opts","text":"<pre><code>const struct isotp_fc_opts fc_opts;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-rx_addr","title":"variable rx_addr","text":"<pre><code>struct isotp_msg_id rx_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-ts","title":"variable ts","text":"<pre><code>ThingSet ts;\n</code></pre> <p>Date:</p> <p>2024 </p> <p>Author:</p> <p>Martin J\u00e4ger martin@libre.solar </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-tx_addr","title":"variable tx_addr","text":"<pre><code>struct isotp_msg_id tx_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#variable-can_dev","title":"variable can_dev","text":"<pre><code>const struct device* can_dev;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-recv_ctx","title":"variable recv_ctx","text":"<pre><code>struct isotp_recv_ctx recv_ctx;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-send_ctx","title":"variable send_ctx","text":"<pre><code>struct isotp_send_ctx send_ctx;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#function-k_thread_define","title":"function K_THREAD_DEFINE","text":"<pre><code>K_THREAD_DEFINE (\n    can_isotp,\n    RX_THREAD_STACK_SIZE,\n    can_isotp_thread,\n    NULL,\n    NULL,\n    NULL,\n    RX_THREAD_PRIORITY,\n    0,\n    1500\n) \n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#function-can_isotp_thread","title":"function can_isotp_thread","text":"<pre><code>void can_isotp_thread () \n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#function-send_complete_cb","title":"function send_complete_cb","text":"<pre><code>void send_complete_cb (\n    int error_nr,\n    void * arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_isotp.cpp</code></p>"},{"location":"powerAPI/thingset__isotp_8cpp_source/","title":"File thingset_isotp.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_isotp.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include &lt;zephyr/canbus/isotp.h&gt;\n#include \"thingset.h\"\n#include \"CommunicationAPI.h\"\n\nextern ThingSet ts;\nextern uint16_t can_node_addr;\nstatic const struct device* can_dev = DEVICE_DT_GET(DT_NODELABEL(can1));\n\n#define RX_THREAD_STACK_SIZE 1024\n#define RX_THREAD_PRIORITY 2\n\nconst struct isotp_fc_opts fc_opts = {\n    .bs = 8,                // block size\n    .stmin = 1              // minimum separation time = 100 ms\n};\n\nstruct isotp_msg_id rx_addr = {\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .use_ext_addr = 0,      // Normal ISO-TP addressing (using only CAN ID)\n    .use_fixed_addr = 1,    // enable SAE J1939 compatible addressing\n};\n\nstruct isotp_msg_id tx_addr = {\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .use_ext_addr = 0,      // Normal ISO-TP addressing (using only CAN ID)\n    .use_fixed_addr = 1,    // enable SAE J1939 compatible addressing\n};\n\nstatic struct isotp_recv_ctx recv_ctx;\nstatic struct isotp_send_ctx send_ctx;\n\nvoid send_complete_cb(int error_nr, void *arg)\n{\n    ARG_UNUSED(arg);\n}\n\nvoid can_isotp_thread()\n{\n    int ret, rem_len, resp_len;\n    unsigned int req_len;\n    struct net_buf *buf;\n    static uint8_t rx_buffer[600];      // large enough to receive a 512k flash page for DFU\n    static uint8_t tx_buffer[1000];\n\n    communication.can.enableCan();\n\n    if (!device_is_ready(can_dev)) {\n        return;\n    }\n\n    while (1) {\n        /* re-assign address in every loop as it may have been changed via ThingSet */\n        rx_addr.ext_id = TS_CAN_BASE_REQRESP | TS_CAN_PRIO_REQRESP | TS_CAN_TARGET_SET(can_node_addr);\n        tx_addr.ext_id = TS_CAN_BASE_REQRESP | TS_CAN_PRIO_REQRESP | TS_CAN_SOURCE_SET(can_node_addr);\n\n        ret = isotp_bind(&amp;recv_ctx, can_dev, &amp;rx_addr, &amp;tx_addr, &amp;fc_opts, K_FOREVER);\n        if (ret != ISOTP_N_OK) {\n            return;\n        }\n\n        req_len = 0;\n        do {\n            rem_len = isotp_recv_net(&amp;recv_ctx, &amp;buf, K_FOREVER);\n            if (rem_len &lt; 0) {\n                break;\n            }\n            if (req_len + buf-&gt;len &lt;= sizeof(rx_buffer)) {\n                memcpy(&amp;rx_buffer[req_len], buf-&gt;data, buf-&gt;len);\n            }\n            req_len += buf-&gt;len;\n            net_buf_unref(buf);\n        } while (rem_len);\n\n        // we need to unbind the receive ctx so that control frames are received in the send ctx\n        isotp_unbind(&amp;recv_ctx);\n\n        if (req_len &gt; sizeof(rx_buffer)) {\n            tx_buffer[0] = TS_STATUS_REQUEST_TOO_LARGE;\n            resp_len = 1;\n        }\n        else if (req_len &gt; 0 &amp;&amp; rem_len == 0) {\n            resp_len = ts.process(rx_buffer, req_len, tx_buffer, sizeof(tx_buffer));\n        }\n        else {\n            tx_buffer[0] = TS_STATUS_INTERNAL_SERVER_ERR;\n            resp_len = 1;\n        }\n\n        if (resp_len &gt; 0) {\n            ret = isotp_send(&amp;send_ctx, can_dev, tx_buffer, resp_len,\n                        &amp;recv_ctx.tx_addr, &amp;recv_ctx.rx_addr, send_complete_cb, NULL);\n        }\n    }\n}\n\nK_THREAD_DEFINE(can_isotp, RX_THREAD_STACK_SIZE, can_isotp_thread, NULL, NULL, NULL,\n    RX_THREAD_PRIORITY, 0, 1500);\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/","title":"File thingset_pub_sub.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_pub_sub.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t broadcast_time   = = 10 uint16_t can_node_addr uint16_t control_time   = = 10 const struct can_filter ctrl_filter   = = { .id = TS_CAN_BASE_CONTROL, .rtr = CAN_DATAFRAME, .id_type = CAN_EXTENDED_IDENTIFIER, .id_mask = TS_CAN_TYPE_MASK, .rtr_mask = 1 } ThingSet ts"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * can_dev   = = DEVICE_DT_GET(DT_NODELABEL(can1))"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-functions","title":"Public Functions","text":"Type Name CAN_MSGQ_DEFINE (sub_msgq, 10)  K_THREAD_DEFINE (can_pubsub, 1024, can_pubsub_thread, NULL, NULL, NULL, 6, 0, 1000)  void can_pub_isr (uint32_t err_flags, void * arg)  void can_pub_send (uint32_t can_id, uint8_t can_data, uint8_t data_len)  void can_pubsub_thread ()  void send_ts_can_pub_message (uint16_t tag)  void update_ts_data_nodes (struct can_frame rx_frame)"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-broadcast_time","title":"variable broadcast_time","text":"<pre><code>uint16_t broadcast_time;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-control_time","title":"variable control_time","text":"<pre><code>uint16_t control_time;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-ctrl_filter","title":"variable ctrl_filter","text":"<pre><code>const struct can_filter ctrl_filter;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-ts","title":"variable ts","text":"<pre><code>ThingSet ts;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-can_dev","title":"variable can_dev","text":"<pre><code>const struct device* can_dev;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_msgq_define","title":"function CAN_MSGQ_DEFINE","text":"<pre><code>CAN_MSGQ_DEFINE (\n    sub_msgq,\n    10\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-k_thread_define","title":"function K_THREAD_DEFINE","text":"<pre><code>K_THREAD_DEFINE (\n    can_pubsub,\n    1024,\n    can_pubsub_thread,\n    NULL,\n    NULL,\n    NULL,\n    6,\n    0,\n    1000\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pub_isr","title":"function can_pub_isr","text":"<pre><code>void can_pub_isr (\n    uint32_t err_flags,\n    void * arg\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pub_send","title":"function can_pub_send","text":"<pre><code>void can_pub_send (\n    uint32_t can_id,\n    uint8_t can_data,\n    uint8_t data_len\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pubsub_thread","title":"function can_pubsub_thread","text":"<pre><code>void can_pubsub_thread () \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-send_ts_can_pub_message","title":"function send_ts_can_pub_message","text":"<pre><code>void send_ts_can_pub_message (\n    uint16_t tag\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-update_ts_data_nodes","title":"function update_ts_data_nodes","text":"<pre><code>void update_ts_data_nodes (\n    struct can_frame rx_frame\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_pub_sub.cpp</code></p>"},{"location":"powerAPI/thingset__pub__sub_8cpp_source/","title":"File thingset_pub_sub.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_pub_sub.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#define CONFIG_THINGSET_CAN 1\n\n#if CONFIG_THINGSET_CAN\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/drivers/can.h&gt;\n\n#include \"data_objects.h\"\n#include \"thingset.h\"\n#include \"CommunicationAPI.h\"\n\n\nextern ThingSet ts;\nextern uint16_t can_node_addr;\nuint16_t broadcast_time = 10; //the time of the measurement variables broadcast (multiples of 100ms)\nuint16_t control_time = 10;  //the time of the control variables broadcast/receive (multiples of 100ms)\nstatic const struct device* can_dev = DEVICE_DT_GET(DT_NODELABEL(can1));\n\n// below defines should go into the ThingSet library\n#define TS_CAN_SOURCE_GET(id)           (((uint32_t)id &amp; TS_CAN_SOURCE_MASK) &gt;&gt; TS_CAN_SOURCE_POS)\n#define TS_CAN_DATA_ID_GET(id)          (((uint32_t)id &amp; TS_CAN_DATA_ID_MASK) &gt;&gt; TS_CAN_DATA_ID_POS)\n\nCAN_MSGQ_DEFINE(sub_msgq, 10);\n\nconst struct can_filter ctrl_filter = {\n    .id = TS_CAN_BASE_CONTROL,\n    .rtr = CAN_DATAFRAME,\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .id_mask = TS_CAN_TYPE_MASK,\n    .rtr_mask = 1\n};\n\nvoid can_pub_isr(uint32_t err_flags, void *arg)\n{\n    // Do nothing. Publication messages are fire and forget.\n}\n\nvoid can_pub_send(uint32_t can_id, uint8_t can_data[8], uint8_t data_len)\n{\n    if (!device_is_ready(can_dev))\n    {\n        return;\n    }\n\n    struct can_frame frame = {0};\n    frame.id_type = CAN_EXTENDED_IDENTIFIER;\n    frame.rtr     = CAN_DATAFRAME;\n    frame.id      = can_id;\n    memcpy(frame.data, can_data, 8);\n\n\n    if (data_len &gt;= 0)\n    {\n        frame.dlc = data_len;\n\n        can_send(can_dev, &amp;frame, K_MSEC(10), can_pub_isr, NULL);\n    }\n}\n\nvoid send_ts_can_pub_message(uint16_t tag)\n{\n    int data_len = 0;\n    int start_pos = 0;\n    uint32_t can_id;\n    uint8_t can_data[8];\n\n    do\n    {\n        data_len = ts.bin_pub_can(start_pos, tag, can_node_addr, can_id, can_data);\n        if (data_len &gt;= 0)\n        {\n            can_pub_send(can_id, can_data, data_len);\n        }\n    } while (data_len &gt;= 0);\n}\n\nvoid update_ts_data_nodes(struct can_frame rx_frame)\n{\n    // process message\n    uint16_t data_id = TS_CAN_DATA_ID_GET(rx_frame.id);\n    uint8_t sender_addr = TS_CAN_SOURCE_GET(rx_frame.id);\n\n    // control message received?\n    if (data_id &gt; 0x8000 &amp;&amp; sender_addr &lt; can_node_addr) {\n        uint8_t buf[5 + 8];     // ThingSet bin headers + CAN frame payload\n        buf[0] = 0x1F;          // ThingSet pub message\n        buf[1] = 0xA1;          // CBOR: map with 1 element\n        buf[2] = 0x19;          // CBOR: uint16 follows\n        buf[3] = data_id &gt;&gt; 8;\n        buf[4] = data_id;\n        memcpy(&amp;buf[5], rx_frame.data, 8);\n\n        // int status = ts.bin_sub(buf, 5 + rx_frame.dlc, TS_WRITE_MASK, SUBSET_CTRL);\n        int status = ts.bin_import(buf + 1, 4 + rx_frame.dlc, TS_WRITE_MASK, SUBSET_CTRL);\n        if (status == TS_STATUS_CHANGED) {\n\n        }\n    }\n}\n\n\nvoid can_pubsub_thread()\n{\n    communication.can.enableCan();\n\n    if (!device_is_ready(can_dev))\n    {\n        return;\n    }\n\n    int filter_id = can_add_rx_filter_msgq(can_dev, &amp;sub_msgq, &amp;ctrl_filter);\n    if (filter_id &lt; 0) {\n        return;\n    }\n\n    int64_t next_pub = k_uptime_get();\n    uint32_t count = 0;\n\n    while (1) {\n\n        // task_wdt_feed(wdt_channel);\n\n        if (count % broadcast_time == 0) {\n            // normal objects: only every second\n            dataObjectsUpdateMeasures();\n            send_ts_can_pub_message(SUBSET_CAN);\n        }\n\n        if (count % control_time == 0) {\n            // control objects: every 100 ms\n            send_ts_can_pub_message(SUBSET_CTRL);\n        }\n\n        struct can_frame rx_frame;\n\n        // wait for incoming messages until the next pub message has to be sent out\n        while (k_msgq_get(&amp;sub_msgq, &amp;rx_frame, K_TIMEOUT_ABS_MS(next_pub)) != -EAGAIN)\n        {\n            update_ts_data_nodes(rx_frame);\n        }\n\n        next_pub += 100;       // 100 ms period (currently fixed)\n        count++;\n    }\n}\n\nK_THREAD_DEFINE(can_pubsub, 1024, can_pubsub_thread, NULL, NULL, NULL, 6, 0, 1000);\n\n#endif /* CONFIG_THINGSET_CAN */\n</code></pre>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver</p>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/</code></p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/#files","title":"Files","text":"Type Name file comparator.c file comparator.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/comparator_8c/","title":"File comparator.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8c/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init ()  void comparator3_init ()"},{"location":"powerAPI/comparator_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8c/#function-comparator1_init","title":"function comparator1_init","text":"<pre><code>void comparator1_init () \n</code></pre> <p>Date:</p> <p>2022 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/comparator_8c/#function-comparator3_init","title":"function comparator3_init","text":"<pre><code>void comparator3_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.c</code></p>"},{"location":"powerAPI/comparator_8c_source/","title":"File comparator.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current module private functions\n#include \"../src/comparator_driver.h\"\n\n\nvoid comparator1_init()\n{\n    comparator_comp1_init();\n}\n\nvoid comparator3_init()\n{\n    comparator_comp3_init();\n}\n</code></pre>"},{"location":"powerAPI/comparator_8h/","title":"File comparator.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8h/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init ()  void comparator3_init ()"},{"location":"powerAPI/comparator_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8h/#function-comparator1_init","title":"function comparator1_init","text":"<pre><code>void comparator1_init () \n</code></pre> <p>Date:</p> <p>2022 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/comparator_8h/#function-comparator3_init","title":"function comparator3_init","text":"<pre><code>void comparator3_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.h</code></p>"},{"location":"powerAPI/comparator_8h_source/","title":"File comparator.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMPARATOR_H_\n#define COMPARATOR_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid comparator1_init();\nvoid comparator3_init();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // COMPARATOR_H_\n</code></pre>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver</p>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/</code></p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/#files","title":"Files","text":"Type Name file dac.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/dac_8h/","title":"File dac.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dac_8h/#classes","title":"Classes","text":"Type Name struct dac_driver_api struct dac_function_config_t"},{"location":"powerAPI/dac_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dac_api_fn_upd_reset typedef void(* dac_api_fn_upd_step typedef void(* dac_api_pinconfigure typedef void(* dac_api_setconstvalue typedef void(* dac_api_setfunction typedef void(* dac_api_start typedef void(* dac_api_stop enum dac_function_t enum dac_pin_config_t enum dac_polarity_t enum dac_trigger_t"},{"location":"powerAPI/dac_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void dac_function_update_reset (const struct device * dev, uint8_t channel, uint32_t reset_data)  void dac_function_update_step (const struct device * dev, uint8_t channel, uint32_t step_data)  void dac_pin_configure (const struct device * dev, uint8_t channel, dac_pin_config_t pin_config)  void dac_set_const_value (const struct device * dev, uint8_t channel, uint32_t value)  void dac_set_function (const struct device * dev, uint8_t channel, const dac_function_config_t * function_config)  void dac_start (const struct device * dev, uint8_t channel)  void dac_stop (const struct device * dev, uint8_t channel)"},{"location":"powerAPI/dac_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_reset","title":"typedef dac_api_fn_upd_reset","text":"<pre><code>typedef void(* dac_api_fn_upd_reset) (const struct device *dev, uint8_t channel, uint32_t reset_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_step","title":"typedef dac_api_fn_upd_step","text":"<pre><code>typedef void(* dac_api_fn_upd_step) (const struct device *dev, uint8_t channel, uint32_t step_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_pinconfigure","title":"typedef dac_api_pinconfigure","text":"<pre><code>typedef void(* dac_api_pinconfigure) (const struct device *dev, uint8_t channel, dac_pin_config_t config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setconstvalue","title":"typedef dac_api_setconstvalue","text":"<pre><code>typedef void(* dac_api_setconstvalue) (const struct device *dev, uint8_t channel, uint32_t value);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setfunction","title":"typedef dac_api_setfunction","text":"<pre><code>typedef void(* dac_api_setfunction) (const struct device *dev, uint8_t channel, const dac_function_config_t *config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_start","title":"typedef dac_api_start","text":"<pre><code>typedef void(* dac_api_start) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_stop","title":"typedef dac_api_stop","text":"<pre><code>typedef void(* dac_api_stop) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_function_t","title":"enum dac_function_t","text":"<pre><code>enum dac_function_t {\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_pin_config_t","title":"enum dac_pin_config_t","text":"<pre><code>enum dac_pin_config_t {\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_polarity_t","title":"enum dac_polarity_t","text":"<pre><code>enum dac_polarity_t {\n    dac_polarity_decrement,\n    dac_polarity_increment\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_trigger_t","title":"enum dac_trigger_t","text":"<pre><code>enum dac_trigger_t {\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/dac_8h/#function-dac_function_update_reset","title":"function dac_function_update_reset","text":"<pre><code>static inline void dac_function_update_reset (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t reset_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_function_update_step","title":"function dac_function_update_step","text":"<pre><code>static inline void dac_function_update_step (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t step_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_pin_configure","title":"function dac_pin_configure","text":"<pre><code>static inline void dac_pin_configure (\n    const struct device * dev,\n    uint8_t channel,\n    dac_pin_config_t pin_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_const_value","title":"function dac_set_const_value","text":"<pre><code>static inline void dac_set_const_value (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t value\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_function","title":"function dac_set_function","text":"<pre><code>static inline void dac_set_function (\n    const struct device * dev,\n    uint8_t channel,\n    const dac_function_config_t * function_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_start","title":"function dac_start","text":"<pre><code>static inline void dac_start (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_stop","title":"function dac_stop","text":"<pre><code>static inline void dac_stop (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/dac_8h_source/","title":"File dac.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DAC_H_\n#define DAC_H_\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public devices names\n\n#define DAC1_DEVICE DT_NODELABEL(dac1)\n#define DAC2_DEVICE DT_NODELABEL(dac2)\n#define DAC3_DEVICE DT_NODELABEL(dac3)\n\n\n// Configuration types\n\ntypedef enum\n{\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n} dac_function_t;\n\ntypedef enum\n{\n    dac_polarity_decrement,\n    dac_polarity_increment\n} dac_polarity_t;\n\ntypedef enum\n{\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n} dac_trigger_t;\n\ntypedef struct\n{\n    dac_function_t dac_function;\n    dac_trigger_t  reset_trigger_source;\n    dac_trigger_t  step_trigger_source;\n    dac_polarity_t polarity;\n    uint32_t       reset_data;\n    uint32_t       step_data;\n} dac_function_config_t;\n\ntypedef enum\n{\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n} dac_pin_config_t;\n\n// API\n\ntypedef void (*dac_api_setconstvalue) (const struct device* dev, uint8_t channel, uint32_t value);\ntypedef void (*dac_api_setfunction)   (const struct device* dev, uint8_t channel, const dac_function_config_t* config);\ntypedef void (*dac_api_fn_upd_reset)  (const struct device* dev, uint8_t channel, uint32_t reset_data);\ntypedef void (*dac_api_fn_upd_step)   (const struct device* dev, uint8_t channel, uint32_t step_data);\ntypedef void (*dac_api_pinconfigure)  (const struct device* dev, uint8_t channel, dac_pin_config_t config);\ntypedef void (*dac_api_start)         (const struct device* dev, uint8_t channel);\ntypedef void (*dac_api_stop)          (const struct device* dev, uint8_t channel);\n\n__subsystem struct dac_driver_api\n{\n    dac_api_setconstvalue setconstvalue;\n    dac_api_setfunction   setfunction;\n    dac_api_fn_upd_reset  fn_upd_reset;\n    dac_api_fn_upd_step   fn_upd_step;\n    dac_api_pinconfigure  pinconfigure;\n    dac_api_start         start;\n    dac_api_stop          stop;\n};\n\nstatic inline void dac_set_const_value(const struct device* dev, uint8_t channel, uint32_t value)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setconstvalue(dev, channel, value);\n}\n\nstatic inline void dac_set_function(const struct device* dev, uint8_t channel, const dac_function_config_t* function_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setfunction(dev, channel, function_config);\n}\n\nstatic inline void dac_function_update_reset(const struct device* dev, uint8_t channel, uint32_t reset_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_reset(dev, channel, reset_data);\n}\n\nstatic inline void dac_function_update_step(const struct device* dev, uint8_t channel, uint32_t step_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_step(dev, channel, step_data);\n}\n\nstatic inline void dac_pin_configure(const struct device* dev, uint8_t channel, dac_pin_config_t pin_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;pinconfigure(dev, channel, pin_config);\n}\n\nstatic inline void dac_start(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev, channel);\n}\n\nstatic inline void dac_stop(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev, channel);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // DAC_H_\n</code></pre>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver</p>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/</code></p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/#files","title":"Files","text":"Type Name file nvs_storage.c file nvs_storage.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/nvs__storage_8c/","title":"File nvs_storage.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t current_storage_version   = = 0x0001 struct nvs_fs fs   = = { .offset       = FIXED_PARTITION_OFFSET(NVS_PARTITION), .flash_device = FIXED_PARTITION_DEVICE(NVS_PARTITION) } bool initialized   = = false uint16_t storage_version_in_nvs   = = 0"},{"location":"powerAPI/nvs__storage_8c/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data ()  uint16_t nvs_storage_get_current_version ()  uint16_t nvs_storage_get_version_in_nvs ()  int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size)  int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size)"},{"location":"powerAPI/nvs__storage_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name int8_t _nvs_storage_init ()  int8_t _nvs_storage_store_version ()"},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#variable-current_storage_version","title":"variable current_storage_version","text":"<pre><code>const uint16_t current_storage_version;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p>"},{"location":"powerAPI/nvs__storage_8c/#variable-fs","title":"variable fs","text":"<pre><code>struct nvs_fs fs;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#variable-initialized","title":"variable initialized","text":"<pre><code>bool initialized;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#variable-storage_version_in_nvs","title":"variable storage_version_in_nvs","text":"<pre><code>uint16_t storage_version_in_nvs;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_init","title":"function _nvs_storage_init","text":"<pre><code>static int8_t _nvs_storage_init () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_store_version","title":"function _nvs_storage_store_version","text":"<pre><code>static int8_t _nvs_storage_store_version () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.c</code></p>"},{"location":"powerAPI/nvs__storage_8c_source/","title":"File nvs_storage.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Include\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/fs/nvs.h&gt;\n#include &lt;zephyr/drivers/flash.h&gt;\n#include &lt;zephyr/storage/flash_map.h&gt;\n\n// CMSIS\n#include &lt;arm_math.h&gt;\n\n// Current file header\n#include \"nvs_storage.h\"\n\n\n// Constants and variables\nstatic const uint16_t current_storage_version = 0x0001;\nstatic uint16_t storage_version_in_nvs = 0;\nstatic bool initialized = false;\n\n// Device-tree related macros\n#define NVS_PARTITION storage_partition\n#define STORAGE_NODE  DT_NODE_BY_FIXED_PARTITION_LABEL(NVS_PARTITION)\n\n// Flash memory file system\nstatic struct nvs_fs fs =\n{\n    .offset       = FIXED_PARTITION_OFFSET(NVS_PARTITION),\n    .flash_device = FIXED_PARTITION_DEVICE(NVS_PARTITION)\n};\n\n\n// Private functions\n\nstatic int8_t _nvs_storage_store_version()\n{\n    if (storage_version_in_nvs == current_storage_version)\n    {\n        // Ok, nothing to do\n        return 0;\n    }\n    else if (storage_version_in_nvs == 0)\n    {\n        // No version in NVS: this is the first use of NVS, store current version number.\n        int rc = nvs_write(&amp;fs, VERSION, &amp;current_storage_version, 2);\n\n        if (rc == 2)\n        {\n            storage_version_in_nvs = current_storage_version;\n            return 0;\n        }\n\n        return -1;\n    }\n    else\n    {\n        // There is already a version number in NVS, but it differs from current API version.\n        // This is currently treated as an error and requires to explicitely clear NVS.\n        return -1;\n    }\n}\n\nstatic int8_t _nvs_storage_init()\n{\n    if (initialized == true)\n        return 0;\n\n    if (!device_is_ready(fs.flash_device))\n    {\n        printk(\"Flash device %s is not ready\\n\", fs.flash_device-&gt;name);\n        return -1;\n    }\n\n    /* Handle non volatile memory used to store ADC parameters\n     * Flash partition reserved to user data storage is 4kB long\n     * We have to mount the file system then we extract one\n     * memory page that is 2kB long that contains the data\n     * and read the relevant addresses to init ADC parameters.\n     */\n\n    struct flash_pages_info info;\n    int rc = flash_get_page_info_by_offs(fs.flash_device, fs.offset, &amp;info);\n    if (rc != 0)\n    {\n        printk(\"Unable to get page info\\n\");\n        return -1;\n    }\n    fs.sector_size = info.size;\n    fs.sector_count = 2U;\n\n    rc = nvs_mount(&amp;fs);\n    if (rc != 0)\n    {\n        printk(\"Flash Init failed\\n\");\n        return -1;\n    }\n\n    // Init OK\n    initialized = true;\n\n    // Check version in storage\n    rc = nvs_storage_retrieve_data(VERSION, &amp;storage_version_in_nvs, 2);\n\n    if (rc &lt; 0)\n    {\n        // No version in NVS: this is the first use of NVS.\n        storage_version_in_nvs = 0;\n    }\n    else if (storage_version_in_nvs != current_storage_version)\n    {\n        printk(\"WARNING: stored version in NVS is different from current module version! Stored data may not have the expected format.\\n\");\n        // -2 indicates that the current version stored in NVS is different from current code version.\n        return -2;\n    }\n\n    return 0;\n}\n\n\n// Public Functions\n\nint8_t nvs_storage_store_data(uint16_t data_id, const void* data, uint8_t data_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = _nvs_storage_store_version();\n    if (rc != 0)\n    {\n        return rc;\n    }\n\n    rc = nvs_write(&amp;fs, data_id, data, data_size);\n\n    return rc;\n}\n\nint8_t nvs_storage_retrieve_data(uint16_t data_id, void* data_buffer, uint8_t data_buffer_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = nvs_read(&amp;fs, data_id, data_buffer, 1);\n\n    if (rc &gt; 1) // There is more than 1 byte of data\n    {\n        if (rc &gt; data_buffer_size)\n        {\n            // Indicate that provided buffer is too small to retreive data\n            return -1;\n        }\n\n        rc = nvs_read(&amp;fs, data_id, data_buffer, rc);\n    }\n\n    return rc;\n}\n\nint8_t nvs_storage_clear_all_stored_data()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return nvs_clear(&amp;fs);\n}\n\nuint16_t nvs_storage_get_current_version()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return current_storage_version;\n}\n\nuint16_t nvs_storage_get_version_in_nvs()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return storage_version_in_nvs;\n}\n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/","title":"File nvs_storage.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8h/#public-types","title":"Public Types","text":"Type Name enum nvs_category_t"},{"location":"powerAPI/nvs__storage_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data ()  uint16_t nvs_storage_get_current_version ()  uint16_t nvs_storage_get_version_in_nvs ()  int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size)  int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size)"},{"location":"powerAPI/nvs__storage_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#enum-nvs_category_t","title":"enum nvs_category_t","text":"<pre><code>enum nvs_category_t {\n    VERSION = 0x0100,\n    ADC_CALIBRATION = 0x0200,\n    MEASURE_THRESHOLD = 0x0300\n};\n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.h</code></p>"},{"location":"powerAPI/nvs__storage_8h_source/","title":"File nvs_storage.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef NVS_STORAGE_H_\n#define NVS_STORAGE_H_\n\n\n#include &lt;stdint.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Type definitions\n\n// NVS categories must be on the upper half\n// of the 2-bytes value, hence end with 00\ntypedef enum\n{\n    VERSION          = 0x0100,\n    ADC_CALIBRATION  = 0x0200,\n    MEASURE_THRESHOLD = 0x0300,\n}nvs_category_t;\n\n// API\n\nint8_t nvs_storage_store_data(uint16_t data_id, const void* data, uint8_t data_size);\nint8_t nvs_storage_retrieve_data(uint16_t data_id, void* data_buffer, uint8_t data_buffer_size);\nint8_t nvs_storage_clear_all_stored_data();\n\nuint16_t nvs_storage_get_current_version();\nuint16_t nvs_storage_get_version_in_nvs();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // NVS_STORAGE_H_\n</code></pre>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver</p>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/</code></p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/#files","title":"Files","text":"Type Name file hrtim.h file hrtim_enum.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/hrtim_8h/","title":"File hrtim.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim_8h/#classes","title":"Classes","text":"Type Name struct timer_hrtim_t Timinig unit configuration - aggregates all the structures."},{"location":"powerAPI/hrtim_8h/#public-attributes","title":"Public Attributes","text":"Type Name timer_hrtim_t * tu_channel"},{"location":"powerAPI/hrtim_8h/#public-functions","title":"Public Functions","text":"Type Name void DualDAC_init (hrtim_tu_number_t tu) Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). uint32_t hrtim_PeriodicEvent_GetRep (hrtim_tu_t tu) Gets the current value of the repetition counter. void hrtim_PeriodicEvent_SetRep (hrtim_tu_t tu, uint32_t repetition) Changes the repetition counter value to control the ISR interrupt. void hrtim_PeriodicEvent_configure (hrtim_tu_t tu, uint32_t repetition, hrtim_callback_t callback) Configures interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_dis (hrtim_tu_t tu) Disables interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_en (hrtim_tu_t tu) Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (hrtim_tu_number_t tu_number) Returns the adc rollover mode. void hrtim_adc_rollover_set (hrtim_tu_number_t tu_number, hrtim_adc_edgetrigger_t adc_rollover) Configures the adc rollover mode. hrtim_adc_trigger_t hrtim_adc_triger_get (hrtim_tu_number_t tu_number) Returns the adc trigger. void hrtim_adc_triger_set (hrtim_tu_number_t tu_number, hrtim_adc_trigger_t adc_trig) Sets the adc trigger number for a timing unit. void hrtim_adc_trigger_dis (hrtim_tu_number_t tu_number) Disbables a ADCx trigger event. void hrtim_adc_trigger_en (hrtim_tu_number_t tu_number) Configures and enables an ADC trigger event. void hrtim_adc_trigger_set_postscaler (hrtim_tu_number_t tu_number, uint32_t ps_ratio) Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. void hrtim_change_frequency (uint32_t new_frequency) Change the frequency/period after it has been initialized. void hrtim_cmpl_pwm_out1 (hrtim_tu_number_t tu_number) Activates OUT 1 (switch H) with a given switching convention. void hrtim_cmpl_pwm_out2 (hrtim_tu_number_t tu_number) Activates OUT 2 (switch L) with a given switching convention. void hrtim_cnt_dis (hrtim_tu_number_t tu_number) Disables a timing unit counter. void hrtim_cnt_en (hrtim_tu_number_t tu_number) Enables a timing unit counter. void hrtim_dt_init (hrtim_tu_number_t tu_number) Initialize the dead-time for the PWM. void hrtim_dt_set (hrtim_tu_number_t tu_number, uint16_t rise_ns, uint16_t fall_ns) Sets up a dead time in nano second for given complementary outputs. void hrtim_duty_cycle_set (hrtim_tu_number_t tu_number, uint16_t value) Updates the duty cycle of a timing unit. hrtim_external_trigger_t hrtim_eev_get (hrtim_tu_number_t tu_number) Returns the external event trigger used in current mode. void hrtim_eev_set (hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev) Sets the external event used in current mode for a timing unit. void hrtim_frequency_set (uint32_t frequency_set, uint32_t frequency_min) Sets the frequency of a given timing unit in Hz. int hrtim_get_apb2_clock () Gets the APB2 clock. uint32_t hrtim_get_max_frequency (hrtim_tu_number_t tu_number) Gets the minimum frequency of the timing unit in Hertz. uint16_t hrtim_get_max_period (hrtim_tu_number_t tu_number) Gets the maximum period of the timing unit in number of clock cycles. uint32_t hrtim_get_min_frequency (hrtim_tu_number_t tu_number) Gets the minimum frequency of the timing unit in Hertz. uint16_t hrtim_get_min_period (hrtim_tu_number_t tu_number) Gets the minimum period of the timing unit in number of clock cycles. hrtim_cnt_t hrtim_get_modulation (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. uint32_t hrtim_get_resolution_ps (hrtim_tu_number_t tu_number) Gets the time resolution for a given timing unit. hrtim_tu_ON_OFF_t hrtim_get_status (hrtim_tu_number_t tu_number) Returns if the timer was initialized with default value or not. hrtim_switch_convention_t hrtim_get_switch_convention (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. void hrtim_init_default_all () this function initalize all the default parameters for each timing unit structure void hrtim_master_cmp_set (hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_out_dis (hrtim_tu_number_t tu_number) Disables the output of a given timingg unit. void hrtim_out_dis_single (hrtim_output_units_t PWM_OUT) Disables only one output of a given timing unit. void hrtim_out_en (hrtim_tu_number_t tu_number) Enables the output of a given timing unit. void hrtim_out_en_single (hrtim_output_units_t PWM_OUT) Enables only one output of a given timing unit. uint16_t hrtim_period_Master_get () Returns the period of a master timer in number of clock cycles. uint32_t hrtim_period_Master_get_us () Returns the period of the master timer in microseconds. uint16_t hrtim_period_get (hrtim_tu_number_t tu_number) Returns the period of a given timing unit in number of clock cycles. uint32_t hrtim_period_get_us (hrtim_tu_number_t tu_number) Returns the period of a given timing unit in microseconds. void hrtim_phase_shift_set (hrtim_tu_number_t tu_number, uint16_t shift) Shifts the PWM of a timing unit. hrtim_pwm_mode_t hrtim_pwm_mode_get (hrtim_tu_number_t tu_number) Returns timing unit pwm mode. void hrtim_pwm_mode_set (hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode) Sets the pwm mode : voltage or current mode. void hrtim_rst_evt_dis (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Disables a timer counter reset event. void hrtim_rst_evt_en (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Enables a timer counter reset event. void hrtim_set_modulation (hrtim_tu_number_t tu_number, hrtim_cnt_t modulation) Sets the switching convention of a given timing unit. void hrtim_set_switch_convention (hrtim_tu_number_t tu_number, hrtim_switch_convention_t convention) Sets the switching convention of a given timing unit. void hrtim_tu_cmp_set (hrtim_tu_number_t tu_number, hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_tu_gpio_init (hrtim_tu_number_t tu_number) Initializes the gpio elements of a given timing unit. uint16_t hrtim_tu_init (hrtim_tu_number_t tu_number) Initializes a given timing unit."},{"location":"powerAPI/hrtim_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/hrtim_8h/#variable-tu_channel","title":"variable tu_channel","text":"<pre><code>timer_hrtim_t* tu_channel[HRTIM_STU_NUMOF];\n</code></pre>"},{"location":"powerAPI/hrtim_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hrtim_8h/#function-dualdac_init","title":"function DualDAC_init","text":"<p>Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). <pre><code>void DualDAC_init (\n    hrtim_tu_number_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> timing unit </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_getrep","title":"function hrtim_PeriodicEvent_GetRep","text":"<p>Gets the current value of the repetition counter. <pre><code>uint32_t hrtim_PeriodicEvent_GetRep (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul> <p>Returns:</p> <p>Value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_setrep","title":"function hrtim_PeriodicEvent_SetRep","text":"<p>Changes the repetition counter value to control the ISR interrupt. <pre><code>void hrtim_PeriodicEvent_SetRep (\n    hrtim_tu_t tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li> <p>TIMF </p> </li> <li> <p><code>repetion</code> value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_configure","title":"function hrtim_PeriodicEvent_configure","text":"<p>Configures interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_configure (\n    hrtim_tu_t tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li> <p>TIMF </p> </li> <li> <p><code>repetition</code> value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </p> </li> <li><code>callback</code> Pointer to a void(void) function that will be called when the event is triggerred. </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_dis","title":"function hrtim_PeriodicEvent_dis","text":"<p>Disables interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_dis (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_en","title":"function hrtim_PeriodicEvent_en","text":"<p>Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. <pre><code>void hrtim_PeriodicEvent_en (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_get","title":"function hrtim_adc_rollover_get","text":"<p>Returns the adc rollover mode. <pre><code>hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF</li> </ul> <p>Returns:</p> <p>adc_rollover rollover mode :  * EdgeTrigger_up  * EdgeTrigger_down  * EdgeTrigger_Both </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_set","title":"function hrtim_adc_rollover_set","text":"<p>Configures the adc rollover mode. <pre><code>void hrtim_adc_rollover_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_edgetrigger_t adc_rollover\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_rollover</code> rollover mode </p> </li> <li>EdgeTrigger_up </li> <li>EdgeTrigger_down </li> <li>EdgeTrigger_Both </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_triger_get","title":"function hrtim_adc_triger_get","text":"<p>Returns the adc trigger. <pre><code>hrtim_adc_trigger_t hrtim_adc_triger_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <ul> <li>ADCTRIG_1 = ADC trigger 1, </li> <li>ADCTRIG_2 = ADC trigger 2, </li> <li>ADCTRIG_3 = ADC trigger 3, </li> <li>ADCTRIG_4 = ADC trigger 4 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_triger_set","title":"function hrtim_adc_triger_set","text":"<p>Sets the adc trigger number for a timing unit. <pre><code>void hrtim_adc_triger_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_trig</code> pwm mode: </p> </li> <li>ADCTRIG_1 </li> <li>ADCTRIG_2 </li> <li>ADCTRIG_3 </li> <li>ADCTRIG_4 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_dis","title":"function hrtim_adc_trigger_dis","text":"<p>Disbables a ADCx trigger event. <pre><code>void hrtim_adc_trigger_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_en","title":"function hrtim_adc_trigger_en","text":"<p>Configures and enables an ADC trigger event. <pre><code>void hrtim_adc_trigger_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_set_postscaler","title":"function hrtim_adc_trigger_set_postscaler","text":"<p>Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. <pre><code>void hrtim_adc_trigger_set_postscaler (\n    hrtim_tu_number_t tu_number,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ps_ratio</code> Post scaler ratio (0 = no post scaler, default) </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_change_frequency","title":"function hrtim_change_frequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void hrtim_change_frequency (\n    uint32_t new_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>new_frequency</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>the new frequency can't be inferior to the the one set in the initialization step </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cmpl_pwm_out1","title":"function hrtim_cmpl_pwm_out1","text":"<p>Activates OUT 1 (switch H) with a given switching convention. <pre><code>void hrtim_cmpl_pwm_out1 (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cmpl_pwm_out2","title":"function hrtim_cmpl_pwm_out2","text":"<p>Activates OUT 2 (switch L) with a given switching convention. <pre><code>void hrtim_cmpl_pwm_out2 (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_dis","title":"function hrtim_cnt_dis","text":"<p>Disables a timing unit counter. <pre><code>void hrtim_cnt_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_en","title":"function hrtim_cnt_en","text":"<p>Enables a timing unit counter. <pre><code>void hrtim_cnt_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_init","title":"function hrtim_dt_init","text":"<p>Initialize the dead-time for the PWM. <pre><code>void hrtim_dt_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_set","title":"function hrtim_dt_set","text":"<p>Sets up a dead time in nano second for given complementary outputs. <pre><code>void hrtim_dt_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>rise_ns</code> The desired dead time of the rising edge in nano second </p> </li> <li><code>fall_ns</code> The desired dead time of the falling edge in nano second </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_duty_cycle_set","title":"function hrtim_duty_cycle_set","text":"<p>Updates the duty cycle of a timing unit. <pre><code>void hrtim_duty_cycle_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>value</code> The desired duty cycle value </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_get","title":"function hrtim_eev_get","text":"<p>Returns the external event trigger used in current mode. <pre><code>hrtim_external_trigger_t hrtim_eev_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <ul> <li>EEV1 = external event 1, </li> <li>EEV2 = external event 2, </li> <li>EEV3 = external event 3, </li> <li>EEV4 = external event 4, </li> <li>EEV5 = external event 5, </li> <li>EEV6 = external event 6, </li> <li>EEV7 = external event 7, </li> <li>EEV8 = external event 8, </li> <li>EEV9 = external event 9 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_set","title":"function hrtim_eev_set","text":"<p>Sets the external event used in current mode for a timing unit. <pre><code>void hrtim_eev_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_trig</code> pwm mode: </p> </li> <li>EEV1 </li> <li>EEV2 </li> <li>EEV3 </li> <li>EEV4 </li> <li>EEV5 </li> <li>EEV6 </li> <li>EEV7 </li> <li>EEV8 </li> <li>EEV9 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_frequency_set","title":"function hrtim_frequency_set","text":"<p>Sets the frequency of a given timing unit in Hz. <pre><code>void hrtim_frequency_set (\n    uint32_t frequency_set,\n    uint32_t frequency_min\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>tu_number</code> Timing unit number: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_apb2_clock","title":"function hrtim_get_apb2_clock","text":"<pre><code>int hrtim_get_apb2_clock () \n</code></pre>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_max_frequency","title":"function hrtim_get_max_frequency","text":"<p>Gets the minimum frequency of the timing unit in Hertz. <pre><code>uint32_t hrtim_get_max_frequency (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>frequency in Hertz </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_max_period","title":"function hrtim_get_max_period","text":"<p>Gets the maximum period of the timing unit in number of clock cycles. <pre><code>uint16_t hrtim_get_max_period (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>period in number of clock cycles </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_min_frequency","title":"function hrtim_get_min_frequency","text":"<p>Gets the minimum frequency of the timing unit in Hertz. <pre><code>uint32_t hrtim_get_min_frequency (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>frequency in Hertz </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_min_period","title":"function hrtim_get_min_period","text":"<p>Gets the minimum period of the timing unit in number of clock cycles. <pre><code>uint16_t hrtim_get_min_period (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>period in number of clock cycles </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_modulation","title":"function hrtim_get_modulation","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_cnt_t hrtim_get_modulation (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>modulation:  * Lft_aligned,  * UpDwn </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_resolution_ps","title":"function hrtim_get_resolution_ps","text":"<p>Gets the time resolution for a given timing unit. <pre><code>uint32_t hrtim_get_resolution_ps (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>resolution in picoseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_status","title":"function hrtim_get_status","text":"<p>Returns if the timer was initialized with default value or not. <pre><code>hrtim_tu_ON_OFF_t hrtim_get_status (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>true or false </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_switch_convention","title":"function hrtim_get_switch_convention","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_switch_convention_t hrtim_get_switch_convention (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Switching convention of the given time unit  * HIGH = 0,  * LOW = 1 </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_init_default_all","title":"function hrtim_init_default_all","text":"<p>this function initalize all the default parameters for each timing unit structure <pre><code>void hrtim_init_default_all () \n</code></pre></p> <p>Warning:</p> <p>this function must be called before changing any timing unit parameters (frequency, phase_shift) </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_master_cmp_set","title":"function hrtim_master_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_master_cmp_set (\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmp</code> Master comparators: </li> <li>MCMP1R = 1, </li> <li>MCMP2R = 2 </li> <li>MCMP3R = 3, </li> <li> <p>MCMP4R = 4 </p> </li> <li> <p><code>value</code> Comparator new value to set: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis","title":"function hrtim_out_dis","text":"<p>Disables the output of a given timingg unit. <pre><code>void hrtim_out_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis_single","title":"function hrtim_out_dis_single","text":"<p>Disables only one output of a given timing unit. <pre><code>void hrtim_out_dis_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: </li> <li>PWMA1 </li> <li>PWMA2 </li> <li>PWMB1 </li> <li>PWMB2 </li> <li>PWMC1 </li> <li>PWMC2 </li> <li>PWMD1 </li> <li>PWMD2 </li> <li>PWME1 </li> <li>PWME2 </li> <li>PWMF1 </li> <li>PWMF2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en","title":"function hrtim_out_en","text":"<p>Enables the output of a given timing unit. <pre><code>void hrtim_out_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en_single","title":"function hrtim_out_en_single","text":"<p>Enables only one output of a given timing unit. <pre><code>void hrtim_out_en_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: </li> <li>PWMA1 </li> <li>PWMA2 </li> <li>PWMB1 </li> <li>PWMB2 </li> <li>PWMC1 </li> <li>PWMC2 </li> <li>PWMD1 </li> <li>PWMD2 </li> <li>PWME1 </li> <li>PWME2 </li> <li>PWMF1 </li> <li>PWMF2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get","title":"function hrtim_period_Master_get","text":"<p>Returns the period of a master timer in number of clock cycles. <pre><code>uint16_t hrtim_period_Master_get () \n</code></pre></p> <p>Returns:</p> <p>Period of the master timer </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get_us","title":"function hrtim_period_Master_get_us","text":"<p>Returns the period of the master timer in microseconds. <pre><code>uint32_t hrtim_period_Master_get_us () \n</code></pre></p> <p>Returns:</p> <p>Period of the timer master in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get","title":"function hrtim_period_get","text":"<p>Returns the period of a given timing unit in number of clock cycles. <pre><code>uint16_t hrtim_period_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Period of the timing unit </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get_us","title":"function hrtim_period_get_us","text":"<p>Returns the period of a given timing unit in microseconds. <pre><code>uint32_t hrtim_period_get_us (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Period of the timing unit in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_phase_shift_set","title":"function hrtim_phase_shift_set","text":"<p>Shifts the PWM of a timing unit. <pre><code>void hrtim_phase_shift_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>shift</code> The desired phase shift value </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_get","title":"function hrtim_pwm_mode_get","text":"<p>Returns timing unit pwm mode. <pre><code>hrtim_pwm_mode_t hrtim_pwm_mode_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <p>CURRENT_MODE or VOLTAGE_MODE </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_set","title":"function hrtim_pwm_mode_set","text":"<p>Sets the pwm mode : voltage or current mode. <pre><code>void hrtim_pwm_mode_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>mode</code> pwm mode: </p> </li> <li>VOLTAGE_MODE </li> <li>CURRENT_MODE </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_dis","title":"function hrtim_rst_evt_dis","text":"<p>Disables a timer counter reset event. <pre><code>void hrtim_rst_evt_dis (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>evt</code> Reset EVent: </p> </li> <li>MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER, </li> <li>MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1, </li> <li>MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2, </li> <li>MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3, </li> <li>MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4, </li> <li>PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_en","title":"function hrtim_rst_evt_en","text":"<p>Enables a timer counter reset event. <pre><code>void hrtim_rst_evt_en (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>evt</code> Reset EVent: </p> </li> <li>MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER, </li> <li>MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1, </li> <li>MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2, </li> <li>MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3, </li> <li>MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4, </li> <li>PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_modulation","title":"function hrtim_set_modulation","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_modulation (\n    hrtim_tu_number_t tu_number,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>modulation</code> modulation: </p> </li> <li>Lft_aligned = LL_HRTIM_COUNTING_MODE_UP, </li> <li>UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_switch_convention","title":"function hrtim_set_switch_convention","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_switch_convention (\n    hrtim_tu_number_t tu_number,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>convention</code> Switching convention: </p> </li> <li>PWMx1 </li> <li>PWMx2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_cmp_set","title":"function hrtim_tu_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_tu_cmp_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmp</code> Master comparators: </li> <li>CMP1xR = 1, </li> <li>CMP2xR = 2, </li> <li>CMP3xR = 3, </li> <li> <p>CMP4xR = 4 </p> </li> <li> <p><code>value</code> Comparator new value to set: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_gpio_init","title":"function hrtim_tu_gpio_init","text":"<p>Initializes the gpio elements of a given timing unit. <pre><code>void hrtim_tu_gpio_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_init","title":"function hrtim_tu_init","text":"<p>Initializes a given timing unit. <pre><code>uint16_t hrtim_tu_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>timing unit period </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/hrtim_8h_source/","title":"File hrtim.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef HRTIM_H_\n#define HRTIM_H_\n\n#include &lt;stdint.h&gt;\n#include \"arm_math.h\"\n#include &lt;zephyr/kernel.h&gt;\n#include \"hrtim_enum.h\"\n\n#define TU_DEFAULT_DT (100U)       /* dead-time in ns */\n#define TU_DEFAULT_FREQ (200000U)  /* frequency in Hz */\n#define TU_DEFAULT_PERIOD (27200U) /* default period for 200kHz in bits */\n\n#ifdef HRTIM_MCR_TFCEN\n#define HRTIM_STU_NUMOF (6U) \n#else\n#define HRTIM_STU_NUMOF (5U)\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef struct\n{\n    pwm_conf_t pwm_conf;            /* Pulse Width Modulation Configuration */\n    phase_shift_conf_t phase_shift; /* Phase shift configuration */\n    gpio_conf_t gpio_conf;          /* Pulse width */\n    switch_conv_conf_t switch_conv; /* Switch Convention */\n    adc_hrtim_conf_t adc_hrtim;     /* ADC - HRTIM setup*/\n    comp_usage_conf_t comp_usage;   /* Usage of comp1 to comp4 */\n} timer_hrtim_t;\n\nextern timer_hrtim_t *tu_channel[HRTIM_STU_NUMOF];\n\n\nint hrtim_get_apb2_clock();\n\nvoid hrtim_init_default_all();\n\nuint16_t hrtim_tu_init(hrtim_tu_number_t tu_number);\n\nhrtim_tu_ON_OFF_t hrtim_get_status(hrtim_tu_number_t tu_number);\n\nvoid hrtim_tu_gpio_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_out_dis_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_set_modulation(hrtim_tu_number_t tu_number, hrtim_cnt_t modulation);\n\nhrtim_cnt_t hrtim_get_modulation(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_get_resolution_ps(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_get_max_period(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_get_min_period(hrtim_tu_number_t tu_number);\n\n\nuint32_t hrtim_get_max_frequency(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_get_min_frequency(hrtim_tu_number_t tu_number);\n\n\n\nvoid hrtim_set_switch_convention(hrtim_tu_number_t tu_number, hrtim_switch_convention_t convention);\n\nhrtim_switch_convention_t hrtim_get_switch_convention(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cmpl_pwm_out1(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cmpl_pwm_out2(hrtim_tu_number_t tu_number);\n\nvoid hrtim_frequency_set(uint32_t frequency_set, uint32_t frequency_min);\n\nuint16_t hrtim_period_get(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_period_Master_get();\n\nuint32_t hrtim_period_get_us(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_period_Master_get_us();\n\nvoid hrtim_tu_cmp_set(hrtim_tu_number_t tu_number, hrtim_cmp_t cmp, uint16_t value);\n\nvoid hrtim_master_cmp_set(hrtim_cmp_t cmp, uint16_t value);\n\nvoid hrtim_dt_set(hrtim_tu_number_t tu_number, uint16_t rise_ns, uint16_t fall_ns);\n\nvoid hrtim_duty_cycle_set(hrtim_tu_number_t tu_number, uint16_t value);\n\nvoid hrtim_phase_shift_set(hrtim_tu_number_t tu_number, uint16_t shift);\n\nvoid hrtim_dt_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cnt_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cnt_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_rst_evt_en(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_rst_evt_dis(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_adc_trigger_set_postscaler(hrtim_tu_number_t tu_number, uint32_t ps_ratio);\n\nvoid hrtim_adc_trigger_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_trigger_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_rollover_set(hrtim_tu_number_t tu_number, hrtim_adc_edgetrigger_t adc_rollover);\n\nhrtim_adc_edgetrigger_t hrtim_adc_rollover_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_PeriodicEvent_configure(hrtim_tu_t tu, uint32_t repetition, hrtim_callback_t callback);\n\nvoid hrtim_PeriodicEvent_en(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_dis(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_SetRep(hrtim_tu_t tu, uint32_t repetition);\n\nuint32_t hrtim_PeriodicEvent_GetRep(hrtim_tu_t tu);\n\nvoid DualDAC_init(hrtim_tu_number_t tu);\n\nvoid hrtim_pwm_mode_set(hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode);\n\nhrtim_pwm_mode_t hrtim_pwm_mode_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_triger_set(hrtim_tu_number_t tu_number, hrtim_adc_trigger_t adc_trig);\n\nhrtim_adc_trigger_t hrtim_adc_triger_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_eev_set(hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev);\n\nhrtim_external_trigger_t hrtim_eev_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_change_frequency(uint32_t new_frequency);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // HRTIM_H_\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/","title":"File hrtim_enum.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim__enum_8h/#classes","title":"Classes","text":"Type Name struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. struct switch_conv_conf_t Structure describing the switching convention of a given timing unit."},{"location":"powerAPI/hrtim__enum_8h/#public-types","title":"Public Types","text":"Type Name enum hrtim_adc_edgetrigger_t enum hrtim_adc_event_t HRTIM ADC event update. enum hrtim_adc_source_t HRTIM ADC Event Number and its associated source There are a huge number of possibilities, for now this code explores only a few. enum hrtim_adc_t HRTIM ADC trigger registers definition. enum hrtim_adc_trigger_t HRTIM ADC trigger. typedef void(* hrtim_callback_t callback function enum hrtim_cmp_t HRTIM comparators definition. enum hrtim_cnt_t HRTIM counting mode setting. enum hrtim_comp_usage_t enum hrtim_external_trigger_t External eventcoming from comparator used for current mode. enum hrtim_gpio_clock_number_t HRTIM gpio clock units definition. enum hrtim_out_t timing unit output 1 or 2 enum hrtim_output_number_t enum hrtim_output_reset_t HRTIM output reset units definition. enum hrtim_output_set_t HRTIM output set units definition. enum hrtim_output_units_t HRTIM output units definition. enum hrtim_pwm_mode_t Special PWM mode for current mode. enum hrtim_reset_trig_t HRTIM reset trig source definitions. enum hrtim_switch_convention_t HRTIM TU switch convention PWMx1 : control high-side mosfet PWMx2 : control low-side mosfet. enum hrtim_tu_ON_OFF_t describe if a timing unit has been initialized enum hrtim_tu_number_t HRTIM timing units number definition. enum hrtim_tu_t HRTIM timing units definition."},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t HRTIM_CHANNELS   = = 6 const uint32_t HRTIM_PRESCALER_RESOLUTION_PS   = = {184, 368, 735, 1470, 2940, 5880, 11760, 23530}"},{"location":"powerAPI/hrtim__enum_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_edgetrigger_t","title":"enum hrtim_adc_edgetrigger_t","text":"<pre><code>enum hrtim_adc_edgetrigger_t {\n    EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n    EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n    EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_event_t","title":"enum hrtim_adc_event_t","text":"<pre><code>enum hrtim_adc_event_t {\n    PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n    PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n    PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n    PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n    PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n    PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_source_t","title":"enum hrtim_adc_source_t","text":"<p>HRTIM ADC Event Number and its associated source There are a huge number of possibilities, for now this code explores only a few. <pre><code>enum hrtim_adc_source_t {\n    TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n    TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n    TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n    TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n    TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n    TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n};\n</code></pre></p> <p>Warning:</p> <p>prioritize cmp3, cmp4 and cmp2 might be used for current mode, and cmp1 for duty cycle </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_t","title":"enum hrtim_adc_t","text":"<pre><code>enum hrtim_adc_t {\n    ADC1R = 1,\n    ADC2R = 2,\n    ADC3R = 3,\n    ADC4R = 4\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_trigger_t","title":"enum hrtim_adc_trigger_t","text":"<pre><code>enum hrtim_adc_trigger_t {\n    ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n    ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n    ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n    ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n    ADCTRIG_NONE\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#typedef-hrtim_callback_t","title":"typedef hrtim_callback_t","text":"<pre><code>typedef void(* hrtim_callback_t) ();\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cmp_t","title":"enum hrtim_cmp_t","text":"<pre><code>enum hrtim_cmp_t {\n    CMP1xR = 1,\n    CMP2xR = 2,\n    CMP3xR = 3,\n    CMP4xR = 4,\n    MCMP1R = 5,\n    MCMP2R = 6,\n    MCMP3R = 7,\n    MCMP4R = 8,\n    MCMPER = 10\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cnt_t","title":"enum hrtim_cnt_t","text":"<pre><code>enum hrtim_cnt_t {\n    Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n    UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_comp_usage_t","title":"enum hrtim_comp_usage_t","text":"<pre><code>enum hrtim_comp_usage_t {\n    USED = true,\n    FREE = false\n};\n</code></pre> <p>comparator usage for a timing unit </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_external_trigger_t","title":"enum hrtim_external_trigger_t","text":"<pre><code>enum hrtim_external_trigger_t {\n    EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n    EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n    EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n    EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n    EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n    EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n    EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n    EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n    EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_gpio_clock_number_t","title":"enum hrtim_gpio_clock_number_t","text":"<pre><code>enum hrtim_gpio_clock_number_t {\n    CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n    CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n    CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_out_t","title":"enum hrtim_out_t","text":"<pre><code>enum hrtim_out_t {\n    OUT1 = 1,\n    OUT2 = 2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_number_t","title":"enum hrtim_output_number_t","text":"<pre><code>enum hrtim_output_number_t {\n    TIMING_OUTPUT1,\n    TIMING_OUTPUT2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_reset_t","title":"enum hrtim_output_reset_t","text":"<pre><code>enum hrtim_output_reset_t {\n    RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n    RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n    RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n    RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n    RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n    RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_set_t","title":"enum hrtim_output_set_t","text":"<pre><code>enum hrtim_output_set_t {\n    SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n    SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n    SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n    SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n    SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n    SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_units_t","title":"enum hrtim_output_units_t","text":"<pre><code>enum hrtim_output_units_t {\n    PWMA1 = LL_HRTIM_OUTPUT_TA1,\n    PWMA2 = LL_HRTIM_OUTPUT_TA2,\n    PWMB1 = LL_HRTIM_OUTPUT_TB1,\n    PWMB2 = LL_HRTIM_OUTPUT_TB2,\n    PWMC1 = LL_HRTIM_OUTPUT_TC1,\n    PWMC2 = LL_HRTIM_OUTPUT_TC2,\n    PWMD1 = LL_HRTIM_OUTPUT_TD1,\n    PWMD2 = LL_HRTIM_OUTPUT_TD2,\n    PWME1 = LL_HRTIM_OUTPUT_TE1,\n    PWME2 = LL_HRTIM_OUTPUT_TE2,\n    PWMF1 = LL_HRTIM_OUTPUT_TF1,\n    PWMF2 = LL_HRTIM_OUTPUT_TF2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_pwm_mode_t","title":"enum hrtim_pwm_mode_t","text":"<pre><code>enum hrtim_pwm_mode_t {\n    VOLTAGE_MODE = 0,\n    CURRENT_MODE = 1\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_reset_trig_t","title":"enum hrtim_reset_trig_t","text":"<pre><code>enum hrtim_reset_trig_t {\n    MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n    MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n    MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n    MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n    MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n    PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_switch_convention_t","title":"enum hrtim_switch_convention_t","text":"<pre><code>enum hrtim_switch_convention_t {\n    PWMx1 = 0,\n    PWMx2 = 1\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_on_off_t","title":"enum hrtim_tu_ON_OFF_t","text":"<pre><code>enum hrtim_tu_ON_OFF_t {\n    UNIT_ON = true,\n    UNIT_OFF = false\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_number_t","title":"enum hrtim_tu_number_t","text":"<pre><code>enum hrtim_tu_number_t {\n    PWMA = 0,\n    PWMB = 1,\n    PWMC = 2,\n    PWMD = 3,\n    PWME = 4,\n    PWMF = 5\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_t","title":"enum hrtim_tu_t","text":"<pre><code>enum hrtim_tu_t {\n    TIMA = LL_HRTIM_TIMER_A,\n    TIMB = LL_HRTIM_TIMER_B,\n    TIMC = LL_HRTIM_TIMER_C,\n    TIMD = LL_HRTIM_TIMER_D,\n    TIME = LL_HRTIM_TIMER_E,\n    TIMF = LL_HRTIM_TIMER_F,\n    MSTR = LL_HRTIM_TIMER_MASTER\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_channels","title":"variable HRTIM_CHANNELS","text":"<pre><code>const uint8_t HRTIM_CHANNELS;\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_prescaler_resolution_ps","title":"variable HRTIM_PRESCALER_RESOLUTION_PS","text":"<pre><code>const uint32_t HRTIM_PRESCALER_RESOLUTION_PS[8];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/hrtim__enum_8h_source/","title":"File hrtim_enum.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef HRTIM_ENUM_H_\n#define HRTIM_ENUM_H_\n\n#include &lt;stm32_ll_hrtim.h&gt;\n#include &lt;stm32g4xx_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    typedef void (*hrtim_callback_t)();\n\n    static const uint8_t HRTIM_CHANNELS = 6;\n\n    static const uint32_t HRTIM_PRESCALER_RESOLUTION_PS[8] = {184, \n                                                              368,\n                                                              735,\n                                                              1470,\n                                                              2940,\n                                                              5880,\n                                                              11760,\n                                                              23530};\n\n\n    typedef enum\n    {\n        TIMA = LL_HRTIM_TIMER_A,\n        TIMB = LL_HRTIM_TIMER_B,\n        TIMC = LL_HRTIM_TIMER_C,\n        TIMD = LL_HRTIM_TIMER_D,\n        TIME = LL_HRTIM_TIMER_E,\n        TIMF = LL_HRTIM_TIMER_F,\n        MSTR = LL_HRTIM_TIMER_MASTER\n    } hrtim_tu_t;\n\n    typedef enum\n    {\n        PWMA = 0,\n        PWMB = 1,\n        PWMC = 2,\n        PWMD = 3,\n        PWME = 4,\n        PWMF = 5\n    } hrtim_tu_number_t;\n\n    typedef enum\n    {\n        CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n        CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n        CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n    } hrtim_gpio_clock_number_t;\n\n    typedef enum\n    {\n        MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n        MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n        MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n        MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n        MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n        PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n    } hrtim_reset_trig_t;\n\n    typedef enum\n    {\n        VOLTAGE_MODE = 0,\n        CURRENT_MODE = 1\n    } hrtim_pwm_mode_t;\n\n    typedef enum\n    {\n        SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n        SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n        SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n        SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n        SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n        SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n    } hrtim_output_set_t;\n\n    typedef enum\n    {\n        RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n        RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n        RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n        RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n        RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n        RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n    } hrtim_output_reset_t;\n\n    typedef enum\n    {\n        PWMA1 = LL_HRTIM_OUTPUT_TA1,\n        PWMA2 = LL_HRTIM_OUTPUT_TA2,\n        PWMB1 = LL_HRTIM_OUTPUT_TB1,\n        PWMB2 = LL_HRTIM_OUTPUT_TB2,\n        PWMC1 = LL_HRTIM_OUTPUT_TC1,\n        PWMC2 = LL_HRTIM_OUTPUT_TC2,\n        PWMD1 = LL_HRTIM_OUTPUT_TD1,\n        PWMD2 = LL_HRTIM_OUTPUT_TD2,\n        PWME1 = LL_HRTIM_OUTPUT_TE1,\n        PWME2 = LL_HRTIM_OUTPUT_TE2,\n        PWMF1 = LL_HRTIM_OUTPUT_TF1,\n        PWMF2 = LL_HRTIM_OUTPUT_TF2\n    } hrtim_output_units_t;\n\n    typedef enum\n    {\n        TIMING_OUTPUT1,\n        TIMING_OUTPUT2,\n    }hrtim_output_number_t;\n\n    typedef enum\n    {\n        ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n        ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n        ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n        ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n        ADCTRIG_NONE,\n    } hrtim_adc_trigger_t;\n\n    typedef enum\n    {\n        PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n        PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n        PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n        PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n        PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n        PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n    } hrtim_adc_event_t;\n\n    typedef enum\n    {\n        TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n        TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n        TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n        TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n        TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n        TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n    } hrtim_adc_source_t;\n\n    typedef enum\n    {\n        CMP1xR = 1,\n        CMP2xR = 2,\n        CMP3xR = 3,\n        CMP4xR = 4,\n        MCMP1R = 5,\n        MCMP2R = 6,\n        MCMP3R = 7,\n        MCMP4R = 8,\n        MCMPER = 10\n    } hrtim_cmp_t;\n\n    typedef enum\n    {\n        OUT1 = 1,\n        OUT2 = 2\n    } hrtim_out_t;\n\n    typedef enum\n    {\n        PWMx1 = 0,\n        PWMx2 = 1\n    } hrtim_switch_convention_t;\n\n    typedef enum\n    {\n        USED = true,\n        FREE = false\n    } hrtim_comp_usage_t;\n\n    typedef enum\n    {\n        UNIT_ON = true,\n        UNIT_OFF = false\n    } hrtim_tu_ON_OFF_t;\n\n    typedef enum\n    {\n        ADC1R = 1,\n        ADC2R = 2,\n        ADC3R = 3,\n        ADC4R = 4\n    } hrtim_adc_t;\n\n    typedef enum\n    {\n        EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n        EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n        EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n    } hrtim_adc_edgetrigger_t;\n\n    typedef enum\n    {\n        EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n        EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n        EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n        EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n        EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n        EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n        EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n        EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n        EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n    } hrtim_external_trigger_t;\n\n    typedef enum\n    {\n        Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n        UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN // also known as center aligned\n\n    } hrtim_cnt_t;\n\n\n    typedef struct\n    {\n        hrtim_tu_t pwm_tu;                         /* Timing Unit associated with the PWM */\n        uint16_t rise_dead_time;                   /* Rising Edge Dead time */\n        uint16_t fall_dead_time;                   /* Falling Edge Dead time */\n        uint16_t duty_cycle;                       /* Current value of its duty cycle */\n        uint16_t period;                           /* Period used by the unit */\n        uint16_t max_period;                       /* Max Period used by the unit */\n        uint16_t min_period;                       /* Min Period used by the unit */\n        uint32_t frequency;                        /* Frequency used by the unit */\n        uint32_t max_frequency;                    /* Max frequency used by the unit */\n        uint32_t min_frequency;                    /* Min frequency used by the unit */\n        hrtim_cnt_t modulation;                    /* Type of modulation used for this unit */\n        hrtim_tu_ON_OFF_t unit_on;                 /* State of the time unit (ON/OFF) */\n        uint8_t ckpsc;                             /* Holds the clock pre-scaler of the timing unit */\n        uint32_t resolution;                       /* Holds the resolution of the timing unit  */\n        hrtim_pwm_mode_t pwm_mode;                 /* pwm mode for voltage mode or current mode */\n        hrtim_external_trigger_t external_trigger; /* external trigger event for current mode */\n    } pwm_conf_t;\n\n    typedef struct\n    {\n        uint16_t value;                /* Value of the phase shift */\n        hrtim_tu_t compare_tu;         /* Compare timing unit used to make the phase shift */\n        hrtim_reset_trig_t reset_trig; /* Pulse width */\n    } phase_shift_conf_t;\n\n    typedef struct\n    {\n        GPIO_TypeDef *unit;                    /* The GPIO structure to which the TU pins belong */\n        LL_GPIO_InitTypeDef switch_H;          /* Details of the high-side switch gpio */\n        hrtim_output_units_t OUT_H;            /* High-side switch hrtim output unit */\n        LL_GPIO_InitTypeDef switch_L;          /* Details of the low-side switch */\n        hrtim_output_units_t OUT_L;            /* Low-side switch hrtim output unit */\n        hrtim_gpio_clock_number_t tu_gpio_CLK; /* Gpio clock unit */\n    } gpio_conf_t;\n\n    typedef struct\n    {\n        hrtim_switch_convention_t convention; /* High-side or Low-side switch convention */\n        uint32_t set_H[2];                    /* Set event used to the High-side switch on the high-side convention */\n        uint32_t reset_H[2];                  /* Set event used to the Low-side switch on the high-side convention */\n        uint32_t set_L[2];                    /* Set event used to the High-side switch on the high-side convention */\n        uint32_t reset_L[2];                  /* Set event used to the Low-side switch on the high-side convention */\n    } switch_conv_conf_t;\n\n    typedef struct\n    {\n        hrtim_adc_event_t adc_event;       /* ADC event linked to this PWM time unit */\n        hrtim_adc_source_t adc_source;     /* ADC time unit linked to this event */\n        hrtim_adc_trigger_t adc_trigger;   /* ADC trigger between source and event */\n        hrtim_adc_edgetrigger_t adc_rollover; /* ADC rollover only relevant in center aligned */\n    } adc_hrtim_conf_t;\n\n    typedef struct\n    {\n        hrtim_comp_usage_t cmp1; /* Sets if the COMP 1 of the tu is being used */\n        uint16_t cmp1_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp2; /* Sets if the COMP 2 of the tu is being used */\n        uint16_t cmp2_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp3; /* Sets if the COMP 3 of the tu is being used */\n        uint16_t cmp3_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp4; /* Sets if the COMP 4 of the tu is being used */\n        uint16_t cmp4_value;     /* Sets if the COMP 1 of the tu is being used */\n    } comp_usage_conf_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // COMPARATOR_DRIVER_H_\n</code></pre>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver</p>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/</code></p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/#files","title":"Files","text":"Type Name file ngnd.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/ngnd_8h/","title":"File ngnd.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ngnd_8h/#public-functions","title":"Public Functions","text":"Type Name void ngnd_set (const struct device * dev, int value)"},{"location":"powerAPI/ngnd_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/ngnd_8h/#function-ngnd_set","title":"function ngnd_set","text":"<pre><code>void ngnd_set (\n    const struct device * dev,\n    int value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/ngnd.h</code></p>"},{"location":"powerAPI/ngnd_8h_source/","title":"File ngnd.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2020-2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef NGND_H_\n#define NGND_H_\n\n\n// Zephyr\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public device name\n\n#define NGND_DEVICE DT_NODELABEL(ngnd)\n\n\n// API\n\nvoid ngnd_set(const struct device* dev, int value);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // NGND_H_\n</code></pre>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/","title":"Dir docs/core/zephyr/modules/owntech_safety_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api</p>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/</code></p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr</p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/</code></p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/#files","title":"Files","text":"Type Name file SafetyAPI.cpp file SafetyAPI.h file safety_internal.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp/","title":"File SafetyAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name safety Safety"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8cpp/#variable-safety","title":"variable Safety","text":"<pre><code>safety Safety;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.cpp</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp_source/","title":"File SafetyAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"SafetyAPI.h\"\n#include \"../src/safety_shield.h\"\n#include \"../src/safety_setting.h\"\n\nsafety Safety;\n\nvoid safety::init_shield()\n{\n    safety_init_shield(true);\n}\n\nvoid safety::init_shield(sensor_t* sensors_watch, uint8_t sensors_watch_number)\n{\n    safety_init_shield(false);\n    safety_set_sensor_watch(sensors_watch, sensors_watch_number);\n}\n\nint8_t safety::setChannelWatch(sensor_t* sensors_watch, uint8_t sensors_watch_number)\n{\n    int8_t status =  safety_set_sensor_watch(sensors_watch, sensors_watch_number);\n    return status;\n}\n\nint8_t safety::unsetChannelWatch(sensor_t* sensors_watch, uint8_t sensors_watch_number)\n{\n    int8_t status =  safety_unset_sensor_watch(sensors_watch, sensors_watch_number);\n    return status;\n}\n\nbool safety::getChannelWatch(sensor_t  sensors_watch)\n{\n    bool Is_watched = safety_get_sensor_watch(sensors_watch);\n    return Is_watched;\n}\n\nvoid safety::setChannelReaction(safety_reaction_t sensors_reaction)\n{\n    safety_set_sensor_reaction(sensors_reaction);\n\n}\n\nsafety_reaction_t safety::getChannelReaction()\n{\n    safety_reaction_t sensors_reaction = safety_get_sensor_reaction();\n    return sensors_reaction;\n}\n\nint8_t safety::setChannelThresholdMax(sensor_t *sensors_threshold, float32_t *threshold_max, uint8_t sensors_threshold_number)\n{\n    uint8_t ret =  safety_set_sensor_threshold_max(sensors_threshold, threshold_max, sensors_threshold_number);\n    return ret;\n}\n\nint8_t safety::setChannelThresholdMin(sensor_t *sensors_threshold, float32_t *threshold_min, uint8_t sensors_threshold_number)\n{\n    uint8_t ret =  safety_set_sensor_threshold_min(sensors_threshold, threshold_min, sensors_threshold_number);\n    return ret;\n}\n\nfloat32_t safety::getChannelThresholdMax(sensor_t sensors_threshold)\n{\n    float32_t threshold = safety_get_sensor_threshold_max(sensors_threshold);\n    return threshold;\n}\n\nfloat32_t safety::getChannelThresholdMin(sensor_t sensors_threshold)\n{\n    float32_t threshold = safety_get_sensor_threshold_min(sensors_threshold);\n    return threshold;\n}\n\nbool safety::getChannelError(sensor_t sensors_error)\n{\n    bool error_status = safety_get_sensor_error(sensors_error);\n    return error_status;\n}\n\nvoid safety::enableSafetyApi()\n{\n    safety_enable_task();\n}\n\nvoid safety::disableSafetyApi()\n{\n    safety_disable_task();\n}\n\nint8_t safety::storeThreshold(sensor_t sensor_threshold_store)\n{\n    uint8_t ret = safety_store_threshold_in_nvs(sensor_threshold_store);\n    return ret;\n}\n\nint8_t safety::retrieveThreshold(sensor_t sensor_threshold_retrieve)\n{\n    uint8_t ret = safety_retrieve_threshold_in_nvs(sensor_threshold_retrieve);\n    return ret;\n}\n</code></pre>"},{"location":"powerAPI/SafetyAPI_8h/","title":"File SafetyAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8h/#classes","title":"Classes","text":"Type Name class safety"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name safety Safety"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8h/#variable-safety","title":"variable Safety","text":"<pre><code>safety Safety;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/SafetyAPI_8h_source/","title":"File SafetyAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SAFETY_H_\n#define SAFETY_H_\n\n#include \"arm_math.h\"\n#include \"ShieldAPI.h\"\n#include \"../src/safety_enum.h\"\n\n\nclass safety{\n\n    public:\n\n    void init_shield();\n\n    void init_shield(sensor_t* sensors_watch, uint8_t sensors_watch_number);\n\n    int8_t setChannelWatch(sensor_t* sensors_watch, uint8_t sensors_watch_number);\n\n    int8_t unsetChannelWatch(sensor_t* sensors_watch, uint8_t sensors_watch_number);\n\n    bool getChannelWatch(sensor_t  sensors_watch);\n\n    void setChannelReaction(safety_reaction_t sensors_reaction);\n\n    safety_reaction_t getChannelReaction();\n\n    int8_t setChannelThresholdMax(sensor_t *sensors_threshold, float32_t *threshold_max, uint8_t sensors_threshold_number);\n\n    int8_t setChannelThresholdMin(sensor_t *sensors_threshold, float32_t *threshold_min, uint8_t sensors_threshold_number);\n\n    float32_t getChannelThresholdMax(sensor_t sensors_threshold);\n\n    float32_t getChannelThresholdMin(sensor_t sensors_threshold);\n\n    bool getChannelError(sensor_t sensors_error);\n\n\n    void enableSafetyApi();\n\n    void disableSafetyApi();\n\n    int8_t storeThreshold(sensor_t sensor_threshold_store);\n\n    int8_t retrieveThreshold(sensor_t sensor_threshold_retrieve);\n};\n\nextern safety Safety;\n\n#endif // SAFETY_H_\n</code></pre>"},{"location":"powerAPI/safety__internal_8h/","title":"File safety_internal.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/safety__internal_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t safety_task () This function first watch the measure from the monitored channels, and compare it with the threshold values max/min to detect faults. If an error was detected, the siwtches will either in open-circuit mode or in short-circuit mode."},{"location":"powerAPI/safety__internal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/safety__internal_8h/#function-safety_task","title":"function safety_task","text":"<p>This function first watch the measure from the monitored channels, and compare it with the threshold values max/min to detect faults. If an error was detected, the siwtches will either in open-circuit mode or in short-circuit mode. <pre><code>int8_t safety_task () \n</code></pre></p> <p>Returns:</p> <p>0 if we did not detect any error, -1 else </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/safety_internal.h</code></p>"},{"location":"powerAPI/safety__internal_8h_source/","title":"File safety_internal.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SAFETY_INTERNAL_H_\n#define SAFETY_INTERNAL_H_\n\n#include \"arm_math.h\"\n\nint8_t safety_task();\n\n#endif // SAFETY_INTERNAL_H_\n</code></pre>"},{"location":"powerAPI/dir_9a89dd71eabb2209bdecc753bd3dc4ac/","title":"Dir docs/core/zephyr/modules/owntech_shield_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api</p>"},{"location":"powerAPI/dir_9a89dd71eabb2209bdecc753bd3dc4ac/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/</code></p>"},{"location":"powerAPI/dir_b3d0c58b5ddf7b1e26f8d905ca8e43b0/","title":"Dir docs/core/zephyr/modules/owntech_shield_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr</p>"},{"location":"powerAPI/dir_b3d0c58b5ddf7b1e26f8d905ca8e43b0/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/</code></p>"},{"location":"powerAPI/dir_1545707aba7ea3e5dcde32c7d0a91b3a/","title":"Dir docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_1545707aba7ea3e5dcde32c7d0a91b3a/#files","title":"Files","text":"Type Name file ShieldAPI.cpp file ShieldAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/ShieldAPI_8cpp/","title":"File ShieldAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ShieldAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name ShieldAPI shield"},{"location":"powerAPI/ShieldAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/ShieldAPI_8cpp/#variable-shield","title":"variable shield","text":"<pre><code>ShieldAPI shield;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@owntech.org </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.cpp</code></p>"},{"location":"powerAPI/ShieldAPI_8cpp_source/","title":"File ShieldAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current class header\n#include \"ShieldAPI.h\"\n\n\nShieldAPI shield;\n\nPowerAPI ShieldAPI::power;\nSensorsAPI ShieldAPI::sensors;\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\nNgndHAL ShieldAPI::ngnd;\n#endif\n</code></pre>"},{"location":"powerAPI/ShieldAPI_8h/","title":"File ShieldAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ShieldAPI_8h/#classes","title":"Classes","text":"Type Name class ShieldAPI"},{"location":"powerAPI/ShieldAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name ShieldAPI shield"},{"location":"powerAPI/ShieldAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/ShieldAPI_8h/#variable-shield","title":"variable shield","text":"<pre><code>ShieldAPI shield;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@owntech.org </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_shield_api/zephyr/public_api/ShieldAPI.h</code></p>"},{"location":"powerAPI/ShieldAPI_8h_source/","title":"File ShieldAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_shield_api &gt; zephyr &gt; public_api &gt; ShieldAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SHIELDAPI_H_\n#define SHIELDAPI_H_\n\n\n#include \"../src/Sensors.h\"\n#include \"../src/Power.h\"\n\n\n// Static class definition\n\nclass ShieldAPI\n{\npublic:\n\n    static SensorsAPI sensors;\n\n    static PowerAPI power;\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\n    static NgndHAL ngnd;\n#endif\n\n};\n\n\n// Public object to interact with the class\n\nextern ShieldAPI shield;\n\n\n#endif // SHIELDAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/","title":"Dir docs/core/zephyr/modules/owntech_spin_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api</p>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/</code></p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr</p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/</code></p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/#files","title":"Files","text":"Type Name file SpinAPI.cpp file SpinAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SpinAPI_8cpp/","title":"File SpinAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SpinAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/SpinAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SpinAPI_8cpp/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Jean Alinei jean.alinei@owntech.org </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.cpp</code></p>"},{"location":"powerAPI/SpinAPI_8cpp_source/","title":"File SpinAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current class header\n#include \"SpinAPI.h\"\n\n\nSpinAPI spin;\n\n#ifdef CONFIG_OWNTECH_GPIO_API\nGpioHAL SpinAPI::gpio;\n#endif\n\nLedHAL SpinAPI::led;\n\nDacHAL SpinAPI::dac;\n\nCompHAL SpinAPI::comp;\n\nPwmHAL SpinAPI::pwm;\n\n#ifdef CONFIG_OWNTECH_UART_API\nUartHAL SpinAPI::uart;\n#endif\n\nTimerHAL SpinAPI::timer;\n\n#ifdef CONFIG_OWNTECH_DATA_API\nDataAPI SpinAPI::data;\n#endif\n</code></pre>"},{"location":"powerAPI/SpinAPI_8h/","title":"File SpinAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SpinAPI_8h/#classes","title":"Classes","text":"Type Name class SpinAPI Contains all the elements linked to peripherals of the spin board."},{"location":"powerAPI/SpinAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/SpinAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SpinAPI_8h/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Jean Alinei jean.alinei@owntech.org </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/SpinAPI_8h_source/","title":"File SpinAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SPINAPI_H_\n#define SPINAPI_H_\n\n#include \"../src/CompHAL.h\"\n#include \"../src/DacHAL.h\"\n#include \"../src/GpioHAL.h\"\n#include \"../src/LedHAL.h\"\n#include \"../src/PwmHAL.h\"\n#include \"../src/TimerHAL.h\"\n\n#ifdef CONFIG_OWNTECH_DATA_API\n#include \"../src/DataAPI.h\"\n#endif\n\n#ifdef CONFIG_OWNTECH_UART_API\n#include \"../src/UartHAL.h\"\n#endif\n\n#ifdef CONFIG_OWNTECH_NGND_DRIVER\n#include \"../src/NgndHAL.h\"\n#endif\n\n\n\nclass SpinAPI\n{\npublic:\n\n#ifdef CONFIG_OWNTECH_GPIO_API\n    static GpioHAL gpio;\n#endif\n    static LedHAL led;\n\n    static DacHAL dac;\n\n    static CompHAL comp;\n\n    static PwmHAL pwm;\n\n#ifdef CONFIG_OWNTECH_UART_API\n    static UartHAL uart;\n#endif\n\n    static TimerHAL timer;\n\n#ifdef CONFIG_OWNTECH_DATA_API\n    static DataAPI data;\n#endif\n\n};\n\n\n// Public object to interact with the class\n\nextern SpinAPI spin;\n\n\n#endif // SPINAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/#files","title":"Files","text":"Type Name file CompHAL.cpp file CompHAL.h file DacHAL.cpp file DacHAL.h file DataAPI.cpp file DataAPI.h file GpioHAL.cpp file GpioHAL.h file LedHAL.cpp file LedHAL.h file PwmHAL.cpp file PwmHAL.h file TimerHAL.cpp file TimerHAL.h file UartHAL.cpp file UartHAL.h file hardware_auto_configuration.cpp"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/#directories","title":"Directories","text":"Type Name dir data <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/</code></p>"},{"location":"powerAPI/CompHAL_8cpp/","title":"File CompHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.cpp</code></p>"},{"location":"powerAPI/CompHAL_8cpp_source/","title":"File CompHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// OwnTech low level module\n#include \"comparator.h\"\n\n// Current file header\n#include \"CompHAL.h\"\n\n\nvoid CompHAL::initialize(uint8_t comparator_number){\n\n    if (comparator_number == 1){\n        comparator1_init();\n    } else if(comparator_number ==3){\n        comparator3_init();\n    }\n}\n</code></pre>"},{"location":"powerAPI/CompHAL_8h/","title":"File CompHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CompHAL_8h/#classes","title":"Classes","text":"Type Name class CompHAL Handles comparator 1 and 3 of the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/CompHAL_8h_source/","title":"File CompHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMPHAL_H_\n#define COMPHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\nclass CompHAL\n{\npublic:\n    void initialize(uint8_t comparator_number);\n};\n\n\n\n#endif // COMPHAL_H_\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/","title":"File DacHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * dac1   = = DEVICE_DT_GET(DAC1_DEVICE) const struct device * dac2   = = DEVICE_DT_GET(DAC2_DEVICE) const struct device * dac3   = = DEVICE_DT_GET(DAC3_DEVICE)"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DacHAL_8cpp/#variable-dac1","title":"variable dac1","text":"<pre><code>const struct device* dac1;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac2","title":"variable dac2","text":"<pre><code>const struct device* dac2;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac3","title":"variable dac3","text":"<pre><code>const struct device* dac3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.cpp</code></p>"},{"location":"powerAPI/DacHAL_8cpp_source/","title":"File DacHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n// Owntech drivers\n#include \"dac.h\"\n#include \"hrtim.h\"\n\n// Current file header\n#include \"DacHAL.h\"\n\n// Define the voltage reference used for ADC.\n// It depends on the board used (On nucleo, choose Vref = 2.48V).\n\n#define VREF 2.048f\n\nstatic const struct device* dac1 = DEVICE_DT_GET(DAC1_DEVICE);\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\nstatic const struct device* dac3 = DEVICE_DT_GET(DAC3_DEVICE);\n\nvoid DacHAL::initConstValue(uint8_t dac_number)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        dac_dev = dac2; // sets the dac 2 as default\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, 1, 0);\n        dac_pin_configure(dac_dev, 1, dac_pin_external);\n        dac_start(dac_dev, 1);\n    }\n}\n\nvoid DacHAL::setConstValue(uint8_t dac_number, uint8_t channel, uint32_t const_value)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        dac_dev = dac2; // sets the dac 2 as default\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, channel, const_value);\n    }\n}\n\nvoid DacHAL::currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src)\n{\n    if (dac_number == 1){// DAC 1\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac1, 1, &amp;function_config);\n        dac_pin_configure(dac1, 1, dac_pin_internal_and_external);\n        dac_start(dac1, 1);\n    } else if(dac_number == 3){\n        // DAC 3\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac3, 1, &amp;function_config);\n        dac_pin_configure(dac3, 1, dac_pin_internal);\n        dac_start(dac3, 1);\n    } else {\n        //does nothing - Should return an error\n    }\n}\n\n\nvoid DacHAL::slopeCompensation(uint8_t dac_number, float32_t set_voltage, float32_t reset_voltage)\n{\n    float32_t Dv = set_voltage - reset_voltage;\n\n        if (Dv &lt; 0)\n            Dv = 0;\n\n        if (Dv &gt; set_voltage)\n        {\n            Dv = set_voltage;\n            if (Dv &gt; VREF)\n                Dv = VREF;\n        }\n\n        uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n        if (set_data &gt; 4095U)\n            set_data = 4095U;\n\n    if (dac_number == 1){\n\n        dac_function_update_reset(dac1, 1, set_data);\n\n        uint32_t reset_data = (uint32_t)(Dv * 65536U) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n        dac_function_update_step(dac1, 1, reset_data);\n    } else if (dac_number == 3){\n\n\n        dac_function_update_reset(dac3, 1, set_data);\n\n        uint32_t reset_data = (uint32_t)(Dv * 65536) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n        dac_function_update_step(dac3, 1, reset_data);\n    }\n}\n\n\n\n// void DacHAL::dacConfigDac3CurrentmodeInit(hrtim_tu_t tu_src)\n// {\n//  // DAC 3\n//  dac_function_config_t function_config =\n//  {\n//      .dac_function = dac_function_sawtooth,\n//      .reset_trigger_source = hrtim_trig1,\n//      .step_trigger_source = hrtim_trig1,\n//      .polarity = dac_polarity_decrement,\n//      .reset_data = 4000,\n//      .step_data = 200\n//  };\n\n//  switch (tu_src)\n//  {\n//  case TIMB:\n//      function_config.reset_trigger_source = hrtim_trig2;\n//      function_config.step_trigger_source = hrtim_trig2;\n//      break;\n\n//  case TIMC:\n//      function_config.reset_trigger_source = hrtim_trig3;\n//      function_config.step_trigger_source = hrtim_trig3;\n//      break;\n\n//  case TIMD:\n//      function_config.reset_trigger_source = hrtim_trig4;\n//      function_config.step_trigger_source = hrtim_trig4;\n//      break;\n\n//  case TIME:\n//      function_config.reset_trigger_source = hrtim_trig5;\n//      function_config.step_trigger_source = hrtim_trig5;\n//      break;\n\n//  case TIMF:\n//      function_config.reset_trigger_source = hrtim_trig6;\n//      function_config.step_trigger_source = hrtim_trig6;\n//      break;\n\n//  default:\n//      break;\n//  }\n\n//  dac_set_function(dac3, 1, &amp;function_config);\n//  dac_pin_configure(dac3, 1, dac_pin_internal);\n//  dac_start(dac3, 1);\n// }\n\n// void DacHAL::slopeCompensationDac3(float32_t set_voltage, float32_t reset_voltage)\n// {\n//  float32_t Dv = set_voltage - reset_voltage;\n\n//  if (Dv &lt; 0)\n//      Dv = 0;\n\n//  if (Dv &gt; set_voltage)\n//  {\n//      Dv = set_voltage;\n//      if (Dv &gt; VREF)\n//          Dv = VREF;\n//  }\n\n//  uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n//  if (set_data &gt; 4095U)\n//      set_data = 4095U;\n\n//  dac_function_update_reset(dac3, 1, set_data);\n\n//  uint32_t reset_data = (uint32_t)(Dv * 65536) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n//  dac_function_update_step(dac3, 1, reset_data);\n// }\n\n// void DacHAL::slopeCompensationDac1(float32_t set_voltage, float32_t reset_voltage)\n// {\n//  float32_t Dv = set_voltage - reset_voltage;\n\n//  if (Dv &lt; 0)\n//      Dv = 0;\n\n//  if (Dv &gt; set_voltage)\n//      Dv = set_voltage;\n\n//  if (Dv &gt; VREF)\n//      Dv = VREF;\n\n//  uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n//  if (set_data &gt; 4095U)\n//      set_data = 4095U;\n\n//  dac_function_update_reset(dac1, 1, set_data);\n\n//  uint32_t reset_data = (uint32_t)(Dv * 65536U) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n//  dac_function_update_step(dac1, 1, reset_data);\n// }\n</code></pre>"},{"location":"powerAPI/DacHAL_8h/","title":"File DacHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8h/#classes","title":"Classes","text":"Type Name class DacHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/DacHAL_8h_source/","title":"File DacHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DACHAL_H_\n#define DACHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n//OwnTech Modules\n#include \"hrtim_enum.h\"\n\n\nclass DacHAL\n{\npublic:\n    void initConstValue(uint8_t dac_number);\n    void setConstValue(uint8_t dac_number, uint8_t channel, uint32_t const_value);\n    void slopeCompensation(uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage);\n    void currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src);\n};\n\n\n\n#endif // DAC_HAL_H_\n</code></pre>"},{"location":"powerAPI/DataAPI_8cpp/","title":"File DataAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.cpp</code></p>"},{"location":"powerAPI/DataAPI_8cpp_source/","title":"File DataAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;string.h&gt;\n\n// Current class header\n#include \"DataAPI.h\"\n\n// OwnTech Power API\n#include \"SpinAPI.h\"\n\n// Current module private functions\n#include \"./data/data_dispatch.h\"\n\n\n// Static class members\n\nbool DataAPI::is_started = false;\nbool DataAPI::adcInitialized = false;\nuint8_t DataAPI::channels_ranks[ADC_COUNT][CHANNELS_PER_ADC] = {0};\nuint8_t DataAPI::current_rank[ADC_COUNT] = {0};\nDispatchMethod_t DataAPI::dispatch_method = DispatchMethod_t::on_dma_interrupt;\nuint32_t DataAPI::repetition_count_between_dispatches = 0;\nfloat32_t*** DataAPI::converted_values_buffer = nullptr;\n\n\nadc_t DataAPI::current_adc[PIN_COUNT] = {DEFAULT_ADC};\n\n// Public functions accessible only when using a power shield\n\n\n// Public functions\n\nint8_t DataAPI::enableAcquisition(uint8_t pin_num, adc_t adc_num)\n{\n    if (adc_num == DEFAULT_ADC)\n    {\n        adc_num = DataAPI::getDefaultAdcForPin(pin_num);\n    }\n\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return -1;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return -1;\n    }\n\n    int8_t err = this-&gt;enableChannel(adc_num, channel_num);\n    if (err == 0)\n    {\n        DataAPI::current_adc[pin_num-1] = adc_num;\n    }\n\n    return err;\n}\n\nint8_t DataAPI::start()\n{\n    if (DataAPI::is_started == true)\n        return -1;\n\n    // Initialize conversion\n    data_conversion_init();\n\n    // Initialize data dispatch\n    switch (this-&gt;dispatch_method)\n    {\n        case DispatchMethod_t::on_dma_interrupt:\n            // Dispatch is handled automatically by Data Dispatch on interrupt\n            data_dispatch_init(interrupt, 0);\n            break;\n        case DispatchMethod_t::externally_triggered:\n            // Dispatch is triggered by an external call\n            if (this-&gt;repetition_count_between_dispatches == 0)\n                return -1;\n\n            data_dispatch_init(task, this-&gt;repetition_count_between_dispatches);\n    }\n\n    // Make sure module is initialized\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Launch ADC conversion\n    adc_start();\n\n    DataAPI::is_started = true;\n\n    return 0;\n}\n\nbool DataAPI::started()\n{\n    return DataAPI::is_started;\n}\n\nint8_t DataAPI::stop()\n{\n    if (DataAPI::is_started != true)\n        return -1;\n\n    adc_stop();\n\n    // Free buffers storage\n    if (DataAPI::converted_values_buffer != nullptr)\n    {\n        for (int adc_index = 0 ; adc_index &lt; ADC_COUNT ; adc_index++)\n        {\n            if (DataAPI::converted_values_buffer[adc_index] != nullptr)\n            {\n                for (int channel_index = 0 ; channel_index &lt; CHANNELS_PER_ADC ; channel_index++)\n                {\n                    delete DataAPI::converted_values_buffer[adc_index][channel_index];\n                }\n                delete DataAPI::converted_values_buffer[adc_index];\n            }\n        }\n        delete DataAPI::converted_values_buffer;\n        DataAPI::converted_values_buffer = nullptr;\n    }\n\n    DataAPI::is_started = false;\n\n    return 0;\n}\n\nvoid DataAPI::triggerAcquisition(adc_t adc_num)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    uint8_t enabled_channels = adc_get_enabled_channels_count(adc_num);\n    adc_trigger_software_conversion(adc_num, enabled_channels);\n}\n\nuint16_t* DataAPI::getRawValues(uint8_t pin_num, uint32_t&amp; number_of_values_acquired)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return this-&gt;getChannelRawValues(adc_num, channel_num, number_of_values_acquired);\n}\n\nfloat32_t* DataAPI::getValues(uint8_t pin_number, uint32_t&amp; number_of_values_acquired)\n{\n    adc_t adc_number = DataAPI::getCurrentAdcForPin(pin_number);\n    if (adc_number == UNKNOWN_ADC)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_number, pin_number);\n    if (channel_num == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return this-&gt;getChannelValues(adc_number, channel_num, number_of_values_acquired);\n}\n\nfloat32_t DataAPI::peekLatestValue(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return NO_VALUE;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return NO_VALUE;\n    }\n\n    return this-&gt;peekChannel(adc_num, channel_num);\n}\n\nfloat32_t DataAPI::getLatestValue(uint8_t pin_num, uint8_t* dataValid)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    return this-&gt;getChannelLatest(adc_num, channel_num, dataValid);\n}\n\nfloat32_t DataAPI::convertValue(uint8_t pin_num, uint16_t raw_value)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nvoid DataAPI::setConversionParametersLinear(uint8_t pin_num, float32_t gain, float32_t offset)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return;\n    }\n\n    data_conversion_set_conversion_parameters_linear(adc_num, channel_num, gain, offset);\n}\n\nvoid DataAPI::setConversionParametersNtcThermistor(uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return;\n    }\n\n    data_conversion_set_conversion_parameters_therm(adc_num, channel_num, r0, b, rdiv, t0);\n}\n\n\nfloat32_t DataAPI::getConversionParameterValue(uint8_t pin_num, parameter_t parameter_name)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_get_parameter(adc_num,channel_num, parameter_name);\n}\n\nconversion_type_t DataAPI::getConversionParameterType(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return no_channel_error;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return no_channel_error;\n    }\n\n    return data_conversion_get_conversion_type(adc_num,channel_num);\n}\n\nint8_t DataAPI::storeConversionParametersInMemory(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_store_channel_parameters_in_nvs(adc_num, channel_num);\n}\n\n\nint8_t DataAPI::retrieveConversionParametersFromMemory(uint8_t pin_num)\n{\n    adc_t adc_num = DataAPI::getCurrentAdcForPin(pin_num);\n    if (adc_num == UNKNOWN_ADC)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_retrieve_channel_parameters_from_nvs(adc_num, channel_num);\n}\n\nvoid DataAPI::configureDiscontinuousMode(adc_t adc_number, uint32_t discontinuous_count)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_configure_discontinuous_mode(adc_number, discontinuous_count);\n}\n\nvoid DataAPI::configureTriggerSource(adc_t adc_number, adc_ev_src_t trigger_source)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_configure_trigger_source(adc_number, trigger_source);\n}\n\n\n// Private functions\n\nvoid DataAPI::initializeAllAdcs()\n{\n    if (DataAPI::adcInitialized == false)\n    {\n        // Perform default configuration\n        adc_configure_trigger_source(1, software);\n        adc_configure_trigger_source(2, software);\n        adc_configure_trigger_source(3, software);\n        adc_configure_trigger_source(4, software);\n        adc_configure_trigger_source(5, software);\n\n        DataAPI::adcInitialized = true;\n    }\n}\n\nint8_t DataAPI::enableChannel(adc_t adc_num, uint8_t channel_num)\n{\n    if (DataAPI::is_started == true)\n        return -1;\n\n    if ( (adc_num == 0) || (adc_num &gt; ADC_COUNT) )\n        return -1;\n\n    if ( (channel_num == 0) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return -1;\n\n\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Enable DMA\n    adc_configure_use_dma(adc_num, true);\n\n    // Set channel for activation\n    adc_add_channel(adc_num, channel_num);\n\n\n    // Remember rank\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n    DataAPI::current_rank[adc_index]++;\n    DataAPI::channels_ranks[adc_index][channel_index] = DataAPI::current_rank[adc_index];\n\n    return 0;\n}\n\nvoid DataAPI::disableChannel(adc_t adc_num, uint8_t channel)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_remove_channel(adc_num, channel);\n}\n\nuint16_t* DataAPI::getChannelRawValues(adc_t adc_num, uint8_t channel_num, uint32_t&amp; number_of_values_acquired)\n{\n    if (DataAPI::is_started == false)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return data_dispatch_get_acquired_values(adc_num, channel_rank, number_of_values_acquired);\n}\n\nfloat32_t* DataAPI::getChannelValues(adc_t adc_number, uint8_t channel_num, uint32_t&amp; number_of_values_acquired)\n{\n    // Check that API is started\n    if (DataAPI::is_started == false)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    // Get raw values\n    uint16_t* raw_values = DataAPI::getChannelRawValues(adc_number, channel_num, number_of_values_acquired);\n    if (number_of_values_acquired == 0)\n    {\n        return nullptr;\n    }\n\n    // At least one value to convert: make sure a buffer is available\n    uint8_t adc_index = (uint8_t)adc_number - 1;\n    uint8_t channel_index = channel_num - 1;\n    if (DataAPI::converted_values_buffer == nullptr)\n    {\n        DataAPI::converted_values_buffer = new float32_t**[ADC_COUNT];\n        for (int i = 0 ; i &lt; ADC_COUNT ; i++)\n        {\n            DataAPI::converted_values_buffer[i] = nullptr;\n        }\n    }\n    if (DataAPI::converted_values_buffer[adc_index] == nullptr)\n    {\n        DataAPI::converted_values_buffer[adc_index] = new float32_t*[CHANNELS_PER_ADC];\n        for (int i = 0 ; i &lt; CHANNELS_PER_ADC ; i++)\n        {\n            DataAPI::converted_values_buffer[adc_index][i] = nullptr;\n        }\n    }\n    if (DataAPI::converted_values_buffer[adc_index][channel_index] == nullptr)\n    {\n        DataAPI::converted_values_buffer[adc_index][channel_index] = new float32_t[CHANNELS_BUFFERS_SIZE];\n    }\n\n    // Proceed to conversion\n    for (uint32_t i = 0 ; i &lt; number_of_values_acquired ; i++)\n    {\n        DataAPI::converted_values_buffer[adc_index][channel_index][i] = data_conversion_convert_raw_value(adc_number, channel_num, raw_values[i]);\n    }\n\n    // Return converted values buffer\n    return DataAPI::converted_values_buffer[adc_index][channel_index];\n}\n\nfloat32_t DataAPI::peekChannel(adc_t adc_num, uint8_t channel_num)\n{\n    if (DataAPI::is_started == false)\n    {\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        return NO_VALUE;\n    }\n\n    uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num, channel_rank);\n    if (raw_value == PEEK_NO_VALUE)\n    {\n        return NO_VALUE;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nfloat32_t DataAPI::getChannelLatest(adc_t adc_num, uint8_t channel_num, uint8_t* dataValid)\n{\n    if (DataAPI::is_started == false)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = DataAPI::getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint32_t data_count;\n    uint16_t* buffer = data_dispatch_get_acquired_values(adc_num, channel_rank, data_count);\n\n    if (data_count &gt; 0)\n    {\n        uint16_t raw_value = buffer[data_count - 1];\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_OK;\n        }\n        return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n    }\n    else\n    {\n        uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num, channel_rank);\n\n        float32_t peekValue;\n        if (raw_value != PEEK_NO_VALUE)\n        {\n            peekValue = data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n        }\n        else\n        {\n            peekValue = NO_VALUE;\n        }\n\n        if (dataValid != nullptr)\n        {\n            if (peekValue != NO_VALUE)\n            {\n                *dataValid = DATA_IS_OLD;\n            }\n            else\n            {\n                *dataValid = DATA_IS_MISSING;\n            }\n        }\n        return peekValue;\n    }\n}\n\nuint8_t DataAPI::getChannelRank(adc_t adc_num, uint8_t channel_num)\n{\n    if ( (adc_num &gt; ADC_COUNT) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return 0;\n\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n\n    return DataAPI::channels_ranks[adc_index][channel_index];\n}\n\nuint8_t DataAPI::getChannelNumber(adc_t adc_num, uint8_t shield_pin)\n{\n    switch (adc_num)\n    {\n    case 1:\n        switch (shield_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 2:\n                return 11;\n                break;\n            case 5:\n                return 5;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 31:\n                return 5;\n                break;\n            case 37:\n                return 12;\n                break;\n            case 50:\n                return 3;\n                break;\n            case 51:\n                return 4;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 2:\n        switch (shield_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 6:\n                return 15;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 32:\n                return 13;\n                break;\n            case 34:\n                return 3;\n                break;\n            case 35:\n                return 5;\n                break;\n            case 42:\n                return 12;\n                break;\n            case 43:\n                return 11;\n                break;\n            case 44:\n                return 4;\n                break;\n            case 45:\n                return 17;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 3:\n        switch (shield_pin)\n        {\n            case 4:\n                return 5;\n                break;\n            case 31:\n                return 12;\n                break;\n            case 37:\n                return 1;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 4:\n        switch (shield_pin)\n        {\n            case 2:\n                return 3;\n                break;\n            case 5:\n                return 4;\n                break;\n            case 6:\n                return 5;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 5:\n        switch (shield_pin)\n        {\n            case 12:\n                return 1;\n                break;\n            case 14:\n                return 2;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    default:\n        return 0;\n        break;\n    }\n}\n\nadc_t DataAPI::getDefaultAdcForPin(uint8_t pin_number)\n{\n    switch (pin_number)\n    {\n        // These pins allow only ADC 1\n        case 51:\n        case 52:\n        // These pins allow ADC 1 and ADC 2: default to ADC 1\n        case 1:\n        case 24:\n        case 25:\n        case 26:\n        case 27:\n        case 29:\n        case 30:\n        // These pins allow ADC 1 and ADC 3: default to ADC 1\n        case 31:\n        case 37:\n            return ADC_1;\n            break;\n        // These pins allow only ADC 2\n        case 32:\n        case 34:\n        case 35:\n        case 42:\n        case 43:\n        case 44:\n        case 45:\n        // This pin allows ADC 2 and ADC 4: default to ADC 2\n        case 5:\n            return ADC_2;\n            break;\n        // This pin allows only ADC 3\n        case 4:\n            return ADC_3;\n            break;\n        // This pin allows only ADC 4\n        case 2:\n            return ADC_4;\n            break;\n        // This pin allows only ADC 5\n        case 12:\n        case 14:\n            return ADC_5;\n            break;\n        default:\n            return UNKNOWN_ADC;\n    }\n}\n\nadc_t DataAPI::getCurrentAdcForPin(uint8_t pin_number)\n{\n    if ( (pin_number &gt; 1) &amp;&amp; (pin_number &lt;=PIN_COUNT) )\n    {\n        adc_t currentAdc = DataAPI::current_adc[pin_number-1];\n\n        if (currentAdc != DEFAULT_ADC)\n        {\n            return currentAdc;\n        }\n    }\n\n    return UNKNOWN_ADC;\n}\n\nvoid DataAPI::setRepetitionsBetweenDispatches(uint32_t repetition)\n{\n    DataAPI::repetition_count_between_dispatches = repetition;\n}\n\nvoid DataAPI::setDispatchMethod(DispatchMethod_t dispatch_method)\n{\n    DataAPI::dispatch_method = dispatch_method;\n}\n\nvoid DataAPI::doFullDispatch()\n{\n    data_dispatch_do_full_dispatch();\n}\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/","title":"File DataAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DataAPI_8h/#classes","title":"Classes","text":"Type Name class DataAPI"},{"location":"powerAPI/DataAPI_8h/#public-types","title":"Public Types","text":"Type Name enum DispatchMethod_t enum int8_t adc_t enum uint8_t parameter_t"},{"location":"powerAPI/DataAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t DATA_IS_MISSING   = = 2 const uint8_t DATA_IS_OK   = = 0 const uint8_t DATA_IS_OLD   = = 1 const float32_t NO_VALUE   = = -10000"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t ADC_COUNT   = = 5 const uint8_t CHANNELS_PER_ADC   = = 19 const uint8_t PIN_COUNT   = = 59"},{"location":"powerAPI/DataAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#enum-dispatchmethod_t","title":"enum DispatchMethod_t","text":"<pre><code>enum DispatchMethod_t {\n    on_dma_interrupt,\n    externally_triggered\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-adc_t","title":"enum adc_t","text":"<pre><code>enum adc_t {\n    UNKNOWN_ADC = -1,\n    DEFAULT_ADC = 0,\n    ADC_1 = 1,\n    ADC_2 = 2,\n    ADC_3 = 3,\n    ADC_4 = 4,\n    ADC_5 = 5\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-parameter_t","title":"enum parameter_t","text":"<pre><code>enum parameter_t {\n    gain = 1,\n    offset = 2,\n    r0 = 1,\n    b = 2,\n    rdiv =3,\n    t0 =4\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-data_is_missing","title":"variable DATA_IS_MISSING","text":"<pre><code>const uint8_t DATA_IS_MISSING;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_ok","title":"variable DATA_IS_OK","text":"<pre><code>const uint8_t DATA_IS_OK;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_old","title":"variable DATA_IS_OLD","text":"<pre><code>const uint8_t DATA_IS_OLD;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-no_value","title":"variable NO_VALUE","text":"<pre><code>const float32_t NO_VALUE;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-adc_count","title":"variable ADC_COUNT","text":"<pre><code>const uint8_t ADC_COUNT;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-channels_per_adc","title":"variable CHANNELS_PER_ADC","text":"<pre><code>const uint8_t CHANNELS_PER_ADC;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-pin_count","title":"variable PIN_COUNT","text":"<pre><code>const uint8_t PIN_COUNT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DataAPI.h</code></p>"},{"location":"powerAPI/DataAPI_8h_source/","title":"File DataAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DataAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DATAAPI_H_\n#define DATAAPI_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n// ARM CMSIS library\n#include &lt;arm_math.h&gt;\n\n// Other modules includes\n#include \"adc.h\"\n\n// Current module private functions\n#include \"./data/data_conversion.h\"\n\n\n// Type definitions\n\ntypedef enum : uint8_t\n{\n    gain = 1,\n    offset = 2,\n    r0 = 1,\n    b = 2,\n    rdiv =3,\n    t0=4\n\n} parameter_t;\n\ntypedef enum : int8_t\n{\n    UNKNOWN_ADC = -1,\n    DEFAULT_ADC = 0,\n    ADC_1 = 1,\n    ADC_2 = 2,\n    ADC_3 = 3,\n    ADC_4 = 4,\n    ADC_5 = 5\n} adc_t;\n\nenum class DispatchMethod_t\n{\n    on_dma_interrupt,\n    externally_triggered\n};\n\n// Constants definitions\n\nstatic const uint8_t ADC_COUNT = 5;\nstatic const uint8_t PIN_COUNT = 59;\nstatic const uint8_t CHANNELS_PER_ADC = 19;\n\n// Define \"no value\" as an impossible, out of range value\nconst float32_t NO_VALUE = -10000;\n#define ERROR_CHANNEL_OFF -5\n#define ERROR_CHANNEL_NOT_FOUND -2\n\nconst uint8_t DATA_IS_OK      = 0;\nconst uint8_t DATA_IS_OLD     = 1;\nconst uint8_t DATA_IS_MISSING = 2;\n\n// Static class definition\n\nclass DataAPI\n{\n    // Allow specific extenal members to access private members of this class\n    friend class SensorsAPI;\n    friend void user_task_proxy();\n    friend void scheduling_start_uninterruptible_synchronous_task(bool);\n\npublic:\n\n    int8_t enableAcquisition(uint8_t pin_number, adc_t adc_number = DEFAULT_ADC);\n\n    int8_t start();\n\n    bool started();\n\n    int8_t stop();\n\n    void triggerAcquisition(adc_t adc_number);\n\n    uint16_t* getRawValues(uint8_t pin_number, uint32_t&amp; number_of_values_acquired);\n\n    float32_t* getValues(uint8_t pin_number, uint32_t&amp; number_of_values_acquired);\n\n    float32_t peekLatestValue(uint8_t pin_number);\n\n    float32_t getLatestValue(uint8_t pin_number, uint8_t* dataValid = nullptr);\n\n    float32_t convertValue(uint8_t pin_number, uint16_t raw_value);\n\n    void setConversionParametersLinear(uint8_t pin_number, float32_t gain, float32_t offset);\n\n    void setConversionParametersNtcThermistor(uint8_t pin_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0);\n\n    float32_t getConversionParameterValue(uint8_t pin_number, parameter_t parameter_name);\n\n    conversion_type_t getConversionParameterType(uint8_t pin_number);\n\n    int8_t storeConversionParametersInMemory(uint8_t pin_number);\n\n    int8_t retrieveConversionParametersFromMemory(uint8_t pin_number);\n\n    void configureDiscontinuousMode(adc_t adc_number, uint32_t dicontinuous_count);\n\n    void configureTriggerSource(adc_t adc_number, adc_ev_src_t trigger_source);\n\nprivate:\n    static void initializeAllAdcs();\n    static int8_t enableChannel(adc_t adc_number, uint8_t channel_num);\n    static void disableChannel(adc_t adc_number, uint8_t channel);\n    static uint16_t* getChannelRawValues(adc_t adc_number, uint8_t channel_num, uint32_t&amp; number_of_values_acquired);\n    static float32_t* getChannelValues(adc_t adc_number, uint8_t channel_num, uint32_t&amp; number_of_values_acquired);\n    static float32_t peekChannel(adc_t adc_number, uint8_t channel_num);\n    static float32_t getChannelLatest(adc_t adc_number, uint8_t channel_num, uint8_t* dataValid = nullptr);\n    static uint8_t getChannelRank(adc_t adc_number, uint8_t channel_num);\n    static uint8_t getChannelNumber(adc_t adc_number, uint8_t shield_pin);\n    static adc_t getDefaultAdcForPin(uint8_t pin_number);\n    static adc_t getCurrentAdcForPin(uint8_t pin_number);\n\n    // Private members accessed by external friend members\n    static void setRepetitionsBetweenDispatches(uint32_t repetition);\n    static void setDispatchMethod(DispatchMethod_t dispatch_method);\n    static void doFullDispatch();\n\nprivate:\n    static bool is_started;\n    static bool adcInitialized;\n    static uint8_t channels_ranks[ADC_COUNT][CHANNELS_PER_ADC];\n    static uint8_t current_rank[ADC_COUNT];\n    static DispatchMethod_t dispatch_method;\n    static uint32_t repetition_count_between_dispatches;\n    static adc_t current_adc[PIN_COUNT];\n    static float32_t*** converted_values_buffer;\n\n};\n\n#endif // DATAAPI_H_\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/","title":"File GpioHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A   = = DEVICE_DT_GET(DT_NODELABEL(gpioa))Owntech GPIO API. const struct device *const GPIO_B   = = DEVICE_DT_GET(DT_NODELABEL(gpiob)) const struct device *const GPIO_C   = = DEVICE_DT_GET(DT_NODELABEL(gpioc)) const struct device *const GPIO_D   = = DEVICE_DT_GET(DT_NODELABEL(gpiod)) const gpio_flags_t INPUT   = = GPIO_INPUT const gpio_flags_t INPUT_PULLUP   = = GPIO_INPUT | GPIO_PULL_UP const gpio_flags_t OUTPUT   = = GPIO_OUTPUT"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.cpp</code></p>"},{"location":"powerAPI/GpioHAL_8cpp_source/","title":"File GpioHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"GpioHAL.h\"\n\nconst struct device* const GPIO_A = DEVICE_DT_GET(DT_NODELABEL(gpioa));\nconst struct device* const GPIO_B = DEVICE_DT_GET(DT_NODELABEL(gpiob));\nconst struct device* const GPIO_C = DEVICE_DT_GET(DT_NODELABEL(gpioc));\nconst struct device* const GPIO_D = DEVICE_DT_GET(DT_NODELABEL(gpiod));\n\nconst gpio_flags_t INPUT        = GPIO_INPUT;\nconst gpio_flags_t INPUT_PULLUP = GPIO_INPUT | GPIO_PULL_UP;\nconst gpio_flags_t OUTPUT       = GPIO_OUTPUT;\n\n\nvoid GpioHAL::configurePin(uint8_t pin, gpio_flags_t flags)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_configure(port, pin_number, flags);\n    }\n}\n\nvoid GpioHAL::setPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 1);\n    }\n}\n\nvoid GpioHAL::resetPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 0);\n    }\n}\n\nvoid GpioHAL::togglePin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_toggle(port, pin_number);\n    }\n}\n\nvoid GpioHAL::writePin(uint8_t pin, uint8_t value)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, value);\n    }\n}\n\nuint8_t GpioHAL::readPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        return (uint8_t) gpio_pin_get(port, pin_number);\n    }\n\n    return 0;\n}\n\ngpio_pin_t GpioHAL::getPinNumber(uint8_t pin)\n{\n    if ( (pin &amp; 0x80) != 0) // Nucleo format\n    {\n        return (((uint8_t)pin) &amp; 0x0F);\n    }\n    else // Pin number\n    {\n        if      (pin == 1)  return 11;\n        else if (pin == 2)  return 12;\n        else if (pin == 4)  return 13;\n        else if (pin == 5)  return 14;\n        else if (pin == 6)  return 15;\n        else if (pin == 7)  return 6;\n        else if (pin == 9)  return 7;\n        else if (pin == 10) return 8;\n        else if (pin == 11) return 9;\n        else if (pin == 12) return 8;\n        else if (pin == 14) return 9;\n        else if (pin == 15) return 10;\n        else if (pin == 16) return 10;\n        else if (pin == 17) return 11;\n        else if (pin == 19) return 12;\n        else if (pin == 20) return 4;\n        else if (pin == 21) return 9;\n        else if (pin == 22) return 13;\n        else if (pin == 24) return 0;\n        else if (pin == 25) return 1;\n        else if (pin == 26) return 2;\n        else if (pin == 27) return 3;\n        else if (pin == 29) return 0;\n        else if (pin == 30) return 1;\n        else if (pin == 31) return 0;\n        else if (pin == 32) return 5;\n        else if (pin == 34) return 6;\n        else if (pin == 35) return 4;\n        else if (pin == 37) return 1;\n        else if (pin == 41) return 10;\n        else if (pin == 42) return 2;\n        else if (pin == 43) return 5;\n        else if (pin == 44) return 7;\n        else if (pin == 45) return 4;\n        else if (pin == 46) return 13;\n        else if (pin == 47) return 14;\n        else if (pin == 48) return 15;\n        else if (pin == 49) return 2;\n        else if (pin == 50) return 3;\n        else if (pin == 51) return 2;\n        else if (pin == 52) return 3;\n        else if (pin == 53) return 5;\n        else if (pin == 55) return 6;\n        else if (pin == 56) return 7;\n        else if (pin == 58) return 8;\n    }\n    return 0xFF;\n}\n\nconst struct device* GpioHAL::getGpioDevice(uint8_t pin)\n{\n    if ( (pin &amp; 0x80) != 0) // Nucleo format\n    {\n        uint8_t deviceNumber = ((uint8_t)pin) &amp; 0xF0;\n        switch (deviceNumber)\n        {\n            case PA:\n                return GPIO_A;\n                break;\n            case PB:\n                return GPIO_B;\n                break;\n            case PC:\n                return GPIO_C;\n                break;\n            case PD:\n                return GPIO_D;\n                break;\n        }\n    }\n    else // Pin number\n    {\n        switch (pin)\n        {\n            case 12:\n            case 14:\n            case 15:\n            case 29:\n            case 30:\n            case 32:\n            case 34:\n            case 44:\n            case 45:\n            case 46:\n            case 47:\n            case 48:\n            case 51:\n            case 52:\n                return GPIO_A;\n                break;\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n            case 6:\n            case 20:\n            case 21:\n            case 31:\n            case 37:\n            case 41:\n            case 42:\n            case 50:\n            case 53:\n            case 55:\n            case 56:\n            case 58:\n                return GPIO_B;\n                break;\n            case 7:\n            case 9:\n            case 10:\n            case 11:\n            case 16:\n            case 17:\n            case 19:\n            case 22:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 35:\n            case 43:\n                return GPIO_C;\n                break;\n            case 49:\n                return GPIO_D;\n                break;\n        }\n    }\n\n    return nullptr;\n}\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/","title":"File GpioHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8h/#classes","title":"Classes","text":"Type Name class GpioHAL"},{"location":"powerAPI/GpioHAL_8h/#public-types","title":"Public Types","text":"Type Name enum uint8_t pin_t"},{"location":"powerAPI/GpioHAL_8h/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A Owntech GPIO API. const struct device *const GPIO_B const struct device *const GPIO_C const struct device *const GPIO_D const gpio_flags_t INPUT const gpio_flags_t INPUT_PULLUP const gpio_flags_t OUTPUT"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t P0   = = 0x0 const uint8_t P1   = = 0x1 const uint8_t P10   = = 0xA const uint8_t P11   = = 0xB const uint8_t P12   = = 0xC const uint8_t P13   = = 0xD const uint8_t P14   = = 0xE const uint8_t P15   = = 0xF const uint8_t P2   = = 0x2 const uint8_t P3   = = 0x3 const uint8_t P4   = = 0x4 const uint8_t P5   = = 0x5 const uint8_t P6   = = 0x6 const uint8_t P7   = = 0x7 const uint8_t P8   = = 0x8 const uint8_t P9   = = 0x9 const uint8_t PA   = = 0x80 | 0x00 const uint8_t PB   = = 0x80 | 0x10 const uint8_t PC   = = 0x80 | 0x20 const uint8_t PD   = = 0x80 | 0x30"},{"location":"powerAPI/GpioHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#enum-pin_t","title":"enum pin_t","text":"<pre><code>enum pin_t {\n    PA0 = PA | P0,\n    PA1 = PA | P1,\n    PA2 = PA | P2,\n    PA3 = PA | P3,\n    PA4 = PA | P4,\n    PA5 = PA | P5,\n    PA6 = PA | P6,\n    PA7 = PA | P7,\n    PA8 = PA | P8,\n    PA9 = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0 = PB | P0,\n    PB1 = PB | P1,\n    PB2 = PB | P2,\n    PB3 = PB | P3,\n    PB4 = PB | P4,\n    PB5 = PB | P5,\n    PB6 = PB | P6,\n    PB7 = PB | P7,\n    PB8 = PB | P8,\n    PB9 = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0 = PC | P0,\n    PC1 = PC | P1,\n    PC2 = PC | P2,\n    PC3 = PC | P3,\n    PC4 = PC | P4,\n    PC5 = PC | P5,\n    PC6 = PC | P6,\n    PC7 = PC | P7,\n    PC8 = PC | P8,\n    PC9 = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0 = PD | P0,\n    PD1 = PD | P1,\n    PD2 = PD | P2,\n    PD3 = PD | P3\n};\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-p0","title":"variable P0","text":"<pre><code>const uint8_t P0;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p1","title":"variable P1","text":"<pre><code>const uint8_t P1;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p10","title":"variable P10","text":"<pre><code>const uint8_t P10;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p11","title":"variable P11","text":"<pre><code>const uint8_t P11;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p12","title":"variable P12","text":"<pre><code>const uint8_t P12;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p13","title":"variable P13","text":"<pre><code>const uint8_t P13;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p14","title":"variable P14","text":"<pre><code>const uint8_t P14;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p15","title":"variable P15","text":"<pre><code>const uint8_t P15;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p2","title":"variable P2","text":"<pre><code>const uint8_t P2;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p3","title":"variable P3","text":"<pre><code>const uint8_t P3;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p4","title":"variable P4","text":"<pre><code>const uint8_t P4;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p5","title":"variable P5","text":"<pre><code>const uint8_t P5;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p6","title":"variable P6","text":"<pre><code>const uint8_t P6;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p7","title":"variable P7","text":"<pre><code>const uint8_t P7;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p8","title":"variable P8","text":"<pre><code>const uint8_t P8;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p9","title":"variable P9","text":"<pre><code>const uint8_t P9;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pa","title":"variable PA","text":"<pre><code>const uint8_t PA;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pb","title":"variable PB","text":"<pre><code>const uint8_t PB;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pc","title":"variable PC","text":"<pre><code>const uint8_t PC;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pd","title":"variable PD","text":"<pre><code>const uint8_t PD;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/GpioHAL_8h_source/","title":"File GpioHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef GPIOHAL_H_\n#define GPIOHAL_H_\n\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n\n// Public constants\n\nextern const struct device* const GPIO_A;\nextern const struct device* const GPIO_B;\nextern const struct device* const GPIO_C;\nextern const struct device* const GPIO_D;\n\nextern const gpio_flags_t INPUT;\nextern const gpio_flags_t INPUT_PULLUP;\nextern const gpio_flags_t OUTPUT;\n\n// 0x80 is used to indicate nucleo-style pin\nstatic const uint8_t PA = 0x80 | 0x00;\nstatic const uint8_t PB = 0x80 | 0x10;\nstatic const uint8_t PC = 0x80 | 0x20;\nstatic const uint8_t PD = 0x80 | 0x30;\n\nstatic const uint8_t P0  = 0x0;\nstatic const uint8_t P1  = 0x1;\nstatic const uint8_t P2  = 0x2;\nstatic const uint8_t P3  = 0x3;\nstatic const uint8_t P4  = 0x4;\nstatic const uint8_t P5  = 0x5;\nstatic const uint8_t P6  = 0x6;\nstatic const uint8_t P7  = 0x7;\nstatic const uint8_t P8  = 0x8;\nstatic const uint8_t P9  = 0x9;\nstatic const uint8_t P10 = 0xA;\nstatic const uint8_t P11 = 0xB;\nstatic const uint8_t P12 = 0xC;\nstatic const uint8_t P13 = 0xD;\nstatic const uint8_t P14 = 0xE;\nstatic const uint8_t P15 = 0xF;\n\n\n// Public types\n\ntypedef enum : uint8_t\n{\n    PA0  = PA | P0,\n    PA1  = PA | P1,\n    PA2  = PA | P2,\n    PA3  = PA | P3,\n    PA4  = PA | P4,\n    PA5  = PA | P5,\n    PA6  = PA | P6,\n    PA7  = PA | P7,\n    PA8  = PA | P8,\n    PA9  = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0  = PB | P0,\n    PB1  = PB | P1,\n    PB2  = PB | P2,\n    PB3  = PB | P3,\n    PB4  = PB | P4,\n    PB5  = PB | P5,\n    PB6  = PB | P6,\n    PB7  = PB | P7,\n    PB8  = PB | P8,\n    PB9  = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0  = PC | P0,\n    PC1  = PC | P1,\n    PC2  = PC | P2,\n    PC3  = PC | P3,\n    PC4  = PC | P4,\n    PC5  = PC | P5,\n    PC6  = PC | P6,\n    PC7  = PC | P7,\n    PC8  = PC | P8,\n    PC9  = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0  = PD | P0,\n    PD1  = PD | P1,\n    PD2  = PD | P2,\n    PD3  = PD | P3\n} pin_t;\n\n\n// Class definition\n\nclass GpioHAL\n{\npublic:\n\n    void configurePin(uint8_t pin, gpio_flags_t flags);\n\n    void setPin(uint8_t pin);\n\n    void resetPin(uint8_t pin);\n\n    void togglePin(uint8_t pin);\n\n    void writePin(uint8_t pin, uint8_t value);\n\n    uint8_t readPin(uint8_t pin);\n\nprivate:\n    gpio_pin_t getPinNumber(uint8_t pin);\n    const struct device* getGpioDevice(uint8_t pin);\n\n};\n\n#endif // GPIOHAL_H_\n</code></pre>"},{"location":"powerAPI/LedHAL_8cpp/","title":"File LedHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name struct gpio_dt_spec led_pin_spec   = = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios)"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/LedHAL_8cpp/#variable-led_pin_spec","title":"variable led_pin_spec","text":"<pre><code>struct gpio_dt_spec led_pin_spec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.cpp</code></p>"},{"location":"powerAPI/LedHAL_8cpp_source/","title":"File LedHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n// Current file header\n#include \"LedHAL.h\"\n\n\nbool LedHAL::ledInitialized = false;\n\nstatic struct gpio_dt_spec led_pin_spec = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\n\n\nvoid LedHAL::initialize()\n{\n    gpio_pin_configure_dt(&amp;led_pin_spec, GPIO_OUTPUT_INACTIVE);\n    ledInitialized = true;\n}\n\nvoid LedHAL::turnOn()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 1);\n}\n\nvoid LedHAL::turnOff()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 0);\n}\n\nvoid LedHAL::toggle()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_toggle_dt(&amp;led_pin_spec);\n}\n</code></pre>"},{"location":"powerAPI/LedHAL_8h/","title":"File LedHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8h/#classes","title":"Classes","text":"Type Name class LedHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/LedHAL_8h_source/","title":"File LedHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef LEDHAL_H_\n#define LEDHAL_H_\n\nclass LedHAL\n{\npublic:\n    void turnOn();\n    void turnOff();\n    void toggle();\n\nprivate:\n    // Private functions\n    void initialize();\n\n    // Private variables\n    static bool ledInitialized;\n\n};\n\n\n\n#endif // LED_H_\n</code></pre>"},{"location":"powerAPI/PwmHAL_8cpp/","title":"File PwmHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.cpp</code></p>"},{"location":"powerAPI/PwmHAL_8cpp_source/","title":"File PwmHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// OwnTech Power API\n\n// Current file header\n#include \"PwmHAL.h\"\n#include \"hrtim.h\" // PWM management layer by inverter leg interface\n\nvoid PwmHAL::initUnit(hrtim_tu_number_t pwmX)\n{\n    hrtim_tu_init(pwmX);\n}\n\nvoid PwmHAL::startDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_en(pwmX);\n}\n\nvoid PwmHAL::stopDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_dis(pwmX);\n}\n\nvoid PwmHAL::startSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::stopSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_set_modulation(pwmX, modulation);\n}\n\nvoid PwmHAL::setSwitchConvention(hrtim_tu_number_t pwmX,\n                                 hrtim_switch_convention_t convention) {\n  if (!hrtim_get_status(pwmX))\n    hrtim_init_default_all(); // initialize default parameters before\n  hrtim_set_switch_convention(pwmX, convention);\n}\n\nvoid PwmHAL::initVariableFrequency(uint32_t initial_frequency, uint32_t minimal_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_frequency_set(initial_frequency, minimal_frequency);\n}\n\nvoid PwmHAL::initFixedFrequency(uint32_t fixed_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_frequency_set(fixed_frequency, fixed_frequency);\n}\n\nvoid PwmHAL::setDeadTime(hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_dt_set(pwmX, rise_ns, fall_ns);\n}\n\nvoid PwmHAL::setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle)\n{\n    uint16_t value = duty_cycle * tu_channel[pwmX]-&gt;pwm_conf.period;\n    hrtim_duty_cycle_set(pwmX, value);\n}\n\nvoid PwmHAL::setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift)\n{\n    int16_t phase_shift_degree = shift % 360; // modulo\n    if (phase_shift_degree &lt; 0)\n        phase_shift_degree += 360; // case of negative phase\n    uint16_t period;\n    if (pwmX != PWMB)\n    {\n        period = hrtim_period_get(pwmX);\n        if (hrtim_get_modulation(pwmX) == UpDwn)\n            period = 2 * period;\n    }\n    else if (pwmX == PWMB)\n    {\n        period = hrtim_period_get(PWMA);\n    }\n    uint16_t phase_shift_int = (period * phase_shift_degree) / 360;\n    hrtim_phase_shift_set(pwmX, phase_shift_int);\n}\n\nhrtim_cnt_t PwmHAL::getModulation(hrtim_tu_number_t pwmX) {\n  return hrtim_get_modulation(pwmX);\n}\n\nhrtim_switch_convention_t PwmHAL::getSwitchConvention(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_switch_convention(pwmX);\n}\n\nuint16_t PwmHAL::getPeriod(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get(pwmX);\n}\n\nuint16_t PwmHAL::getPeriodMax(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_max_period(pwmX);\n}\n\nuint16_t PwmHAL::getPeriodMin(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_min_period(pwmX);\n}\n\nvoid PwmHAL::setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio)\n{\n    hrtim_adc_trigger_set_postscaler(pwmX, ps_ratio);\n}\n\nvoid PwmHAL::enableAdcTrigger(hrtim_tu_number_t pwmX)\n{\n    uint16_t initial_trigger_value; // initial trigger value when you enable the adc trigger\n    hrtim_adc_trigger_en(pwmX);\n    if (hrtim_get_modulation(pwmX) == UpDwn)\n    {\n        initial_trigger_value = 0.06 * hrtim_period_get(pwmX);\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n    else\n    {\n        initial_trigger_value = 100;\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n}\n\nvoid PwmHAL::setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val)\n{\n    uint16_t triger_value_int = trig_val * hrtim_period_get(pwmX);\n    hrtim_tu_cmp_set(pwmX, CMP3xR, triger_value_int);\n}\n\nvoid PwmHAL::disableAdcTrigger(hrtim_tu_number_t tu_number)\n{\n    hrtim_adc_trigger_dis(tu_number);\n}\n\nvoid PwmHAL::configurePeriodEvnt(hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback)\n{\n    hrtim_PeriodicEvent_configure(PWM_tu, repetition, callback);\n}\n\nvoid PwmHAL::enablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_en(PWM_tu);\n}\n\nvoid PwmHAL::disablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_dis(PWM_tu);\n}\n\nvoid PwmHAL::setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition)\n{\n    hrtim_PeriodicEvent_SetRep(PWM_tu, repetition);\n}\n\nuint32_t PwmHAL::getPeriodEvntRep(hrtim_tu_t PWM_tu)\n{\n    return hrtim_PeriodicEvent_GetRep(PWM_tu);\n}\n\nuint32_t PwmHAL::getPeriodUs(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get_us(pwmX);\n}\n\nvoid PwmHAL::setAdcEdgeTrigger(hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_adc_rollover_set(pwmX, adc_edge_trigger);\n}\n\nhrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger(hrtim_tu_number_t pwmX)\n{\n    return hrtim_adc_rollover_get(pwmX);\n}\n\nvoid PwmHAL::setAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_adc_triger_set(pwmX, adc_trig);\n}\n\nhrtim_adc_trigger_t PwmHAL::getAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig)\n{\n    return hrtim_adc_triger_get(pwmX);\n}\n\nvoid PwmHAL::setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_pwm_mode_set(pwmX, mode);\n}\n\nhrtim_pwm_mode_t PwmHAL::getMode(hrtim_tu_number_t pwmX)\n{\n    return hrtim_pwm_mode_get(pwmX);\n}\n\nvoid PwmHAL::setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_eev_set(pwmX, eev);\n}\n\nhrtim_external_trigger_t PwmHAL::getEev(hrtim_tu_number_t pwmX)\n{\n    return hrtim_eev_get(pwmX);\n}\n\nvoid PwmHAL::setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation)\n{\n    if (decimation &gt; 32)\n        decimation = 32;\n    else if (decimation &lt; 1)\n        decimation = 1;\n    hrtim_adc_trigger_set_postscaler(pwmX, decimation - 1);\n}\n\nvoid PwmHAL::setFrequency(uint32_t frequency_update)\n{\n    hrtim_change_frequency(frequency_update);\n}\n\nuint32_t PwmHAL::getFrequencyMax(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_max_frequency(pwmX);\n}\n\nuint32_t PwmHAL::getFrequencyMin(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_min_frequency(pwmX);\n}\n\nuint32_t PwmHAL::getResolutionPs(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_resolution_ps(pwmX);\n}\n</code></pre>"},{"location":"powerAPI/PwmHAL_8h/","title":"File PwmHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/PwmHAL_8h/#classes","title":"Classes","text":"Type Name class PwmHAL Handles all pwm signals for the spin board."},{"location":"powerAPI/PwmHAL_8h/#public-types","title":"Public Types","text":"Type Name enum inverter_modulation_t enum leg_operation_t"},{"location":"powerAPI/PwmHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/PwmHAL_8h/#enum-inverter_modulation_t","title":"enum inverter_modulation_t","text":"<pre><code>enum inverter_modulation_t {\n    unipolar,\n    bipolar\n};\n</code></pre> <p>Inverter leg operation type. </p>"},{"location":"powerAPI/PwmHAL_8h/#enum-leg_operation_t","title":"enum leg_operation_t","text":"<pre><code>enum leg_operation_t {\n    buck,\n    boost\n};\n</code></pre> <p>Switch leg operation type. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/PwmHAL_8h_source/","title":"File PwmHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef PWMHAL_H_\n#define PWMHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// OwnTech API\n#include \"adc.h\"\n#include \"hrtim_enum.h\"\n\ntypedef enum\n{\n     buck,\n     boost\n} leg_operation_t;\n\ntypedef enum\n{\n     unipolar,\n     bipolar\n} inverter_modulation_t;\n\nclass PwmHAL\n{\npublic:\n     // HRTIM configuration\n\n     void initUnit(hrtim_tu_number_t pwmX);\n\n     void startDualOutput(hrtim_tu_number_t pwmX);\n\n     void stopDualOutput(hrtim_tu_number_t pwmX);\n\n     void startSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void stopSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation);\n\n     void setSwitchConvention(hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention);\n\n     void initFixedFrequency(uint32_t fixed_frequency);\n\n     void initVariableFrequency(uint32_t initial_frequency,\n                                uint32_t minimal_frequency);\n\n     void setDeadTime(hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns);\n\n     void setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle);\n\n     void setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift);\n\n     void setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode);\n\n     hrtim_pwm_mode_t getMode(hrtim_tu_number_t pwmX);\n\n     void setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev);\n\n     hrtim_external_trigger_t getEev(hrtim_tu_number_t pwmX);\n\n     hrtim_cnt_t getModulation(hrtim_tu_number_t pwmX);\n\n     hrtim_switch_convention_t getSwitchConvention(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriod(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriodMax(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriodMin(hrtim_tu_number_t pwmX);\n\n     void setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio);\n\n     void setAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig);\n\n     hrtim_adc_trigger_t getAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig);\n\n     void enableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void disableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val);\n\n     void setAdcEdgeTrigger(hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger);\n\n     hrtim_adc_edgetrigger_t getAdcEdgeTrigger(hrtim_tu_number_t pwmX);\n\n     void setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation);\n\n     void disablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     void setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition);\n\n     uint32_t getPeriodEvntRep(hrtim_tu_t PWM_tu);\n\n     void configurePeriodEvnt(hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback);\n\n     void enablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     uint32_t getPeriodUs(hrtim_tu_number_t pwmX);\n\n     void setFrequency(uint32_t frequency_update);\n\n     uint32_t getFrequencyMin(hrtim_tu_number_t pwmX);\n\n     uint32_t getFrequencyMax(hrtim_tu_number_t pwmX);\n\n     uint32_t getResolutionPs(hrtim_tu_number_t pwmX);\n};\n\n#endif // PWMHAL_H_\n</code></pre>"},{"location":"powerAPI/TimerHAL_8cpp/","title":"File TimerHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * timer4   = = DEVICE_DT_GET(TIMER4_DEVICE)"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/TimerHAL_8cpp/#variable-timer4","title":"variable timer4","text":"<pre><code>const struct device* timer4;\n</code></pre> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.cpp</code></p>"},{"location":"powerAPI/TimerHAL_8cpp_source/","title":"File TimerHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current file header\n#include \"TimerHAL.h\"\n\n\nstatic const struct device* timer4 = DEVICE_DT_GET(TIMER4_DEVICE);\n\nbool TimerHAL::timer4init    = false;\nbool TimerHAL::timer4started = false;\n\n\nvoid TimerHAL::timer4Initialize()\n{\n    if (device_is_ready(timer4) == true)\n    {\n        // Configure timer\n        struct timer_config_t timer_cfg =\n        {\n            .timer_enable_irq = 0,\n            .timer_enable_encoder = 1,\n            .timer_enc_pin_mode = pull_up\n\n        };\n        timer_config(timer4, &amp;timer_cfg);\n        timer4init = true;\n    }\n}\n\nvoid TimerHAL::startLogTimer4IncrementalEncoder()\n{\n    if (timer4init == false)\n    {\n        timer4Initialize();\n    }\n\n    if (timer4started == false)\n    {\n        if (device_is_ready(timer4) == true)\n        {\n            timer_start(timer4);\n            timer4started = true;\n        }\n    }\n}\n\nuint32_t TimerHAL::getTimer4IncrementalEncoderValue()\n{\n    if (timer4started == true)\n    {\n        return timer_get_count(timer4);\n    }\n    else\n    {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"powerAPI/TimerHAL_8h/","title":"File TimerHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8h/#classes","title":"Classes","text":"Type Name class TimerHAL Handles timer 4 for the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/TimerHAL_8h_source/","title":"File TimerHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TIMERHAL_H_\n#define TIMERHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// OwnTech API\n#include \"timer.h\"\n\n\n\n\nclass TimerHAL\n{\npublic:\n\n    void startLogTimer4IncrementalEncoder();\n\n    uint32_t getTimer4IncrementalEncoderValue();\n\n\n\nprivate:\n\n    void timer4Initialize();\n\n    // Variables\n    static bool timer4init;\n    static bool timer4started;\n\n\n};\n\n\n\n#endif // TIMERHAL_H_\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/","title":"File UartHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name char buf_req bool command_flag   = = false const struct device * uart_dev   = = DEVICE_DT_GET(DT_NODELABEL(usart1))"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _uart_usart1_process_input (const struct device * dev, void * user_data)"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#variable-buf_req","title":"variable buf_req","text":"<pre><code>char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-command_flag","title":"variable command_flag","text":"<pre><code>bool command_flag;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#function-_uart_usart1_process_input","title":"function _uart_usart1_process_input","text":"<pre><code>static void _uart_usart1_process_input (\n    const struct device * dev,\n    void * user_data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.cpp</code></p>"},{"location":"powerAPI/UartHAL_8cpp_source/","title":"File UartHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// STM 32 LL\n#include &lt;stm32_ll_lpuart.h&gt;\n\n// Zephyr\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n// Current file header\n#include \"UartHAL.h\"\n\n\n// USART 1 defines\n\n#define CONFIG_OWNTECH_SERIAL_TX_BUF_SIZE 5\n#define CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE 5\n#define USART1_DEVICE DT_PROP(DT_NODELABEL(usart1), label)\n\nstatic const struct device* uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart1));\nstatic char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\nstatic bool command_flag = false;\n\n\n// USART 1 private functions\n\nstatic void _uart_usart1_process_input(const struct device *dev, void* user_data)\n{\n    uint8_t c;\n\n    if (!uart_irq_update(uart_dev)) {\n        printk(\"no data \\n\");\n        return;\n    }\n\n    while (uart_irq_rx_ready(uart_dev) &amp;&amp; command_flag == false) {\n        uart_fifo_read(uart_dev, &amp;c, 1);\n        printk(\"received %c \\n\",c);\n        buf_req[0] = c;\n        command_flag = true;\n    }\n}\n\n// USART 1 public functions\n\nvoid UartHAL::usart1Init()\n{\n    const struct uart_config usart1_config =\n    {\n        .baudrate  = 9600,\n        .parity    = UART_CFG_PARITY_NONE,\n        .stop_bits = UART_CFG_STOP_BITS_1,\n        .data_bits = UART_CFG_DATA_BITS_8,\n        .flow_ctrl = UART_CFG_FLOW_CTRL_NONE\n    };\n\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_configure(uart_dev, &amp;usart1_config);\n        uart_irq_callback_user_data_set(uart_dev, _uart_usart1_process_input, NULL);\n        uart_irq_rx_enable(uart_dev);\n    }\n}\n\nchar UartHAL::usart1ReadChar()\n{\n    if (command_flag){\n        command_flag = false;\n        return buf_req[0];\n    } else {\n        return 'x';     // returns an x to signal there is no command waiting to be treated\n    }\n}\n\nvoid UartHAL::usart1WriteChar(char data)\n{\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_poll_out(uart_dev,data);\n    }\n}\n\nvoid UartHAL::usart1SwapRxTx()\n{\n    LL_LPUART_Disable(LPUART1);\n    LL_LPUART_SetTXRXSwap(LPUART1, LL_LPUART_TXRX_SWAPPED);\n    LL_LPUART_Enable(LPUART1);\n}\n</code></pre>"},{"location":"powerAPI/UartHAL_8h/","title":"File UartHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8h/#classes","title":"Classes","text":"Type Name class UartHAL Handles usart 1 for the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/UartHAL_8h_source/","title":"File UartHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef UARTHAL_H_\n#define UARTHAL_H_\n\nclass UartHAL\n{\npublic:\n    void usart1Init();\n\n    char usart1ReadChar();\n\n    void usart1WriteChar(char data);\n\n    void usart1SwapRxTx();\n\n\n};\n\n\n\n#endif // UARTHAL_H_\n</code></pre>"},{"location":"powerAPI/dir_5931dfac2e1245380efda5ad202dc380/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data</p>"},{"location":"powerAPI/dir_5931dfac2e1245380efda5ad202dc380/#files","title":"Files","text":"Type Name file data_conversion.cpp file data_conversion.h file data_dispatch.cpp file data_dispatch.h file dma.cpp file dma.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/</code></p>"},{"location":"powerAPI/data__conversion_8cpp/","title":"File data_conversion.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__conversion_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name float32_t * conversion_parameters conversion_type_t conversion_types const uint8_t max_parameters_count   = = 2"},{"location":"powerAPI/data__conversion_8cpp/#public-functions","title":"Public Functions","text":"Type Name float32_t data_conversion_convert_raw_value (uint8_t adc_num, uint8_t channel_num, uint16_t raw_value) Converts the values of the given raw_value into a physical unit. conversion_type_t data_conversion_get_conversion_type (uint8_t adc_num, uint8_t channel_num) Get the conversion type for a given channel. float32_t data_conversion_get_parameter (uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num) Get a conversion parameter for a given channel. void data_conversion_init () Initialize data conversion. int8_t data_conversion_retrieve_channel_parameters_from_nvs (uint8_t adc_num, uint8_t channel_num) Retreived previously configured conversion parameters from NVS. void data_conversion_set_conversion_parameters_linear (uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset) Set the conversion type for a given channel to linear and set parameters values. void data_conversion_set_conversion_parameters_therm (uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Set the conversion type for a given channel to therm and set parameters values. int8_t data_conversion_store_channel_parameters_in_nvs (uint8_t adc_num, uint8_t channel_num) Store the currently configured conversion parameters of a given channel in NVS."},{"location":"powerAPI/data__conversion_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name uint8_t _data_conversion_get_parameters_count (conversion_type_t type)"},{"location":"powerAPI/data__conversion_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#variable-conversion_parameters","title":"variable conversion_parameters","text":"<pre><code>float32_t* conversion_parameters[ADC_COUNT][CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/data__conversion_8cpp/#variable-conversion_types","title":"variable conversion_types","text":"<pre><code>conversion_type_t conversion_types[ADC_COUNT][CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/data__conversion_8cpp/#variable-max_parameters_count","title":"variable max_parameters_count","text":"<pre><code>const uint8_t max_parameters_count;\n</code></pre> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Antoine Boche antoine.boche@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Thomas Walter thomas.walter@laas.fr </p>"},{"location":"powerAPI/data__conversion_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_convert_raw_value","title":"function data_conversion_convert_raw_value","text":"<p>Converts the values of the given raw_value into a physical unit. <pre><code>float32_t data_conversion_convert_raw_value (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>raw_value</code> Value to convert</li> </ul> <p>Returns:</p> <p>A float32_t value representing the value in the physical unit of the given channel. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_get_conversion_type","title":"function data_conversion_get_conversion_type","text":"<p>Get the conversion type for a given channel. <pre><code>conversion_type_t data_conversion_get_conversion_type (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>Currently configured conversion type. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_get_parameter","title":"function data_conversion_get_parameter","text":"<p>Get a conversion parameter for a given channel. <pre><code>float32_t data_conversion_get_parameter (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint8_t parameter_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>parameter_num</code> Number of the paramter to retreive. E.g. for linear parameters, gain is param 1 and offset is param 2.</li> </ul> <p>Returns:</p> <p>Current value of the given parameter. </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_init","title":"function data_conversion_init","text":"<pre><code>void data_conversion_init () \n</code></pre>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_retrieve_channel_parameters_from_nvs","title":"function data_conversion_retrieve_channel_parameters_from_nvs","text":"<p>Retreived previously configured conversion parameters from NVS. <pre><code>int8_t data_conversion_retrieve_channel_parameters_from_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested channel </p>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_set_conversion_parameters_linear","title":"function data_conversion_set_conversion_parameters_linear","text":"<p>Set the conversion type for a given channel to linear and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_linear (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>gain</code> Gain of the channel </li> <li><code>offset</code> Offset of the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_set_conversion_parameters_therm","title":"function data_conversion_set_conversion_parameters_therm","text":"<p>Set the conversion type for a given channel to therm and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_therm (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>r0</code> Parameter R0 for the channel </li> <li><code>b</code> Parameter B for the channel </li> <li><code>rdiv</code> Parameter RDIV for the channel </li> <li><code>t0</code> Parameter T0 for the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8cpp/#function-data_conversion_store_channel_parameters_in_nvs","title":"function data_conversion_store_channel_parameters_in_nvs","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t data_conversion_store_channel_parameters_in_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, -1 if there was an error. </p>"},{"location":"powerAPI/data__conversion_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8cpp/#function-_data_conversion_get_parameters_count","title":"function _data_conversion_get_parameters_count","text":"<pre><code>static uint8_t _data_conversion_get_parameters_count (\n    conversion_type_t type\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_conversion.cpp</code></p>"},{"location":"powerAPI/data__conversion_8cpp_source/","title":"File data_conversion.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Include\n\n// OwnTech API\n#include \"../DataAPI.h\"\n\n// Current file header\n#include \"data_conversion.h\"\n#include \"nvs_storage.h\"\n\n\n// Local variables\n\nstatic const uint8_t max_parameters_count = 2;\n\nstatic conversion_type_t conversion_types[ADC_COUNT][CHANNELS_PER_ADC];\nstatic float32_t* conversion_parameters[ADC_COUNT][CHANNELS_PER_ADC];\n\n#define VREF 2.048f // voltage reference from ADC\n#define QUANTUM_MAX 4096.0f // ADC resolution \n#define Vin_dividor 3.3f // Input voltage in the voltage divider\n\n// Private functions\n\nstatic uint8_t _data_conversion_get_parameters_count(conversion_type_t type)\n{\n    uint8_t parameters_count = 0;\n\n    switch(type)\n    {\n        case conversion_linear:\n            // Param 0 = gain\n            // Param 1 = offset\n            parameters_count = 2;\n            break;\n        case conversion_therm:\n            // Param 0 = R0\n            // Param 1 = B\n            // Param 2 = RDIV\n            // Param 3 = T0\n            parameters_count = 4;\n        case no_channel_error:\n            break;\n    }\n\n    return parameters_count;\n}\n\n// Public Functions\n\nvoid data_conversion_init()\n{\n    // Make sure all channels have conversion parameters\n    for (int adc_index = 0 ; adc_index &lt; ADC_COUNT ; adc_index++)\n    {\n        for (int channel_index = 0 ; channel_index &lt; CHANNELS_PER_ADC ; channel_index++)\n        {\n            if (conversion_parameters[adc_index][channel_index] == nullptr)\n            {\n                uint8_t param_count = _data_conversion_get_parameters_count(conversion_types[adc_index][channel_index]);\n                conversion_parameters[adc_index][channel_index] = (float32_t*)k_malloc(param_count*sizeof(float32_t));\n                switch(conversion_types[adc_index][channel_index])\n                {\n                    case conversion_linear:\n                        // For linear conversion, set default gain to 1 and default offset to 0\n                        conversion_parameters[adc_index][channel_index][0]= 1;\n                        conversion_parameters[adc_index][channel_index][1]= 0;\n                        break;\n                    case conversion_therm:\n                        // For therm conversion, set all parameters to 1 by default\n                        conversion_parameters[adc_index][channel_index][0]= 1;\n                        conversion_parameters[adc_index][channel_index][1]= 1;\n                        conversion_parameters[adc_index][channel_index][2]= 1;\n                        conversion_parameters[adc_index][channel_index][3]= 1;\n                        break;\n                    case no_channel_error:\n                        break;\n                }\n            }\n        }\n    }\n}\n\nfloat32_t data_conversion_convert_raw_value(uint8_t adc_num, uint8_t channel_num, uint16_t raw_value)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    switch(conversion_types[adc_index][channel_index])\n    {\n        case conversion_linear:\n            return (raw_value*conversion_parameters[adc_index][channel_index][0]) + conversion_parameters[adc_index][channel_index][1];\n            break;\n        case conversion_therm:\n        {\n            /* Retrieves the parameters for the thermo resistor */\n            float32_t local_r0 = conversion_parameters[adc_index][channel_index][0]; \n            float32_t local_b = conversion_parameters[adc_index][channel_index][1];\n            float32_t local_rdiv = conversion_parameters[adc_index][channel_index][2];\n            float32_t local_t0 = conversion_parameters[adc_index][channel_index][3];\n\n            float32_t V_adc = (raw_value/QUANTUM_MAX)*VREF;                         /* converts raw values into voltage */\n            float32_t R_t = (V_adc/(Vin_dividor - V_adc))*local_rdiv;               /* uses a bridge divider equation to estimate the sensor resistance */\n            float32_t T = local_t0/( 1 + log(R_t/local_r0) * (local_t0/local_b));   /* original equation R = exp(B*(1/T - 1/T0)) */\n            return (T - 273.15f);                                                   /* returns value in degree Celsius */\n            break;\n        }           break;\n        case no_channel_error:\n            return ERROR_CHANNEL_NOT_FOUND;\n            break;\n        default:\n            return ERROR_CHANNEL_NOT_FOUND;\n            break;\n    }\n}\n\nvoid data_conversion_set_conversion_parameters_linear(uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    conversion_types[adc_index][channel_index] = conversion_linear;\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        k_free(conversion_parameters[adc_index][channel_index]);\n    }\n\n    conversion_parameters[adc_index][channel_index] = (float32_t*)k_malloc(2*sizeof(float32_t));\n\n    conversion_parameters[adc_index][channel_index][0] = gain;\n    conversion_parameters[adc_index][channel_index][1] = offset;\n}\n\nvoid data_conversion_set_conversion_parameters_therm(uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    conversion_types[adc_index][channel_index] = conversion_therm;\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        k_free(conversion_parameters[adc_index][channel_index]);\n    }\n\n    conversion_parameters[adc_index][channel_index] = (float32_t*)k_malloc(4*sizeof(float32_t));\n\n    conversion_parameters[adc_index][channel_index][0] = r0;\n    conversion_parameters[adc_index][channel_index][1] = b;\n    conversion_parameters[adc_index][channel_index][2] = rdiv;\n    conversion_parameters[adc_index][channel_index][3] = t0;\n}\n\nconversion_type_t data_conversion_get_conversion_type(uint8_t adc_num, uint8_t channel_num)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    return conversion_types[adc_index][channel_index];\n}\n\nfloat32_t data_conversion_get_parameter(uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num)\n{\n    uint8_t adc_index       = adc_num - 1;\n    uint8_t channel_index   = channel_num - 1;\n    uint8_t parameter_index = parameter_num - 1;\n\n    if (conversion_parameters[adc_index][channel_index] != nullptr)\n    {\n        uint8_t param_count = _data_conversion_get_parameters_count(conversion_types[adc_index][channel_index]);\n        if (parameter_index &lt; param_count)\n        {\n            return conversion_parameters[adc_index][channel_index][parameter_index];\n        }\n    }\n\n    // Defult case: parameter was not found\n    return 0;\n}\n\nint8_t data_conversion_store_channel_parameters_in_nvs(uint8_t adc_num, uint8_t channel_num)\n{\n    /* Handle non volatile memory used to store ADC parameters\n     * Flash partition reserved to user data storage is 4kB long\n     * We have to mount the file system then we extract one\n     * memory page that is 4kB long that contains the data\n     * and write the relevant addresses to store ADC parameters.\n     */\n\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    // The data structure is as follows:\n    // - 1 byte indicating the channel descriptor string size\n    // - The channel descriptor string (should be max. 23 bytes in current version)\n    // - 1 byte indicating ADC number\n    // - 1 byte indicating channel number\n    // - 1 byte indicating number of conversion parameters\n    // - Array of conversion parameters, each using 4 bytes.\n\n\n    uint8_t parameters_count = _data_conversion_get_parameters_count(conversion_types[adc_index][channel_index]);\n\n    uint8_t* buffer = (uint8_t*)k_malloc(1 + 23 + 1 + 1 + 1 + 4*parameters_count);\n\n    snprintk((char*)(&amp;buffer[1]), 23, \"Spin_ADC_%u_Channel_%u\", adc_num, channel_num);\n\n    uint8_t string_len = strlen((char*)(&amp;buffer[1]));\n\n    buffer[0] = string_len;\n    // Buffer [1 -&gt; string_len] contains channel name (\\0 will be overwritten)\n    buffer[string_len + 1] = adc_num;\n    buffer[string_len + 2] = channel_num;\n    buffer[string_len + 3] = conversion_types[adc_index][channel_index];\n    for (int i = 0 ; i &lt; parameters_count ; i++)\n    {\n        *((float32_t*)&amp;buffer[string_len + 4 + 4*i]) = conversion_parameters[adc_index][channel_index][i];\n    }\n\n    uint16_t channel_ID = ADC_CALIBRATION | (adc_num&amp;0x0F) &lt;&lt; 4 | (channel_num&amp;0x0F);\n\n    int ns = nvs_storage_store_data(channel_ID, buffer, 1 + string_len + 1 + 1 + 1 + 4*parameters_count);\n\n    k_free(buffer);\n\n    if (ns &lt; 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint8_t data_conversion_retrieve_channel_parameters_from_nvs(uint8_t adc_num, uint8_t channel_num)\n{\n    uint8_t adc_index     = adc_num - 1;\n    uint8_t channel_index = channel_num - 1;\n\n    // Check that parameters currently stored in NVS are from the same version\n    uint16_t current_stored_version = nvs_storage_get_version_in_nvs();\n    if (current_stored_version == 0)\n    {\n        return -1;\n    }\n    else if (current_stored_version != nvs_storage_get_current_version())\n    {\n        return -2;\n    }\n\n    uint16_t channel_ID = ADC_CALIBRATION | (adc_num&amp;0x0F) &lt;&lt; 4 | (channel_num&amp;0x0F);\n\n    int buffer_size = 1 + 23 + 1 + 1 + 1 + 4*max_parameters_count;\n    uint8_t* buffer = (uint8_t*)k_malloc(buffer_size);\n\n    int read_size = nvs_storage_retrieve_data(channel_ID, buffer, buffer_size);\n\n    int ret = 0;\n    if (read_size &gt; 0)\n    {\n        uint8_t string_len = buffer[0];\n\n        // Check that all required values match\n        if (adc_num != buffer[string_len + 1])\n        {\n            ret = -3;\n        }\n        else if (channel_num != buffer[string_len + 2])\n        {\n            ret = -3;\n        }\n        else\n        {\n            conversion_type_t conversion_type = (conversion_type_t)buffer[string_len + 3];\n            uint8_t parameters_count = _data_conversion_get_parameters_count(conversion_type);\n            conversion_types[adc_index][channel_index] = conversion_type;\n\n            if (conversion_parameters[adc_index][channel_index] != nullptr)\n            {\n                k_free(conversion_parameters[adc_index][channel_index]);\n            }\n            conversion_parameters[adc_index][channel_index] = (float32_t*)k_malloc(parameters_count*sizeof(float32_t));\n\n            for (int i = 0 ; i &lt; parameters_count ; i++)\n            {\n                conversion_parameters[adc_index][channel_index][i] = *((float32_t*)&amp;buffer[string_len + 4 + 4*i]);\n            }\n        }\n    }\n    else\n    {\n        ret = -4;\n    }\n\n    k_free(buffer);\n    return ret;\n}\n</code></pre>"},{"location":"powerAPI/data__conversion_8h/","title":"File data_conversion.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__conversion_8h/#public-types","title":"Public Types","text":"Type Name enum int8_t conversion_type_t"},{"location":"powerAPI/data__conversion_8h/#public-functions","title":"Public Functions","text":"Type Name float32_t data_conversion_convert_raw_value (uint8_t adc_num, uint8_t channel_num, uint16_t raw_value) Converts the values of the given raw_value into a physical unit. conversion_type_t data_conversion_get_conversion_type (uint8_t adc_num, uint8_t channel_num) Get the conversion type for a given channel. float32_t data_conversion_get_parameter (uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num) Get a conversion parameter for a given channel. void data_conversion_init () Initialize data conversion. int8_t data_conversion_retrieve_channel_parameters_from_nvs (uint8_t adc_num, uint8_t channel_num) Retreived previously configured conversion parameters from NVS. void data_conversion_set_conversion_parameters_linear (uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset) Set the conversion type for a given channel to linear and set parameters values. void data_conversion_set_conversion_parameters_therm (uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0) Set the conversion type for a given channel to therm and set parameters values. int8_t data_conversion_store_channel_parameters_in_nvs (uint8_t adc_num, uint8_t channel_num) Store the currently configured conversion parameters of a given channel in NVS."},{"location":"powerAPI/data__conversion_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/data__conversion_8h/#enum-conversion_type_t","title":"enum conversion_type_t","text":"<pre><code>enum conversion_type_t {\n    conversion_linear = 0,\n    conversion_therm = 1,\n    no_channel_error = -5\n};\n</code></pre>"},{"location":"powerAPI/data__conversion_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_convert_raw_value","title":"function data_conversion_convert_raw_value","text":"<p>Converts the values of the given raw_value into a physical unit. <pre><code>float32_t data_conversion_convert_raw_value (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>raw_value</code> Value to convert</li> </ul> <p>Returns:</p> <p>A float32_t value representing the value in the physical unit of the given channel. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_get_conversion_type","title":"function data_conversion_get_conversion_type","text":"<p>Get the conversion type for a given channel. <pre><code>conversion_type_t data_conversion_get_conversion_type (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>Currently configured conversion type. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_get_parameter","title":"function data_conversion_get_parameter","text":"<p>Get a conversion parameter for a given channel. <pre><code>float32_t data_conversion_get_parameter (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    uint8_t parameter_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>parameter_num</code> Number of the paramter to retreive. E.g. for linear parameters, gain is param 1 and offset is param 2.</li> </ul> <p>Returns:</p> <p>Current value of the given parameter. </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_init","title":"function data_conversion_init","text":"<pre><code>void data_conversion_init () \n</code></pre>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_retrieve_channel_parameters_from_nvs","title":"function data_conversion_retrieve_channel_parameters_from_nvs","text":"<p>Retreived previously configured conversion parameters from NVS. <pre><code>int8_t data_conversion_retrieve_channel_parameters_from_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested channel </p>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_set_conversion_parameters_linear","title":"function data_conversion_set_conversion_parameters_linear","text":"<p>Set the conversion type for a given channel to linear and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_linear (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>gain</code> Gain of the channel </li> <li><code>offset</code> Offset of the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_set_conversion_parameters_therm","title":"function data_conversion_set_conversion_parameters_therm","text":"<p>Set the conversion type for a given channel to therm and set parameters values. <pre><code>void data_conversion_set_conversion_parameters_therm (\n    uint8_t adc_num,\n    uint8_t channel_num,\n    float32_t r0,\n    float32_t b,\n    float32_t rdiv,\n    float32_t t0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number </li> <li><code>r0</code> Parameter R0 for the channel </li> <li><code>b</code> Parameter B for the channel </li> <li><code>rdiv</code> Parameter RDIV for the channel </li> <li><code>t0</code> Parameter T0 for the channel </li> </ul>"},{"location":"powerAPI/data__conversion_8h/#function-data_conversion_store_channel_parameters_in_nvs","title":"function data_conversion_store_channel_parameters_in_nvs","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t data_conversion_store_channel_parameters_in_nvs (\n    uint8_t adc_num,\n    uint8_t channel_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>channel_num</code> Channel number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, -1 if there was an error. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_conversion.h</code></p>"},{"location":"powerAPI/data__conversion_8h_source/","title":"File data_conversion.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_conversion.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DATA_CONVERSION_H_\n#define DATA_CONVERSION_H_\n\n#include &lt;arm_math.h&gt;   // adds all the CMSIS library\n\n\n// Type definitions\n\ntypedef enum : int8_t\n{\n    conversion_linear = 0,\n    conversion_therm  = 1,\n    no_channel_error  = -5\n\n} conversion_type_t;\n\n\n// API\n\nvoid data_conversion_init();\n\nfloat32_t data_conversion_convert_raw_value(uint8_t adc_num, uint8_t channel_num, uint16_t raw_value);\n\nvoid data_conversion_set_conversion_parameters_linear(uint8_t adc_num, uint8_t channel_num, float32_t gain, float32_t offset);\n\nvoid data_conversion_set_conversion_parameters_therm(uint8_t adc_num, uint8_t channel_num, float32_t r0, float32_t b, float32_t rdiv, float32_t t0);\n\nconversion_type_t data_conversion_get_conversion_type(uint8_t adc_num, uint8_t channel_num);\n\nfloat32_t data_conversion_get_parameter(uint8_t adc_num, uint8_t channel_num, uint8_t parameter_num);\n\nint8_t data_conversion_store_channel_parameters_in_nvs(uint8_t adc_num, uint8_t channel_num);\n\nint8_t data_conversion_retrieve_channel_parameters_from_nvs(uint8_t adc_num, uint8_t channel_num);\n\n\n#endif // DATA_CONVERSION_H_\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/","title":"File data_dispatch.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__dispatch_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint16_t **** adc_channel_buffers   = = nullptr uint32_t ** buffers_data_count   = = nullptr uint8_t ** current_buffer   = = nullptr uint8_t current_dma_buffer   = = {0} dispatch_t dispatch_type size_t dma_buffer_sizes   = = {0} uint16_t * dma_main_buffers   = = {0} uint16_t * dma_secondary_buffers   = = {0} uint8_t * enabled_channels_count   = = nullptr uint16_t ** peek_memory   = = nullptr"},{"location":"powerAPI/data__dispatch_8cpp/#public-functions","title":"Public Functions","text":"Type Name __STATIC_INLINE uint16_t * _data_dispatch_get_buffer (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE uint32_t _data_dispatch_get_count (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE void _data_dispatch_increment_count (uint8_t adc_index, uint8_t channel_index)  __STATIC_INLINE void _data_dispatch_swap_buffers (uint8_t adc_index, uint8_t channel_index)  void data_dispatch_do_dispatch (uint8_t adc_number) Dispatch function: gets the readings and store them in per-channel arrays. This functon is called by DMA callback when the DMA has filled one of its buffers. void data_dispatch_do_full_dispatch () Function to proceed to all chanels dispatch when it is done at uninterruptible task start. uint16_t * data_dispatch_get_acquired_values (uint8_t adc_number, uint8_t channel_rank, uint32_t &amp; number_of_values_acquired) Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. void data_dispatch_init (dispatch_t dispatch_method, uint32_t repetitions) Init function to be called first. uint16_t data_dispatch_peek_acquired_value (uint8_t adc_number, uint8_t channel_rank) Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer."},{"location":"powerAPI/data__dispatch_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__dispatch_8cpp/#variable-adc_channel_buffers","title":"variable adc_channel_buffers","text":"<pre><code>uint16_t**** adc_channel_buffers;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-buffers_data_count","title":"variable buffers_data_count","text":"<pre><code>uint32_t** buffers_data_count;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-current_buffer","title":"variable current_buffer","text":"<pre><code>uint8_t** current_buffer;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-current_dma_buffer","title":"variable current_dma_buffer","text":"<pre><code>uint8_t current_dma_buffer[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dispatch_type","title":"variable dispatch_type","text":"<pre><code>dispatch_t dispatch_type;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_buffer_sizes","title":"variable dma_buffer_sizes","text":"<pre><code>size_t dma_buffer_sizes[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_main_buffers","title":"variable dma_main_buffers","text":"<pre><code>uint16_t* dma_main_buffers[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-dma_secondary_buffers","title":"variable dma_secondary_buffers","text":"<pre><code>uint16_t* dma_secondary_buffers[ADC_COUNT];\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-enabled_channels_count","title":"variable enabled_channels_count","text":"<pre><code>uint8_t* enabled_channels_count;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/data__dispatch_8cpp/#variable-peek_memory","title":"variable peek_memory","text":"<pre><code>uint16_t** peek_memory;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_get_buffer","title":"function _data_dispatch_get_buffer","text":"<pre><code>__STATIC_INLINE uint16_t * _data_dispatch_get_buffer (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_get_count","title":"function _data_dispatch_get_count","text":"<pre><code>__STATIC_INLINE uint32_t _data_dispatch_get_count (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_increment_count","title":"function _data_dispatch_increment_count","text":"<pre><code>__STATIC_INLINE void _data_dispatch_increment_count (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-_data_dispatch_swap_buffers","title":"function _data_dispatch_swap_buffers","text":"<pre><code>__STATIC_INLINE void _data_dispatch_swap_buffers (\n    uint8_t adc_index,\n    uint8_t channel_index\n) \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_do_dispatch","title":"function data_dispatch_do_dispatch","text":"<p>Dispatch function: gets the readings and store them in per-channel arrays. This functon is called by DMA callback when the DMA has filled one of its buffers. <pre><code>void data_dispatch_do_dispatch (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which data comes. </li> </ul>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_do_full_dispatch","title":"function data_dispatch_do_full_dispatch","text":"<pre><code>void data_dispatch_do_full_dispatch () \n</code></pre>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_get_acquired_values","title":"function data_dispatch_get_acquired_values","text":"<p>Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. <pre><code>uint16_t * data_dispatch_get_acquired_values (\n    uint8_t adc_number,\n    uint8_t channel_rank,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> <li><code>number_of_values_acquired</code> Output parameter: address to a variable that will be updated by the function with the data count. </li> </ul> <p>Returns:</p> <p>Buffer containing the available data. Note that the returned buffer is invalidated by further calls to the function with same adc number/channel rank. </p>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_init","title":"function data_dispatch_init","text":"<p>Init function to be called first. <pre><code>void data_dispatch_init (\n    dispatch_t dispatch_method,\n    uint32_t repetitions\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dispatch_method</code> Indicates when the dispatch should be done. </li> <li><code>repetitions</code> If dispatch is done at task start, this value represents the number of acquisitions that are done between two execution of the task. Ignored if dispatch is done on interrupt. </li> </ul>"},{"location":"powerAPI/data__dispatch_8cpp/#function-data_dispatch_peek_acquired_value","title":"function data_dispatch_peek_acquired_value","text":"<p>Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer. <pre><code>uint16_t data_dispatch_peek_acquired_value (\n    uint8_t adc_number,\n    uint8_t channel_rank\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> </ul> <p>Returns:</p> <p>Latest available value from the buffer. Note that if no value has been acquired, returned value will be 0. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_dispatch.cpp</code></p>"},{"location":"powerAPI/data__dispatch_8cpp_source/","title":"File data_dispatch.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\n//Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n// OwnTech API\n#include \"SpinAPI.h\"\n\n// Current module header\n#include \"dma.h\"\n\n// Current file header\n#include \"data_dispatch.h\"\n\n\n// Local variables\n\n// Number of channels in each ADC (cell i is ADC number i+1)\nstatic uint8_t* enabled_channels_count = nullptr;\n\n// Array of per-adc/per-channel buffers.\n// adc_channel_buffers[x][y][z][] is ADC x+1 channel y buffer z\n// with z either 0 or 1 as there are two buffers per channel (double buffering)\nstatic uint16_t**** adc_channel_buffers = nullptr;\n\n// Number of readings stored in each channel.\n// buffers_data_count[x][y] is the current nuumber of\n// values stored in the currently written buffer of ADC x+1 Channel y\nstatic uint32_t** buffers_data_count = nullptr;\n\n// Currently written buffer for each channel.\n// Either 0 or 1.\n// If current_buffer[x][y] is 0, the currently written buffer\n// for ADC x+1 Channel y is buffer 0 and the user buffer is buffer 1\nstatic uint8_t** current_buffer = nullptr;\n\n// Small memory to retain latest value available to\n// the peek() function after a buffer swap.\nstatic uint16_t** peek_memory = nullptr;\n\n// DMA buffers: data from the ADC 1/2 are stored in these\n// buffers until dispatch is done (ADC 3/4 won't use DMA).\n// Main buffers are always used, while secondary buffers\n// will only be used when double-buffering is activated.\n// Double buffering is activated in Interrupt mode,\n// while Task mode doesn't need it.\nstatic uint16_t* dma_main_buffers[ADC_COUNT]      = {0};\nstatic uint16_t* dma_secondary_buffers[ADC_COUNT] = {0};\nstatic uint8_t   current_dma_buffer[ADC_COUNT]    = {0};\nstatic size_t    dma_buffer_sizes[ADC_COUNT]      = {0};\n\n// Dispatch method\nstatic dispatch_t dispatch_type;\n\n\n// Private functions\n\n__STATIC_INLINE uint16_t* _data_dispatch_get_buffer(uint8_t adc_index, uint8_t channel_index)\n{\n    uint8_t active_buffer = current_buffer[adc_index][channel_index];\n    return adc_channel_buffers[adc_index][channel_index][active_buffer];\n}\n\n__STATIC_INLINE uint32_t _data_dispatch_get_count(uint8_t adc_index, uint8_t channel_index)\n{\n    return buffers_data_count[adc_index][channel_index];\n}\n\n__STATIC_INLINE void _data_dispatch_increment_count(uint8_t adc_index, uint8_t channel_index)\n{\n    uint32_t* current_count = &amp;buffers_data_count[adc_index][channel_index];\n    if ( (*current_count) &lt; CHANNELS_BUFFERS_SIZE)\n    {\n        (*current_count)++;\n    }\n}\n\n__STATIC_INLINE void _data_dispatch_swap_buffers(uint8_t adc_index, uint8_t channel_index)\n{\n    uint8_t* active_buffer = &amp;current_buffer[adc_index][channel_index];\n\n    *active_buffer = ((*active_buffer) == 0) ? 1 : 0;\n    buffers_data_count[adc_index][channel_index] = 0;\n}\n\n// Public API\n\nvoid data_dispatch_init(dispatch_t dispatch_method, uint32_t repetitions)\n{\n    // Store dispatch method\n    dispatch_type = dispatch_method;\n\n    // Prepare arrays for each ADC\n    enabled_channels_count = (uint8_t*)    k_malloc(ADC_COUNT * sizeof(uint8_t));\n    adc_channel_buffers    = (uint16_t****)k_calloc(ADC_COUNT,  sizeof(uint16_t***));\n    buffers_data_count     = (uint32_t**)  k_calloc(ADC_COUNT,  sizeof(uint32_t*));\n    current_buffer         = (uint8_t**)   k_calloc(ADC_COUNT,  sizeof(uint8_t*));\n    peek_memory            = (uint16_t**)  k_calloc(ADC_COUNT,  sizeof(uint16_t*));\n\n    // Configure DMA 1 channels\n    for (uint8_t adc_num = 1 ; adc_num &lt;= ADC_COUNT ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        enabled_channels_count[adc_index] = adc_get_enabled_channels_count(adc_num);\n\n        // Ignore this ADC if it has no enabled channel\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            // Prepare buffers for DMA\n            size_t dma_buffer_size;\n\n            if (dispatch_type == interrupt)\n            {\n                dma_buffer_size = enabled_channels_count[adc_index];\n\n                // DMA double-buffering\n                dma_buffer_size = dma_buffer_size * 2;\n            }\n            else\n            {\n                dma_buffer_size = repetitions;\n\n                // Make sure buffer size is a multiple of enabled channels count\n                // so that each channel data will always be at the same position\n                if (repetitions % enabled_channels_count[adc_index] != 0)\n                {\n                    dma_buffer_size += enabled_channels_count[adc_index] - (repetitions % enabled_channels_count[adc_index]);\n                }\n                else\n                {\n                    // Add room for one additional measure per channel.\n                    // This prevents DMA buffer to do exactly one rotation\n                    // between two tasks calls, to prevent edge cases in\n                    // acquired data count computation.\n                    dma_buffer_size += enabled_channels_count[adc_index];\n                }\n            }\n\n            dma_buffer_sizes[adc_index] = dma_buffer_size;\n            dma_main_buffers[adc_index] = (uint16_t*)k_malloc(dma_buffer_size * sizeof(uint16_t));\n            if (dispatch_type == interrupt)\n            {\n                dma_secondary_buffers[adc_index] = dma_main_buffers[adc_index] + enabled_channels_count[adc_index];\n            }\n\n            // Initialize DMA\n            bool disable_interrupts = false;\n            if (dispatch_type == task)\n            {\n                disable_interrupts = true;\n            }\n            dma_configure_adc_acquisition(adc_num, disable_interrupts, dma_main_buffers[adc_index], dma_buffer_size);\n\n            // Prepare arrays for each channel\n            adc_channel_buffers[adc_index] = (uint16_t***)k_malloc(enabled_channels_count[adc_index] * sizeof(uint16_t**));\n\n            buffers_data_count[adc_index] = (uint32_t*)k_calloc(enabled_channels_count[adc_index], sizeof(uint32_t));\n            current_buffer[adc_index]     = (uint8_t*) k_calloc(enabled_channels_count[adc_index], sizeof(uint8_t));\n            peek_memory[adc_index]        = (uint16_t*)k_calloc(enabled_channels_count[adc_index], sizeof(uint16_t));\n            for (int channel_index = 0 ; channel_index &lt; enabled_channels_count[adc_index] ; channel_index++)\n            {\n                // Prepare double buffer\n                adc_channel_buffers[adc_index][channel_index] = (uint16_t**)k_malloc(sizeof(uint16_t*) * 2);\n                adc_channel_buffers[adc_index][channel_index][0] = (uint16_t*)k_malloc(sizeof(uint16_t) * CHANNELS_BUFFERS_SIZE);\n                adc_channel_buffers[adc_index][channel_index][1] = (uint16_t*)k_malloc(sizeof(uint16_t) * CHANNELS_BUFFERS_SIZE);\n\n                peek_memory[adc_index][channel_index] = PEEK_NO_VALUE;\n            }\n        }\n    }\n}\n\nvoid data_dispatch_do_dispatch(uint8_t adc_num)\n{\n    uint8_t adc_index = adc_num - 1;\n\n    if (enabled_channels_count[adc_index] == 0)\n        return;\n\n    uint16_t* dma_buffer = dma_main_buffers[adc_index];\n    if (dma_secondary_buffers[adc_index] != nullptr)\n    {\n        if (current_dma_buffer[adc_index] == 0)\n        {\n            current_dma_buffer[adc_index] = 1;\n        }\n        else\n        {\n            dma_buffer = dma_secondary_buffers[adc_index];\n            current_dma_buffer[adc_index] = 0;\n        }\n    }\n\n    size_t data_count_in_dma_buffer;\n    if (dispatch_type == interrupt)\n    {\n        data_count_in_dma_buffer = enabled_channels_count[adc_index];\n    }\n    else\n    {\n        data_count_in_dma_buffer = dma_get_retreived_data_count(adc_num);\n    }\n\n    for (size_t dma_index = 0 ; dma_index &lt; data_count_in_dma_buffer ; dma_index++)\n    {\n        // Copy data\n        size_t dma_buffer_index;\n        if (dispatch_type == interrupt)\n        {\n            dma_buffer_index = dma_index % enabled_channels_count[adc_index];\n        }\n        else\n        {\n            static size_t next_dma_buffer_index[ADC_COUNT] = {0};\n\n            dma_buffer_index = next_dma_buffer_index[adc_index];\n            if (next_dma_buffer_index[adc_index] &lt; dma_buffer_sizes[adc_index]-1)\n            {\n                next_dma_buffer_index[adc_index]++;\n            }\n            else\n            {\n                next_dma_buffer_index[adc_index] = 0;\n            }\n        }\n\n        // Get info on buffer\n        size_t channel_index = dma_buffer_index % enabled_channels_count[adc_index];\n        uint16_t* active_buffer = _data_dispatch_get_buffer(adc_index, channel_index);\n        uint32_t  current_count = _data_dispatch_get_count(adc_index, channel_index);\n\n        active_buffer[current_count] = dma_buffer[dma_buffer_index];\n\n        // Increment count\n        _data_dispatch_increment_count(adc_index, channel_index);\n    }\n}\n\nvoid data_dispatch_do_full_dispatch()\n{\n    for (uint8_t adc_num = 1 ; adc_num &lt;= ADC_COUNT ; adc_num++)\n    {\n        data_dispatch_do_dispatch(adc_num);\n    }\n}\n\n\n// Accessors\n\nuint16_t* data_dispatch_get_acquired_values(uint8_t adc_number, uint8_t channel_rank, uint32_t&amp; number_of_values_acquired)\n{\n    // Prepare default value\n    number_of_values_acquired = 0;\n\n    // Check index\n    uint8_t adc_index = adc_number-1;\n    if (adc_index &gt;= ADC_COUNT)\n        return nullptr;\n\n    // Get and check data count\n    uint8_t channel_index = channel_rank-1;\n    uint32_t current_count = _data_dispatch_get_count(adc_index, channel_index);\n    if (current_count == 0)\n        return nullptr;\n\n    // Get and swap buffer\n    uint16_t* active_buffer = _data_dispatch_get_buffer(adc_index, channel_index);\n    _data_dispatch_swap_buffers(adc_index, channel_index);\n\n    // Retain latest value for peek() functions\n    if (current_count &gt; 0)\n    {\n        peek_memory[adc_index][channel_index] = active_buffer[current_count-1];\n    }\n\n    // Return data\n    number_of_values_acquired = current_count;\n    return active_buffer;\n}\n\nuint16_t data_dispatch_peek_acquired_value(uint8_t adc_number, uint8_t channel_rank)\n{\n    uint8_t adc_index = adc_number-1;\n    uint8_t channel_index = channel_rank-1;\n    if (adc_index &lt; ADC_COUNT)\n    {\n        // Get info on buffer\n        uint16_t* active_buffer = _data_dispatch_get_buffer(adc_index, channel_index);\n        uint32_t  current_count = _data_dispatch_get_count(adc_index, channel_index);\n\n        // Return data\n        if (current_count &gt; 0)\n        {\n            return active_buffer[current_count-1];\n        }\n        else\n        {\n            return peek_memory[adc_index][channel_index];\n        }\n    }\n    else\n    {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/","title":"File data_dispatch.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__dispatch_8h/#public-types","title":"Public Types","text":"Type Name enum dispatch_t"},{"location":"powerAPI/data__dispatch_8h/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t CHANNELS_BUFFERS_SIZE   = = 32 const uint16_t PEEK_NO_VALUE   = = 0xFFFF"},{"location":"powerAPI/data__dispatch_8h/#public-functions","title":"Public Functions","text":"Type Name void data_dispatch_do_dispatch (uint8_t adc_number) Dispatch function: gets the readings and store them in per-channel arrays. This functon is called by DMA callback when the DMA has filled one of its buffers. void data_dispatch_do_full_dispatch () Function to proceed to all chanels dispatch when it is done at uninterruptible task start. uint16_t * data_dispatch_get_acquired_values (uint8_t adc_number, uint8_t channel_rank, uint32_t &amp; number_of_values_acquired) Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. void data_dispatch_init (dispatch_t dispatch_method, uint32_t repetitions) Init function to be called first. uint16_t data_dispatch_peek_acquired_value (uint8_t adc_number, uint8_t channel_rank) Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer."},{"location":"powerAPI/data__dispatch_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#enum-dispatch_t","title":"enum dispatch_t","text":"<pre><code>enum dispatch_t {\n    task,\n    interrupt\n};\n</code></pre> <p>Dispatch method </p>"},{"location":"powerAPI/data__dispatch_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#variable-channels_buffers_size","title":"variable CHANNELS_BUFFERS_SIZE","text":"<pre><code>const uint8_t CHANNELS_BUFFERS_SIZE;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/#variable-peek_no_value","title":"variable PEEK_NO_VALUE","text":"<pre><code>const uint16_t PEEK_NO_VALUE;\n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_do_dispatch","title":"function data_dispatch_do_dispatch","text":"<p>Dispatch function: gets the readings and store them in per-channel arrays. This functon is called by DMA callback when the DMA has filled one of its buffers. <pre><code>void data_dispatch_do_dispatch (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which data comes. </li> </ul>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_do_full_dispatch","title":"function data_dispatch_do_full_dispatch","text":"<pre><code>void data_dispatch_do_full_dispatch () \n</code></pre>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_get_acquired_values","title":"function data_dispatch_get_acquired_values","text":"<p>Obtain data for a specific channel. The data is provided as an array of values and the count of data in this buffer is returned as an output parameter. <pre><code>uint16_t * data_dispatch_get_acquired_values (\n    uint8_t adc_number,\n    uint8_t channel_rank,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> <li><code>number_of_values_acquired</code> Output parameter: address to a variable that will be updated by the function with the data count. </li> </ul> <p>Returns:</p> <p>Buffer containing the available data. Note that the returned buffer is invalidated by further calls to the function with same adc number/channel rank. </p>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_init","title":"function data_dispatch_init","text":"<p>Init function to be called first. <pre><code>void data_dispatch_init (\n    dispatch_t dispatch_method,\n    uint32_t repetitions\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dispatch_method</code> Indicates when the dispatch should be done. </li> <li><code>repetitions</code> If dispatch is done at task start, this value represents the number of acquisitions that are done between two execution of the task. Ignored if dispatch is done on interrupt. </li> </ul>"},{"location":"powerAPI/data__dispatch_8h/#function-data_dispatch_peek_acquired_value","title":"function data_dispatch_peek_acquired_value","text":"<p>Peek data for a specific channel: obtain the latest value from the channel without removing it from the buffer. <pre><code>uint16_t data_dispatch_peek_acquired_value (\n    uint8_t adc_number,\n    uint8_t channel_rank\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC from which to obtain data. </li> <li><code>channel_rank</code> Rank of the channel from which to obtain data. </li> </ul> <p>Returns:</p> <p>Latest available value from the buffer. Note that if no value has been acquired, returned value will be 0. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/data_dispatch.h</code></p>"},{"location":"powerAPI/data__dispatch_8h_source/","title":"File data_dispatch.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; data_dispatch.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DATA_DISPATCH_H_\n#define DATA_DISPATCH_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n\n// Constants\n\nconst uint16_t PEEK_NO_VALUE = 0xFFFF;\nconst uint8_t CHANNELS_BUFFERS_SIZE = 32;\n\ntypedef enum {task, interrupt} dispatch_t;\n\nvoid data_dispatch_init(dispatch_t dispatch_method, uint32_t repetitions);\n\nvoid data_dispatch_do_dispatch(uint8_t adc_number);\n\nvoid data_dispatch_do_full_dispatch();\n\nuint16_t* data_dispatch_get_acquired_values(uint8_t adc_number, uint8_t channel_rank, uint32_t&amp; number_of_values_acquired);\n\nuint16_t data_dispatch_peek_acquired_value(uint8_t adc_number, uint8_t channel_rank);\n\n\n#endif // DATA_DISPATCH_H_\n</code></pre>"},{"location":"powerAPI/dma_8cpp/","title":"File dma.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dma_8cpp/#classes","title":"Classes","text":"Type Name struct dma_user_data_t"},{"location":"powerAPI/dma_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name size_t buffers_sizes   = = {0} const struct device * dma1   = = DEVICE_DT_GET(DT_NODELABEL(dma1)) const uint32_t source_registers   = = { (uint32_t)(&amp;(ADC1-&gt;DR)), (uint32_t)(&amp;(ADC2-&gt;DR)), (uint32_t)(&amp;(ADC3-&gt;DR)), (uint32_t)(&amp;(ADC4-&gt;DR)), (uint32_t)(&amp;(ADC5-&gt;DR)) } const uint32_t source_triggers   = = { LL_DMAMUX_REQ_ADC1, LL_DMAMUX_REQ_ADC2, LL_DMAMUX_REQ_ADC3, LL_DMAMUX_REQ_ADC4, LL_DMAMUX_REQ_ADC5 } dma_user_data_t user_data   = = {0}"},{"location":"powerAPI/dma_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dma_configure_adc_acquisition (uint8_t adc_number, bool disable_interrupts, uint16_t * buffer, size_t buffer_size) This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. uint32_t dma_get_retreived_data_count (uint8_t adc_number) Obtain the number of acquired data since last time this function was called."},{"location":"powerAPI/dma_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _dma_callback (const struct device * dev, void * user_data, uint32_t dma_channel, int status)"},{"location":"powerAPI/dma_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/dma_8cpp/#variable-buffers_sizes","title":"variable buffers_sizes","text":"<pre><code>size_t buffers_sizes[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#variable-dma1","title":"variable dma1","text":"<pre><code>const struct device* dma1;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/dma_8cpp/#variable-source_registers","title":"variable source_registers","text":"<pre><code>const uint32_t source_registers[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#variable-source_triggers","title":"variable source_triggers","text":"<pre><code>const uint32_t source_triggers[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#variable-user_data","title":"variable user_data","text":"<pre><code>dma_user_data_t user_data[5];\n</code></pre>"},{"location":"powerAPI/dma_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/dma_8cpp/#function-dma_configure_adc_acquisition","title":"function dma_configure_adc_acquisition","text":"<p>This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. <pre><code>void dma_configure_adc_acquisition (\n    uint8_t adc_number,\n    bool disable_interrupts,\n    uint16_t * buffer,\n    size_t buffer_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to acquire measures from. </li> <li><code>disable_interrupts</code> Boolean indicating whether interrupts shoud be disabled. Warning: this override Zephyr DMA driver default behavior. </li> <li><code>buffer</code> Pointer to buffer. </li> <li><code>buffer_size</code> Number of uint16_t words the buffer can contain. </li> </ul>"},{"location":"powerAPI/dma_8cpp/#function-dma_get_retreived_data_count","title":"function dma_get_retreived_data_count","text":"<p>Obtain the number of acquired data since last time this function was called. <pre><code>uint32_t dma_get_retreived_data_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC.</li> </ul> <p>Returns:</p> <p>Number of acquired data modulo buffer size. </p>"},{"location":"powerAPI/dma_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/dma_8cpp/#function-_dma_callback","title":"function _dma_callback","text":"<pre><code>static void _dma_callback (\n    const struct device * dev,\n    void * user_data,\n    uint32_t dma_channel,\n    int status\n) \n</code></pre> <p>DMA callback This callback is called on DMA interrupt. For ADCs with enabled interrupt, is will be called twice: when buffer is half-filled and when buffer is filled. For other ADCs, it will never be called. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.cpp</code></p>"},{"location":"powerAPI/dma_8cpp_source/","title":"File dma.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/dma.h&gt;\n\n// STM32 LL\n#include &lt;stm32_ll_dma.h&gt;\n\n// Current module private functions\n#include \"data_dispatch.h\"\n\n\n// DT definition\n\nstatic const struct device* dma1 = DEVICE_DT_GET(DT_NODELABEL(dma1));\n\n\n// Local variables\n\nstatic const uint32_t source_registers[5] =\n{\n    (uint32_t)(&amp;(ADC1-&gt;DR)),\n    (uint32_t)(&amp;(ADC2-&gt;DR)),\n    (uint32_t)(&amp;(ADC3-&gt;DR)),\n    (uint32_t)(&amp;(ADC4-&gt;DR)),\n    (uint32_t)(&amp;(ADC5-&gt;DR))\n};\n\nstatic const uint32_t source_triggers[5] =\n{\n    LL_DMAMUX_REQ_ADC1,\n    LL_DMAMUX_REQ_ADC2,\n    LL_DMAMUX_REQ_ADC3,\n    LL_DMAMUX_REQ_ADC4,\n    LL_DMAMUX_REQ_ADC5\n};\n\nstatic size_t buffers_sizes[5] = {0};\n\ntypedef struct\n{\n    bool     has_interrupt;\n    uint32_t src;\n    uint32_t dst;\n    size_t   size;\n    uint32_t channel;\n} dma_user_data_t;\n\nstatic dma_user_data_t user_data[5] = {0};\n\n// Private API\n\nstatic void _dma_callback(const struct device* dev, void* user_data, uint32_t dma_channel, int status)\n{\n    UNUSED(dev);\n    UNUSED(dma_channel);\n\n    // Get user data for current channel\n    dma_user_data_t* my_user_data = (dma_user_data_t*) user_data;\n\n    // Do dispatch\n    data_dispatch_do_dispatch(my_user_data-&gt;channel);\n\n    // Reload DMA on last transaction\n    if ( (my_user_data-&gt;has_interrupt == true) &amp;&amp; (status == DMA_STATUS_COMPLETE) )\n    {\n        dma_reload(dma1, my_user_data-&gt;channel, my_user_data-&gt;src, my_user_data-&gt;dst, my_user_data-&gt;size);\n    }\n}\n\n\n// Public API\n\nvoid dma_configure_adc_acquisition(uint8_t adc_number, bool disable_interrupts, uint16_t* buffer, size_t buffer_size)\n{\n    // Check environment\n    if (device_is_ready(dma1) == false)\n        return;\n\n    uint8_t dma_index = adc_number - 1;\n    uint32_t buffer_size_bytes = (uint32_t) buffer_size * sizeof(uint16_t);\n    buffers_sizes[dma_index] = buffer_size;\n\n    // Private data for DMA channel\n    user_data[dma_index].has_interrupt = !disable_interrupts;\n    user_data[dma_index].src           = source_registers[dma_index];\n    user_data[dma_index].dst           = (uint32_t)buffer;\n    user_data[dma_index].size          = buffer_size_bytes;\n    user_data[dma_index].channel       = adc_number;\n\n    // Configure DMA\n    struct dma_block_config dma_block_config_s = {0};\n    dma_block_config_s.source_address   = user_data[dma_index].src;  // Source: ADC DR register\n    dma_block_config_s.dest_address     = user_data[dma_index].dst;  // Dest: buffer in memory\n    dma_block_config_s.block_size       = user_data[dma_index].size; // Buffer size in bytes\n    dma_block_config_s.source_addr_adj  = DMA_ADDR_ADJ_NO_CHANGE;    // Source: no increment in ADC register\n    dma_block_config_s.dest_addr_adj    = DMA_ADDR_ADJ_INCREMENT;    // Dest: increment in memory\n    dma_block_config_s.dest_reload_en   = 1;                         // Reload destination address on block completion\n    dma_block_config_s.source_reload_en = 1;                         // Reload source address on block completion; Enables Half-transfer interrupt\n\n    struct dma_config dma_config_s = {0};\n    dma_config_s.dma_slot            = source_triggers[dma_index]; // Trigger source: ADC\n    dma_config_s.channel_direction   = PERIPHERAL_TO_MEMORY;       // From periph to mem\n    dma_config_s.source_data_size    = 2;                          // Source: 2 bytes (uint16_t)\n    dma_config_s.dest_data_size      = 2;                          // Dest: 2 bytes (uint16_t)\n    dma_config_s.source_burst_length = 1;                          // Source: No burst\n    dma_config_s.dest_burst_length   = 1;                          // Dest: No burst\n    dma_config_s.block_count         = 1;                          // 1 block\n    dma_config_s.head_block          = &amp;dma_block_config_s;        // Block config as defined above\n    dma_config_s.dma_callback        = _dma_callback;              // DMA interrupt callback\n    dma_config_s.user_data           = &amp;user_data[dma_index];      // User data provided to callback\n\n    // Use DMA 1 channel x for ADC x\n    dma_config(dma1, user_data[dma_index].channel, &amp;dma_config_s);\n\n    if (disable_interrupts == true)\n    {\n        LL_DMA_DisableIT_HT(DMA1, dma_index);\n        LL_DMA_DisableIT_TC(DMA1, dma_index);\n    }\n\n    dma_start(dma1, user_data[dma_index].channel);\n}\n\nuint32_t dma_get_retreived_data_count(uint8_t adc_number)\n{\n    // Permanent variable\n    // -1 is equivalent to (buffer size - 1) in modulo arithmetics\n    static int32_t previous_dma_latest_data_pointers[5] = {-1, -1, -1, -1, -1};\n\n    // Get data\n    uint32_t dma_index = adc_number - 1;\n    uint32_t dma_remaining_data = LL_DMA_GetDataLength(DMA1, dma_index);\n    int32_t previous_dma_latest_data_pointer = previous_dma_latest_data_pointers[dma_index];\n\n    // Compute pointers\n    int32_t dma_next_data_pointer = buffers_sizes[dma_index] - dma_remaining_data;\n    int32_t dma_latest_data_pointer = dma_next_data_pointer - 1;\n\n    int32_t corrected_dma_pointer = dma_latest_data_pointer;\n    if (dma_latest_data_pointer &lt; previous_dma_latest_data_pointer)\n    {\n        corrected_dma_pointer += buffers_sizes[dma_index];\n    }\n\n    uint32_t retreived_data = corrected_dma_pointer - previous_dma_latest_data_pointer;\n    previous_dma_latest_data_pointers[dma_index] = dma_latest_data_pointer;\n\n    return retreived_data;\n}\n</code></pre>"},{"location":"powerAPI/dma_8h/","title":"File dma.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dma_8h/#public-functions","title":"Public Functions","text":"Type Name void dma_configure_adc_acquisition (uint8_t adc_number, bool disable_interrupts, uint16_t * buffer, size_t buffer_size) This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. uint32_t dma_get_retreived_data_count (uint8_t adc_number) Obtain the number of acquired data since last time this function was called."},{"location":"powerAPI/dma_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/dma_8h/#function-dma_configure_adc_acquisition","title":"function dma_configure_adc_acquisition","text":"<p>This function configures a channel from DMA 1 to transfer measures from an ADC to buffers, then starts the channels. It must only be called after all the ADCs configuration has been carried out, as it uses its channels configuration to determine the size of the buffers. <pre><code>void dma_configure_adc_acquisition (\n    uint8_t adc_number,\n    bool disable_interrupts,\n    uint16_t * buffer,\n    size_t buffer_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to acquire measures from. </li> <li><code>disable_interrupts</code> Boolean indicating whether interrupts shoud be disabled. Warning: this override Zephyr DMA driver default behavior. </li> <li><code>buffer</code> Pointer to buffer. </li> <li><code>buffer_size</code> Number of uint16_t words the buffer can contain. </li> </ul>"},{"location":"powerAPI/dma_8h/#function-dma_get_retreived_data_count","title":"function dma_get_retreived_data_count","text":"<p>Obtain the number of acquired data since last time this function was called. <pre><code>uint32_t dma_get_retreived_data_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC.</li> </ul> <p>Returns:</p> <p>Number of acquired data modulo buffer size. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/data/dma.h</code></p>"},{"location":"powerAPI/dma_8h_source/","title":"File dma.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; data &gt; dma.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DMA_H_\n#define DMA_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n\nvoid dma_configure_adc_acquisition(uint8_t adc_number, bool disable_interrupts, uint16_t* buffer, size_t buffer_size);\n\nuint32_t dma_get_retreived_data_count(uint8_t adc_number);\n\n\n#endif // DMA_H_\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/","title":"File hardware_auto_configuration.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * cdc_acm_console   = = DEVICE_DT_GET(CDC_ACM_DEVICE) const struct device * dac2   = = DEVICE_DT_GET(DAC2_DEVICE)This file automatically performs some hardware configuration using Zephyr macros. Configuration done in this file is low-level peripheral configuration required for OwnTech board to operate, do not mess with it unless you are absolutely sure of what you're doing. This file does not contain any public function."},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions","title":"Public Functions","text":"Type Name K_WORK_DEFINE (reboot_bootloader_work, reboot_bootloader_task)  SYS_INIT (_vrefbuf_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_dac2_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_console_init, APPLICATION, 89)  SYS_INIT (_img_validation, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  SYS_INIT (_register_cdc_rate_callback, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  SYS_INIT (_swap_usart1_tx_rx, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  void _cdc_rate_callback (const struct device * dev, uint32_t rate)  void reboot_bootloader_task (struct k_work * work)"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name int _console_init ()  int _dac2_init ()  int _img_validation ()  int _register_cdc_rate_callback ()  int _swap_usart1_tx_rx ()  int _vrefbuf_init ()"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-cdc_acm_console","title":"variable cdc_acm_console","text":"<pre><code>const struct device* cdc_acm_console;\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-dac2","title":"variable dac2","text":"<p>This file automatically performs some hardware configuration using Zephyr macros. Configuration done in this file is low-level peripheral configuration required for OwnTech board to operate, do not mess with it unless you are absolutely sure of what you're doing. This file does not contain any public function. <pre><code>const struct device* dac2;\n</code></pre></p> <p>Date:</p> <p>2024 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-k_work_define","title":"function K_WORK_DEFINE","text":"<pre><code>K_WORK_DEFINE (\n    reboot_bootloader_work,\n    reboot_bootloader_task\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _vrefbuf_init,\n    PRE_KERNEL_1,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_1","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _dac2_init,\n    PRE_KERNEL_2,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_2","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _console_init,\n    APPLICATION,\n    89\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_3","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _img_validation,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_4","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _register_cdc_rate_callback,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_5","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _swap_usart1_tx_rx,\n    PRE_KERNEL_1,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_cdc_rate_callback","title":"function _cdc_rate_callback","text":"<pre><code>void _cdc_rate_callback (\n    const struct device * dev,\n    uint32_t rate\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-reboot_bootloader_task","title":"function reboot_bootloader_task","text":"<pre><code>void reboot_bootloader_task (\n    struct k_work * work\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_console_init","title":"function _console_init","text":"<pre><code>static int _console_init () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_dac2_init","title":"function _dac2_init","text":"<pre><code>static int _dac2_init () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_img_validation","title":"function _img_validation","text":"<pre><code>static int _img_validation () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_register_cdc_rate_callback","title":"function _register_cdc_rate_callback","text":"<pre><code>static int _register_cdc_rate_callback () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_swap_usart1_tx_rx","title":"function _swap_usart1_tx_rx","text":"<pre><code>static int _swap_usart1_tx_rx () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_vrefbuf_init","title":"function _vrefbuf_init","text":"<pre><code>static int _vrefbuf_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/hardware_auto_configuration.cpp</code></p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp_source/","title":"File hardware_auto_configuration.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n// STM32 LL\n#include &lt;stm32_ll_bus.h&gt;\n#include &lt;stm32_ll_system.h&gt;\n\n// Owntech driver\n#include \"dac.h\"\n\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\n\n// Functions to be run\n\nstatic int _vrefbuf_init()\n{\n    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);\n    LL_VREFBUF_SetVoltageScaling(LL_VREFBUF_VOLTAGE_SCALE0);\n    LL_VREFBUF_DisableHIZ();\n    LL_VREFBUF_Enable();\n\n    return 0;\n}\n\nstatic int _dac2_init()\n{\n    if (device_is_ready(dac2) == true)\n    {\n        dac_set_const_value(dac2, 1, 2048U);\n        dac_pin_configure(dac2, 1, dac_pin_external);\n        dac_start(dac2, 1);\n    }\n\n    return 0;\n}\n\nstatic int _console_init()\n{\n    console_init();\n\n    return 0;\n}\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/dfu/mcuboot.h&gt;\nstatic int _img_validation()\n{\n    if (boot_is_img_confirmed() == false)\n    {\n        int rc = boot_write_img_confirmed();\n        if (rc != 0)\n        {\n            printk(\"Failed to confirm image\");\n        }\n    }\n\n    return 0;\n}\n#endif // CONFIG_BOOTLOADER_MCUBOOT\n\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; defined(CONFIG_USB_CDC_ACM)\n#include &lt;zephyr/retention/bootmode.h&gt;\n#include &lt;zephyr/sys/reboot.h&gt;\nvoid reboot_bootloader_task(struct k_work* work)\n{\n    bootmode_set(BOOT_MODE_TYPE_BOOTLOADER);\n    sys_reboot(SYS_REBOOT_WARM);\n}\n\nK_WORK_DEFINE(reboot_bootloader_work, reboot_bootloader_task);\nvoid _cdc_rate_callback(const struct device* dev, uint32_t rate)\n{\n    if (rate == 1200)\n    {\n        k_work_submit(&amp;reboot_bootloader_work);\n    }\n}\n\n#include &lt;zephyr/drivers/uart/cdc_acm.h&gt;\n#define CDC_ACM_DEVICE DT_NODELABEL(cdc_acm_uart0)\nstatic const struct device* cdc_acm_console = DEVICE_DT_GET(CDC_ACM_DEVICE);\nstatic int _register_cdc_rate_callback()\n{\n    cdc_acm_dte_rate_callback_set(cdc_acm_console, _cdc_rate_callback);\n\n    return 0;\n}\n#endif // CONFIG_RETENTION_BOOT_MODE &amp;&amp; CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp; CONFIG_USB_CDC_ACM\n\n\n#ifdef CONFIG_SHIELD_O2\n#include &lt;stm32_ll_lpuart.h&gt;\nstatic int _swap_usart1_tx_rx()\n{\n    LL_LPUART_Disable(LPUART1);\n    LL_LPUART_SetTXRXSwap(LPUART1, LL_LPUART_TXRX_SWAPPED);\n    LL_LPUART_Enable(LPUART1);\n\n    return 0;\n}\n#endif // SHIELD_O2\n\n// Zephyr macros to automatically run above functions\n\nSYS_INIT(_vrefbuf_init,\n         PRE_KERNEL_1, // To be run in the first init phase\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\nSYS_INIT(_dac2_init,\n         PRE_KERNEL_2, // To be run in the second init phase (depends on DAC driver initialization)\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\nSYS_INIT(_console_init,\n         APPLICATION,\n         89\n        );\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\nSYS_INIT(_img_validation,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif // CONFIG_BOOTLOADER_MCUBOOT\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; defined(CONFIG_USB_CDC_ACM)\nSYS_INIT(_register_cdc_rate_callback,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif // CONFIG_RETENTION_BOOT_MODE &amp;&amp; CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp; CONFIG_USB_CDC_ACM\n\n#ifdef CONFIG_SHIELD_O2\nSYS_INIT(_swap_usart1_tx_rx,\n         PRE_KERNEL_1, // To be run in the first init phase\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n#endif // SHIELD_O2\n</code></pre>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/","title":"Dir docs/core/zephyr/modules/owntech_task_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api</p>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/</code></p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr</p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/</code></p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/#files","title":"Files","text":"Type Name file TaskAPI.cpp file TaskAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/TaskAPI_8cpp/","title":"File TaskAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8cpp/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.cpp</code></p>"},{"location":"powerAPI/TaskAPI_8cpp_source/","title":"File TaskAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// OwnTech Power API\n#include \"../src/uninterruptible_synchronous_task.hpp\"\n#include \"../src/asynchronous_tasks.hpp\"\n\n\n// Current class header\n#include \"TaskAPI.h\"\n\n\n// Static variables\n\nconst int TaskAPI::DEFAULT_PRIORITY = 5;\n\n\n// Public object to interact with the class\n\nTaskAPI task;\n\n\n// Public API\n\n// Non-interruptible control task\n\nint8_t TaskAPI::createCritical(task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source)\n{\n    scheduling_set_uninterruptible_synchronous_task_interrupt_source(int_source);\n    return scheduling_define_uninterruptible_synchronous_task(periodic_task, task_period_us);\n}\n\nvoid TaskAPI::startCritical(bool manage_data_acquisition)\n{\n    scheduling_start_uninterruptible_synchronous_task(manage_data_acquisition);\n}\n\nvoid TaskAPI::stopCritical()\n{\n    scheduling_stop_uninterruptible_synchronous_task();\n}\n\n\n// Asynchronous tasks\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\nint8_t TaskAPI::createBackground(task_function_t routine)\n{\n    return scheduling_define_asynchronous_task(routine);\n}\n\nvoid TaskAPI::startBackground(uint8_t task_number)\n{\n    scheduling_start_asynchronous_task(task_number);\n}\n\nvoid TaskAPI::stopBackground(uint8_t task_number)\n{\n    scheduling_stop_asynchronous_task(task_number);\n}\n\n// Suspend asynchronous tasks\n\nvoid TaskAPI::suspendBackgroundMs(uint32_t duration_ms)\n{\n    k_sleep(K_MSEC(duration_ms));\n}\n\nvoid TaskAPI::suspendBackgroundUs(uint32_t duration_us)\n{\n    k_sleep(K_USEC(duration_us));\n}\n\n#endif // CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/","title":"File TaskAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8h/#classes","title":"Classes","text":"Type Name class TaskAPI"},{"location":"powerAPI/TaskAPI_8h/#public-types","title":"Public Types","text":"Type Name enum scheduling_interrupt_source_t typedef void(* task_function_t"},{"location":"powerAPI/TaskAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#enum-scheduling_interrupt_source_t","title":"enum scheduling_interrupt_source_t","text":"<pre><code>enum scheduling_interrupt_source_t {\n    source_uninitialized,\n    source_hrtim,\n    source_tim6\n};\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/#typedef-task_function_t","title":"typedef task_function_t","text":"<pre><code>typedef void(* task_function_t) ();\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/TaskAPI_8h_source/","title":"File TaskAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TASKAPI_H_\n#define TASKAPI_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n\n// Public types\n\ntypedef void (*task_function_t)();\n\ntypedef enum { source_uninitialized, source_hrtim, source_tim6 } scheduling_interrupt_source_t;\n\n\n// Static class definition\n\nclass TaskAPI\n{\npublic:\n    int8_t createCritical(task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source = source_hrtim);\n\n    void startCritical(bool manage_data_acquisition = true);\n\n    void stopCritical();\n\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\n    int8_t createBackground(task_function_t routine);\n\n    void startBackground(uint8_t task_number);\n\n    void stopBackground(uint8_t task_number);\n\n    void suspendBackgroundMs(uint32_t duration_ms);\n\n    void suspendBackgroundUs(uint32_t duration_us);\n\n#endif // CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\nprivate:\n    static const int DEFAULT_PRIORITY;\n\n};\n\n\n// Public object to interact with the class\n\nextern TaskAPI task;\n\n\n#endif // TASKAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver</p>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/</code></p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/#files","title":"Files","text":"Type Name file timer.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/timer_8h/","title":"File timer.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/timer_8h/#classes","title":"Classes","text":"Type Name struct timer_config_t struct timer_driver_api"},{"location":"powerAPI/timer_8h/#public-types","title":"Public Types","text":"Type Name enum pin_mode_t typedef void(* timer_api_config typedef uint32_t(* timer_api_get_count typedef void(* timer_api_start typedef void(* timer_api_stop typedef void(* timer_callback_t"},{"location":"powerAPI/timer_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void timer_config (const struct device * dev, const struct timer_config_t * config)  uint32_t timer_get_count (const struct device * dev)  void timer_start (const struct device * dev)  void timer_stop (const struct device * dev)"},{"location":"powerAPI/timer_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/timer_8h/#enum-pin_mode_t","title":"enum pin_mode_t","text":"<pre><code>enum pin_mode_t {\n    no_pull,\n    pull_up,\n    pull_down\n};\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_config","title":"typedef timer_api_config","text":"<pre><code>typedef void(* timer_api_config) (const struct device *dev, const struct timer_config_t *config);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_get_count","title":"typedef timer_api_get_count","text":"<pre><code>typedef uint32_t(* timer_api_get_count) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_start","title":"typedef timer_api_start","text":"<pre><code>typedef void(* timer_api_start) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_stop","title":"typedef timer_api_stop","text":"<pre><code>typedef void(* timer_api_stop) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_callback_t","title":"typedef timer_callback_t","text":"<pre><code>typedef void(* timer_callback_t) ();\n</code></pre>"},{"location":"powerAPI/timer_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/timer_8h/#function-timer_config","title":"function timer_config","text":"<pre><code>static inline void timer_config (\n    const struct device * dev,\n    const struct timer_config_t * config\n) \n</code></pre> <p>Configure the timer dev using given configuration structure config.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> <li><code>config</code> Configuration holding the timer configuration. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_get_count","title":"function timer_get_count","text":"<pre><code>static inline uint32_t timer_get_count (\n    const struct device * dev\n) \n</code></pre> <p>Get the current timer counter value.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>Returns:</p> <p>Current value of the timer internal counter. </p>"},{"location":"powerAPI/timer_8h/#function-timer_start","title":"function timer_start","text":"<pre><code>static inline void timer_start (\n    const struct device * dev\n) \n</code></pre> <p>Start the timer dev. If timer is configured to provide a perdiodic interrupt, it will also enable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_stop","title":"function timer_stop","text":"<pre><code>static inline void timer_stop (\n    const struct device * dev\n) \n</code></pre> <p>Stop the timer dev. If timer is configured to provide a perdiodic interrupt, it will also disable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/timer_8h_source/","title":"File timer.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TIMER_H_\n#define TIMER_H_\n\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public devices names\n\n#define TIMER4_DEVICE DT_NODELABEL(timers4)\n#define TIMER6_DEVICE DT_NODELABEL(timers6)\n#define TIMER7_DEVICE DT_NODELABEL(timers7)\n\n\n// Configuration structure\n\ntypedef void (*timer_callback_t)();\n\ntypedef enum\n{\n    no_pull,\n    pull_up,\n    pull_down\n} pin_mode_t;\n\nstruct timer_config_t\n{\n    // Mode\n    uint32_t         timer_enable_irq     : 1;\n    uint32_t         timer_enable_encoder : 1;\n    // IRQ options\n    timer_callback_t timer_irq_callback;\n    uint32_t         timer_irq_t_usec;\n    uint32_t         timer_use_zero_latency : 1;\n    // Incremental encoder option\n    pin_mode_t       timer_enc_pin_mode;\n};\n\n\n// API\n\ntypedef void     (*timer_api_config)   (const struct device* dev, const struct timer_config_t* config);\ntypedef void     (*timer_api_start)    (const struct device* dev);\ntypedef void     (*timer_api_stop)     (const struct device* dev);\ntypedef uint32_t (*timer_api_get_count)(const struct device* dev);\n\n__subsystem struct timer_driver_api\n{\n    timer_api_config    config;\n    timer_api_start     start;\n    timer_api_stop      stop;\n    timer_api_get_count get_count;\n};\n\n\nstatic inline void timer_config(const struct device* dev, const struct timer_config_t* config)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;config(dev, config);\n}\n\nstatic inline void timer_start(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev);\n}\n\nstatic inline void timer_stop(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev);\n}\n\nstatic inline uint32_t timer_get_count(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    return api-&gt;get_count(dev);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // TIMER_H_\n</code></pre>"},{"location":"powerAPI/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"powerAPI/classes/","title":"Class Index","text":""},{"location":"powerAPI/classes/#a","title":"a","text":"<ul> <li>adc_hrtim_conf_t</li> <li>AnalogCommunication</li> </ul>"},{"location":"powerAPI/classes/#c","title":"c","text":"<ul> <li>CanCommunication</li> <li>CommunicationAPI</li> <li>comp_usage_conf_t</li> <li>CompHAL</li> </ul>"},{"location":"powerAPI/classes/#d","title":"d","text":"<ul> <li>dac_driver_api</li> <li>dac_function_config_t</li> <li>DacHAL</li> <li>DataAPI</li> <li>dma_user_data_t</li> </ul>"},{"location":"powerAPI/classes/#g","title":"g","text":"<ul> <li>gpio_conf_t</li> <li>GpioHAL</li> </ul>"},{"location":"powerAPI/classes/#l","title":"l","text":"<ul> <li>LedHAL</li> </ul>"},{"location":"powerAPI/classes/#p","title":"p","text":"<ul> <li>phase_shift_conf_t</li> <li>pwm_conf_t</li> <li>PwmHAL</li> </ul>"},{"location":"powerAPI/classes/#r","title":"r","text":"<ul> <li>Rs485Communication</li> </ul>"},{"location":"powerAPI/classes/#s","title":"s","text":"<ul> <li>safety</li> <li>ShieldAPI</li> <li>SpinAPI</li> <li>switch_conv_conf_t</li> <li>SyncCommunication</li> </ul>"},{"location":"powerAPI/classes/#t","title":"t","text":"<ul> <li>TaskAPI</li> <li>timer_config_t</li> <li>timer_driver_api</li> <li>timer_hrtim_t</li> <li>TimerHAL</li> </ul>"},{"location":"powerAPI/classes/#u","title":"u","text":"<ul> <li>UartHAL</li> </ul>"},{"location":"powerAPI/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class ShieldAPI </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class UartHAL Handles usart 1 for the SPIN board. </li> <li>class safety </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t </li> <li>struct dma_user_data_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t </li> <li>struct timer_driver_api </li> <li>struct timer_hrtim_t Timinig unit configuration - aggregates all the structures. </li> </ul>"},{"location":"powerAPI/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"powerAPI/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"powerAPI/class_members/","title":"Class Members","text":""},{"location":"powerAPI/class_members/#a","title":"a","text":"<ul> <li>analog (CommunicationAPI)</li> <li>adcInitialized (DataAPI)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#c","title":"c","text":"<ul> <li>can (CommunicationAPI)</li> <li>currentModeInit (DacHAL)</li> <li>channels_ranks (DataAPI)</li> <li>configureDiscontinuousMode (DataAPI)</li> <li>configureTriggerSource (DataAPI)</li> <li>convertValue (DataAPI)</li> <li>converted_values_buffer (DataAPI)</li> <li>current_adc (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>comp (SpinAPI)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>channel (dma_user_data_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#d","title":"d","text":"<ul> <li>disableChannel (DataAPI)</li> <li>dispatch_method (DataAPI)</li> <li>doFullDispatch (DataAPI)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>dac (SpinAPI)</li> <li>data (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>dst (dma_user_data_t)</li> <li>duty_cycle (pwm_conf_t)</li> <li>disableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_members/#e","title":"e","text":"<ul> <li>enableCan (CanCommunication)</li> <li>enableAcquisition (DataAPI)</li> <li>enableChannel (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>external_trigger (pwm_conf_t)</li> <li>enableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_members/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#g","title":"g","text":"<ul> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getChannelValues (DataAPI)</li> <li>getConversionParameterType (DataAPI)</li> <li>getConversionParameterValue (DataAPI)</li> <li>getCurrentAdcForPin (DataAPI)</li> <li>getDefaultAdcForPin (DataAPI)</li> <li>getLatestValue (DataAPI)</li> <li>getRawValues (DataAPI)</li> <li>getValues (DataAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getFrequencyMax (PwmHAL)</li> <li>getFrequencyMin (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriod (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodMax (PwmHAL)</li> <li>getPeriodMin (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getResolutionPs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>gpio (SpinAPI)</li> <li>getTimer4IncrementalEncoderValue (TimerHAL)</li> <li>getChannelError (safety)</li> <li>getChannelReaction (safety)</li> <li>getChannelThresholdMax (safety)</li> <li>getChannelThresholdMin (safety)</li> <li>getChannelWatch (safety)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#h","title":"h","text":"<ul> <li>has_interrupt (dma_user_data_t)</li> </ul>"},{"location":"powerAPI/class_members/#i","title":"i","text":"<ul> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>initializeAllAdcs (DataAPI)</li> <li>is_started (DataAPI)</li> <li>initFixedFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initVariableFrequency (PwmHAL)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>init_shield (safety)</li> </ul>"},{"location":"powerAPI/class_members/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_members/#m","title":"m","text":"<ul> <li>max_frequency (pwm_conf_t)</li> <li>max_period (pwm_conf_t)</li> <li>min_frequency (pwm_conf_t)</li> <li>min_period (pwm_conf_t)</li> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#n","title":"n","text":"<ul> <li>ngnd (ShieldAPI)</li> </ul>"},{"location":"powerAPI/class_members/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#p","title":"p","text":"<ul> <li>peekChannel (DataAPI)</li> <li>peekLatestValue (DataAPI)</li> <li>power (ShieldAPI)</li> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>period (pwm_conf_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>retrieveConversionParametersFromMemory (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>resolution (pwm_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>retrieveThreshold (safety)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#s","title":"s","text":"<ul> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>sync (CommunicationAPI)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setConversionParametersLinear (DataAPI)</li> <li>setConversionParametersNtcThermistor (DataAPI)</li> <li>setDispatchMethod (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>start (DataAPI, dac_driver_api, timer_driver_api)</li> <li>started (DataAPI)</li> <li>stop (DataAPI, dac_driver_api, timer_driver_api)</li> <li>storeConversionParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setDeadTime (PwmHAL)</li> <li>setDutyCycle (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setPhaseShift (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>sensors (ShieldAPI)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogTimer4IncrementalEncoder (TimerHAL)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>size (dma_user_data_t)</li> <li>src (dma_user_data_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>setChannelReaction (safety)</li> <li>setChannelThresholdMax (safety)</li> <li>setChannelThresholdMin (safety)</li> <li>setChannelWatch (safety)</li> <li>storeThreshold (safety)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#t","title":"t","text":"<ul> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL)</li> <li>turnOn (LedHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>timer (SpinAPI)</li> <li>timer4Initialize (TimerHAL)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> <li>timer_use_zero_latency (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_members/#u","title":"u","text":"<ul> <li>uart (SpinAPI)</li> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> <li>unsetChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_members/#v","title":"v","text":"<ul> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/","title":"Class Member Functions","text":""},{"location":"powerAPI/class_member_functions/#c","title":"c","text":"<ul> <li>currentModeInit (DacHAL)</li> <li>configureDiscontinuousMode (DataAPI)</li> <li>configureTriggerSource (DataAPI)</li> <li>convertValue (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#d","title":"d","text":"<ul> <li>disableChannel (DataAPI)</li> <li>doFullDispatch (DataAPI)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>disableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#e","title":"e","text":"<ul> <li>enableCan (CanCommunication)</li> <li>enableAcquisition (DataAPI)</li> <li>enableChannel (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>enableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#g","title":"g","text":"<ul> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getChannelValues (DataAPI)</li> <li>getConversionParameterType (DataAPI)</li> <li>getConversionParameterValue (DataAPI)</li> <li>getCurrentAdcForPin (DataAPI)</li> <li>getDefaultAdcForPin (DataAPI)</li> <li>getLatestValue (DataAPI)</li> <li>getRawValues (DataAPI)</li> <li>getValues (DataAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getFrequencyMax (PwmHAL)</li> <li>getFrequencyMin (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriod (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodMax (PwmHAL)</li> <li>getPeriodMin (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getResolutionPs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>getTimer4IncrementalEncoderValue (TimerHAL)</li> <li>getChannelError (safety)</li> <li>getChannelReaction (safety)</li> <li>getChannelThresholdMax (safety)</li> <li>getChannelThresholdMin (safety)</li> <li>getChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#i","title":"i","text":"<ul> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>initializeAllAdcs (DataAPI)</li> <li>initFixedFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initVariableFrequency (PwmHAL)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>init_shield (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#p","title":"p","text":"<ul> <li>peekChannel (DataAPI)</li> <li>peekLatestValue (DataAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#r","title":"r","text":"<ul> <li>retrieveConversionParametersFromMemory (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>retrieveThreshold (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#s","title":"s","text":"<ul> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setConversionParametersLinear (DataAPI)</li> <li>setConversionParametersNtcThermistor (DataAPI)</li> <li>setDispatchMethod (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>start (DataAPI)</li> <li>started (DataAPI)</li> <li>stop (DataAPI)</li> <li>storeConversionParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setDeadTime (PwmHAL)</li> <li>setDutyCycle (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setPhaseShift (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogTimer4IncrementalEncoder (TimerHAL)</li> <li>setChannelReaction (safety)</li> <li>setChannelThresholdMax (safety)</li> <li>setChannelThresholdMin (safety)</li> <li>setChannelWatch (safety)</li> <li>storeThreshold (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#t","title":"t","text":"<ul> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL)</li> <li>turnOn (LedHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>timer4Initialize (TimerHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/#u","title":"u","text":"<ul> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> <li>unsetChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> </ul>"},{"location":"powerAPI/class_member_variables/","title":"Class Member Variables","text":""},{"location":"powerAPI/class_member_variables/#a","title":"a","text":"<ul> <li>analog (CommunicationAPI)</li> <li>adcInitialized (DataAPI)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#c","title":"c","text":"<ul> <li>can (CommunicationAPI)</li> <li>channels_ranks (DataAPI)</li> <li>converted_values_buffer (DataAPI)</li> <li>current_adc (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>comp (SpinAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>channel (dma_user_data_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#d","title":"d","text":"<ul> <li>dispatch_method (DataAPI)</li> <li>dac (SpinAPI)</li> <li>data (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>dst (dma_user_data_t)</li> <li>duty_cycle (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#e","title":"e","text":"<ul> <li>external_trigger (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (SpinAPI)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#h","title":"h","text":"<ul> <li>has_interrupt (dma_user_data_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#i","title":"i","text":"<ul> <li>is_started (DataAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#m","title":"m","text":"<ul> <li>max_frequency (pwm_conf_t)</li> <li>max_period (pwm_conf_t)</li> <li>min_frequency (pwm_conf_t)</li> <li>min_period (pwm_conf_t)</li> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#n","title":"n","text":"<ul> <li>ngnd (ShieldAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#p","title":"p","text":"<ul> <li>power (ShieldAPI)</li> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>period (pwm_conf_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>resolution (pwm_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#s","title":"s","text":"<ul> <li>sync (CommunicationAPI)</li> <li>sensors (ShieldAPI)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>start (dac_driver_api, timer_driver_api)</li> <li>stop (dac_driver_api, timer_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>size (dma_user_data_t)</li> <li>src (dma_user_data_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#t","title":"t","text":"<ul> <li>timer (SpinAPI)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> <li>timer_use_zero_latency (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#u","title":"u","text":"<ul> <li>uart (SpinAPI)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#v","title":"v","text":"<ul> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"powerAPI/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"powerAPI/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"powerAPI/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"powerAPI/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"powerAPI/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"powerAPI/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"powerAPI/functions/","title":"Functions","text":""},{"location":"powerAPI/functions/#a","title":"a","text":"<ul> <li>adc_add_channel (adc.c, adc.h)</li> <li>adc_configure_discontinuous_mode (adc.c, adc.h)</li> <li>adc_configure_trigger_source (adc.c, adc.h)</li> <li>adc_configure_use_dma (adc.c, adc.h)</li> <li>adc_get_enabled_channels_count (adc.c, adc.h)</li> <li>adc_remove_channel (adc.c, adc.h)</li> <li>adc_start (adc.c, adc.h)</li> <li>adc_stop (adc.c, adc.h)</li> <li>adc_trigger_software_conversion (adc.c, adc.h)</li> </ul>"},{"location":"powerAPI/functions/#c","title":"c","text":"<ul> <li>can_isotp_thread (thingset_isotp.cpp)</li> <li>CAN_MSGQ_DEFINE (thingset_pub_sub.cpp)</li> <li>can_pub_isr (thingset_pub_sub.cpp)</li> <li>can_pub_send (thingset_pub_sub.cpp)</li> <li>can_pubsub_thread (thingset_pub_sub.cpp)</li> <li>comparator1_init (comparator.c, comparator.h)</li> <li>comparator3_init (comparator.c, comparator.h)</li> </ul>"},{"location":"powerAPI/functions/#d","title":"d","text":"<ul> <li>dma_channel_init_rx (Rs485.cpp, Rs485.h)</li> <li>dma_channel_init_tx (Rs485.cpp, Rs485.h)</li> <li>dataObjectsUpdateMeasures (data_objects.cpp, data_objects.h)</li> <li>dac_function_update_reset (dac.h)</li> <li>dac_function_update_step (dac.h)</li> <li>dac_pin_configure (dac.h)</li> <li>dac_set_const_value (dac.h)</li> <li>dac_set_function (dac.h)</li> <li>dac_start (dac.h)</li> <li>dac_stop (dac.h)</li> <li>DualDAC_init (hrtim.h)</li> <li>data_conversion_convert_raw_value (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_get_conversion_type (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_get_parameter (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_init (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_retrieve_channel_parameters_from_nvs (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_set_conversion_parameters_linear (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_set_conversion_parameters_therm (data_conversion.cpp, data_conversion.h)</li> <li>data_conversion_store_channel_parameters_in_nvs (data_conversion.cpp, data_conversion.h)</li> <li>data_dispatch_do_dispatch (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_do_full_dispatch (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_get_acquired_values (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_init (data_dispatch.cpp, data_dispatch.h)</li> <li>data_dispatch_peek_acquired_value (data_dispatch.cpp, data_dispatch.h)</li> <li>dma_configure_adc_acquisition (dma.cpp, dma.h)</li> <li>dma_get_retreived_data_count (dma.cpp, dma.h)</li> </ul>"},{"location":"powerAPI/functions/#h","title":"h","text":"<ul> <li>hrtim_PeriodicEvent_GetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_SetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_configure (hrtim.h)</li> <li>hrtim_PeriodicEvent_dis (hrtim.h)</li> <li>hrtim_PeriodicEvent_en (hrtim.h)</li> <li>hrtim_adc_rollover_get (hrtim.h)</li> <li>hrtim_adc_rollover_set (hrtim.h)</li> <li>hrtim_adc_triger_get (hrtim.h)</li> <li>hrtim_adc_triger_set (hrtim.h)</li> <li>hrtim_adc_trigger_dis (hrtim.h)</li> <li>hrtim_adc_trigger_en (hrtim.h)</li> <li>hrtim_adc_trigger_set_postscaler (hrtim.h)</li> <li>hrtim_change_frequency (hrtim.h)</li> <li>hrtim_cmpl_pwm_out1 (hrtim.h)</li> <li>hrtim_cmpl_pwm_out2 (hrtim.h)</li> <li>hrtim_cnt_dis (hrtim.h)</li> <li>hrtim_cnt_en (hrtim.h)</li> <li>hrtim_dt_init (hrtim.h)</li> <li>hrtim_dt_set (hrtim.h)</li> <li>hrtim_duty_cycle_set (hrtim.h)</li> <li>hrtim_eev_get (hrtim.h)</li> <li>hrtim_eev_set (hrtim.h)</li> <li>hrtim_frequency_set (hrtim.h)</li> <li>hrtim_get_apb2_clock (hrtim.h)</li> <li>hrtim_get_max_frequency (hrtim.h)</li> <li>hrtim_get_max_period (hrtim.h)</li> <li>hrtim_get_min_frequency (hrtim.h)</li> <li>hrtim_get_min_period (hrtim.h)</li> <li>hrtim_get_modulation (hrtim.h)</li> <li>hrtim_get_resolution_ps (hrtim.h)</li> <li>hrtim_get_status (hrtim.h)</li> <li>hrtim_get_switch_convention (hrtim.h)</li> <li>hrtim_init_default_all (hrtim.h)</li> <li>hrtim_master_cmp_set (hrtim.h)</li> <li>hrtim_out_dis (hrtim.h)</li> <li>hrtim_out_dis_single (hrtim.h)</li> <li>hrtim_out_en (hrtim.h)</li> <li>hrtim_out_en_single (hrtim.h)</li> <li>hrtim_period_Master_get (hrtim.h)</li> <li>hrtim_period_Master_get_us (hrtim.h)</li> <li>hrtim_period_get (hrtim.h)</li> <li>hrtim_period_get_us (hrtim.h)</li> <li>hrtim_phase_shift_set (hrtim.h)</li> <li>hrtim_pwm_mode_get (hrtim.h)</li> <li>hrtim_pwm_mode_set (hrtim.h)</li> <li>hrtim_rst_evt_dis (hrtim.h)</li> <li>hrtim_rst_evt_en (hrtim.h)</li> <li>hrtim_set_modulation (hrtim.h)</li> <li>hrtim_set_switch_convention (hrtim.h)</li> <li>hrtim_tu_cmp_set (hrtim.h)</li> <li>hrtim_tu_gpio_init (hrtim.h)</li> <li>hrtim_tu_init (hrtim.h)</li> </ul>"},{"location":"powerAPI/functions/#i","title":"i","text":"<ul> <li>init_DEmode (Rs485.cpp, Rs485.h)</li> <li>init_usrBaudrate (Rs485.cpp, Rs485.h)</li> <li>init_usrBuffer (Rs485.cpp, Rs485.h)</li> <li>init_usrDataSize (Rs485.cpp, Rs485.h)</li> <li>init_usrFunc (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#k","title":"k","text":"<ul> <li>K_THREAD_DEFINE (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>K_WORK_DEFINE (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#n","title":"n","text":"<ul> <li>nvs_storage_clear_all_stored_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_current_version (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_version_in_nvs (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_retrieve_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_store_data (nvs_storage.c, nvs_storage.h)</li> <li>ngnd_set (ngnd.h)</li> </ul>"},{"location":"powerAPI/functions/#o","title":"o","text":"<ul> <li>oversamp_set (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#r","title":"r","text":"<ul> <li>reboot_bootloader_task (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#s","title":"s","text":"<ul> <li>serial_init (Rs485.cpp, Rs485.h)</li> <li>serial_start (Rs485.cpp, Rs485.h)</li> <li>serial_stop (Rs485.cpp, Rs485.h)</li> <li>serial_tx_on (Rs485.cpp, Rs485.h)</li> <li>send_complete_cb (thingset_isotp.cpp)</li> <li>send_ts_can_pub_message (thingset_pub_sub.cpp)</li> <li>safety_task (safety_internal.h)</li> <li>SYS_INIT (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#t","title":"t","text":"<ul> <li>ts (data_objects.cpp)</li> <li>timer_config (timer.h)</li> <li>timer_get_count (timer.h)</li> <li>timer_start (timer.h)</li> <li>timer_stop (timer.h)</li> </ul>"},{"location":"powerAPI/functions/#u","title":"u","text":"<ul> <li>update_ts_data_nodes (thingset_pub_sub.cpp)</li> </ul>"},{"location":"powerAPI/functions/#_","title":"_","text":"<ul> <li>_dma_callback_rx (Rs485.cpp)</li> <li>_dma_callback_tx (Rs485.cpp)</li> <li>_nvs_storage_init (nvs_storage.c)</li> <li>_nvs_storage_store_version (nvs_storage.c)</li> <li>_uart_usart1_process_input (UartHAL.cpp)</li> <li>_data_conversion_get_parameters_count (data_conversion.cpp)</li> <li>_data_dispatch_get_buffer (data_dispatch.cpp)</li> <li>_data_dispatch_get_count (data_dispatch.cpp)</li> <li>_data_dispatch_increment_count (data_dispatch.cpp)</li> <li>_data_dispatch_swap_buffers (data_dispatch.cpp)</li> <li>_dma_callback (dma.cpp)</li> <li>_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_console_init (hardware_auto_configuration.cpp)</li> <li>_dac2_init (hardware_auto_configuration.cpp)</li> <li>_img_validation (hardware_auto_configuration.cpp)</li> <li>_register_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_swap_usart1_tx_rx (hardware_auto_configuration.cpp)</li> <li>_vrefbuf_init (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"powerAPI/variables/","title":"Variables","text":""},{"location":"powerAPI/variables/#a","title":"a","text":"<ul> <li>adc_discontinuous_mode (adc.c)</li> <li>adc_trigger_sources (adc.c)</li> <li>adc_ev_src_t (adc.h)</li> <li>ADC_COUNT (DataAPI.h)</li> <li>adc_t (DataAPI.h)</li> <li>adc_channel_buffers (data_dispatch.cpp)</li> </ul>"},{"location":"powerAPI/variables/#b","title":"b","text":"<ul> <li>broadcast_time (CanCommunication.cpp, thingset_pub_sub.cpp)</li> <li>baud (Rs485.cpp)</li> <li>buf_req (UartHAL.cpp)</li> <li>buffers_data_count (data_dispatch.cpp)</li> <li>buffers_sizes (dma.cpp)</li> </ul>"},{"location":"powerAPI/variables/#c","title":"c","text":"<ul> <li>communication (CommunicationAPI.cpp, CommunicationAPI.h)</li> <li>control_time (CanCommunication.cpp, thingset_pub_sub.cpp)</li> <li>can_node_addr (data_objects.cpp, data_objects.h, thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>ctrl_enable (data_objects.cpp, data_objects.h)</li> <li>can_dev (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>ctrl_filter (thingset_pub_sub.cpp)</li> <li>current_storage_version (nvs_storage.c)</li> <li>CHANNELS_PER_ADC (DataAPI.h)</li> <li>command_flag (UartHAL.cpp)</li> <li>conversion_parameters (data_conversion.cpp)</li> <li>conversion_types (data_conversion.cpp)</li> <li>conversion_type_t (data_conversion.h)</li> <li>current_buffer (data_dispatch.cpp)</li> <li>current_dma_buffer (data_dispatch.cpp)</li> <li>CHANNELS_BUFFERS_SIZE (data_dispatch.h)</li> <li>cdc_acm_console (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/variables/#d","title":"d","text":"<ul> <li>dma1 (Rs485.cpp, dma.cpp)</li> <li>dma_buffer_size (Rs485.cpp)</li> <li>dma_callbackRXfunc_t (Rs485.h)</li> <li>data_objects (data_objects.cpp)</li> <li>device_id (data_objects.cpp)</li> <li>device_type (data_objects.cpp)</li> <li>dac_api_fn_upd_reset (dac.h)</li> <li>dac_api_fn_upd_step (dac.h)</li> <li>dac_api_pinconfigure (dac.h)</li> <li>dac_api_setconstvalue (dac.h)</li> <li>dac_api_setfunction (dac.h)</li> <li>dac_api_start (dac.h)</li> <li>dac_api_stop (dac.h)</li> <li>dac_function_t (dac.h)</li> <li>dac_pin_config_t (dac.h)</li> <li>dac_polarity_t (dac.h)</li> <li>dac_trigger_t (dac.h)</li> <li>dac1 (DacHAL.cpp)</li> <li>dac2 (DacHAL.cpp, hardware_auto_configuration.cpp)</li> <li>dac3 (DacHAL.cpp)</li> <li>DATA_IS_MISSING (DataAPI.h)</li> <li>DATA_IS_OK (DataAPI.h)</li> <li>DATA_IS_OLD (DataAPI.h)</li> <li>DispatchMethod_t (DataAPI.h)</li> <li>dispatch_type (data_dispatch.cpp)</li> <li>dma_buffer_sizes (data_dispatch.cpp)</li> <li>dma_main_buffers (data_dispatch.cpp)</li> <li>dma_secondary_buffers (data_dispatch.cpp)</li> <li>dispatch_t (data_dispatch.h)</li> </ul>"},{"location":"powerAPI/variables/#e","title":"e","text":"<ul> <li>enable_dma (adc.c)</li> <li>enabled_channels (adc.c)</li> <li>enabled_channels_count (adc.c, data_dispatch.cpp)</li> <li>evt (Rs485.cpp)</li> </ul>"},{"location":"powerAPI/variables/#f","title":"f","text":"<ul> <li>firmware_version (data_objects.cpp)</li> <li>fc_opts (thingset_isotp.cpp)</li> <li>fs (nvs_storage.c)</li> </ul>"},{"location":"powerAPI/variables/#g","title":"g","text":"<ul> <li>GPIO_A (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_B (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_C (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_D (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#h","title":"h","text":"<ul> <li>hardware_version (data_objects.cpp)</li> <li>HRTIM_CHANNELS (hrtim_enum.h)</li> <li>HRTIM_PRESCALER_RESOLUTION_PS (hrtim_enum.h)</li> <li>hrtim_adc_edgetrigger_t (hrtim_enum.h)</li> <li>hrtim_adc_event_t (hrtim_enum.h)</li> <li>hrtim_adc_source_t (hrtim_enum.h)</li> <li>hrtim_adc_t (hrtim_enum.h)</li> <li>hrtim_adc_trigger_t (hrtim_enum.h)</li> <li>hrtim_callback_t (hrtim_enum.h)</li> <li>hrtim_cmp_t (hrtim_enum.h)</li> <li>hrtim_cnt_t (hrtim_enum.h)</li> <li>hrtim_comp_usage_t (hrtim_enum.h)</li> <li>hrtim_external_trigger_t (hrtim_enum.h)</li> <li>hrtim_gpio_clock_number_t (hrtim_enum.h)</li> <li>hrtim_out_t (hrtim_enum.h)</li> <li>hrtim_output_number_t (hrtim_enum.h)</li> <li>hrtim_output_reset_t (hrtim_enum.h)</li> <li>hrtim_output_set_t (hrtim_enum.h)</li> <li>hrtim_output_units_t (hrtim_enum.h)</li> <li>hrtim_pwm_mode_t (hrtim_enum.h)</li> <li>hrtim_reset_trig_t (hrtim_enum.h)</li> <li>hrtim_switch_convention_t (hrtim_enum.h)</li> <li>hrtim_tu_ON_OFF_t (hrtim_enum.h)</li> <li>hrtim_tu_number_t (hrtim_enum.h)</li> <li>hrtim_tu_t (hrtim_enum.h)</li> </ul>"},{"location":"powerAPI/variables/#i","title":"i","text":"<ul> <li>i1_low_value (data_objects.cpp)</li> <li>i2_low_value (data_objects.cpp)</li> <li>i_high_value (data_objects.cpp)</li> <li>initialized (nvs_storage.c)</li> <li>INPUT (GpioHAL.cpp, GpioHAL.h)</li> <li>INPUT_PULLUP (GpioHAL.cpp, GpioHAL.h)</li> <li>inverter_modulation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#l","title":"l","text":"<ul> <li>led_pin_spec (LedHAL.cpp)</li> <li>leg_operation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#m","title":"m","text":"<ul> <li>manufacturer (data_objects.cpp)</li> <li>max_parameters_count (data_conversion.cpp)</li> </ul>"},{"location":"powerAPI/variables/#n","title":"n","text":"<ul> <li>nvs_category_t (nvs_storage.h)</li> <li>NO_VALUE (DataAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#o","title":"o","text":"<ul> <li>OUTPUT (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#p","title":"p","text":"<ul> <li>PIN_COUNT (DataAPI.h)</li> <li>parameter_t (DataAPI.h)</li> <li>P0 (GpioHAL.h)</li> <li>P1 (GpioHAL.h)</li> <li>P10 (GpioHAL.h)</li> <li>P11 (GpioHAL.h)</li> <li>P12 (GpioHAL.h)</li> <li>P13 (GpioHAL.h)</li> <li>P14 (GpioHAL.h)</li> <li>P15 (GpioHAL.h)</li> <li>P2 (GpioHAL.h)</li> <li>P3 (GpioHAL.h)</li> <li>P4 (GpioHAL.h)</li> <li>P5 (GpioHAL.h)</li> <li>P6 (GpioHAL.h)</li> <li>P7 (GpioHAL.h)</li> <li>P8 (GpioHAL.h)</li> <li>P9 (GpioHAL.h)</li> <li>PA (GpioHAL.h)</li> <li>PB (GpioHAL.h)</li> <li>PC (GpioHAL.h)</li> <li>PD (GpioHAL.h)</li> <li>pin_t (GpioHAL.h)</li> <li>peek_memory (data_dispatch.cpp)</li> <li>PEEK_NO_VALUE (data_dispatch.h)</li> <li>pin_mode_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#r","title":"r","text":"<ul> <li>rx_usart_val (Rs485.cpp)</li> <li>rs485_speed_t (Rs485Communication.h)</li> <li>reference_value (data_objects.cpp, data_objects.h)</li> <li>recv_ctx (thingset_isotp.cpp)</li> <li>rx_addr (thingset_isotp.cpp)</li> </ul>"},{"location":"powerAPI/variables/#s","title":"s","text":"<ul> <li>send_ctx (thingset_isotp.cpp)</li> <li>storage_version_in_nvs (nvs_storage.c)</li> <li>Safety (SafetyAPI.cpp, SafetyAPI.h)</li> <li>shield (ShieldAPI.cpp, ShieldAPI.h)</li> <li>spin (SpinAPI.cpp, SpinAPI.h)</li> <li>source_registers (dma.cpp)</li> <li>source_triggers (dma.cpp)</li> <li>scheduling_interrupt_source_t (TaskAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#t","title":"t","text":"<ul> <li>tx_usart_val (Rs485.cpp)</li> <li>temp_value (data_objects.cpp)</li> <li>ts (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>tx_addr (thingset_isotp.cpp)</li> <li>tu_channel (hrtim.h)</li> <li>timer4 (TimerHAL.cpp)</li> <li>task (TaskAPI.cpp, TaskAPI.h)</li> <li>task_function_t (TaskAPI.h)</li> <li>timer_api_config (timer.h)</li> <li>timer_api_get_count (timer.h)</li> <li>timer_api_start (timer.h)</li> <li>timer_api_stop (timer.h)</li> <li>timer_callback_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#u","title":"u","text":"<ul> <li>uart_cfg (Rs485.cpp)</li> <li>uart_dev (Rs485.cpp, UartHAL.cpp)</li> <li>user_fnc (Rs485.cpp)</li> <li>usart_oversampling_t (Rs485.h)</li> <li>user_data (dma.cpp)</li> </ul>"},{"location":"powerAPI/variables/#v","title":"v","text":"<ul> <li>v1_low_value (data_objects.cpp)</li> <li>v2_low_value (data_objects.cpp)</li> <li>v_high_value (data_objects.cpp)</li> </ul>"},{"location":"powerAPI/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"controlLibrary/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,... </li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class Pid Pid in a standard form taking into account saturation. </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class Pr </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RST discrete polynomial regulator taking into account saturations. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir controlLibrary <ul> <li>dir src <ul> <li>file controller.h </li> <li>file filters.h </li> <li>file fir.h </li> <li>file pid.h </li> <li>file pr.h </li> <li>file rst.h </li> <li>file transform.h </li> <li>file trigo.h </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"controlLibrary/classController/","title":"Class Controller","text":"<p>template &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;</p> <p>ClassList &gt; Controller</p> <p>Controller interface for various inherited class like pid, rst, pr,...More...</p> <ul> <li><code>#include &lt;controller.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classController/#public-functions","title":"Public Functions","text":"Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classController/#protected-attributes","title":"Protected Attributes","text":"Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classController/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Guillaume Arthaud. </p> <p>Template parameters:</p> <ul> <li><code>refs_T</code> type of the reference </li> <li><code>meas_T</code> type of the measure </li> <li><code>outputs_T</code> type of the output </li> <li><code>params_T</code> type of the parameter </li> </ul> <p>Parameters:</p> <ul> <li><code>parameters</code> structure including all parameters needs to make calculations.</li> </ul> <p>we assume that outputs_T has already an order relation implemented. </p>"},{"location":"controlLibrary/classController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classController/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Controller::calculate (\n    void\n) = 0\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p>"},{"location":"controlLibrary/classController/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<p>calculate a new command value according the argument values <pre><code>inline virtual outputs_T Controller::calculateWithReturn (\n    refs_T yref,\n    meas_T y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p>"},{"location":"controlLibrary/classController/#function-getoutput","title":"function getOutput","text":"<p>retrieve the last command value calculated. <pre><code>inline virtual outputs_T Controller::getOutput () \n</code></pre></p> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Controller::init (\n    params_T parameters\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p>"},{"location":"controlLibrary/classController/#function-reset","title":"function reset","text":"<pre><code>virtual void Controller::reset (\n    void\n) = 0\n</code></pre>"},{"location":"controlLibrary/classController/#function-saturate","title":"function saturate","text":"<p>limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. <pre><code>inline virtual outputs_T Controller::saturate (\n    outputs_T u\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>u</code> should be a command value. </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-setmeasurement","title":"function setMeasurement","text":"<p>capture a new measurement. <pre><code>inline virtual void Controller::setMeasurement (\n    meas_T measure\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>measure</code> </li> </ul>"},{"location":"controlLibrary/classController/#function-setreference","title":"function setReference","text":"<p>capture a new reference. <pre><code>inline virtual void Controller::setReference (\n    refs_T reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> </li> </ul>"},{"location":"controlLibrary/classController/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"controlLibrary/classController/#variable-_ts","title":"variable _Ts","text":"<pre><code>float32_t Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_Ts;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_lower_bound","title":"variable _lower_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_lower_bound;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_measure","title":"variable _measure","text":"<pre><code>meas_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_measure;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_output","title":"variable _output","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_output;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_reference","title":"variable _reference","text":"<pre><code>refs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_reference;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_upper_bound","title":"variable _upper_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/classFir/","title":"Class Fir","text":"<p>ClassList &gt; Fir</p> <p>a class to implement the Finite Impulse Response filter behaviour More...</p> <ul> <li><code>#include &lt;fir.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classFir/#public-functions","title":"Public Functions","text":"Type Name Fir ()  Fir (const uint8_t nc, const float32_t * coeffs)  uint8_t init (uint8_t nc, const float32_t * coeffs) method to initialize the Fir with its coefficients void reset ()  void setCoeff (uint8_t n, float32_t value)  float32_t update (float32_t new_data)  ~Fir ()"},{"location":"controlLibrary/classFir/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients</li> <li><code>*coeffs</code> pointer to array of coefficients </li> </ul>"},{"location":"controlLibrary/classFir/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classFir/#function-fir-12","title":"function Fir [1/2]","text":"<pre><code>Fir::Fir () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir-22","title":"function Fir [2/2]","text":"<pre><code>Fir::Fir (\n    const uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-init","title":"function init","text":"<p>method to initialize the Fir with its coefficients <pre><code>uint8_t Fir::init (\n    uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients </li> <li><code>coeffs</code> pointer to array of coefficients </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classFir/#function-reset","title":"function reset","text":"<pre><code>void Fir::reset () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-setcoeff","title":"function setCoeff","text":"<pre><code>void Fir::setCoeff (\n    uint8_t n,\n    float32_t value\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-update","title":"function update","text":"<pre><code>float32_t Fir::update (\n    float32_t new_data\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir","title":"function ~Fir","text":"<pre><code>Fir::~Fir () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/","title":"Class LowPassFirstOrderFilter","text":"<p>ClassList &gt; LowPassFirstOrderFilter</p> <p>More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions","title":"Public Functions","text":"Type Name LowPassFirstOrderFilter (float32_t Ts, float32_t tau)  float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t tau)  void reset ()  void reset (float32_t value)"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-lowpassfirstorderfilter","title":"function LowPassFirstOrderFilter","text":"<pre><code>LowPassFirstOrderFilter::LowPassFirstOrderFilter (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t LowPassFirstOrderFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-init","title":"function init","text":"<pre><code>uint8_t LowPassFirstOrderFilter::init (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-12","title":"function reset [1/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset () \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset (\n    float32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classNotchFilter/","title":"Class NotchFilter","text":"<p>ClassList &gt; NotchFilter</p>"},{"location":"controlLibrary/classNotchFilter/#public-functions","title":"Public Functions","text":"Type Name NotchFilter ()  NotchFilter (float32_t Ts, float32_t f0, float32_t bandwidth) its a band stop filter float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t f0, float32_t bandwidth) initialize the band stop filter parameters void reset ()"},{"location":"controlLibrary/classNotchFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-12","title":"function NotchFilter [1/2]","text":"<pre><code>inline NotchFilter::NotchFilter () \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-22","title":"function NotchFilter [2/2]","text":"<p>its a band stop filter <pre><code>NotchFilter::NotchFilter (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t NotchFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-init","title":"function init","text":"<p>initialize the band stop filter parameters <pre><code>uint8_t NotchFilter::init (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop in [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-reset","title":"function reset","text":"<pre><code>void NotchFilter::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPid/","title":"Class Pid","text":"<p>ClassList &gt; Pid</p> <p>Pid in a standard form taking into account saturation.More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPid/#public-functions","title":"Public Functions","text":"Type Name Pid ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (PidParams params) overrideinitialize the standard pid virtual void reset () overridereset internal states and the last command of the controller. void reset (float32_t output)"},{"location":"controlLibrary/classPid/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPid/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPid/#detailed-description","title":"Detailed Description","text":"<p>out = Kp * (error + 1 / Ti * error / s + 1 / (1 + Td / N * s) * Td * s * error )</p> <p>It uses backward euler integration method.</p> <p>Example of use:</p> <p>Pid mypid; PidParams params(Ts, Kp, Ti, Td, N, lower_bound, upper_bound); mypid.init(params); mypid.setMeasurement(y); mypid.setReference(yref); mypid.calculate(); mypid.getOutput(); </p>"},{"location":"controlLibrary/classPid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPid/#function-pid","title":"function Pid","text":"<pre><code>inline Pid::Pid () \n</code></pre>"},{"location":"controlLibrary/classPid/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Pid::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPid/#function-init","title":"function init","text":"<p>initialize the standard pid <pre><code>virtual int8_t Pid::init (\n    PidParams params\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> is a PidParams structure with all the parameters of the Pid. </li> </ul> <p>Returns:</p> <p>0 if ok else -EINVAL </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPid/#function-reset-12","title":"function reset [1/2]","text":"<pre><code>virtual void Pid::reset () override\n</code></pre> <p>Implements Controller::reset</p>"},{"location":"controlLibrary/classPid/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void Pid::reset (\n    float32_t output\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPidParams/","title":"Class PidParams","text":"<p>ClassList &gt; PidParams</p> <p>all parameters of a standard pid More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t N float32_t Td float32_t Ti float32_t Ts float32_t lower_bound float32_t upper_bound"},{"location":"controlLibrary/structPidParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Ti</code> integral time constant</li> <li><code>Td</code> derivative time constant</li> <li><code>N</code> derivative filter coefficient</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPidParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PidParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-n","title":"variable N","text":"<pre><code>float32_t PidParams::N;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-td","title":"variable Td","text":"<pre><code>float32_t PidParams::Td;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ti","title":"variable Ti","text":"<pre><code>float32_t PidParams::Ti;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PidParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PidParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PidParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPllDatas/","title":"Class PllDatas","text":"<p>ClassList &gt; PllDatas</p> <p>datas returned by pll calculations More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes","title":"Public Attributes","text":"Type Name float32_t angle float32_t error float32_t w"},{"location":"controlLibrary/structPllDatas/#detailed-description","title":"Detailed Description","text":"<p>Parameters:</p> <ul> <li><code>w</code> pulsation estimated of the tracked signal [rad/s]</li> <li><code>angle</code> of the tracked signal [rad] </li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPllDatas/#variable-angle","title":"variable angle","text":"<pre><code>float32_t PllDatas::angle;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-error","title":"variable error","text":"<pre><code>float32_t PllDatas::error;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-w","title":"variable w","text":"<pre><code>float32_t PllDatas::w;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPllSinus/","title":"Class PllSinus","text":"<p>ClassList &gt; PllSinus</p>"},{"location":"controlLibrary/classPllSinus/#public-functions","title":"Public Functions","text":"Type Name PllSinus () a software phase lock loop on a sinusoidal signal PllSinus (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  PllDatas calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  void reset (float32_t f0)"},{"location":"controlLibrary/classPllSinus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPllSinus/#function-pllsinus-12","title":"function PllSinus [1/2]","text":"<p>a software phase lock loop on a sinusoidal signal <pre><code>inline PllSinus::PllSinus () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time in [s] </li> <li><code>amplitude</code> amplitude of the signal to track. </li> <li><code>f0</code> mean frequency of the signal to track </li> <li><code>rt</code> rise time of the loop in [s]. </li> </ul>"},{"location":"controlLibrary/classPllSinus/#function-pllsinus-22","title":"function PllSinus [2/2]","text":"<pre><code>PllSinus::PllSinus (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>PllDatas PllSinus::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-init","title":"function init","text":"<pre><code>uint8_t PllSinus::init (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-reset","title":"function reset","text":"<pre><code>void PllSinus::reset (\n    float32_t f0\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPr/","title":"Class Pr","text":"<p>ClassList &gt; Pr</p> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPr/#public-functions","title":"Public Functions","text":"Type Name Pr ()  virtual void calculate (void) calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . virtual int8_t init (PrParams parameters) initialize the controller. virtual void reset (void) calculate a new command value according the argument values"},{"location":"controlLibrary/classPr/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPr/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPr/#function-pr","title":"function Pr","text":"<pre><code>inline Pr::Pr () \n</code></pre>"},{"location":"controlLibrary/classPr/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . <pre><code>virtual void Pr::calculate (\n    void\n) \n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPr/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Pr::init (\n    PrParams parameters\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPr/#function-reset","title":"function reset","text":"<p>calculate a new command value according the argument values <pre><code>virtual void Pr::reset (\n    void\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/structPrParams/","title":"Class PrParams","text":"<p>ClassList &gt; PrParams</p> <p>all parameters to define the proportional resonant controller. More...</p> <ul> <li><code>#include &lt;pr.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t Kr float32_t Ts float32_t lower_bound float32_t phi_prime float32_t upper_bound float32_t w0"},{"location":"controlLibrary/structPrParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Kr</code> resonant gain</li> <li><code>w0</code> pulsation [rad/s]</li> <li><code>phi_prime</code> angle in rad to compensate delays</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPrParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PrParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-kr","title":"variable Kr","text":"<pre><code>float32_t PrParams::Kr;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PrParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PrParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-phi_prime","title":"variable phi_prime","text":"<pre><code>float32_t PrParams::phi_prime;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PrParams::upper_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-w0","title":"variable w0","text":"<pre><code>float32_t PrParams::w0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/classRST/","title":"Class RST","text":"<p>ClassList &gt; RST</p> <p>discrete polynomial regulator taking into account saturations. More...</p> <ul> <li><code>#include &lt;rst.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classRST/#public-functions","title":"Public Functions","text":"Type Name RST ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (RstParams p) overrideinitialize the rst controller virtual void reset (void) overridereset internal states and the last command of the controller."},{"location":"controlLibrary/classRST/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classRST/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classRST/#detailed-description","title":"Detailed Description","text":"<p>It uses 3 Fir : * one on the measurements called R(), * one on the previous command, called S(), * and the last on the reference called T()</p> <p>It mainly allows to add some filtering action on reference or measurements. and sometimes to add some filtering poles which help stabilisation.</p> <p>some classical regulators can be implemented by its way like pid and pr. </p>"},{"location":"controlLibrary/classRST/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classRST/#function-rst","title":"function RST","text":"<pre><code>inline RST::RST () \n</code></pre>"},{"location":"controlLibrary/classRST/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void RST::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classRST/#function-init","title":"function init","text":"<p>initialize the rst controller <pre><code>virtual int8_t RST::init (\n    RstParams p\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> RstParams structure </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL if not </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classRST/#function-reset","title":"function reset","text":"<pre><code>virtual void RST::reset (\n    void\n) override\n</code></pre> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/structRstParams/","title":"Class RstParams","text":"<p>ClassList &gt; RstParams</p> <p>More...</p>"},{"location":"controlLibrary/structRstParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Ts float32_t lower_bound uint8_t nr uint8_t ns uint8_t nt const float32_t * r const float32_t * s const float32_t * t float32_t upper_bound"},{"location":"controlLibrary/structRstParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr Rst parameters </p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>nr</code> number of R coefficients</li> <li><code>r[]</code> array of R coefficients</li> <li><code>ns</code> number of S coefficients</li> <li><code>s[]</code> array of S coefficients</li> <li><code>nt</code> number of t coefficients</li> <li><code>t[]</code> array of T coefficients</li> <li><code>lower_bound</code> minimal value of output</li> <li><code>upper_bound</code> maximal value of output </li> </ul>"},{"location":"controlLibrary/structRstParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structRstParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t RstParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t RstParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nr","title":"variable nr","text":"<pre><code>uint8_t RstParams::nr;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-ns","title":"variable ns","text":"<pre><code>uint8_t RstParams::ns;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nt","title":"variable nt","text":"<pre><code>uint8_t RstParams::nt;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-r","title":"variable r","text":"<pre><code>const float32_t* RstParams::r;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-s","title":"variable s","text":"<pre><code>const float32_t* RstParams::s;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-t","title":"variable t","text":"<pre><code>const float32_t* RstParams::t;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t RstParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/classTransform/","title":"Class Transform","text":"<p>ClassList &gt; Transform</p> <p>static class to group methods helping translation between reference frames More...</p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classTransform/#public-static-functions","title":"Public Static Functions","text":"Type Name clarke_t clarke (three_phase_t Xabc) transform a three_phase_t vector to aclarke_t vector. three_phase_t clarke_inverse (clarke_t Xabo) transform a clarke_t vector to athree_phase_t vector. clarke_t rotation_to_clarke (dqo_t Xdqo, float32_t theta) make a rotation which transform adqo_t vector to aclarke_t vector. dqo_t rotation_to_dqo (clarke_t Xabo, float32_t theta) make a - rotation which transform aclarke_t vector to adqo_t vector. dqo_t to_dqo (three_phase_t Xabc, float32_t theta) transform a three_phase_t vector to adqo_t vector. three_phase_t to_threephase (dqo_t Xdqo, float32_t theta) transform a dqo_t vector to athree_phase_t vector."},{"location":"controlLibrary/classTransform/#detailed-description","title":"Detailed Description","text":"<p>mainly 3 reference frames: * abc :three phase *  : clarke. * d, q, o : direct-quadrature. </p>"},{"location":"controlLibrary/classTransform/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"controlLibrary/classTransform/#function-clarke","title":"function clarke","text":"<pre><code>static clarke_t Transform::clarke (\n    three_phase_t Xabc\n) \n</code></pre>"},{"location":"controlLibrary/classTransform/#function-clarke_inverse","title":"function clarke_inverse","text":"<pre><code>static three_phase_t Transform::clarke_inverse (\n    clarke_t Xabo\n) \n</code></pre>"},{"location":"controlLibrary/classTransform/#function-rotation_to_clarke","title":"function rotation_to_clarke","text":"<pre><code>static clarke_t Transform::rotation_to_clarke (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/classTransform/#function-rotation_to_dqo","title":"function rotation_to_dqo","text":"<pre><code>static dqo_t Transform::rotation_to_dqo (\n    clarke_t Xabo,\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/classTransform/#function-to_dqo","title":"function to_dqo","text":"<pre><code>static dqo_t Transform::to_dqo (\n    three_phase_t Xabc,\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/classTransform/#function-to_threephase","title":"function to_threephase","text":"<pre><code>static three_phase_t Transform::to_threephase (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structclarke__t/","title":"Struct clarke_t","text":"<p>ClassList &gt; clarke_t</p> <p>to keep together \u03b1, \u03b2 and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structclarke__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t alpha float32_t beta float32_t o"},{"location":"controlLibrary/structclarke__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structclarke__t/#variable-alpha","title":"variable alpha","text":"<pre><code>float32_t clarke_t::alpha;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-beta","title":"variable beta","text":"<pre><code>float32_t clarke_t::beta;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-o","title":"variable o","text":"<pre><code>float32_t clarke_t::o;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structdqo__t/","title":"Struct dqo_t","text":"<p>ClassList &gt; dqo_t</p> <p>to keep together d, q and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structdqo__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t d float32_t o float32_t q"},{"location":"controlLibrary/structdqo__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structdqo__t/#variable-d","title":"variable d","text":"<pre><code>float32_t dqo_t::d;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-o","title":"variable o","text":"<pre><code>float32_t dqo_t::o;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-q","title":"variable q","text":"<pre><code>float32_t dqo_t::q;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structthree__phase__t/","title":"Struct three_phase_t","text":"<p>ClassList &gt; three_phase_t</p> <p>to keep together a,b and c phase values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structthree__phase__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t a float32_t b float32_t c"},{"location":"controlLibrary/structthree__phase__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structthree__phase__t/#variable-a","title":"variable a","text":"<pre><code>float32_t three_phase_t::a;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-b","title":"variable b","text":"<pre><code>float32_t three_phase_t::b;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-c","title":"variable c","text":"<pre><code>float32_t three_phase_t::c;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir controlLibrary <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/","title":"Dir docs/controlLibrary","text":"<p>FileList &gt; controlLibrary</p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/</code></p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/","title":"Dir docs/controlLibrary/src","text":"<p>FileList &gt; controlLibrary &gt; src</p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/#files","title":"Files","text":"Type Name file controller.h file filters.h file fir.h file pid.h file pr.h file rst.h file transform.h file trigo.h <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/</code></p>"},{"location":"controlLibrary/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include &lt;zephyr/logging/log.h&gt;</code></li> </ul>"},{"location":"controlLibrary/controller_8h/#classes","title":"Classes","text":"Type Name class Controller &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;Controller interface for various inherited class like pid, rst, pr,... <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include &lt;arm_math.h&gt;\n#ifndef CONTROLLER_H_\n#define CONTROLLER_H_\n#include &lt;zephyr/logging/log.h&gt;\n\ntemplate&lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;\nclass Controller\n{\n    public:\n    virtual int8_t init(params_T parameters) = 0; //ref + mesure\n\n    virtual void reset(void) = 0;\n\n    virtual void calculate(void) = 0; \n    virtual outputs_T calculateWithReturn(refs_T yref, meas_T y) {\n        this-&gt;setReference(yref);\n        this-&gt;setMeasurement(y);\n        this-&gt;calculate();\n        return this-&gt;getOutput();\n    }\n\n    virtual void setReference(refs_T reference) {\n        _reference = reference;\n    }; \n\n    virtual void setMeasurement(meas_T measure) {\n        _measure = measure;\n    }; \n\n    virtual outputs_T getOutput() {\n        return _output;\n    }; \n\n    virtual outputs_T saturate(outputs_T u) {\n        if ( u &gt; _upper_bound) {\n            u = _upper_bound;\n        }\n        if (u &lt; _lower_bound) {\n            u = _lower_bound;\n        }\n        return u;\n    };\nprotected:\n    float32_t _Ts; // sample time\n    outputs_T _lower_bound;\n    outputs_T _upper_bound;\n    // template \n    refs_T _reference;\n    outputs_T _output;\n    meas_T _measure;\n\n};\n\n#endif /* !CONTROLLER_H_ */\n</code></pre>"},{"location":"controlLibrary/filters_8h/","title":"File filters.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"arm_math_types.h\"</code></li> <li><code>#include \"fir.h\"</code></li> <li><code>#include \"pid.h\"</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/filters_8h/#classes","title":"Classes","text":"Type Name class LowPassFirstOrderFilter class NotchFilter class PllDatas datas returned by pll calculations class PllSinus <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/filters_8h_source/","title":"File filters.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef FILTERS_H_\n#define FILTERS_H_\n#include \"arm_math_types.h\"\n#include \"fir.h\"\n#include \"pid.h\"\n#include \"trigo.h\" \n\nclass LowPassFirstOrderFilter {\npublic:\n    LowPassFirstOrderFilter(float32_t Ts, float32_t tau);\n    uint8_t init(float32_t Ts, float32_t tau);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\n    void reset(float32_t value);\nprivate:\n    float32_t _Ts;\n    float32_t _tau;\n    float32_t _a1;\n    float32_t _b1;\n\n    float32_t _previous_value;\n};\n\nclass NotchFilter {\npublic:\n    NotchFilter() {};\n    NotchFilter(float32_t Ts, float32_t f0, float32_t bandwidth);\n\n    uint8_t init(float32_t Ts, float32_t f0, float32_t bandwidth);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\nprivate:\n    float32_t _Ts;\n    float32_t _f0;\n    float32_t _bandwidth;\n\n    Fir _B; // numerator of the filter\n    Fir _A; // denominator of the filter\n    float32_t _output;\n};\n\nstruct PllDatas {\n    float32_t w;\n    float32_t angle;\n    float32_t error;\n};\n\nclass PllSinus {\npublic:\n    PllSinus() {};\n    PllSinus(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    uint8_t init(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    PllDatas calculateWithReturn(float32_t signal);\n    void reset(float32_t f0);\n\nprivate:\n    float32_t _Ts;\n    float32_t _amplitude;\n    float32_t _f0;\n    float32_t _rt;\n\n    NotchFilter _notch;\n    Pid _pi;\n    float32_t _w;\n    float32_t _angle;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/fir_8h/","title":"File fir.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/fir_8h/#classes","title":"Classes","text":"Type Name class Fir a class to implement the Finite Impulse Response filter behaviour <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/fir_8h_source/","title":"File fir.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef FIR_H_\n#define FIR_H_\n#include &lt;arm_math.h&gt;\n\nclass Fir {\npublic:\n    Fir();\n    Fir(const uint8_t nc, const float32_t *coeffs);\n    uint8_t init(uint8_t nc, const float32_t *coeffs);\n    float32_t update(float32_t new_data);\n    void reset();\n    void setCoeff(uint8_t n, float32_t value);\n    ~Fir();\nprivate:\n    uint8_t nc;\n    float32_t *coeffs;\n    float32_t *datas;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pid_8h/","title":"File pid.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> </ul>"},{"location":"controlLibrary/pid_8h/#classes","title":"Classes","text":"Type Name class Pid Pid in a standard form taking into account saturation. class PidParams all parameters of a standard pid <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/pid_8h_source/","title":"File pid.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef PID_H_\n#define PID_H_\n#include \"controller.h\"\n\nstruct PidParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Ti;\n    float32_t Td;\n    float32_t N;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass Pid: public Controller &lt;float32_t, float32_t, float32_t, PidParams&gt; {\n\npublic:\n    Pid(){};\n\n    int8_t init(PidParams params) override; \n\n    void calculate(void) override;\n\n    void reset() override;\n\n    void reset(float32_t output);\n\nprivate:\n    float32_t _integral;\n    float32_t _Kp;\n    float32_t _Ti;\n    float32_t _Td;\n    float32_t _N;\n    float32_t _previous_f_deriv; // previous filtered derivative value\n    float32_t _previous_error;  // previous error\n\n    float32_t _inverse_Ts;\n    float32_t _inverse_Ti;\n    float32_t _inverse_Kp;\n    float32_t _b1_filter;\n    float32_t _a1_filter;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pr_8h/","title":"File pr.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/pr_8h/#classes","title":"Classes","text":"Type Name class Pr class PrParams all parameters to define the proportional resonant controller. <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/pr_8h_source/","title":"File pr.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include \"controller.h\"\n#include \"fir.h\"\n\nstruct PrParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Kr;\n    float32_t w0;\n    float32_t phi_prime;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\nclass Pr: public Controller &lt;float32_t, float32_t, float32_t, PrParams&gt; {\n\npublic:\n    Pr() {};\n\n    int8_t init(PrParams p);\n\n    void calculate(void);\n\n    void reset(void);\n\nprivate:\n    float32_t _Ts;\n    float32_t _Kp;\n    float32_t _Kr;\n    float32_t _inverse_Kr;\n    Fir _B; // numerator of the resonator\n    Fir _A; // denominator of the resonator\n    float32_t _resonant; // resonator output\n};\n</code></pre>"},{"location":"controlLibrary/rst_8h/","title":"File rst.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/rst_8h/#classes","title":"Classes","text":"Type Name class RST discrete polynomial regulator taking into account saturations. class RstParams <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/rst_8h_source/","title":"File rst.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef RST_H_\n#define RST_H_\n#include \"controller.h\"\n#include \"fir.h\" \n\nstruct RstParams {\n    float32_t Ts;\n    uint8_t nr;\n    const float32_t *r;\n    uint8_t ns;\n    const float32_t *s;\n    uint8_t nt;\n    const float32_t *t;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass RST: public Controller&lt;float32_t, float32_t, float32_t, RstParams&gt; {\npublic:\n    RST() {};\n\n    int8_t init(RstParams p) override;\n\n    void calculate(void) override;\n\n    using Controller&lt;float32_t, float32_t, float32_t, RstParams&gt;::calculate;\n\n    void reset(void) override;\n\nprivate:\n    Fir _R;\n    Fir _Sp;\n    Fir _T;\n    float32_t _inv_s0;\n};\n\n#endif\n</code></pre>"},{"location":"controlLibrary/transform_8h/","title":"File transform.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/transform_8h/#classes","title":"Classes","text":"Type Name class Transform static class to group methods helping translation between reference frames struct clarke_t to keep together \u03b1, \u03b2 and o values. struct dqo_t to keep together d, q and o values. struct three_phase_t to keep together a,b and c phase values."},{"location":"controlLibrary/transform_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t SQRT3_DIV_2   = = 0.8660254F const float32_t SQRT3_INVERSE   = = 0.57735026F"},{"location":"controlLibrary/transform_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/transform_8h/#variable-sqrt3_div_2","title":"variable SQRT3_DIV_2","text":"<pre><code>const float32_t SQRT3_DIV_2;\n</code></pre>"},{"location":"controlLibrary/transform_8h/#variable-sqrt3_inverse","title":"variable SQRT3_INVERSE","text":"<pre><code>const float32_t SQRT3_INVERSE;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/transform_8h_source/","title":"File transform.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n#ifndef TRANSFORM_H_\n#define TRANSFORM_H_\n#include &lt;arm_math.h&gt;\n#include \"trigo.h\"\n\nconst float32_t SQRT3_INVERSE  = 0.57735026F;\nconst float32_t SQRT3_DIV_2    = 0.8660254F;\n\n\nstruct three_phase_t {\n    float32_t a;\n    float32_t b;\n    float32_t c;\n\n};\n\nstruct clarke_t {\n    float32_t alpha;\n    float32_t beta;\n    float32_t o;\n};\n\nstruct dqo_t {\n    float32_t d;\n    float32_t q;\n    float32_t o;\n};\n\nclass Transform\n{\npublic:\n    static dqo_t rotation_to_dqo(clarke_t Xabo, float32_t theta);\n    static clarke_t rotation_to_clarke(dqo_t Xdqo, float32_t theta);\n    static clarke_t clarke(three_phase_t Xabc);\n    static three_phase_t clarke_inverse(clarke_t Xabo);\n    static dqo_t to_dqo(three_phase_t Xabc, float32_t theta);\n    static three_phase_t to_threephase(dqo_t Xdqo, float32_t theta);\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/trigo_8h/","title":"File trigo.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/trigo_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t INV_MODULO_RES const float32_t MODULO_RES const uint32_t MODULO_SIZE"},{"location":"controlLibrary/trigo_8h/#public-functions","title":"Public Functions","text":"Type Name float32_t ot_cos (float32_t x)  float32_t ot_modulo_2pi (float32_t theta)  float32_t ot_sin (float32_t x)"},{"location":"controlLibrary/trigo_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/trigo_8h/#variable-inv_modulo_res","title":"variable INV_MODULO_RES","text":"<pre><code>const float32_t INV_MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_res","title":"variable MODULO_RES","text":"<pre><code>const float32_t MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_size","title":"variable MODULO_SIZE","text":"<pre><code>const uint32_t MODULO_SIZE;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/trigo_8h/#function-ot_cos","title":"function ot_cos","text":"<pre><code>float32_t ot_cos (\n    float32_t x\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_modulo_2pi","title":"function ot_modulo_2pi","text":"<pre><code>float32_t ot_modulo_2pi (\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_sin","title":"function ot_sin","text":"<pre><code>float32_t ot_sin (\n    float32_t x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/trigo.h</code></p>"},{"location":"controlLibrary/trigo_8h_source/","title":"File trigo.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include &lt;arm_math.h&gt;\nextern const uint32_t MODULO_SIZE;     \nextern const float32_t INV_MODULO_RES;\nextern const float32_t MODULO_RES; \n\n// TODO: use CORDIC ?\n#ifdef CORDIC \n#include \"stm32g4xx_ll_cordic.h\"\n#endif\n\n\nfloat32_t ot_sin(float32_t x);\nfloat32_t ot_cos(float32_t x);\nfloat32_t ot_modulo_2pi(float32_t theta);\n</code></pre>"},{"location":"controlLibrary/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"controlLibrary/classes/","title":"Class Index","text":""},{"location":"controlLibrary/classes/#c","title":"c","text":"<ul> <li>clarke_t</li> <li>Controller</li> </ul>"},{"location":"controlLibrary/classes/#d","title":"d","text":"<ul> <li>dqo_t</li> </ul>"},{"location":"controlLibrary/classes/#f","title":"f","text":"<ul> <li>Fir</li> </ul>"},{"location":"controlLibrary/classes/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter</li> </ul>"},{"location":"controlLibrary/classes/#n","title":"n","text":"<ul> <li>NotchFilter</li> </ul>"},{"location":"controlLibrary/classes/#p","title":"p","text":"<ul> <li>Pid</li> <li>PidParams</li> <li>PllDatas</li> <li>PllSinus</li> <li>Pr</li> <li>PrParams</li> </ul>"},{"location":"controlLibrary/classes/#r","title":"r","text":"<ul> <li>RST</li> <li>RstParams</li> </ul>"},{"location":"controlLibrary/classes/#t","title":"t","text":"<ul> <li>three_phase_t</li> <li>Transform</li> </ul>"},{"location":"controlLibrary/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,...</li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"controlLibrary/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"controlLibrary/class_members/","title":"Class Members","text":""},{"location":"controlLibrary/class_members/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>coeffs (Fir)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_members/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_members/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_members/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>NotchFilter (NotchFilter)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>r (RstParams)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#u","title":"u","text":"<ul> <li>update (Fir)</li> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/","title":"Class Member Functions","text":""},{"location":"controlLibrary/class_member_functions/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#n","title":"n","text":"<ul> <li>NotchFilter (NotchFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#t","title":"t","text":"<ul> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#u","title":"u","text":"<ul> <li>update (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_variables/","title":"Class Member Variables","text":""},{"location":"controlLibrary/class_member_variables/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#c","title":"c","text":"<ul> <li>coeffs (Fir)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#l","title":"l","text":"<ul> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#p","title":"p","text":"<ul> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#r","title":"r","text":"<ul> <li>r (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#s","title":"s","text":"<ul> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#u","title":"u","text":"<ul> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"controlLibrary/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"controlLibrary/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"controlLibrary/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"controlLibrary/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"controlLibrary/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"controlLibrary/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"controlLibrary/functions/","title":"Functions","text":""},{"location":"controlLibrary/functions/#o","title":"o","text":"<ul> <li>ot_cos (trigo.h)</li> <li>ot_modulo_2pi (trigo.h)</li> <li>ot_sin (trigo.h)</li> </ul>"},{"location":"controlLibrary/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"controlLibrary/variables/","title":"Variables","text":""},{"location":"controlLibrary/variables/#i","title":"i","text":"<ul> <li>INV_MODULO_RES (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#m","title":"m","text":"<ul> <li>MODULO_RES (trigo.h)</li> <li>MODULO_SIZE (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#s","title":"s","text":"<ul> <li>SQRT3_DIV_2 (transform.h)</li> <li>SQRT3_INVERSE (transform.h)</li> </ul>"},{"location":"controlLibrary/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}