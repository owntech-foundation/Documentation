{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Matlab/docs/closed_loop_buck/","title":"Closed loop buck","text":"<p>After the open-loop mode, the aim of this tutorial is to show you how you can implement a buck voltage control using simulink and owntech library.</p> <p>You can delete all the data store variable related to the duty_cycle that we have created in the open loop section. Enter inside the block closed_loop_task, and with the association of the block \u201cconstant\u201d, \u201csum\u201d and \u201cdiscrete PID controller\u201d from the simulink library, <code>set leg duty</code> and <code>get data</code> from owntech library you can create the following schema :</p> <p></p> <p>We are fixing the output voltage to 15 volt, as for the PI paramters you should have the same as below\u00a0:</p> <p> </p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code\u00a0:</p> <p></p> <p>When enabling the matlab_mode, the output voltage will be fixed to 15V.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/","title":"First compilation with matlab","text":""},{"location":"Matlab/docs/first_compilation_with_matlab/#owntech-blocksets","title":"Owntech blocksets","text":"<p>There is a set of simulinks blocks ready to be used, to install it first clone this repository and checkout to the branch Ownblock_library_V3. In a console use the commands : </p> <pre><code>git clone https://gitlab.laas.fr/owntech/owntech-matlab.git\ngit checkout Ownblock_library_V3\n</code></pre> <p></p> <p>In the folder where the repository is cloned, you will find a file with the extension .mtltbx which is a matlab toolbox. There are multiple toolbox, choose the one correspondings to your OS and open it with matlab (in matlab press <code>ctrl+o</code> then open the chosen file), and the toolbox will be installed automatically.</p> <p>After the installation you can check that the library has been correctly installed. In simuinks \"Library Brower\" you can see if Owntech Library is present.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#simulink-template","title":"Simulink template","text":"<p>Still in the folder where we cloned the repository checkout to the branch matlab_zephyrV3 :</p> <pre><code>git checkout matlab_zephyrV3\n</code></pre> Resulting folder file structure<pre><code>\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 matlab_file\n\u251c\u2500\u2500 owntech\n\u251c\u2500\u2500 platformio.ini\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 zephyr\n</code></pre> <p></p> <p>Make sure that your working directory in matlab is the folder <code>matlab_file</code>. Browse for the folder in matlab.</p> <p>In matlab_file, there is a simulink file (owntech_template.slx) already set to be used for code generation. Open it and let\u2019s take a look at what is inside :</p> <p></p> <p>Let's see how each of this blocks work, starting by the initialize block.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#initialize-block","title":"Initialize block","text":"<p>This block will generate the initialization step for the hardware and software configuration. You can choose the convention for the legs (buck, boost) and the version of the board.</p> <p></p> <p>You can left it as it is to continue with the default value. </p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#increasedecrease-functions-and-pwr_enable-state","title":"Increase/decrease functions and pwr_enable state","text":"The application task and the control loop  <p>Inside the simulink file, we can see two functions that you can use to increment or decrement variables that you have defined. We will see how to use them later in another section of this tutorial. You can also notice that there is a variable pwr_enable, the state of this variable is used to activate or deactivate the PWM command of the converters.</p> <p></p> <p>We have two blocks here, we will focus on them to generate our code. The first one is the application_loop_task which works at a period of 100ms. Currently it is empty, but it will allow us later to define voltage reference and duty cycle here. </p> <p></p> <p>On the other hand the control_loop_task is faster, and works at 10kHz. We will typically use this block for all the critical tasks (sending the pwm command, PID implementation..). For now, the control_loop blocks contains a block called Interleaved_ON and depending on the value of pwr_enable, this block is supposed to activate the converter drivers. This block is currently commented to not activate the converter, we will uncomment it later on this tutorial.  </p> <p>This concludes the presentation of the simulink template, before generating any code we will need to make some configuration with the serial monitor to visualize data and also send commands.</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#serial-monitor-setting","title":"Serial monitor setting","text":"<p>If you check the main file (main.cpp) in the src folder, you will notice that we have essentially two modes :</p> <pre><code>enum serial_interface_menu_mode //LIST OF POSSIBLE MODES FOR THE OWNTECH CONVERTER\n{\n    IDLEMODE =0,\n    MATLABMODE\n};\n</code></pre> <p>The idle mode will turn off the PWM signal sent to the converters, while the matlab mode will execute the generated code. If you look at the loop_communication_task inside the main file, you will see all the commands needed to activate either the idle mode or the matlab mode, but also to use the increase <code>Up_function()</code> and decrease <code>Dwn_function()</code> functions defined in the simulink template. For example, if we send \u201cm\u201d to the serial monitor, we will switch to the matlab mode.</p> different modes and command to send<pre><code>void loop_communication_task()\n{\n    while(1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n            case 'h':\n                //----------SERIAL INTERFACE MENU-----------------------\n                printk(\" ________________________________________\\n\");\n                printk(\"|     Communication task Tutorial        |\\n\");\n                printk(\"|     ------- MENU ---------             |\\n\");\n                printk(\"|     press i : idle mode                |\\n\");\n                printk(\"|     press m : matlab generated code    |\\n\");\n                printk(\"|     press u : increment variable       |\\n\");\n                printk(\"|     press d : decrement variable       |\\n\");\n                printk(\"|________________________________________|\\n\\n\");\n                //------------------------------------------------------\n                break;\n            case 'i':\n                printk(\"idle mode\\n\");\n                mode = IDLEMODE;\n                break;\n            case 'm':\n                printk(\"Matlab generated code\\n\");\n                mode = MATLABMODE;\n                break;\n            case 'u':\n                printk(\"increase!\\n\");\n                Up_function();\n                break; \n            case 'd':\n                printk(\"decrease!\\n\");\n                Dwn_function();\n                break;    \n            default:\n                break;\n        }\n    }\n}\n</code></pre> <p>We will use ownplot as a serial monitor, go to this github page.</p> <p>Then click on release :</p> <p></p> <p>Depending on your OS, choose the correspondig binary file and download it : </p> <p></p> <p>Execute the binary file to launch ownplot, start it and open the \u201csend\u201d tab. First we will set the commands.</p> <p></p> <p>In (1) enter the command\u2019s name (eg: decrease), in (2) the data associated to this command that we will send and finally press (3) to save the command. Repeat this process three time for the other command (idle-i, matlab_mode-m and increase-i).</p> <p></p> <p>In the \u201csetting\u201d tab, check that you have the same parameters.</p> <p></p> <p>With the serial monitor we can visualize current and voltage from the sensor, in the \u201cchart\u201d tab rename the dataset to have the following names in exactly the same order</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#adding-platformio-command-to-the-system-path","title":"Adding platformIO command to the system path","text":"<p>This process depends on your OS: </p> WindowsLinux <p>It is necessary to add C:\\Users\\ user \\.platformio\\penv\\Scripts (user is your user name on the computer) to your system path. We recommend that you follow this guide.</p> <p>You can call this command from matlab command window: <code>setenv(\"PATH\",[getenv(\"PATH\"),':/home/username/.platformio/penv/bin'])</code> Where home is your home directory and username is your user name. If your platformio is installed somewhere else, please change this path.</p> <p>You are now all set to generate your first code !</p>"},{"location":"Matlab/docs/first_compilation_with_matlab/#how-to-generate","title":"How to generate","text":"<p>We can try to compile and flash the board with this empty template to make sure that embedded coder work. </p> <p>Go to the app tab and then select Embedded Coder :</p> <p> </p> <p></p> <p>After the code generation, matlab will automatically flash the code to the board. If everything went well, you should see this window appears :</p> <p>If not, make sure that your current working directory is matlab_files, that the board is turned on and connected to your computer or that you have added \u201cC:\\Users\\user.platformio\\penv\\Scripts\u201d to the system path.</p>"},{"location":"Matlab/docs/getting_started/","title":"Gettings started with matlab","text":"<p>Matlab with the Embedded Coder add-on, is employed in the embedded field to generate code directly from Simulink blocksets. By integrating Owntech APIs as blocksets, the Embedded Coder allows you to accelerate the code generation process from your Simulink designs.</p> <p> Image : Example of implementation of PID with Owntech Blockset in Simulink</p> <p>Owntech blocksets might be useful for you if:</p> <ul> <li>You work in fields like research and development, simulation, or other areas where Matlab/Simulink is used regularly.</li> <li>You are interested in quickly generating and deploying code using Simulink blocksets and the Embedded Coder add-on.</li> </ul> <p>Tip</p> <p>It is not required, but you can try to follow first this tutorial to become familiar with owntech hardware and software.</p> <p>Abstract</p> <ul> <li>A TWIST power board</li> <li>A 50V power supply</li> <li>A resistive load (like an electronic load, or a variable resistive load)</li> </ul> <p>Abstract</p> <ul> <li>Matlab-Simulink</li> <li>Embedded coder toolbox</li> <li>Visual Studio Code with PlatformIO</li> </ul>"},{"location":"Matlab/docs/open_loop_buck/","title":"Open loop buck control","text":"<p>This section of the tutorial will show you how you can generate a code to control the converter in open-loop mode with the simulink template.</p> <p></p> <p>First let\u2019s start by creating a variable which will represents the duty cycle. Take a \u201cdata store memory\u201d block from simulink, to the root (where pwr_enable is located).</p> <p></p> <p>Name this data store block duty_cycle, and in the signal attribute tab choose the initial value (0.5 here to have 50% duty cycle) and data type (double or float):</p> <p></p> <p></p> <p>Then enter inside the increase function block, take a \u201cdata store read\u201d and a \u201cdata store write\u201d from simulink library and link them with duty_cycle (name them duty_cycle). With the association of the \u201cconstant\u201d and \u201cadd\u201d block from simulink you can form the following schema.</p> <p></p> <p>You can do the same thing in the decrease function block, instead of an addition it will be a subtraction.</p> <p>You have now the possibility to control the duty_cycle either by increasing or decreasing it, the only thing missing is sending this value to the converters. Inside control_loop_task, we will first uncomment the <code>POWER_ON</code> to activate power : click on the block then press ctrl+shift+x. We will then place a \u201cdata store read\u201d block linked to duty_cycle and a <code>set leg duty</code> block connected together.</p> <p></p> <p>Then generate the code, matlab will upload it automatically to the board :</p> <p></p> <p>Finally, switch to ownplot, open the correct port and send the matlab_mode to execute the generated code, use increase and decrease function to control the duty cycle\u00a0:</p> <p></p>"},{"location":"OwnModels/","title":"OwnModels","text":"<p>Repository that gathers all models of the OwnTech foundation.</p>"},{"location":"OwnModels/docs/first_example/","title":"First model example with PLECS","text":"<p>This page shows how to run your first example of a PLECS based OwnTech model.</p>"},{"location":"OwnModels/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> </ul>"},{"location":"OwnModels/docs/first_example/#running-the-open-loop-model-for-the-first-time","title":"Running the open loop model for the first time","text":"<p>We have developed a first model that you can run out-of-the-box. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Open loop folder. Choose the Twist_open_loop.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. At 1 milisecond, the Twist board starts to operate and voltage goes up to around half of the generator voltage, as expected for a 50% duty cycle setup.</p>"},{"location":"OwnModels/docs/first_example/#analyzing-the-model-a-little-further","title":"Analyzing the model a little further","text":"<p>The open loop model will allow you to explore how the twist board operates.</p> <p>The model input is a standard voltage source with an inductive impedence and a bus capacitor.</p> <p>The output is a 1 Ohm resistor.</p> <p>You are now able to run simulations. The next step is to run closed loop simulations using this model.</p>"},{"location":"OwnModels/docs/getting_started/","title":"Gettings started with PLECS","text":"<p>PLECS is a software tool for system-level simualtions of electrical circuits developed by Plexim. It is not open-source, but it remains very accessible, which is a reason why we adopted it as one of the solutions to model our power converters. In this section we will explain to you how to get started with PLECS and run your first simulation.</p>"},{"location":"OwnModels/docs/getting_started/#installing-plecs","title":"Installing PLECS","text":"<p>To install PLECS, go to their website and download the standalone package. Choose your platform and follow the instructions.</p> <p>PLECS LICENSE</p> <p>There are three ways where you can use PLECS. Choose the one of your convenience.</p> Trial licenseDemo modeJCGE 2024 special license <p>PLECS provides a 90 days trial license for its products. Follow their dedicated page to get yours.</p> <p>If you do not want to ask for a license, you can still use PLECS in its demo mode. You will still be able to run the simulations, but you will not be able to modify the model or save its data.</p> <p>During the JCGE 2024 conference we will provide you with a special license that you can get with by clicking here.</p> <p>This License will expire on June 23rd 2024.</p> <p>Once PLECS is installed, you will see its library browser. You are now ready to start working with OwnModels.</p> <p></p>"},{"location":"OwnModels/docs/getting_started/#getting-the-ownmodels-plecs-library","title":"Getting the OwnModels PLECS library","text":"<p>This section will show you how to add the OwnTech library to your PLECS instance.</p> <p>Step 1 - Go to the OwnModels repository of the owntech foundation github. Either clone it locally (if you know how to use git) or download the zip file.</p> <p></p> <p>Step 2 - Unzip the file if you use zip. Keep the path at hand.</p> <p>Step 3 - In PLECS Library Browser go to File-&gt;PLECS Preferences</p> <p></p> <p>Step 4 - In PLECS Preferences click on the Libraries tab. You will see two sub blocks, search path and user libraries.</p> <p></p> <p>Step 5 - In Libraries-&gt;Search path click on the + icon and navigate to the owntech-lib folder. Click on Choose.</p> <p></p> <p></p> <p>Step 7 - In Libraries-&gt;User libraries click on the + icon and navigate to the Owntech_lib.plecs file. Click on Open.</p> <p></p> <p></p> <p>Step 8 - Rename the library name from User Library 1 to OwnTech. Click on Apply and Ok to finish.</p> <p></p> <p></p> <p>Step 9 - Verify that the library is correctly added to the Library Browser.</p> <p></p> <p>You are now ready to run your first PLECS example.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/","title":"Voltage mode simulaton","text":"<p>This page shows how to run a closed loop voltage mode PLECS based OwnTech simulation.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have installed and configured the licence of your PLECS instance</li> <li>Setup the OwnTech PLECS library.</li> <li>Successfully Run an open-loop simulation.</li> </ul>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model","title":"Running the closed loop model","text":"<p>The closed loop model is much similar to its open-loop equivalent. Here are the steps to launch it.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then steadly rises to track its reference of 15 volts.</p> <p>Speed</p> <p>You will notice that this simulation is significantly slower than the open-loop. This is normal as the model used was a switched one. These models are precise, requiring longer to run.</p>"},{"location":"OwnModels/docs/voltage_mode_simulation/#running-the-closed-loop-model-averaged-version","title":"Running the closed loop model - AVERAGED version","text":"<p>We will now run the averaged version of the closed loop voltage mode model. The idea here is to show you how a less precise model is much faster.</p> <p>Step 1 - In PLECS Library Browser go to File-&gt;Open</p> <p></p> <p>Step 2 - Navigate to the Voltage Mode Buck folder. Choose the Twist_voltage_mode_buck_AVG.plecs and click Open*.</p> <p></p> <p>Step 3 - You will see the model and a scope window. Notice that there is a discrete PI controller attached to the PWM generator. Press Ctrl+T on your computer or click on Simulation-&gt;Start.</p> <p></p> <p>Step 4 - The simulation will run its course and give you the results as in the image below.</p> <p></p> <p>You can see an initial in-rush current for loading the Twist board capacitors. The voltage then rises to track its reference of 15 volts.</p> <p>Speed</p> <p>Notice how much faster this model is. Using averaged models allows for much faster iteration and study of the system in steady-state conditions. It can also be used whenever the study is much more focused on system-level behavior rather than switching.</p> <p>You are now ready to start working on a droop control example.</p>"},{"location":"OwnPlot/","title":"OwnPlot","text":"<p>OwnPlot is a free and opensource data plotter software designed to work with OwnTech's dev board. </p> <p>However, everybody can use this software as a data plotter with any devboard.</p>"},{"location":"OwnPlot/#why-create-another-plotting-app-from-scratch","title":"Why create another plotting app from scratch","text":"<p>After testing the most popular plotting app, we realized that it was not an easy task to run the app on all systems without tweaking. We also want to add power electronics-specific features in the near future. We are glad to present an easy-to-use and painless installation app.</p> <p>And most of all, it's free! Happy plotting \ud83d\ude01</p>"},{"location":"OwnPlot/#how-to-use-it","title":"How to use it","text":"<p>Go to the settings tab to specify the data format that your devboard is sending. Then select the right port and open it. You can pause both chart and terminal with the top right button. Once you are done, you can close the port (it will close when you close the app anyway).</p> <p>You can custom the chart layout under chart tab. Click on a channel in the legend to change its layout.</p> <p>A record feature is also available. You have to click play under the record tab. Do not forget to download the file !</p> <p>Send command to your devboard through the command tab ! You can add buttons if you have to send the same data regularly.</p>"},{"location":"OwnPlot/#running-the-development-environment","title":"Running the development environment","text":"<p>First of all, open the terminal of your choice. If you are using Windows, we recommand the use of git bash https://www.git-scm.com/downloads</p> <ol> <li> <p>type: \\     <code>node --version</code></p> <ul> <li>If the command prompt tells you node isn't present on your computer, then download and install nodejs thru this website:     https://nodejs.org/en/download/</li> <li>If the version is inferior than version 14.x.x then you'll need to update nodejs. <code>nvm</code> is a great little piece of kit that will make your life a lot easier   https://github.com/nvm-sh/nvm</li> </ul> <p>Note: version <code>18.7.0</code> is recommanded</p> </li> <li> <p>Clone the repository:</p> <ul> <li> <p>If you have a gitlab accound and a ssh key linked to this one, clone with this command instead: \\ <code>git clone git@gitlab.laas.fr:owntech/ownplot.git</code></p> </li> <li> <p>Otherwise use this command: \\ <code>git clone https://gitlab.laas.fr/owntech/ownplot.git</code></p> </li> </ul> </li> <li> <p>Go the the newly created folder: \\ <code>cd ownplot</code></p> </li> <li> <p>Install the decencies: \\ <code>npm install</code></p> </li> <li> <p>Run the development environment: \\ <code>npm start</code></p> </li> </ol> <p>Congrats! \ud83e\udd73 \\ A window should be opened with OwnPlot.</p> <p>If you are experiencing problems during the install, please post an issue and report the problem. This will greatly help us improve the user experience.</p>"},{"location":"OwnPlot/#build-for-your-plateform","title":"Build for your plateform","text":"<p>Run  - <code>npm run pack-win</code> for the <code>.exe</code> installer - <code>npm run pack-linux</code> for the <code>.deb</code>, <code>.rpm</code> and <code>.AppImage</code> - <code>npm run pack-mac-uni</code> for the <code>.dmg</code></p> <p>Note: Only a mac can build all the plateforms.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [owntech@laas.fr]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"OwnPlot/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"OwnPlot/CONTRIBUTE/","title":"Contribute to OwnPlot","text":"<p>Welcome ! Thank you for your interest in OwnPlot. We would greatly appreciate your involvement in the project if you wish.</p> <p>You will find in this file some informations to guide you through the contributing process.</p>"},{"location":"OwnPlot/CONTRIBUTE/#summary","title":"Summary","text":"<ul> <li>Community guidelines</li> <li>Bug Report</li> <li>Suggest Feature</li> <li>Contribute to the code base</li> <li>Contact for further questions</li> </ul>"},{"location":"OwnPlot/CONTRIBUTE/#community-guidelines","title":"Community guidelines","text":"<p>Always be nice to other contributors. Be constructive and understanding when interacting with someone. Read and then follow the Code of Conduct at all times.</p>"},{"location":"OwnPlot/CONTRIBUTE/#bug-report","title":"Bug Report","text":"<p>Please report bugs within the gitlab repository by creating a new issue. Use the bug issue template and try to be as descriptive as possible. Always check first if a similar issue already exists or has been closed.</p>"},{"location":"OwnPlot/CONTRIBUTE/#suggest-feature","title":"Suggest Feature","text":"<p>Feel free to make any suggestion that would improve the user experience. To do so, please use the feature issue template in the gitlab repository.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contribute-to-the-code-base","title":"Contribute to the code base","text":"<p>If you want to get involved further, you can write and modify the existing code base available at the gitlab OwnPlot repository. Your modifications should always be related to an issue. You can submit a feature/bug issue if no one answers your problematic. The code base is clearly not perfectly written so far. Code related improvements are welcomed if they make code easier to understand, more compact, faster to execute. A related issue template is available.</p>"},{"location":"OwnPlot/CONTRIBUTE/#coding-style","title":"Coding Style","text":"<p>Always try to make your code as readable as possible as other people will work on it. Names should be as descriptive as possible. Here is a guide that we try to follow when writing code, so please try to stick to it too. Do not worry if you do not achieve to write a perfect piece of code, just try to be clear about what you are trying to code. Comments are precious friends, but should not be redudant with explicit lines of code. Explicit naming should be your first concern. Other contributors can help you, do not hesitate to ask for help.</p>"},{"location":"OwnPlot/CONTRIBUTE/#submit-your-modifications","title":"Submit your modifications","text":"<p>Please begin with creating a branch, which name should be XXXX_nameOfTheBranch, considering XXXX as the number of the corresponding issue. Then add and commit changes everytime an improvement has been brought to the code, but always ensure that each commit is atomic (brings a full modification and is functionnal). Consider reading this page for a clear explanation of good practice in commits. Finally ask for a pull request that will be examined as soon as possible.</p>"},{"location":"OwnPlot/CONTRIBUTE/#contact-for-further-questions","title":"Contact for further questions","text":"<p>OwnPlot is an open-source software created and maintained by the OwnTech Foundation. It is delivered with the GNU LGPL v2.1 Licence. An overview of our work is available at our website. Contact us at owntech@laas.fr, or join our Discord.</p> <p>Thank you for your involvement. See you soon !</p>"},{"location":"OwnPlot/LICENCE/","title":"Licence","text":"<p>OwnPlot, the OwnTech data plotter. Copyright (C) 2022 OwnTech Foundation.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p> <p>Contact the OwnTech Foundation by email at [owntech@laas.fr].</p> <p>Full licence is available at: https://opensource.org/licenses/LGPL-2.1.</p>"},{"location":"OwnPlot/docs/","title":"Index","text":""},{"location":"OwnPlot/docs/#welcome-to-ownplot","title":"Welcome to OwnPlot!","text":"<p>This documentation will help you use and develop for OwnPlot.</p> OwnPlot is a Free and OpenSource plotter written in Electron"},{"location":"OwnPlot/docs/#documentation","title":"Documentation","text":"<p>The documentation is split between the User Manual and the Developer Manual</p> <p> User Manual</p> <p> Dev Manual</p>"},{"location":"OwnPlot/docs/#user-manual","title":"User Manual","text":"<p>The User Manual will guide you through all of OwnPlot's features.</p>"},{"location":"OwnPlot/docs/#developer-manual","title":"Developer Manual","text":"<p>The Dev Manual will help you understand the architecture and will permit you to add features and contribute to OwnPlot's development.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/","title":"Files description","text":""},{"location":"OwnPlot/docs/dev-manual/arch/#main-files","title":"Main files","text":"<p>These files are located at the root of the repo. - main.js Program Starting Point. This file sets up the windows as well as default configurations.  This also loads user configuration. This file will render index.ejs - index.ejs The main skeleton of OwnPlot. This file includes other .ejs files present in the template folder</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files","title":"Template files","text":"<p>Files used to describe skeletons of the different parts of OwnPlot. - header.ejs This file includes stylesheets and some scripts. description needed - navBar.ejs The navigation hub of OwnPlot. This file permits to change the main view. screenshot of the navbar. - portBar.ejs description needed - tabs.ejs description needed - apps.ejs description needed - myTerminal.ejs description needed - footer.ejs Closing the HTML tag.</p>"},{"location":"OwnPlot/docs/dev-manual/arch/#template-files_1","title":"Template files","text":""},{"location":"OwnPlot/docs/dev-manual/home/","title":"Development Manual","text":""},{"location":"OwnPlot/docs/dev-manual/home/#setting-up-a-dev-environment","title":"Setting up a dev environment","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#dev-board-demo-code","title":"Dev board demo code","text":"<p>In order to transmit data to OwnPlot, your device must send data through a serial port. This serial port on dev boards is in most cases USB based.</p> <p>This page will provide you with sample codes that will make those dev boards \"talk\" in the serial port.</p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#sawtooth-demo-code","title":"Sawtooth demo code","text":"<p>This code will generate sawteeth with ASCII formatting.</p> <p>You can change the number of datasets by modifying the <code>#define numberOfTriangles 3</code> statement. The default value is 3.</p>  SPIN Arduino <p>Info</p> <p>If you need to familiarize yourself with OwnTech's SDK, please start here</p> <pre><code>#include \"TaskAPI.h\"\n#include \"SpinAPI.h\"\n#include \"zephyr/console/console.h\"\n\nvoid setup_routine();\nvoid loop_communication_task();\nvoid initTriangles();\nint main();\n\n#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nuint8_t received_serial_char;\nuint8_t state = 1;\n\nvoid setup_routine() {\n    spin.version.setBoardVersion(SPIN_v_1_0);\n    uint32_t com_task_number = task.createBackground(loop_communication_task);\n    task.startBackground(com_task_number);\n}\n\nvoid loop_communication_task()\n{\n    while (1) {\n        received_serial_char = console_getchar();\n        switch (received_serial_char) {\n        case 's':\n            state ^= 1;\n            break;\n        default:\n            break;\n        }\n        k_msleep(100);\n    }\n}\n\nvoid initTriangles() {\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nint main() {\n    setup_routine();\n    initTriangles();\n    while (1) {\n        if (state) {\n            for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n                printk(\"%d:\", triangles[i]);\n            }\n            printk(\"%d\\n\", triangles[numberOfTriangles - 1]);\n            for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n                triangles[i] = triangles[i] + numberPoints;\n            }\n        }\n        k_msleep(50);\n    }\n    return 0;\n}\n</code></pre> <p>Here is the demo code. Tested on an Arduino Uno and Mega. <pre><code>#define numberOfTriangles 3\nuint16_t maxValue = 256;\nuint8_t triangles[numberOfTriangles];\nuint8_t numberPoints = 4;\nint incomingByte;\nuint8_t state = 1;\n\nvoid setup() {\n    Serial.begin(115200);\n    initTriangles();\n}\n\nvoid initTriangles() {\nfor (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n    triangles[i] = (maxValue / numberOfTriangles) * i;\n    }\n}\n\nvoid loop() {\nincomingByte = Serial.read();\nif (incomingByte &gt; 0) {\n    if (incomingByte == 's') {\n        state ^= 1;\n    }\n}\nif (state) {\n    for (uint8_t i = 0; i &lt; numberOfTriangles - 1; i++) {\n        Serial.print(triangles[i]);\n        Serial.print(\":\");\n    }\n    Serial.println(triangles[numberOfTriangles - 1]);\n    for (uint8_t i = 0; i &lt; numberOfTriangles; i++) {\n        triangles[i] = triangles[i] + numberPoints;\n    }\n}\ndelay(100);\n}\n</code></pre></p>"},{"location":"OwnPlot/docs/user-manual/dev-board-demo/#result","title":"Result","text":"<p>In either case, you will get the same sawteeth in OwnPlot. To open the port, please refer to this page.</p>"},{"location":"OwnPlot/docs/user-manual/first-steps/","title":"My First Port","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#first-steps","title":"First Steps","text":""},{"location":"OwnPlot/docs/user-manual/first-steps/#open-a-port","title":"Open a port","text":"<ol> <li>Select the send tab (This will spawn the graph)</li> <li>Plug in a SPIN or an Arduino talking on the serial port. if you want to test this, sample programs will be available later.</li> <li> <p>Select the corresponding serial port in the port dropdown</p>  Windows macOS Linux <p>The port will start with COM TODO: PIC { width=\"300\" }</p> <p>The port will most likely start with /dev/tty.usbserial but your mileage may vary. </p> <p>The port will most likely start with /dev/tty.usb but your mileage may vary. TODO: PIC { width=\"300\" }</p> </li> <li> <p>Open the port by clicking the \"Open\" button</p> <p></p> </li> <li> <p>You should observe the data coming from the serial port in the terminal and data points should appear on the graph.</p> <p></p> </li> </ol> <p>Troubleshooting</p> <ul> <li>if you have trouble seeing the desired port, check out the troubleshooting guide</li> </ul>"},{"location":"OwnPlot/docs/user-manual/home/","title":"Home","text":""},{"location":"OwnPlot/docs/user-manual/home/#user-manual","title":"User Manual","text":"<p>Welcome to the OwnPlot's user manual. This documentation will help you familiarize yourself with OwnPlot and understand all its features. If you find a mistake or a malfunction of OwnPlot, please report the issue Here .</p>"},{"location":"OwnPlot/docs/user-manual/home/#start-here","title":"Start Here","text":"<p>If you are a new user of OwnPlot, please start here.</p>"},{"location":"OwnPlot/docs/user-manual/home/#download-setup","title":"Download &amp; Setup","text":""},{"location":"OwnPlot/docs/user-manual/home/#dev-board-demo-code","title":"Dev board demo code","text":""},{"location":"OwnPlot/docs/user-manual/home/#my-first-port","title":"My first port","text":""},{"location":"OwnPlot/docs/user-manual/home/#components","title":"Components","text":""},{"location":"OwnPlot/docs/user-manual/home/#tabs","title":"Tabs","text":""},{"location":"OwnPlot/docs/user-manual/home/#terminal","title":"Terminal","text":""},{"location":"OwnPlot/docs/user-manual/home/#plotter","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/setup/","title":"Setup","text":""},{"location":"OwnPlot/docs/user-manual/setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"OwnPlot/docs/user-manual/setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"OwnPlot/docs/user-manual/setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p> <p>Great! Now that you have OwnPlot installed and all setup, we can proceed to your first steps with OwnPlot.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/","title":"Troubleshooting","text":""},{"location":"OwnPlot/docs/user-manual/troubleshooting/#port-finding","title":"Port finding","text":"<p>If you can't see the port you are looking for, try to unplug and plug in the dev board to another port. You can try to reflash the sample program.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#antivirus","title":"Antivirus","text":"<p>It has been reported that some antivirus like Norton Antivirus can cause problems while downloading OwnPlot. If you have trouble downloading OwnPlot, please disable or trust the executable file.</p>"},{"location":"OwnPlot/docs/user-manual/troubleshooting/#empty-canvas","title":"Empty canvas","text":"<p>By default, no activities are loaded into OwnPlot (this might change in the future). Select any tab like the send tab to load the graph and terminal</p>"},{"location":"OwnPlot/docs/user-manual/Components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/Components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/Components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/Components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/Components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/Components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"OwnPlot/docs/user-manual/components/plotter/","title":"Plotter","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/","title":"Tabs","text":"<p>The tabs of OwnPlot splits all the settings and functions of the app between different pages. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#send-tab","title":"Send Tab","text":"<p>Purpose: The send tab is dedicated to \"Send\" data to the selected serial port. The most important field is </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#settings-tab","title":"Settings Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#chart-tab","title":"Chart Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#record-tab","title":"Record Tab","text":""},{"location":"OwnPlot/docs/user-manual/components/tabs/#mockports-tab","title":"Mockports Tab","text":"<p>The Mockports tab hosts the setup of the Mockport 4 (File reader).</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#file-reader","title":"File reader","text":"<p>You can upload a file recorded from the Record tab and play it back. </p> <p>Note</p> <p>You have to select the Mockport 4 in the port selector in order to upload a record file.</p> <p>By default, the data will be read once and the port will automatically close.  You can change this behavior by pressing the Loop Data button. This will read the available data in the provided file and restart the process every time the end file has been reached.</p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#interval","title":"Interval","text":"<p>You can also change the interval of points using the interval (ms). the smaller the number, the more data points per second will appear in the graph. </p>"},{"location":"OwnPlot/docs/user-manual/components/tabs/#controls-tab","title":"Controls Tab","text":"<p>The Controls tab enables you to set shortcuts for common actions.</p> Shortcut Action Manual action Ctrl + Enter Opens/Closes the current port click on the open/close button in the port bar Ctrl + BackSpace Clear the char/plotting data click on the clear button in the port bar Ctrl + Space Run and stop plotting click on running/paused button in the port bar Ctrl + digit 1 switch to Tab1 (Send Tab) click on the Send Tab Ctrl + digit 2 switch to Tab2 (Settings Tab) click on the Settings Tab Ctrl + digit 3 switch to Tab3 (Chart Tab) click on the Chart Tab Ctrl + digit 4 switch to Tab4 (Record Tab) click on the Record Tab Ctrl + digit 5 switch to Tab5 (Mockports Tab) click on the Mockports Tab Ctrl + digit 6 switch to Tab6 (Controls Tab) click on the Controls Tab"},{"location":"OwnPlot/docs/user-manual/components/terminal/","title":"OwnPlot's terminal","text":"<p>Understanding OwnPlot's terminal and its features.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#settings","title":"Settings","text":""},{"location":"OwnPlot/docs/user-manual/components/terminal/#a-quick-word","title":"A quick word","text":"<p>As of today, the terminal is not independent. It relies on the graph data to show information. Consequently, some settings are linked with the graph. Moreover, the data is coming from the port, so a lot of standard settings for this type of application are related to the port.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#main-terminals-settings-section","title":"Main terminal's settings section","text":"<p>Most of the terminal settings live under the Settings tab.</p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#lines-history","title":"Lines history","text":"<p>To set the maximum number of lines stored in the terminal, enter a number between 0 and 1000 in the input field # Lines </p>"},{"location":"OwnPlot/docs/user-manual/components/terminal/#timestamp","title":"Timestamp","text":"<p>The timestamp option permits to log the time aside of the data. It is enabled by default (green button) and can be disabled by pressing the timestamp button (it will become yellow). </p> <p>The timestamp in the terminal is the part preceding the data. </p>"},{"location":"bootloader/docs/getting_started/","title":"Bootloader","text":"<p>OwnTech use its own bootloader in order to be able to flash code using USB without the use of a dedicated debug tool.  It is based on MCUBoot an open source bootloader supported by the zephyr ecosystem. </p>"},{"location":"bootloader/docs/getting_started/#features","title":"Features","text":"<ul> <li>USB compatible</li> <li>Supports Over The Air (OTA) updates</li> <li>Image validation </li> <li>Encryption ready</li> </ul>"},{"location":"bootloader/docs/getting_started/#boot-sequence","title":"Boot sequence","text":"<p>When pressing reset button the following happens : </p> <ul> <li>Program initiates at 0x80000000, and bootloader is launched.</li> <li>Bootloader jumps at Image-0 address at 0x8010000.</li> </ul>"},{"location":"bootloader/docs/getting_started/#nomal-upload-sequence","title":"Nomal Upload sequence","text":"<p>When pressing upload button the following happens : </p> <p></p> <ul> <li>Image-1 is the memory bank where the program is uploaded using USB or via STLink</li> <li>When the USB transfer is complete, a reboot order is sent to the board. </li> </ul> <ul> <li>Image is marked for testing</li> <li>A memory swap is performed. Image-1 is sent to memory bank 0 at the address 0x8010000 and Image-0 is sent to memory bank 1 at the address 0x8047800. </li> <li>A boot test is performed.</li> <li>If the initialization is successful, the new program is marked as good and stays in image-0.</li> <li>Otherwise, the image is rejected and the swap action is reverted. </li> <li>After that, application code is executed normally from address 0x8010000</li> </ul> <p>Note</p> <p>This bootloading sequence is complex but has advantages. If your program has an issue during initialization, the bootloader will detect it and will reject the     image. </p> <p>After a Reset, the previous working program will be launched, recovering the board from a non functional program that would have otherwise bricked it.</p> <p>Warning</p> <p>Image swapping requires having a valid image at address 0x8010000. </p> <p>If no image-0 is present normal upload sequence will fail. </p> <p>If you observe serial messages using an STlink, you will receive a message like below </p> Serial Port<pre><code>*** Booting Zephyr OS build zephyr-v3.5.0 ***\nI: Starting bootloader\nI: Primary image: magic=good, swap_type=0x1, copy_done=0x3, image_ok=0x3\nI: Secondary image: magic=good, swap_type=0x1, copy_done=0x3, image_ok=0x3\nI: Boot source: none\nW: Failed reading image headers; Image=0\n</code></pre> <p>Tip</p> <p>In that case use Recovery Mode to upload a valid Image-0 and proceed again.</p>"},{"location":"bootloader/docs/getting_started/#recovery-mode","title":"Recovery Mode","text":"<p>The OwnTech bootloader has a recovery mode in order to flash directly the Image-0 without performing a swap action. This mode is really helpfull to recover the board when something went wrong.</p> <p>Tip</p> <p>To enter recovery mode, press BOOT button and RESET button simultaneously.  </p> <p>Success</p> <p>When entering recovery mode, the user LED should light up</p> <p>When pressing the upload button in recovery mode the following happens : </p> <p></p> <ul> <li>User program is written at the address 0x8010000 directly. </li> <li>A reboot is performed and the bootloader jumps to user code at address 0x8010000.</li> </ul> <p>Note</p> <p>Recovery mode is significantly slower than Normal Upload Sequence.</p>"},{"location":"bootloader/docs/getting_started/#how-it-works","title":"How it works","text":"<p>USB upload uses what is called a magic baudrate callback. When pressing the upload button:  </p> <ul> <li>The user code is compiled, creating a bin executable.</li> <li>A trailer containing meta-data is added to the bin file, and the executable is marked for testing.  </li> <li>The USB serial disconnects and reconnects using the magic 1200Baud baudrate. </li> <li>That baudrate is detected and it triggers a reboot order to switch in bootloader mode.</li> <li>On the computer side, a small program called MCUMgr is called to upload the user code image to the microcontroller (it is located in owntech/third_party/mcumgr - if it is not present, it will be downloaded automatically.)</li> <li>When upload is finished, a reboot order is sent</li> <li>Bootloader starts and detects the new image trailer marked for testing.</li> <li>Bootloader performs the swap action</li> <li>Bootloader jumps to user application at address 0x8010000 and USB serial is available again.</li> </ul>"},{"location":"controlLibrary/","title":"control_library","text":"<p>Control and dsp algorithms for owntech converters</p> <p>This library has been integrated and tested on TWIST converters using SPIN controller.</p> <p>The integration is based on the dedicated OwnTech Power API.</p> <p>Remarks: The library is currently not optimized to make it easier to read (we hope).</p>"},{"location":"controlLibrary/#features","title":"Features","text":"<p>The library provides the following functionalities mainly through C++ objects :  * <code>Pid()</code>: Standard form of the PID regulator.  * <code>Pr()</code>: Proportional Resonant regulator.  * <code>Rst()</code>: Discrete form of Polynomial regulator.  * <code>PllSinus()</code>: Software PLL (Phased Lock Loop)  * Digital filters: <code>LowPassFirstOrdreFilter()</code>, <code>NotchFilter()</code></p> <p><code>Pid()</code>, <code>Pr()</code> and <code>Rst()</code> inherit from the <code>Controller()</code> class which define the same interface.</p>"},{"location":"controlLibrary/#installation","title":"Installation","text":"<p>We describe here the process to use it with the Power API which has been designed to use PlatformIO.</p> <p>The installation here recall the procedure of using a library in PlatformIO.</p> <p>To use the library, you need to add the line above in the <code>platformio.ini</code> file.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>You can find various examples in the OwnTech examples library </p>"},{"location":"controlLibrary/#links","title":"Links:","text":"<p>Links which inspired this work:</p> <ul> <li>PID:</li> <li>K. Astrom et T. Hagglund, Advanced PID Control.</li> <li>PR:</li> <li>A. G\u00ef, \u00ab\u00a0Digital Resonant Current Controllers For Voltage Source Converters\u00a0\u00bb. Thesis</li> <li>RST:</li> <li>I. D. Landau, C. Cyrot, A. Voda, et D. Rey, \u00ab\u00a0Robust digital control of flexible structures using the combined pole placement/sensitivity function shaping method\u00a0\u00bb, in Proceedings of 1994 American Control Conference - ACC \u201994, Baltimore, MD, USA: IEEE, 1994, p. 283\u2011288. doi: 10.1109/ACC.1994.751743.</li> <li>I. D. Landau et G. Zito, \u00ab\u00a0Digital Control Systems - New edition (I. D. Landau &amp; G. Zito)\u00a0\u00bb, 2020, doi: 10.13140/RG.2.2.19321.49764.</li> <li>PLL:</li> <li>F. D. Freijedo, J. Doval-Gandoy, O. Lopez, et J. Cabaleiro, \u00ab\u00a0Robust phase locked loops optimized for DSP implementation in power quality applications\u00a0\u00bb, in 2008 34th Annual Conference of IEEE Industrial Electronics, Orlando, FL: IEEE, nov. 2008, p. 3052\u20113057. doi: 10.1109/IECON.2008.4758447.</li> </ul>"},{"location":"controlLibrary/#thanks","title":"Thanks","text":"<p>Thanks to the OwnTech contributors:</p> <ul> <li>Luiz</li> <li>Ayoub</li> <li>Guillaume</li> <li>Jean</li> <li>Clement</li> </ul>"},{"location":"controlLibrary/docs/controller/","title":"Controller","text":"<p><code>Controller</code> is an abstract class.</p> <p>The main idea is to fix the interface of a <code>controller</code>.</p> <p>Each type of controller like <code>Pid</code>, <code>RST</code> and <code>Pr</code> have then the same way of life.</p> <p>It has been thinking considering SISO (Single Input Single Output) and sample controller.</p> <p>If you want to implement a new controller type, you should consider to inherit from this class.</p>"},{"location":"controlLibrary/docs/getting-started/","title":"Getting started","text":"<p>Control library has been written in c++, the library is a set of object you can instanciate. </p> <p>Each <code>Controller</code> is in a different file (<code>pid.cpp, rst.cpp, pr.cpp</code>).</p> <p>It has mainly been developped to be used with  The OwnTech Power API based on Zephyr and integrated with PlatformIO.</p>"},{"location":"controlLibrary/docs/getting-started/#installation","title":"Installation","text":"<p>Control library has been designed to be integrated as a PlatformIO library.</p> <p>To use it, you need to add the line below in the <code>platformio.ini</code> file.</p> <p>platformio.ini</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"controlLibrary/docs/getting-started/#using-the-pid-controller","title":"Using the <code>Pid()</code> <code>Controller</code>.","text":"<p>To introduce the control library, we propose to implement a PID regulator.</p> <p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-filters/","title":"Filters module.","text":"<p>In the filters module <code>filters.h</code> there's multiple digital filter.</p> <ul> <li> <p>First Order Low Pass filter</p> <p></p> <p> LowPassFirstOrder</p> </li> <li> <p>Notch Filter</p> <p> </p> <p> Notch filter</p> </li> <li> <p>Phase Locked Loop</p> <p></p> <p> PllSinus</p> </li> </ul>"},{"location":"controlLibrary/docs/use-fir/","title":"Use <code>Fir</code> object.","text":""},{"location":"controlLibrary/docs/use-firstorder/","title":"Use First Order Low Pass Filter","text":""},{"location":"controlLibrary/docs/use-firstorder/#introduction","title":"Introduction.","text":""},{"location":"controlLibrary/docs/use-firstorder/#parameters","title":"Parameters","text":"<p>Here, the transfer function representation of the first order filter (where \\(s\\) is the Laplace variable) :  </p> \\[H(s) = \\dfrac{1}{1+\\tau.s}\\] <p>Where:</p> <ul> <li>\\(\\tau\\) is the constant time in [s].</li> </ul> <p>transfer function is sampled</p> <p>We show here the continuous transfer function of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-firstorder/#discretization","title":"Discretization","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_1.z^{-1}}{1+a_1.z^{-1}} \\\\ \\\\ H(z) = \\dfrac{b_1}{z + a_1} \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> <p>We give here the recurrence equation used to filter the \\(\\text{input}\\) signal.</p> \\[  out_k = b_1 . \\text{in}_k - a_1 . out_{k-1} \\] <p>where:</p> \\[ \\begin{align} a_1 &amp;= -exp\\left(-\\dfrac{Ts}{\\tau}\\right) \\\\ \\\\ b_1 &amp;= 1 + a_1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-firstorder/#use","title":"Use.","text":"<p>3 steps to use the first order filter</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t tau = 1e-3;               // constant time\n    const float32_t Ts = 100e-6;              // sampling time\n    myfilter = LowPassFirstOrderFilter(Ts, tau);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-notchfilter/","title":"Use Notch Filter","text":""},{"location":"controlLibrary/docs/use-notchfilter/#introduction","title":"Introduction.","text":"<p>The notch filter allow to remove a band of frequencies from an input signal.</p> <p> </p>"},{"location":"controlLibrary/docs/use-notchfilter/#parameters","title":"Parameters.","text":"<p>Here, the transfer function representation of the notch filter:</p> \\[H(s) = \\dfrac{s^2 + (2 \\pi f_0)^2}{s^2 + 2 \\pi \\Delta f .s + (2 \\pi f_0)^2}\\] <p>Where:</p> <ul> <li> <p>\\(f_0\\) is the notch frequency,</p> </li> <li> <p>\\(\\Delta f\\) is the bandwidth of the filter.</p> </li> </ul>"},{"location":"controlLibrary/docs/use-notchfilter/#discretization","title":"Discretization.","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} H(z^{-1}) = \\dfrac{b_0 + b_1.z^{-1} + b_2.z^{-2}}{ a_0 + a_1.z^{-1}+ a_2.z^{-2}} \\\\ \\\\ H(z) = \\dfrac{b_0.z^2 + b_1.z^{1} + b_2}{ a_0.z^2 + a_1.z^{1}+ a_2} \\\\ \\\\ \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[ out_k = b_0 . in_k + b_1 . in_{k-1} + b_2 . in_{k-2} - a_1 . out_{k-1} - a_2 . out_{k-2}. \\] <p>Where:</p> \\[ \\begin{align} b_0 &amp;= \\dfrac{1}{1+ \\pi . \\Delta f . T_s} \\\\ \\\\ b_1 &amp;= -2 . b_0 .\\cos(2\\pi.f_0.T_s)  \\\\ \\\\ b_2 &amp;= b_0 \\\\ \\\\ a_1 &amp;= b_1 \\\\ \\\\ a_2 &amp;= 2 b_0 - 1 \\end{align} \\]"},{"location":"controlLibrary/docs/use-notchfilter/#use-of-the-notchfilter-object","title":"Use of the <code>NotchFilter</code> object.","text":"<p>3 steps to use the notchfilter.</p> 1. Declaration.2. Initialisation.3. Execution. <pre><code>    #include \"filters.h\"\n\n    const float32_t f0 = 50.0;               // notch frequency [Hz]\n    const float32_t bandwidth = 5.0;         // notch bandwidth [Hz]\n    const float32_t Ts = 100e-6;              // sampling time [s]\n    myfilter = NotchFilter(Ts, f0, bandwidth);\n</code></pre> <p>Before to run, we advise to <code>reset</code> the filter, in the <code>setup_routine()</code> of the OwnTech Power API.</p> <pre><code>myfilter.reset();\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code>.</p> <pre><code>signal_filtered = myfilter.calculateWithReturn(signal_to_filter);\n</code></pre> <p>It returns the data filtered.</p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pid/","title":"PID <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-pid/#introduction","title":"Introduction.","text":"<p>The PID  <code>Controller</code> is implemented here in a Standard form.</p> bloc diagram of standard form of a continuous PID with filtered derivative"},{"location":"controlLibrary/docs/use-pid/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the PID.</p> \\[command = K_p . \\left( \\varepsilon + \\dfrac{1}{T_i.s} .  \\varepsilon + \\dfrac{T_d.s}{1 + \\frac{T_d}{N}.s}.\\varepsilon \\right)\\] <p>where:</p> <ul> <li>\\(K_p\\) is the proportionnal gain</li> <li>\\(T_i\\) is the integration time</li> <li>\\(T_d\\) is derivative time</li> <li>\\(N\\) help to filter the derivative (typical values \\(\\in [2, 20]\\)).</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pid/#discretization","title":"Discretization:","text":"<p>This <code>Pid()</code> object is implemented using a backward euler integration method.</p> <p>We have the following discrete equation implemented:</p> \\[  \\begin{align} \\epsilon_k &amp;=  y_{ref_{k}} - y_{meas_{k}} \\\\ \\\\  i_k &amp;= i_{k-1}  + T_s . \\epsilon_k \\\\ \\\\ d_k &amp;= \\dfrac{\\epsilon_k - \\epsilon_{k-1}}{T_s} \\\\ \\\\ f_{d_k} &amp;= (1 - e^{-T_s/\\tau}) . d_k  + e^{-T_s/\\tau} . f_{d_{k-1}} \\end{align} \\] \\[ u_k = K_p .\\left( \\epsilon_k +  \\dfrac{1}{T_i} . i_k + T_d . f_{d_k}\\right) \\]"},{"location":"controlLibrary/docs/use-pid/#use-of-the-pid-controller","title":"Use of the PID <code>Controller</code>.","text":"<p>The use of the <code>Pid</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pid.h\"\n\nstatic float32_t Ti = 7.5175e-5F;\nstatic float32_t Td = 0.0F;\nstatic float32_t N = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>pid</code> which is a <code>Pid</code> object. <pre><code>static Pid pid;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pid</code> with its parameters.</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = pid.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pid calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pid/#example","title":"Example","text":"<p>You can find a pid use with the buck voltage mode example which regulates a DC voltage.</p>"},{"location":"controlLibrary/docs/use-pll/","title":"Use the software Phase Locked Loop.","text":""},{"location":"controlLibrary/docs/use-pll/#introduction","title":"Introduction","text":"<p>The <code>PllSinus</code> is used to track sinusoid and extract angle and pulsation. It is included in the <code>filters.cpp</code> module.</p> <p> block diagram of software phase locked loop <p></p>"},{"location":"controlLibrary/docs/use-pll/#parameters","title":"Parameters:","text":"<ul> <li>We set \\(f_0\\) the frequency of the signal to track linked with \\(\\omega_0=2.\\pi.f_0\\). </li> <li>\\(\\Delta \\omega\\) has been arbitrarily fixed to be 20% of \\(\\omega_0\\).</li> <li>\\(K_p, T_i\\) parameters are computed using the <code>rise_time</code> of the closed loop, which   fix the dynamic of the PLL and we have also to take into account of the <code>amplitude</code> of   the signal.</li> </ul>"},{"location":"controlLibrary/docs/use-pll/#use-of-the-pllsinus-filter","title":"Use of the <code>PllSinus</code> filter.","text":"<p>The use of the `PllSinus is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters declaration.2. Initialization.3. Execution. <p>We define constants used to initialize the parameter structure. <pre><code>#include \"filters.h\"\n\nstatic float32_t amplitude = 16.0F; // amplitude of the voltage sinus to track.\nstatic float32_t f0 = 50.0;               // frequency assumed of the signal to track [Hz]\nstatic float32_t rise_time = 50.e-3F;     // dynamic of the loop [s].\nstatic float32_t Ts = 100.0e-6F;          // sampling time [s]\n</code></pre></p> <p>We define the variable <code>pll</code> which is an instance of <code>PllSinus</code> object. <pre><code>static PllSinus pll;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>PllSinus</code> with its parameters.</p> <pre><code>pll.init(Ts, amplitude, f0, rise_time);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code></p> <pre><code>pll_datas = pll.calculateWithReturn(signal_to_track);\n</code></pre> <p><code>pll_datas</code> is a structure which kept the results of the PllSinus calculation for one step.</p> <p>the PllData structure has 3 fields: <pre><code>struct PllDatas {\n    float32_t w;     // estimated pulsation [rad/s]\n    float32_t angle; // estimated angle [rad]\n    float32_t error; // angle error [rad]\n};\n</code></pre></p> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p>"},{"location":"controlLibrary/docs/use-pll/#example","title":"Example","text":"<p>You can find a pll use with the grid following example which requires a synchronisation to inject current in parallel with a voltage source.</p>"},{"location":"controlLibrary/docs/use-pr/","title":"Proportionnal Resonant <code>Controller</code>","text":""},{"location":"controlLibrary/docs/use-pr/#introduction","title":"Introduction.","text":"<p>The Proportionnal Resonant <code>Controller</code> is dedicated to follow a sinusoidal reference.</p> <p>It is design to minimized phase shift and amplitude error.</p> Block diagram of Proportionnal Resonant controller <p>The \\(\\phi'\\) variable is dedicated to reduce delay generated by the calculation and the PWM.</p> Block diagram of Proportionnal Resonant controller including delay compensation"},{"location":"controlLibrary/docs/use-pr/#parameters","title":"Parameters:","text":"<p>Here the continuous transfer function representation of the Proportionnal resonant.</p> \\[Pr(s)=K_p + K_r \\dfrac{s \\cos(\\phi')-\\omega_0.\\sin(\\phi')}{s^2+w_0^2}\\] <p>Where:</p> <ul> <li>\\(\\omega_0\\)  is the pulsation in [rad/s]</li> <li>\\(\\phi'\\) is the compensation delay in [rad]</li> </ul> <p>controller are sampled</p> <p>We show here the continuous form of the function we want to implement. But calculation are sampled. Relationship to Laplace transform</p>"},{"location":"controlLibrary/docs/use-pr/#discretization","title":"Discretization:","text":"<p>Using the \\(z\\)-transform we get the following form:</p> \\[ \\begin{align} Pr(z^{-1}) = \\left(K_p + K_r . \\dfrac{b_0 + b_1.z^{-1}}{a_0+a_1.z^{-1}+ a_2.z^{-2}}\\right) \\\\ \\\\ Pr(z) = \\left(K_p + K_r . \\dfrac{b_0 .z^2 + b_1.z^1}{a_0.z^{2}+a_1.z^{1}+ a_2}\\right) \\end{align} \\] <p>As there's a direct relation between \\(z^{-1}\\) and \\(q^{-1}\\) the delay operator, we can write the reccuring equations we will use in the code.</p> \\[  \\begin{align} res_k &amp;= b_0.\\epsilon_k + b_1.\\epsilon_{k-1} - a_1.res_{k-1} - a_2.res_{k-2} \\\\ \\\\ u_k &amp;= K_p . \\epsilon_k + K_r .res_k \\end{align} \\] <p>With:</p> \\[ \\begin{align} a_1 &amp;= -2.\\cos(T_s . \\omega_0)\\\\ a_2 &amp;= 1.0\\\\ b_0 &amp;= T_s . \\cos(\\phi')\\\\ b_1 &amp;= -T_s . \\cos(\\phi' - T_s . \\omega_0)\\\\ \\end{align} \\]"},{"location":"controlLibrary/docs/use-pr/#use-of-the-proportionnal-resonant-controller","title":"Use of the Proportionnal Resonant <code>Controller</code>.","text":"<p>The use of the <code>Pr</code> is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"pr.h\"\n\nstatic float32_t Kp = 0.001F;\nstatic float32_t Kr = 300.0F;\nstatic float32_t w0 = 2 * PI * 50.0F;\nstatic float32_t phase_shift = 0.0F;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static  PrParams params = PrParams(Ts, Kp, Kr, w0, phase_shift, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>prop_res</code> which is a <code>Pr</code> object. <pre><code>static Pr prop_res;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Pr</code> with its parameters.</p> <pre><code>prop_res.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Remind that the <code>loop_critical_task()</code> is called every 100\u00b5s.</p> <pre><code>new_command = prop_res.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the pr calculation for one step.</p>"},{"location":"controlLibrary/docs/use-pr/#example","title":"Example","text":"<p>You can find the use with a grid forming example which generate an AC voltage source.</p>"},{"location":"controlLibrary/docs/use-rst/","title":"Polynomial RST <code>Controller</code>.","text":""},{"location":"controlLibrary/docs/use-rst/#introduction","title":"Introduction.","text":"<p>The polynomial R-S-T <code>Controller</code> is a two degree of freedom digital controller (allowing to fix a regulation dynamic uncoupling from the setting point dynamic). </p> <p>It allows to implement various digital filters in the measurement part (\\(R\\)) or in the integration part (\\(\\frac{1}{S}\\)).</p> <p> </p>"},{"location":"controlLibrary/docs/use-rst/#parameters","title":"Parameters:","text":"<p>Here the equation of the RST controller.</p> \\[S(q^{-1}).u = T(q^{-1}).y_{ref} - R(q^{-1}).y\\] <p>where:</p> <ul> <li> <p>\\(S(q^{-1}),\\ T(q^{-1})\\ \\text{and}\\ R(q^{-1})\\) are polynomial of delay operator \\(q^{-1}\\)</p> </li> <li> <p>\\(S(q^{-1}) = s_0 + s_1.q^{-1} + ... + s_{ns}.q^{-ns}\\)</p> </li> <li>\\(R(q^{-1}) = r_0 + r_1.q^{-1} + ... + r_{nr}.q^{-nr}\\)</li> <li>\\(T(q^{-1}) = t_0 + t_1.q^{-1} + ... + t_{nt}.q^{-nt}\\)</li> </ul>"},{"location":"controlLibrary/docs/use-rst/#use-of-the-rst-controller","title":"Use of the RST <code>Controller</code>.","text":"<p>The use of the `RST is based on 3 steps.</p> <ol> <li>Object instanciation (declaration).</li> <li>Initialisation.</li> <li>Execution.</li> </ol> <p>Example</p> 1. Object and parameters instanciation.2. Initialization.3. Execution. <p>For each <code>Controller</code> like (<code>Pid</code>, <code>Rst</code>, <code>Pr</code>) we have to define a parameter structure.</p> <p>We define constants used to initialize the parameter structure. <pre><code>#include \"rst.h\"\n\nconst uint8_t nr = 3;\nconst float R[] = { 0.8914, -1.1521, 0.3732 };\n\nconst uint8_t ns = 6;\nconst float S[] = { 0.2, 0.0852, -0.0134, -0.0045, -0.1785, -0.0888 };\n\nconst uint8_t nt = 3;\nconst float T[] = { 1.0, -1.3741, 0.4867 };\n\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = -1.0F;\n\nstatic float32_t Ts = 100.0e-6F;\n</code></pre></p> <p>We define the parameter structure. Each parameter is defined here. <pre><code>static RstParams params = RstParams(Ts, nr, R, ns, S, nt, T, lower_bound, upper_bound);\n</code></pre></p> <p>We define the variable <code>my_rst</code> which is a <code>Rst</code> object. <pre><code>static RST my_rst;\n</code></pre></p> <p>In the <code>setup_routine()</code> of the OwnTech Power API, you must initialize the <code>Rst</code> with its parameters.</p> <pre><code>my_rst.init(params);\n</code></pre> <p>In the <code>loop_critical_task()</code> you can call the method <code>calculateWithReturn()</code> which have two arguments: </p> <ol> <li>the reference</li> <li>the measure.</li> </ol> <p>Note</p> <p>Remind that the <code>loop_critical_task()</code> is called at the sampling time you define and must be equal to \\(T_s\\).</p> <pre><code>new_command = my_rst.calculateWithReturn(reference, measurement);\n</code></pre> <p><code>new_command</code> is the result of the rst calculation for one step.</p>"},{"location":"core/","title":"OwnTech Power API","text":"<p>This is the OwnTech Power API Core repository.</p> <p>The Power API is designed to be used with VS Code and PlatformIO. Installing VS Code with PlatformIO.</p> <p>For information about Power API, check out its Documentation.</p>"},{"location":"core/#downloading-owntech-power-api-core","title":"Downloading OwnTech Power API Core","text":"<p>You fisrt need to download the Power API Core repository using the following command:</p> <p><code>git clone https://github.com/owntech-foundation/Core.git owntech_power_api</code></p> <p>Then, open VS Code and, if not already done, install the PlatformIO plugin.</p> <p>Finally, open the newly cloned folder <code>owntech_power_api</code> using menu <code>File &gt; Open Folder...</code></p>"},{"location":"core/#working-with-owntech-power-api","title":"Working with OwnTech Power API","text":"<p>While the project contains many folders and files, all your code goes to the <code>src</code> folder. In the this folder, the file <code>main.cpp</code> is the entry point of the application. Aditionally, some configuration can be done in the <code>platformio.ini</code> file.</p> <p>Other folders and files are used to configure the underlying Zephyr OS and PlatformIO, and are hidden by default.</p>"},{"location":"core/#accessing-owntech-source-code-in-vs-code-for-advanced-developers","title":"Accessing OwnTech source code in VS Code (for advanced developers)","text":"<p>The full hierarchy of the project is as follows:</p> <pre><code>owntech_power_api\n\u2514\u2500 owntech\n|  \u2514\u2500 boards\n|  \u2514\u2500 scripts\n|  \u2514\u2500&gt;pio_extra.ini\n\u2514\u2500 src\n|  \u2514\u2500&gt;main.cpp\n\u2514\u2500 zephyr\n|  \u2514\u2500 boards\n|  \u2514\u2500 dts\n|  \u2514\u2500 modules\n|  \u2514\u2500&gt;CMakeLists.txt\n|  \u2514\u2500&gt;prj.conf\n\u2514\u2500&gt;LICENSE\n\u2514\u2500&gt;platformio.ini\n\u2514\u2500&gt;README.md\n</code></pre> <p>The <code>owntech</code> folder contains scripts and board description for PlatformIO, while the <code>zephyr</code> folder contains board decription and OwnTech's Zephyr modules. By default, these folders (as well as VS Code and PlatformIO folders <code>.vscode</code> and <code>.pio</code>) are hidden when opening the project in VS Code.</p> <p>If you need to access these in VS Code, open the project using your file explorer, then in the <code>.vscode</code> folder, rename file <code>settings.json</code>, e.g. to <code>settings.json.old</code>.</p> <p>Advanced Zephyr configuration can be tweaked by editing <code>zephyr/prj.conf</code>.</p> <p>The OwnTech API source code is located in <code>zephyr/modules</code>. If you need to tailor it to your needs, please checkout the Zephyr documentation.</p>"},{"location":"core/docs/adc/","title":"ADC","text":"<p>An ADC, or Analog-to-Digital Converter, is a device that turns analog signals, like sound or temperature, into digital data that a computer or microcontroller can understand. It measures the analog voltage and converts it into a digital value that can be used by digital systems for processing, storage, or display.</p> <p>Warning</p> <p>The ADC API is an advanced interface provided for users with technical background. For most data acquisition tasks, use the Data API which provides a more user-friendly and higher-level entry point.</p>"},{"location":"core/docs/adc/#pinout","title":"Pinout","text":"<p>SPIN boards have 5 independant ADC units. Each unit can measure multiple analog signals, using a measurment sequence.</p> <p>Capabilities</p> <p>Each ADC channel has : -  12 bit resolution: 0b to 4096b -  Sensing full scale: 0V to 2.048V -  Sampling time down to 42ns</p> SPIN v1.1.0SPIN v1.0.0 <p> </p> <p> </p> <p>Info</p> <ul> <li>ADC12 means that the pin can be used either as ADC1 or ADC2</li> <li>INx means that it is channel x.</li> </ul>"},{"location":"core/docs/adc/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre> Make sure that SPIN API is included to use AdcHAL</p>"},{"location":"core/docs/adc/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Software triggeredHardware triggered <ol> <li>Link an adc trigger event to the ADC <code>spin.adc.configureTriggerSource(ADCx, TRIG)</code></li> <li>Define acquisition sequence by enabling adc channel : <code>spin.adc.enableChannel(ADCx, channelx)</code></li> <li>trigger an adc <code>data.triggerAcquisition()</code></li> <li>Retrieve value : <code>data.getLatest(ADCx, pinx)</code></li> </ol> <p>1. Make sure PWM engine is initialized 2. Link an adc trigger event to the ADC <code>spin.adc.configureTriggerSource(ADCx, TRIG)</code> 3. Set continuous/discontinuous conversion mode. Optional : <code>spin.adc.configureDiscontinuousMode(x, 0/1)</code> 4.  Define acquisition sequence by enabling adc channel : <code>spin.adc.enableChannel(ADCx, channelx)</code> 6. Start data dispatching to get acquired values <code>data.start()</code> 7.  Retrieve value : <code>data.getLatest(ADCx, pinx)</code></p> <p>Example</p> Software triggeredHardware triggered <pre><code>spin.adc.configureTriggerSource(1, software);\nspin.adc.enableChannel(1, 30);\ndata.triggerAcquisition(1);\nfloat32_t adc_value =   data.getLatest(1, 30);\n</code></pre> <pre><code>/* PWM unit initialization */\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n\n/* ADC initialization */\nspin.adc.configureTriggerSource(1, hrtim_eev1);\nspin.adc.configureDiscontinuousMode(1,1);\nspin.adc.enableChannel(1, 30);\ndata.start();\nfloat32_t adc_value =   data.getLatest(1, 30);\n</code></pre>"},{"location":"core/docs/adc/#channel-sequence","title":"Channel sequence","text":"<p>Each ADC unit can measure multiple analog signal. This works by defining an acquisition sequence.</p> <p>Tip</p> <p>By default the aquisition sequence is in continuous mode. It means than one trigger will trigger all the sequence of acquisition. This can be changed using Discontinuous Mode</p> <p>Example</p> 3 channels on ADC1 <p><pre><code>spin.adc.enableChannel(1, 2)\nspin.adc.enableChannel(1, 3)\nspin.adc.enableChannel(1, 1)\n</code></pre> In this example, for each trigger action, the ADC1 will measure channel 2, then channel 3, then channel 1.</p> Single channel <p><code>spin.adc.enableChannel(1, 1)</code></p> <p>In this example, for each trigger, the ADC1 will measure  channel 1.</p> <p>Note</p> <p>Sequence order is given by <code>spin.adc.enableChannel()</code> order.</p>"},{"location":"core/docs/adc/#software-triggered","title":"Software triggered","text":"<p>A software trigger for an ADC is a command or signal generated by the software to start the ADC conversion process. Instead of using a hardware signal or event to initiate the conversion, the ADC is triggered by software instructions, allowing for precise control and synchronization with other software processes or events. For example this trigger command can be generated from a high speed control task.</p> <pre><code>spin.adc.configureTriggerSource(2, software); // ADC 2 configured in software mode\ndata.triggerAcquisition(2); // Send an adc trigger to ADC2 to start conversion\nadc_value = data.getLatest(2, 35); // Get the acquired data\n</code></pre> <p>Example</p> <p>See the following example for an application :</p> <ul> <li>Software trigerred ADC</li> </ul>"},{"location":"core/docs/adc/#synchronous-with-pwms","title":"Synchronous with PWMs","text":"<p>Software triggers is generally speaking not suitable for applications that requires precise timing. Sometimes measurement have to be taken at a specific time, in interaction with the control signal.</p> <p>Info</p> <p>This kind of acquisition have a side benefit. It operates in the background and does not interfer with software. It means that periodical sampling will not interrupt code execution.</p> <p>The trigger is the PWM peripheral, the ADC performs the conversion and place the result in an output buffer, the output buffer is directly placed in memory by a DMA. A rather complex software mechanics execute periodically and serve each measurement in a dedicated memory space. The periodical routine is executed at the beggining of the controlTask.</p> <p>Info</p> <p>Synchronous measurement require having a controlTask running.</p> <p>Tip</p> <p>This page informs on how to parameters the triggering of the measurement To retrieve measurement values please refer to DataAPI</p> <p>The section below explain how to synchronize measurements with control signals.</p> <p>Note</p> <p>These features are available for ADC1 and ADC2.</p>"},{"location":"core/docs/adc/#the-different-event-and-trigger-of-adchrtim","title":"The different event and trigger of ADC/HRTIM","text":"<p>You might have seen that there are differents variables referencing adc trigger : </p> <p><pre><code>spin.adc.configureTriggerSource(1, hrtim_eev1);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n</code></pre> There is <code>hrtim_eevx</code> or <code>ADCTRIG_x</code>, let's see the role of each of them.</p>"},{"location":"core/docs/adc/#adctrig_x","title":"ADCTRIG_x","text":"<p>In the PWM API, four signals can serve as ADC triggers, initiating ADC conversions: ADC_TRIG1, ADC_TRIG2, ADC_TRIG3, and ADC_TRIG4.</p> <p>The PWM is produced by a carrier (see here) by using a comparator to compare a specific constant value with the carrier, we can generate an event when enabling a trigger on the PWM. For instance :  </p> <pre><code>spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p>We are enabling and linking ADCTRIG_1 to PWMA. That means that when the comparator value and the carrier value of the PWMA we can generate an event from ADCTRIG_1 that can be used to start an ADC conversion : </p> <p></p> <p>The comparator value can be adjusted using the function <code>spin.pwm.setAdcTriggerInstant(PWMA, 0.5)</code>. For example, setting it to 0.5 means triggering an event halfway through the switching period, initiating an ADC conversion.</p>"},{"location":"core/docs/adc/#hrtim_eevx","title":"hrtim_eevx","text":"<p>An ADC conversion can be initiated either by software (via a function) or hardware through an external event. Numerous external events exist, but some are specifically related to PWM: <code>hrtim_eev1</code>, <code>hrtim_eev2</code>, <code>hrtim_eev3</code>, and <code>hrtim_eev4</code>.</p> <p>Each of these external events is associated with events generated by ADCTRIG_x. For instance, hrtim_eev1 is linked to ADCTRIG_1, and so on.</p> <p><pre><code>spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.adc.configureTriggerSource(1, hrtim_eev1);\n</code></pre> The above code indicates that we've connected ADC1 to the external event hrtim_eev1, which, in turn, is connected to the event generated by ADCTRIG1 when the comparator (set by the trigger value) matches the carrier of PWMA.</p>"},{"location":"core/docs/adc/#source-adc-and-pwm-channel","title":"Source ADC and PWM channel","text":"<p>ADC1 and ADC2 can be associated with PWM channels at will.</p>"},{"location":"core/docs/adc/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. <pre><code>void AdcHAL::configureDiscontinuousMode (\n    uint8_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul> ADC1 and PWMAADC1 and PWMC <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMC, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMC);\n</code></pre>"},{"location":"core/docs/adc/#modulation-impact","title":"Modulation impact","text":"<p>Note</p> <p>Hardware trigger depends on PWM modulation.</p> Left Aligned ModulationCenter aligned modulation <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>"},{"location":"core/docs/adc/#rising-edge-falling-edge","title":"Rising Edge / Falling edge","text":"<p>Note</p> <p>This only applies to center aligned modulation.</p> Rising EdgeFalling Edge <p></p> <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\n    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_down);\n    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\n    spin.pwm.enableAdcTrigger(PWMA);\n</code></pre>"},{"location":"core/docs/adc/#measurment-trigger-instant","title":"Measurment trigger instant","text":"<p>Trigger timing can be defined or changed dynamically.</p> 20% Duty cycle80% Duty cycle <p></p> <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.2);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerInstant(PWMA, 0.8);\n</code></pre>"},{"location":"core/docs/adc/#continuous-discontinuous-sequence","title":"Continuous / Discontinuous sequence","text":"<p>Note</p> <p>This is relevant if more than one measurement is taken with the same ADC.</p> Continuous sequenceDiscontinuous sequence  <p></p> <pre><code>    spin.adc.configureDiscontinuousMode(1, 0);\n</code></pre> <p></p> <pre><code>    spin.adc.configureDiscontinuousMode(1, 1);\n</code></pre>"},{"location":"core/docs/adc/#number-of-pwm-period-between-acquisition","title":"Number of PWM period between acquisition","text":"<p>Note</p> <p>This is relevant if more than one measurement is taken with the same ADC.</p> With 2 periodsWith 4 periodsWithout interuptions <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 2);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 4);\n</code></pre> <p></p> <pre><code>    spin.pwm.setAdcTriggerPostScaler(PWMA, 1);\n</code></pre> <p>Example</p> <p>see the following example for an application :</p> <ul> <li>PWM trigerred ADC</li> </ul>"},{"location":"core/docs/adc/#api-reference","title":"API Reference","text":""},{"location":"core/docs/adc/#class-adchal","title":"Class AdcHAL","text":"<p>ClassList &gt; AdcHAL</p> <p>Handles the ADC for the spin board. More...</p> <ul> <li><code>#include &lt;AdcHAL.h&gt;</code></li> </ul>"},{"location":"core/docs/adc/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (uint8_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. void configureTriggerSource (uint8_t adc_number, adc_ev_src_t trigger_source) Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. void disableChannel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. void enableChannel (uint8_t adc_number, uint8_t channel) Add a channel to the list of channels to be acquired for an ADC. The order in which channels are acquired is determined by the order in which they are enabled. void enableDma (uint8_t adc_number, bool use_dma) ADC DMA mode configuration. Enables DMA and circular mode on an ADC. uint32_t getEnabledChannelsCount (uint8_t adc_number) Returns the number of enabled channels for an ADC. void startAllAdcs () Start all configured ADCs. void stopAllAdcs () Stop all configured ADCs. void triggerSoftwareConversion (uint8_t adc_number, uint8_t number_of_acquisitions) Triggers a conversion on an ADC which is configured as software triggered."},{"location":"core/docs/adc/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions linked to the ADC for the SPIN board </p>"},{"location":"core/docs/adc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/adc/#function-configurediscontinuousmode_1","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. <pre><code>void AdcHAL::configureDiscontinuousMode (\n    uint8_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"core/docs/adc/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. <pre><code>void AdcHAL::configureTriggerSource (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"core/docs/adc/#function-disablechannel","title":"function disableChannel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. <pre><code>void AdcHAL::disableChannel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>Note:</p> <p>If a channel has been enabled multiple times, then only the first occurence in the list will be removed.</p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"core/docs/adc/#function-enablechannel","title":"function enableChannel","text":"<p>Add a channel to the list of channels to be acquired for an ADC. The order in which channels are acquired is determined by the order in which they are enabled. <pre><code>void AdcHAL::enableChannel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"core/docs/adc/#function-enabledma","title":"function enableDma","text":"<p>ADC DMA mode configuration. Enables DMA and circular mode on an ADC. <pre><code>void AdcHAL::enableDma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC on which to enable DMA. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"core/docs/adc/#function-getenabledchannelscount","title":"function getEnabledChannelsCount","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t AdcHAL::getEnabledChannelsCount (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"core/docs/adc/#function-startalladcs","title":"function startAllAdcs","text":"<p>Start all configured ADCs. <pre><code>void AdcHAL::startAllAdcs () \n</code></pre></p>"},{"location":"core/docs/adc/#function-stopalladcs","title":"function stopAllAdcs","text":"<p>Stop all configured ADCs. <pre><code>void AdcHAL::stopAllAdcs () \n</code></pre></p>"},{"location":"core/docs/adc/#function-triggersoftwareconversion","title":"function triggerSoftwareConversion","text":"<p>Triggers a conversion on an ADC which is configured as software triggered. <pre><code>void AdcHAL::triggerSoftwareConversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>Note:</p> <p>Software trigger is default for all ADCs unless configured differently by the user or another module.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> <li><code>number_of_acquisitions</code> Number of channels to acquire. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/AdcHAL.h</code></p>"},{"location":"core/docs/dac/","title":"DAC","text":"<p>A Digital-to-Analog Converter (DAC) transforms digital signals into analog signals by mapping digital values to specific voltages. This process effectively creates continuous analog waveforms from discrete digital data. DACs play a vital role in electronic systems by enabling the generation of diverse waveforms.</p>"},{"location":"core/docs/dac/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>1. First start by calling the initialization function of the DAC <code>spin.dac.initConsValue(DAC_NUM)</code>.  2. Second enter the integer value to send to the DAC <code>spin.dac.setConstValue(DAC_NUM, DAC_CHAN, DAC_VALUE)</code> </p> <p>Example</p> <pre><code>spin.dac.initConstValue(2); // DAC 2 initialization\nspin.dac.setConstValue(2, 1, 2048);\n</code></pre>"},{"location":"core/docs/dac/#conversion-from-numerical-to-analog-value","title":"Conversion from numerical to analog value","text":"<p>The value we can send to the DAC is an integer between 0 and 4096, this value is then converted to voltage between 0 and 2.048V. For example : </p> <p><pre><code>spin.dac.setConstValue(2, 1, 2048);\n</code></pre> Generate a 1.024V signal.</p> <p></p> <p>Example</p> <p>For a pratical example of the DAC see the example :      - Signal generation</p>"},{"location":"core/docs/dac/#api-reference","title":"API Reference","text":""},{"location":"core/docs/dac/#class-dachal","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"core/docs/dac/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src)  void initConstValue (uint8_t dac_number)  void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value)  void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage)"},{"location":"core/docs/dac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/dac/#function-currentmodeinit","title":"function currentModeInit","text":"<pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre>"},{"location":"core/docs/dac/#function-initconstvalue","title":"function initConstValue","text":"<pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre>"},{"location":"core/docs/dac/#function-setconstvalue","title":"function setConstValue","text":"<pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre>"},{"location":"core/docs/dac/#function-slopecompensation","title":"function slopeCompensation","text":"<pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"core/docs/dataAPI/","title":"Data API","text":"<p>Data acquisition is the process of sampling signals that measure real-world physical conditions and converting the resulting samples into digital numeric values that can be manipulated by a computer.</p> <p>In the powerAPI context, the DataAPI helps the user retrieve the values sampled by the ADC.</p> <p>The Data API configures the DMAs to store the ADCs acquisitions for the Spin board, and dispatches them in per-channel buffers that can be read by the user. The module also provides functions to convert the raw values acquired by the sensors into values in the adequate unit.</p> <p>If using a shield such as Twist, channels are automatically made available for configuration and conversions functions are automatically calibrated using the device tree.</p>"},{"location":"core/docs/dataAPI/#include","title":"Include","text":"<p>Note</p> <pre><code>#include &lt;DataAPI.h&gt;\n</code></pre> <p>To use the Data API, include <code>DataAPI.h</code> in your source file. From there, a <code>data</code> object is available to interact with the API.</p>"},{"location":"core/docs/dataAPI/#data-dispatching","title":"Data dispatching","text":"<p>When using the control task (critical task) data are dispatched at the start, which means there are ready to be retrieved.</p> <p></p>"},{"location":"core/docs/dataAPI/#initialization-sequence","title":"Initialization sequence","text":"<p>If you want specific ADC behavior (trigger sources, discontinuous mode, etc.), you may want to configure the ADCs using the lower-level ADC API first. Then, you can enable channels that you want to acquire.</p> <p>After channels have been enabled, the conversion parameters can be set so that raw values can be automatically converted to the relevant unit. This is done using the <code>data.setParameters()</code> function.</p> <p>After channels have been enabled (and optionnally conversion parameters have been set), there are two ways of starting the API, depending on your use of other OwnTech APIs. If your code uses an uninterruptible task, nothing more is required, the Data API will be started automatically when task is started. However, if you do not have an uninterruptible task in your code, you need to manually start the API by calling <code>data.start()</code>.</p> <p>Note</p> Software triggeredHardware triggered <ol> <li>Enable acquisition on the pins you want: <code>data.enableAcquisition()</code></li> <li>Define acquisition conversion parameter: <code>data.setParameters()</code></li> <li>start data dispatching <code>data.start()</code></li> <li>Trigger an initial adc conversion <code>data.triggerAcquisition(ADCx)</code></li> <li>Retrieve values : <code>data.getLatest()</code> or <code>data.getRawValues()</code></li> </ol> <ol> <li>Make sure PWM engine is initialized</li> <li>Enable acquisition on the pins you want: <code>data.enableAcquisition()</code></li> <li>Define acquisition conversion parameter: <code>data.setParameters()</code></li> <li>start data dispatching <code>data.start()</code></li> <li>Retrieve values : <code>data.getLatest()</code> or <code>data.getRawValues()</code></li> </ol> <p>Example</p> Software triggered ADCHardware triggered ADC <pre><code>data.enableAcquisition(1, 5); // ADC 1 ; Pin 5\ndata.triggerAcquisition(1); // ADC 1\nfloat32_t adc_value = data.getLatest(1, 5); // ADC 1 ; Pin 5\n</code></pre> <pre><code>/* PWM unit initialization */\nspin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n\n/* ADC initialization */\nspin.adc.configureTriggerSource(1, hrtim_eev1); // ADC 1 ; HRTIM event 1\nspin.adc.configureDiscontinuousMode(1, 1); // ADC 1 ; acquire 1 pin at each event\ndata.enableAcquisition(1, 5); // ADC 1 ; Pin 5\ndata.start();\nfloat32_t adc_value = data.getLatest(1, 5); // ADC 1 ; Pin 5\n</code></pre>"},{"location":"core/docs/dataAPI/#retrieving-last-value","title":"Retrieving last value","text":"<p>Getting the last measured value to feed the control algorithm is super simple.</p> <p>Example</p> Get last value <p><pre><code>data.getLatest(1, 5)\n</code></pre> This will retrieve the last sampled value of ADC 1 pin 5.</p>"},{"location":"core/docs/dataAPI/#getting-values-with-the-right-unit","title":"Getting values with the right unit","text":"<p>DataAPI contains commodity functions to convert the raw binary measurement values in meaningful units.</p> <p>Example</p> Converting in volts <pre><code>data.setParameters()\n</code></pre>"},{"location":"core/docs/dataAPI/#get-an-array-of-values","title":"Get an array of values","text":"<p>DataAPI contains commodity function to retrieve an array of raw values that can be fed to a post processing filter.</p> <p>Example</p> Retrieve 5 values <pre><code>data.getRawValues()\n</code></pre>"},{"location":"core/docs/dataAPI/#class-dataapi","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p>"},{"location":"core/docs/dataAPI/#public-functions","title":"Public Functions","text":"Type Name float32_t convert (channel_t channel, uint16_t raw_value) Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. float32_t convert (uint8_t adc_num, uint8_t pin_num, uint16_t raw_value) Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. int8_t enableAcquisition (uint8_t adc_num, uint8_t pin_num) This function is used to enable acquisition on a Spin PIN with a given ADC. int8_t enableShieldChannel (uint8_t adc_num, channel_t channel_name) This function is used to enable a channel on a given ADC using its name on a shield, rather than the ADC channel number. This function requires the presence of an \"adc-channels\" node in the shield device-tree. void enableTwistDefaultChannels () This function is used to enable acquisition of all voltage/current channels on the Twist shield. Channels are attributed as follows: ADC1: - I1_LOW ADC2: - I2_LOW. DispatchMethod_t getDispatchMethod () Gets the dispatch method of the module. float32_t getLatest (channel_t channel, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. float32_t getLatest (uint8_t adc_num, uint8_t pin_num, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. uint16_t * getRawValues (channel_t channel, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified channel. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. uint16_t * getRawValues (uint8_t adc_num, uint8_t pin_num, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t peek (channel_t channel) Function to access the latest value available from the channel, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. float32_t peek (uint8_t adc_num, uint8_t pin_num) Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. int8_t retrieveParametersFromMemory (channel_t channel) Use this function to read the gain and offset parameters of the board to is non-volatile memory. int8_t retrieveParametersFromMemory (uint8_t adc_num, uint8_t pin_num) Retreived previously configured conversion parameters from NVS. conversion_type_t retrieveStoredConversionType (channel_t channel) Use this function to get the current conversion type for the chosen channel. conversion_type_t retrieveStoredConversionType (uint8_t adc_num, uint8_t pin_num) Use this function to get the current conversion type for the chosen channel. float32_t retrieveStoredParameterValue (channel_t channel, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . float32_t retrieveStoredParameterValue (uint8_t adc_num, uint8_t pin_num, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . void setDispatchMethod (DispatchMethod_t dispatch_method) Sets the dispatch method of the module. void setParameters (channel_t channel, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setParameters (uint8_t adc_num, uint8_t pin_num, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setRepetitionsBetweenDispatches (uint32_t repetition) Indicates the repetition count between two external dispatches when it is handled externally by the Scheduling module. This value is used to calibrate buffers sizes. void setTwistChannelsUserCalibrationFactors () Retrieve stored parameters from Flash memory and configure ADC parameters. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t storeParametersInMemory (channel_t channel) Use this function to write the gain and offset parameters of the board to is non-volatile memory. int8_t storeParametersInMemory (uint8_t adc_num, uint8_t pin_num) Store the currently configured conversion parameters of a given channel in NVS. void triggerAcquisition (uint8_t adc_num) Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired."},{"location":"core/docs/dataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/dataAPI/#function-convert-12","title":"function convert [1/2]","text":"<p>Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convert (\n    channel_t channel,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which the value originates </li> <li><code>raw_value</code> Raw value obtained from which the value originates</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. Returns -5000 if the channel is not active. </p>"},{"location":"core/docs/dataAPI/#function-convert-22","title":"function convert [2/2]","text":"<p>Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convert (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which the value originates. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. If there is an error, returns -5000. </p>"},{"location":"core/docs/dataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisiton: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before ADC is started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which acquisition is to be done. </li> <li><code>pin_num</code> Number of the Spin pin to acquire.</li> </ul> <p>Returns:</p> <p>0 if acquisition was correctly enabled, -1 if there was an error. </p>"},{"location":"core/docs/dataAPI/#function-enableshieldchannel","title":"function enableShieldChannel","text":"<p>This function is used to enable a channel on a given ADC using its name on a shield, rather than the ADC channel number. This function requires the presence of an \"adc-channels\" node in the shield device-tree. <pre><code>int8_t DataAPI::enableShieldChannel (\n    uint8_t adc_num,\n    channel_t channel_name\n) \n</code></pre></p> <p>Note:</p> <p>This function must be called before ADC is started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which channel is to be enabled. </li> <li><code>channel_name</code> Name of the channel using enumeration channel_t.</li> </ul> <p>Returns:</p> <p>0 if channel was correctly enabled, -1 if there was an error. </p>"},{"location":"core/docs/dataAPI/#function-enabletwistdefaultchannels","title":"function enableTwistDefaultChannels","text":"<p>This function is used to enable acquisition of all voltage/current channels on the Twist shield. Channels are attributed as follows: ADC1: - I1_LOW ADC2: - I2_LOW. <pre><code>void DataAPI::enableTwistDefaultChannels () \n</code></pre></p> <ul> <li>V1_LOW - V2_LOW</li> <li>V_HIGH - I_HIGH</li> </ul> <p>Note:</p> <p>This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events. All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> <p>Note:</p> <p>This function must be called before ADC is started. </p>"},{"location":"core/docs/dataAPI/#function-getdispatchmethod","title":"function getDispatchMethod","text":"<p>Gets the dispatch method of the module. <pre><code>DispatchMethod_t DataAPI::getDispatchMethod () \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Returns:</p> <p>Dispatch method indicatinng when the dispatch is done. </p>"},{"location":"core/docs/dataAPI/#function-getlatest-12","title":"function getLatest [1/2]","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatest (\n    channel_t channel,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.get*RawValues() function for the matching channel, as data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain value. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-getlatest-22","title":"function getLatest [2/2]","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatest (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.get*RawValues() function for the matching channel, as data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain value. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-getrawvalues-12","title":"function getRawValues [1/2]","text":"<p>Function to access the acquired data for specified channel. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    channel_t channel,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use matching data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"core/docs/dataAPI/#function-getrawvalues-22","title":"function getRawValues [2/2]","text":"<p>Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use matching data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain values. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"core/docs/dataAPI/#function-peek-12","title":"function peek [1/2]","text":"<p>Function to access the latest value available from the channel, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peek (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain value.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-peek-22","title":"function peek [2/2]","text":"<p>Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peek (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain value. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"core/docs/dataAPI/#function-retrieveparametersfrommemory-12","title":"function retrieveParametersFromMemory [1/2]","text":"<p>Use this function to read the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t DataAPI::retrieveParametersFromMemory (\n    channel_t channel\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to save the values. </li> </ul>"},{"location":"core/docs/dataAPI/#function-retrieveparametersfrommemory-22","title":"function retrieveParametersFromMemory [2/2]","text":"<p>Retreived previously configured conversion parameters from NVS. <pre><code>int8_t DataAPI::retrieveParametersFromMemory (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>pin_num</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested channel -5000: Channel not found. </p>"},{"location":"core/docs/dataAPI/#function-retrievestoredconversiontype-12","title":"function retrieveStoredConversionType [1/2]","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::retrieveStoredConversionType (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> </ul>"},{"location":"core/docs/dataAPI/#function-retrievestoredconversiontype-22","title":"function retrieveStoredConversionType [2/2]","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::retrieveStoredConversionType (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter.</li> </ul> <p>Returns:</p> <p>Returns the type of convertion of the given pin. Returns -5 if the channel is not active. </p>"},{"location":"core/docs/dataAPI/#function-retrievestoredparametervalue-12","title":"function retrieveStoredParameterValue [1/2]","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::retrieveStoredParameterValue (\n    channel_t channel,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>. </li> </ul>"},{"location":"core/docs/dataAPI/#function-retrievestoredparametervalue-22","title":"function retrieveStoredParameterValue [2/2]","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::retrieveStoredParameterValue (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter. Returns -5000 if the channel is not active. </p>"},{"location":"core/docs/dataAPI/#function-setdispatchmethod","title":"function setDispatchMethod","text":"<p>Sets the dispatch method of the module. <pre><code>void DataAPI::setDispatchMethod (\n    DispatchMethod_t dispatch_method\n) \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Parameters:</p> <ul> <li><code>dispatch_method</code> Indicates when the dispatch should be done (default value: DispatchMethod_t::on_dma_interrupt) </li> </ul>"},{"location":"core/docs/dataAPI/#function-setparameters-12","title":"function setParameters [1/2]","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setParameters (\n    channel_t channel,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to set conversion values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"core/docs/dataAPI/#function-setparameters-22","title":"function setParameters [2/2]","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setParameters (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC to set conversion values. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"core/docs/dataAPI/#function-setrepetitionsbetweendispatches","title":"function setRepetitionsBetweenDispatches","text":"<p>Indicates the repetition count between two external dispatches when it is handled externally by the Scheduling module. This value is used to calibrate buffers sizes. <pre><code>void DataAPI::setRepetitionsBetweenDispatches (\n    uint32_t repetition\n) \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Parameters:</p> <ul> <li><code>repetition</code> Number of repetitions between two calls of dispatch. Used to calibrate buffers sizes. </li> </ul>"},{"location":"core/docs/dataAPI/#function-settwistchannelsusercalibrationfactors","title":"function setTwistChannelsUserCalibrationFactors","text":"<p>Retrieve stored parameters from Flash memory and configure ADC parameters. <pre><code>void DataAPI::setTwistChannelsUserCalibrationFactors () \n</code></pre></p> <p>Note:</p> <p>This function requires Console to interact with the user. You must first call console_init() before calling this function.</p> <p>Note:</p> <p>This function can't be called before all Twist channels have been enabled (you can use enableTwistDefaultChannels() for that purpose). The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task. </p>"},{"location":"core/docs/dataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually, it will automatically be started at the same time as the task as their internal behavior are intrinsically linked. If for some reason you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task. In that case, Data Acquisition must be manually started using this function. Note that in taht case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out. No ADC configuration change is allowed after module has been started. If you're using the Twist shield and are not sure how to initialize ADCs, you can use data.enableTwistDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function. Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when dispatch method is set to be external, but the repetition value has not provided. Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"core/docs/dataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"core/docs/dataAPI/#function-storeparametersinmemory-12","title":"function storeParametersInMemory [1/2]","text":"<p>Use this function to write the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t DataAPI::storeParametersInMemory (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function should be called after updating the parameters using setParameters.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to save the values. </li> </ul>"},{"location":"core/docs/dataAPI/#function-storeparametersinmemory-22","title":"function storeParametersInMemory [2/2]","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t DataAPI::storeParametersInMemory (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>pin_num</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, negative value if there was an error: -1: There was an error, -5000: Channel not found. </p>"},{"location":"core/docs/dataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired. <pre><code>void DataAPI::triggerAcquisition (\n    uint8_t adc_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the at least one channel is enabled on the ADC and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/DataAPI.h</code></p>"},{"location":"core/docs/dataAPI/#using-the-data-api-with-a-twist-shield","title":"Using the Data API with a Twist shield","text":"<p>The Data API is optimized for running on Twist shields. It provides variants of the functions that take Twist sensors as parameters instead of pins numbers.</p> <p>To enable the Twist Shield channels, use <code>set(SHIELD twist)</code> in <code>CMakeLists.txt</code>. From there, this module will provide additional functions to acquire and convert Twist channels by name.</p> <p>If you use the Twist sensors, you can use <code>data.enableTwistDefaultChannels()</code> to automatically perform a standard configuration. From there, all current/tension channels of the Twist shields will be enabled as part of the default configuration. Default parameters for the channels are also loaded automatically as part of the process.</p>"},{"location":"core/docs/environment_setup/","title":"Environment Setup","text":"<p>If you use or wish to use Visual Studio Code, follow this tutorial to set up your work environment. It will use a \u201cBlinky\u201d (blinking LED) example which requires no other hardware than your OwnTech board.</p>"},{"location":"core/docs/environment_setup/#requirements","title":"Requirements","text":"<p>Before we start, make sure your machine meets all the requirements below.</p> <p>Required software</p> WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Internet connection</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers<ul> <li>The pip package installer is needed. If using the system Python (<code>/usr/bin/python3</code>), <code>pip</code> may not be installed by default.   See Installing pip with Linux Package Managers.</li> <li>The venv module is needed.   Warning if using the system Python: although <code>venv</code> is part of the Python Standard Library, some Linux distributions such as Debian and Ubuntu don't install it by default.   In that case, make sure that the <code>python3-venv</code> package is installed.</li> </ul> </li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>64 bit Linux distribution</li> <li>Write permission for the serial port (<code>/dev/ttyACM0</code>): See PlatformIO documentation which provides a udev rules file</li> <li>Internet connection</li> </ul>"},{"location":"core/docs/environment_setup/#setup-your-work-environment","title":"Setup your work environment","text":"<p>To use OwnTech's system, we will use:</p> <ul> <li>Visual Studio Code - The platform or Integrated Development Environment we will use to write code.</li> <li>PlatformIO - A Visual Studio Code extension that is a toolbox for microcontrollers</li> </ul> <p>Required Disk Space</p> <p>Make sure that you have more than 2GB on your hard drive so that PlatformIO can download all the required files without issues.</p> <p>Here is how to set up this environment.</p>"},{"location":"core/docs/environment_setup/#step-1-empty-folder","title":"Step 1 - Empty folder","text":"<p>Create an empty folder in which you will work throughout the tutorials.</p> <p>Warning</p> Windows <ul> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not linked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> </ul>"},{"location":"core/docs/environment_setup/#step-2-install-visual-studio-code","title":"Step 2 - Install Visual Studio Code","text":"<p>Download  and install Visual Studio Code (\u201cVS Code\u201d for short).</p> <p>An overview of VS Code user interface is available in their official Get Started / User Interface documentation.</p>"},{"location":"core/docs/environment_setup/#step-3-install-platformio","title":"Step 3 - Install PlatformIO","text":"<p>Launch Visual Studio Code.</p> <p>In the \u201cActivity Bar\u201d, located on the far left-hand side, click on the Extensions icon (1) to open the VS Code Extensions manager in the Primary Side Bar.</p> <ol> <li>The VS Code Extensions manager icon looks like this: </li> </ol> <p>Using the search box in the Extensions Marketplace, search for the \u201cPlatformIO IDE\u201d extension and install it.</p> <p>Finally, restart Visual Studio Code when you are prompted to do so.</p> <p></p> <p>Once installed, you should see that PlatformIO has appended its \u201calien head\u201d icon (1) to the Activity Bar.</p> <ol> <li>The PlatformIO icon looks like this: </li> </ol> <p>Pro tip</p> <p>If the alien icon does not show up spontaneously, wait for a few more seconds, then press F1 key and type \"platformio home\".</p>"},{"location":"core/docs/environment_setup/#step-4-open-platformio-in-vs-code","title":"Step 4 - Open PlatformIO in VS Code","text":"<p>In VS Code Activity Bar, click on the newly added PlatformIO \u201calien head\u201d icon to open PlatformIO in the Primary Side Bar. It should contain:</p> <ul> <li>\u201cProject Tasks\u201d view, at the top (without any task list at that stage, since you haven\u2019t opened a PlatformIO project at this stage)</li> <li>\u201cQuick Access\u201d view, below</li> </ul>"},{"location":"core/docs/environment_setup/#step-5-clone-our-core-repository","title":"Step 5 - Clone our Core repository","text":"<p>In PlatformIO's \u201cQuick Access\u201d view, select the \u201cMiscelleanous / Clone Git Project\u201d action. This will open a field in which you should enter the following Git repository address:</p> <pre><code>https://github.com/owntech-foundation/Core\n</code></pre> <p>PlatformIO will then ask you in which folder the project should be cloned. Choose the folder you have created previously. This will start the cloning process (with a progress window popping up in the lower right corner).</p> <p>At the end of the cloning process, VS Code will ask you if you wish to open the cloned repository and you should answer yes (\"Open\" or \"Open in New Window\").</p> <p>Once the project folder is opened, a popup will appear asking if you trust the authors of the files in this folder. You can trust us. </p> <p></p> <p>Once the repository is cloned successfully, make sure you are on the <code>main</code> branch of the Git project. The name of the current branch is displayed on the left side of the Status Bar, at the bottom of the VS Code window, as highlighted in the following screenshot:</p> <p></p> <p>Now the project is successfully opened and you should see two tabs in the Editor area:</p> <ul> <li>the \u201cPIO Home\u201d tab that we will not use here   (remark: PIO Home\u2019s Devices tab can be used to check that your board is well detected once connected)</li> <li>the <code>platformio.ini</code> Project Configuration File,   which is already well configured for the present example</li> </ul> <p>This first example you have just opened implements a simple \u201cBlinky\u201d (blinking LED) demo. If you wish to understand how it is implemented, open and read through the main C++ code which is <code>main.cpp</code>, located in the <code>src</code> folder. VS Code file Explorer can be opened from the first icon at the top of the Activity Bar.</p>"},{"location":"core/docs/environment_setup/#step-6-build-our-core-code","title":"Step 6 - Build our Core code","text":"<p>In the Status Bar, at the bottom of the VS Code window, click on the Build (<code>\u2713</code>) icon. This will launch the code compilation process.</p> <p></p> <p>Coffee Time</p> <p>During your first build, PlatformIO will download all the necessary dependencies of our code. This may take several minutes depending on your machine and your internet connection.</p> <p>Do not hesitate to go get yourself a coffee.</p> <p>When the compilation is completed, you should see:</p> <p></p> <p>Note</p> <p>If you encounter an error during compilation, please refer to the troubleshooting section below.</p>"},{"location":"core/docs/environment_setup/#step-7-prepare-your-hardware","title":"Step 7 - Prepare your hardware","text":"<p>Before running the code, make sure that you meet the following requirements:</p> <p>Requirements for running the code on a board</p> <ul> <li>Have your VS Code Environment already set up</li> <li>Run your first compilation successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> </ul> <p></p> <ul> <li>Connect the SPIN board to your computer via the USB.</li> <li>Notice that the LED PWR must turn on.</li> <li>Here you see the connection of a SPIN board embedded onto a TWIST board.</li> </ul>"},{"location":"core/docs/environment_setup/#step-8-upload-our-core-code-in-your-spin-board","title":"Step 8 - Upload our Core code in your SPIN board","text":"<p>Now it is time to run a Blinky (i.e. blinking LED) example on the board.</p> <p>This requires uploading (or flashing) the compiled code to the SPIN controller board. To do so, press the Upload icon (<code>\u2192</code>, just to the right of the Build icon <code>\u2713</code>).</p> <p>Pro tip</p> <p>The Build and Upload action buttons are also available in the top right corner of the Editor area</p> <p>Coffee time 2</p> <p>During your first upload, PlatformIO will automatically download the necessary dependencies to send data to the SPIN board. Depending on your machine and your internet connection, this might take some time.</p> <p>Time to pour another coffee.</p> Known bug - mcumgr macOS <p>The upload requires a software called mcumgr.</p> <p>As of the time of writing, we have experienced issues with some macOS devices in finding it.</p> <p>Please refer to the ongoing issue to handle it if you have the error below.</p> <p></p> <p>If everything goes well, you will get a success as in the image below.</p> <p></p> <p>Finally, allowing a few extra seconds for the board to reboot, you will see the <code>LED</code> LED blink.</p> <p>  Success</p> <p>Congratulations! You have uploaded your first code!</p> <p>If you want to make sure you really master this first example, you can change the blinking frequency. The blinking period is set at the last line of the <code>loop_background_task()</code> routine in the <code>main.cpp</code> file (<code>1000</code> by default, expressed in ms). After saving the modified code, you will need to redo the Build and Upload steps.</p>"},{"location":"core/docs/environment_setup/#troubleshooting","title":"Troubleshooting","text":"<p>From our experience, there are multiple types of errors that can block your compilation.</p> <p>Check the list below of possible issues</p> Troubleshooting WindowsmacOSLinux <ul> <li>Git: If you do not have git installed, get it here git for Windows</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Make sure that you have administrator privileges on the folder where you clone your repository.</li> <li>Check that you are working on a path that is not liked to OneDrive</li> <li>Check that you do not have any spaces in the path of your project</li> <li>Check that the length of your project path is smaller than 256 characters.</li> <li>You should preferably have your project folder as close as possible to the root</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for macOS</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> <li>If you have a problem with <code>mcumgr</code>, please refer to the ongoing issue to handle it.</li> </ul> <ul> <li>Git: If you do not have git installed, get it here git for Linux</li> <li>Python3: If you do not have python3 installed, get it here Python3 Installers</li> <li>CMake: If you do not have CMake installed, get it here CMake Installer</li> <li>Check that your Linux is 64 bits</li> <li>Be sure the SPIN board PWR LED lights up correctly when connected to the USB</li> <li>Check your USB-C cable is working and can handle data</li> <li>Check your internet connection is up and running</li> </ul> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.07.11: Pierre Haessig</li> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/first_example/","title":"First Example","text":"<p>The best way \"to owntech\" is to use our examples.</p> <p>In this section we will show you how to use our example interface.</p>"},{"location":"core/docs/first_example/#requirements","title":"Requirements","text":"<p>Before you start, please make sure you fullfil the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Run your first compilation successfully.</li> <li>Run your first upload successfully.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/first_example/#using-the-example-interface","title":"Using the example interface","text":"<p>We have developed an automatic method to use the examples available in our github example repository within our environment.</p> <p>Here are the steps to use it.</p>"},{"location":"core/docs/first_example/#step-1-open-project-tasks","title":"Step 1 - Open project tasks","text":"<p>Click on the PlatformIO alien icon. (1)</p> <ol> <li>The alien icon looks like this </li> </ol> <p>There are three group of tasks:</p> <ul> <li>Default:</li> <li>STLink:</li> <li>USB: These are the tasks we will work with</li> </ul> <p>Environments</p> <p>These three groups of tasks are called \"environments\" in PlatformIO.</p> <ul> <li>Default is given by PlatformIO itself and we do not use it.</li> <li>STLink is the environment that supports using an STLink when interacting to the SPIN board.</li> <li>USB is the default environment which uses an USB cable to interact with the SPIN board.</li> </ul> <p>We will work with different environments in later more advanced examples.</p>"},{"location":"core/docs/first_example/#step-2-open-the-usb-tasks","title":"Step 2 - Open the USB tasks","text":"<p>There are multiple folders on the USB tasks.</p> <ul> <li>From General to Msciellaneous are tasks by default that we don not use</li> <li>OwnTech: are tasks that can be used for more advanced users.</li> <li>Examples TWIST: are the examples dedicated to the TWIST board which we will see later.</li> <li>Examples SPIN: groups all the examples related to the SPIN board.</li> </ul>"},{"location":"core/docs/first_example/#step-3-open-the-examples-spin-folder","title":"Step 3 - Open the Examples SPIN folder","text":"<p>Click on the Examples SPIN folder.</p> <p>You will see multiple examples on this folder.</p> <ul> <li>Blinky LED: Your trusted companion.</li> <li>Setting PWM: An example to create a single PWM signal</li> <li>Setting multiple PWM: An example for creating multiple PWM signals</li> <li>Setting PWM phase shift: An example for shifting two PWM signals</li> <li>DAC signal: An example for generating an analog signal from digital data</li> <li>Software triggered ADC: An example to activate</li> <li>HRTIM triggered ADC: An example to active an ADC measuremente using a hardware trigger</li> <li>Incremental encoder: An example on how to interface an incremental encoder to the SPIN board</li> </ul>"},{"location":"core/docs/first_example/#step-4-get-your-example","title":"Step 4 - Get your example","text":"<p>Click on the Setting PWM duty cycle example.</p> <p>The file will be automatically downloaded and replace your <code>main.cpp</code>.</p>"},{"location":"core/docs/first_example/#step-5-build-the-example","title":"Step 5 - Build the example","text":"<p>Go back to your VSCode Explorer tab.(1)</p> <ol> <li>The explorer tab icon looks like this: </li> </ol> <p>Notice that an <code>old/old0/src</code> folder has been created.  You will find your previous <code>main.cpp</code> in this folder.  This way you can access your old code anytime.</p> <p>In the <code>src</code> folder, notice that an <code>Image</code> folder has been created and that the <code>readme.md</code> of the example was downloaded.</p> <p>You can click on the new <code>main.cpp</code> file to explore the newly downloaded example.</p> <p>When you are ready to build, click on the build icon. (1)</p> <ol> <li>The build icon looks like this: </li> </ol>"},{"location":"core/docs/first_example/#step-6-upload-the-example","title":"Step 6 - Upload the example","text":"<p>If the build is successful, connect your SPIN board and click on the flash icon. (1)</p> <ol> <li>The flash icon looks like this: </li> </ol> <p>Connect your SPIN board</p> <p>Remember to connect your SPIN board to your computer to allow you to upload the new example.</p> <p></p> <p>Once the upload is completed, the LED will stop blinking.</p> <p>You can connect to the serial port by cliking on its icon. (1)</p> <ol> <li>The serial icon looks like this: </li> </ol> <p>VSCode will open a <code>TERMINAL</code> window and show what the SPIN board is writing on the console.</p> <p>You should see a <code>0.300000</code> which represents a duty cycle of 30%.</p> <p>If you click on the terminal and push the <code>d</code> key on your keyboard, the value will go <code>DOWN</code> and decrease to <code>0.250000</code>.</p> <p>If you push the <code>u</code> key on your key board, the value will go <code>UP</code> and increase back to <code>0.300000</code>.</p> <p>Congratulations! you have uploaded your fist example. Do not hesitate to explore more examples either via our interface or our repository.</p> List of contributors <p>Here is a short list of contributors to this page:</p> <ul> <li>2024.02.24: Ayoub Farah, Luiz Villa</li> <li>2021.11.04: Lo\u00efc Qu\u00e9val, Romain Delpoux, Adrien Pr\u00e9vost</li> <li>2021.11.07: Luiz Villa, Antoine Boche</li> <li>2022.01.24: Luiz Villa, Adrien Prevost, Lo\u00efc Qu\u00e9val</li> <li>2022.03.13: Luiz Villa</li> <li>2022.05.06: Luiz Villa</li> <li>2022.06.23: Lo\u00efc Qu\u00e9val</li> <li>2022.01.16: Mathilde Longuet and Luiz Villa</li> <li>2023.07.10: Luiz Villa</li> <li>2023.09.02: Mathilde Longuet</li> <li>2023.09.25: Mathilde Longuet</li> </ul>"},{"location":"core/docs/gpio/","title":"GPIO","text":"<p>A GPIO, or General Purpose Input/Output, is a pin on a microcontroller or processor that can be programmed to function either as an input or an output. As an input, it can read the state of an external electrical signal, such as a switch or a sensor. As an output, it can send an electrical signal, such as a high or low logic level, to an external component, such as an LED.</p>"},{"location":"core/docs/gpio/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Set the output pinReset the output pinRead the input pin <p>1. Configure the pin in output mode. 2. Set the pin.  </p> <p>1. Configure the pin in output mode. 2. Reset the pin  </p> <p>1. Configure the pin in input mode. 2. Read the pin input.  </p> <p>Example</p> Set the output pinReset the output pinRead the input pin <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.setPin(9);  </p> <p>spin.gpio.configurePin(9, OUTPUT); spin.gpio.resetPin(9);  </p> <p>spin.gpio.configurePin(9, INPUT); uint8_t return_gpio = spin.gpio.readPin(9);  </p>"},{"location":"core/docs/gpio/#api-reference","title":"API Reference","text":""},{"location":"core/docs/gpio/#class-gpiohal","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p>"},{"location":"core/docs/gpio/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"core/docs/gpio/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/gpio/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>flags</code> Pin configuration flags. Authorized values:</li> <li>INPUT</li> <li>INPUT_PULLUP</li> <li>OUTPUT </li> </ul>"},{"location":"core/docs/gpio/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"core/docs/gpio/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <ul> <li>if pin value is 1, it will be set to 0</li> <li>if pin value is 0, it will be set to 1.</li> </ul> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"core/docs/gpio/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"core/docs/ownplot_setup/","title":"OwnPlot Setup","text":"<p>OwnPlot is the software we have developed to easily visualize data. Here we will show you how to install and use it.</p>"},{"location":"core/docs/ownplot_setup/#requirements","title":"Requirements","text":"<p>Before you start, make sure you meet the requirements below.</p> <p>Requirements</p> <ul> <li>Have your VSCode Environment already setup</li> <li>Have your first PWM example uploaded.</li> <li>Have an USB-C cable ready</li> <li>Have a SPIN board ready and connected to your computer (stand-alone or embedded on a TWIST)</li> <li>Have an internet connection up and running</li> </ul>"},{"location":"core/docs/ownplot_setup/#installing-ownplot","title":"Installing OwnPlot","text":"<p>Choose your system and follow the installation procedure.</p>"},{"location":"core/docs/ownplot_setup/#step-1-download-ownplot","title":"Step 1 - Download OwnPlot","text":"<p>Releases</p> <p>All OwnPlot releases can be downloaded on github.</p>  Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <p>Download the file OwnPlot.Setup.0.6.1.exe</p> <p>This works with Intel &amp; Apple silicon</p> <p>Download the file OwnPlot-0.6.1-universal.dmg</p> <p>Download the file OwnPlot_0.6.1_amd64.deb</p> <p>Download the file OwnPlot-0.6.1.x86_64.rpm</p> <p>Download the file OwnPlot-0.6.1.AppImage</p>"},{"location":"core/docs/ownplot_setup/#step-2-install-ownplot","title":"Step 2 - Install OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>Launch the executable OwnPlot.Setup.0.6.1.exe</li> <li>The app will automatically install in the <code>User\\AppData\\Local\\Programs\\OwnPlot</code> folder</li> </ol> <p>Compatibility</p> <p>This works with Intel &amp; Apple silicon</p> <ol> <li>Launch the disk image OwnPlot-0.6.1-universal.dmg</li> <li>Drag and drop OwnPlot into your Applications folder  </li> </ol> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo dpkg -i OwnPlot_0.6.1_amd64.deb\n</code></pre></li> </ol> <p>Warning</p> <p>This install has not been tested yet</p> <ol> <li>Open a terminal</li> <li>Install the package <pre><code>sudo rpm -i OwnPlot-0.6.1.x86_64.rpm\n</code></pre></li> </ol> <ol> <li>Right-click on the AppImage file</li> <li>Check the button to allow it to run as a program</li> </ol>"},{"location":"core/docs/ownplot_setup/#step-3-run-ownplot","title":"Step 3 - Run OwnPlot","text":"Windows macOS Linux (Debian based) Linux (RedHat based) Linux (AppImage) <ol> <li>OwnPlot should launch itself right after the installation has been completed.</li> <li>OwnPlot should be available from the start menu</li> </ol> <p>Launch OwnPlot from your Application folder or the LaunchPad</p> <p>If you have trouble running the app for the first time</p> <ol> <li>If you get this:</li> </ol> <p></p> <ol> <li>Open System Preferences</li> <li>Go to Security &amp; Privacy Tab</li> <li>Allow OwnPlot to run by clicking the button \"Allow\" </li> </ol> <p>Type <code>ownplot</code> in the terminal.</p> <p>Type <code>ownplot</code> in the terminal.</p> <p>Double-click on the AppImage file</p> <p>Performances issues</p> <p>Version v0.6.0 has been reported to have a low performance.  A quick patch has been released which enhances performance a bit v0.6.1 If you have trouble running this release, fall back on version v0.5.1</p>"},{"location":"core/docs/powerAPI/","title":"Home","text":"<p>PowerAPI is a comprehensive software API for demanding applications. </p> <ul> <li> <p> Blazing Fast</p> <p>Get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Application oriented</p> <p>Focus on your application and generate your real time control</p> <p> Examples</p> </li> </ul>"},{"location":"core/docs/powerAPI/#browse-the-documentation","title":"Browse the documentation","text":"<ul> <li> <p> Real time tasks</p> <p>Generate accurate periodic actions and handle background tasks</p> <p> API Reference</p> </li> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> HAL Reference</p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> HAL Reference </p> <p> API Reference</p> </li> <li> <p> Analog accelerated control loops</p> <p>Use internal analog hardware to control your application</p> <p> HAL Reference</p> </li> <li> <p> Real time synchronization</p> <p>Synchronize multiple SPIN boards down to 10 of ns </p> <p> API Reference</p> </li> <li> <p> Real time communication</p> <p>Send critical data, at real time pace.</p> <p> Digital communication API </p> <p> Analog communication API</p> </li> </ul>"},{"location":"core/docs/pwm/","title":"PWM","text":"<p>PWM, or Pulse Width Modulation, is a method used in electronics to control the power supplied to devices like motors, LEDs, and heaters. Instead of changing the voltage or current level, PWM changes the amount of time the power is on (the pulse width) compared to the time it's off.</p> <p>In power electronics, PWM is super important because it allows us to control the average power delivered to a load by varying the duty cycle of the pulse. This means we can regulate the speed of motors or the brightness of LEDs.</p>"},{"location":"core/docs/pwm/#features","title":"Features","text":"<ul> <li>Up to 5 pairs of PWMs possible (PWMA, PWC, PWMD, PWME, PWMF)</li> <li>Each PWM unit has a resolution of 184ps.</li> </ul> <p>Note</p> <p>The resolution of a PWM signal defines the maximum number of steps that can be present in a single PWM period. In other words, it determines how finely you can adjust the pulse width of the        signal. A higher resolution means you can make smaller and more precise adjustments to the pulse width.</p> <ul> <li>Frequencies in the range of 650Hz to 1Ghz theorically possible</li> </ul> <p>Warning</p> <p>Only 200Khz was tested with SPIN and TWIST</p> <ul> <li>Two different modulation mode possible : left aligned, and center aligned</li> <li>Two ADC linkable to two differents PWM unit for precise measurement instant</li> <li>Compatible for peak current control with the internal analog comparator</li> <li>Positive and negative dead time set via software</li> <li>Phase shift possible for interleaved operations</li> </ul>"},{"location":"core/docs/pwm/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;SpinAPI.h&gt;\n</code></pre> Make sure that SPIN API is included to use PwmHAL </p>"},{"location":"core/docs/pwm/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> <p>Function to call before initializing the PWM unit.</p> Software triggeredHardware triggered <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set wich output (1 or 2) will be controlled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 3.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 4.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code> </p> <p>1.  Set the modulation type : <code>spin.pwm.setModulation(PWMx, lft_aligned/upDwn)</code> 2. Set ow which edge (up/down) to trigger adc conversion <code>spin.pwm.setAdcEdgeTrigger(PWMx, edgeTrigUp/edgeTrigDwn)</code> 3. Set the division of the number of trigger in a fixed period <code>spin.pwm.setAdcDecimation(PWMx, DecimValue)</code> 4. Set wich output (1 or 2) will be constrolled by the duty cycle, the other will be complementary <code>spin.pwm.setSwitchConvention(PWMx, PWMx1/PWMx2)</code> 5.  Set if the pwm is designed to be duty-cycle driven (voltage mode) or current driven (current mode) <code>spin.pwm.setMode(PWMx, voltageMode/currentMode)</code> 6.  Initialize the pwm unit : <code>spin.pwm.initUnit(PWMx)</code> </p> <p>Note</p> <p>Function to call after initializing PWM unit.</p> Software triggeredHardware triggered <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code> </li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code> </li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code> </li> <li>if ADC hardware triggered : follow ADC init sequence </li> </ol> <ol> <li>Set the rising/falling dead time. Can be changed before/after init : <code>spin.pwm.setDeadTime(PWMx, rise, fall)</code> </li> <li>Set wich ADC trigger to link to PWM unit <code>spin.pwm.setAdcTrigger(PWMx, ADCtrig)</code> </li> <li>Enable the adc trigger <code>spin.pwm.enableAdcTrigger</code> </li> <li>Set an initial value for the  duty cycle <code>spin.pwm.setDutyCycle(0.5)</code> </li> <li>Start the PWM, either start both outout or just one <code>spin.pwm.startDualOutput(PWMx)</code> / <code>spin.pwm.startSingleOutput(PWMx, PWMx1/PWMx2)</code> </li> <li>if ADC hardware triggered : follow ADC init sequence </li> </ol> <p>Example</p> Software triggeredHardware triggered <pre><code>spin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre> <pre><code>spin.pwm.setModulation(PWMA, UpDwn);\nspin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up);\nspin.pwm.setSwitchConvention(PWMA, PWMx1);\nspin.pwm.setAdcDecimation(PWMA, 1);\nspin.pwm.setMode(PWMA, VOLTAGE_MODE);\nspin.pwm.initUnit(PWMA);\nspin.pwm.setDeadTime(PWMA, 200,200);\nspin.pwm.setAdcTrigger(PWMA, ADCTRIG_1);\nspin.pwm.enableAdcTrigger(PWMA);\nspin.pwm.setDutyCycle(0.5);\nspin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/pwm/#how-it-works","title":"How it works","text":"<p>To generate a PWM you need two signals, a variable high frequency signals called the carrier and a constant signal called the duty cycle. </p>"},{"location":"core/docs/pwm/#carrier-signal-and-pwm-resolution","title":"Carrier signal and PWM resolution","text":"<p>The carrier signal is usually a counter in the form of a sawtooth or triangle wave. The frequency of the PWM is given by the max value of that counter. It means that the minimal duty cycle step of phase step, is proportional to the frequency of the signal.</p> <p>Example</p> <p>Here is a counter incrementing from 0 to 27200. </p> <p>The increment between each step is made at the PWM resolution which is here 184ps, so the carrier gets from 0 to 27200 in 5\u00b5s so a frequency of 200kHz. In other words the smallest step is 1/27200 or 0.0037% of the period. </p>"},{"location":"core/docs/pwm/#duty-cycle","title":"Duty cycle","text":"<p>The duty cycle is a constant value compared to the carrier. </p> <p></p> <p>When the carrier is superior to the duty cycle, the logic output is at high level. On the contrary, when the carrier is inferior to the duty cycle the the output logic is low level. A PWM signal is thus a sqarewave signal with a frequency (the switching frequency) is fixed by the carrier.</p> <p>Varying the duty cycle is how to vary the output of the PWM.</p>"},{"location":"core/docs/pwm/#snippet-examples","title":"Snippet examples","text":""},{"location":"core/docs/pwm/#frequency","title":"Frequency","text":"200kHz frequency400kHz frequency <pre><code>    spin.pwm.setFrequency(PWMA, 200000);\n</code></pre> <pre><code>    spin.pwm.setFrequency(PWMA, 400000);\n</code></pre>"},{"location":"core/docs/pwm/#singledual-output","title":"Single/Dual Output","text":"Single OutputSingle Output PWMx2Dual Output <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT1);    \n</code></pre> <pre><code>    spin.pwm.startSingleOutput(PWMA, TIMING_OUTPUT2);    \n</code></pre> <pre><code>    spin.pwm.startDualOutput(PWMA);\n</code></pre>"},{"location":"core/docs/pwm/#duty-cycle_1","title":"Duty Cycle","text":"20% Duty cycle80% Duty cycleHow it works <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.2);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre> <pre><code>    spin.pwm.setDutyCycle(PWMA, 0.8);\n</code></pre>"},{"location":"core/docs/pwm/#phase-shift","title":"Phase Shift","text":"<p>Tip</p> <p>PWMA is defined as the phase reference. It can not be phase shifted.  If you are not using PWMA, you can define any PWM channel as the reference by setting its phase shift to 0\u00b0 NB: Phase reference is 0\u00b0.</p> 20% Phase Shift80% Phase ShiftHow it works <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  72);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMC,  288);\n</code></pre> <p></p> <pre><code>    spin.pwm.setPhaseShift(PWMA,  288);\n</code></pre>"},{"location":"core/docs/pwm/#dead-time","title":"Dead Time","text":"2% Dead Time8% Dead TimeAsymetric Dead Time leading edgeAsymetric Dead Time trailing edge <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  100);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  100,  400);\n</code></pre> <pre><code>    spin.pwm.setDeadtime(PWMA,  400,  100);\n</code></pre>"},{"location":"core/docs/pwm/#modulation-type","title":"Modulation Type","text":"Left AlignedCenter Aligned <pre><code>    spin.pwm.setModulation(PWMA, Lft_aligned);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <pre><code>    spin.pwm.setModulation(PWMA, UpDwn);\n    spin.pwm.setDutyCycle(PWMA, 0.28);\n</code></pre> <p>Example</p> <p>See this examples for more details :  </p> <ul> <li> <p>How to control duty cycle of a PWM unit </p> </li> <li> <p>How to set the trigger instant by linking adc trigger to PWM unit </p> </li> <li> <p>Managing phase shift between two PWM units</p> </li> </ul>"},{"location":"core/docs/pwm/#class-pwmhal","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"core/docs/pwm/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. hrtim_adc_trigger_t getAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initFrequency (uint32_t init_frequency) This function initialize the frequency. void initFrequency (uint32_t init_frequency, uint32_t minimal_frequency) This functions initialize the frequency and also sets the minimal reachable frequency. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startDualOutput (hrtim_tu_number_t pwmX) This fonction starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"core/docs/pwm/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"core/docs/pwm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/pwm/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> function to call each interupt </li> </ul>"},{"location":"core/docs/pwm/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"core/docs/pwm/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Warning:</p> <p>call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"core/docs/pwm/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both </p>"},{"location":"core/docs/pwm/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>hrtim_adc_trigger_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4 </p>"},{"location":"core/docs/pwm/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9 </p>"},{"location":"core/docs/pwm/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWM mode - VOLTAGE_MODE or CURRENT_MODE</p> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"core/docs/pwm/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Lft_aligned or UpDwn (center aligned) </p>"},{"location":"core/docs/pwm/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in uint16 </p>"},{"location":"core/docs/pwm/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"core/docs/pwm/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWMx1 (high side convention) or PWMx2 (low-side convention) </p>"},{"location":"core/docs/pwm/#function-initfrequency-12","title":"function initFrequency [1/2]","text":"<p>This function initialize the frequency. <pre><code>void PwmHAL::initFrequency (\n    uint32_t init_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>init_frequency</code> frequency in Hz</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing any timing unit. the frequency initialized becomes the MINIMUM possible. use it BEFORE initialization of the timing unit. </p>"},{"location":"core/docs/pwm/#function-initfrequency-22","title":"function initFrequency [2/2]","text":"<p>This functions initialize the frequency and also sets the minimal reachable frequency. <pre><code>void PwmHAL::initFrequency (\n    uint32_t init_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>init_frequency</code> frequency in Hz </li> <li><code>minimal_frequency</code> desired minimal frequency in Hz</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing any timing unit </p>"},{"location":"core/docs/pwm/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"core/docs/pwm/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>decimation</code> decimation/post-scaler - a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_edge_trigger</code> Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_trig</code> adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4</li> </ul> <p>Warning:</p> <p>Call this function BEFORE enabling the adc trigger and AFTER initializing the selected timer </p>"},{"location":"core/docs/pwm/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>trig_val</code> a value between 0 and 1 </li> </ul>"},{"location":"core/docs/pwm/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>this function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"core/docs/pwm/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"core/docs/pwm/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>eev</code> external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9</li> </ul> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"core/docs/pwm/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step Use it AFTER the initialization of the timing unit. </p>"},{"location":"core/docs/pwm/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"core/docs/pwm/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>modulation</code> PWM Modulation - Lft_aligned or UpDwn</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"core/docs/pwm/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"core/docs/pwm/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>shift</code> phase shift value \u00b0 between -360 and 360</li> </ul> <p>Warning:</p> <p>use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"core/docs/pwm/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"core/docs/pwm/#function-startdualoutput","title":"function startDualOutput","text":"<p>This fonction starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul>"},{"location":"core/docs/pwm/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"core/docs/pwm/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"core/docs/scheduling/","title":"Task API","text":"<p>PowerAPI is meant to deploy easily Real-time programs that must guarantee response within specified time constraints. In that context, scheduling is the action of asigning computing ressources to perform tasks.</p>"},{"location":"core/docs/scheduling/#include","title":"Include","text":"<p>Note</p> <p><pre><code>#include &lt;TaskAPI.h&gt;\n</code></pre> Make sure that Task API is included</p>"},{"location":"core/docs/scheduling/#deploying-a-real-time-control-task","title":"Deploying a real time control task","text":"<p>Having a periodical code execution is key to real time applications. It is easy to spawn one using the TaskAPI.</p>"},{"location":"core/docs/scheduling/#the-control-task-sources","title":"The control task sources","text":"<p>You can have different source calling the control task.</p> <p>The control task is synchronous, it means that it is called at fixed period. So we need some kind of timer calling the control, this timer is considered as the source. There are two sources :  - The PWM carrier - An independant timer   </p>"},{"location":"core/docs/scheduling/#the-pwm-carrier","title":"The PWM carrier","text":"<p>The carrier has a period called the switching period, we can use it to call the control task after a fixed number of switching period. </p> <p></p> <p>On the figure above, the switching period is 5\u00b5s (200Khz) and we call the control every 10 switching cycle so 50\u00b5s (20Khz).</p> <p>Warning</p> <p>There are limitations when using this method :      - You need to start the a PWM to start the control task     - You can only have control period which are multiple of the switching period     - You can not have a control period inferior to the switching period  </p> <p>Tip</p> <p>Synchronizing the control task period with PWM period can be usefull when you try to synchronize PWM between several SPIN or TWIST, in that case the control task is also synchronized between the board.  </p>"},{"location":"core/docs/scheduling/#independant-timer","title":"Independant timer","text":"<p>A simple timer not related to the PWM can be used to compute the control task period. We choose one of the MCU timer (the <code>timer 6</code>), to which we give our control period and this timer will call the control task each period.  </p> <p></p> <p>Tip</p> <p>With an independant timer you can choose any value in \u00b5s as the control period, there is not the same limitation as the PWM source.  </p> <p>Warning</p> <p>The disavantage of such method is that since it is independant from the PWM you can't have synchronization between several control task modules.</p>"},{"location":"core/docs/scheduling/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Periodic task based on PWM sourcePeriodic task based on Timer6 <p>1. Create the critical task and link it to the function to be called and choose hrtim as the source source. <code>task.createCritical(critical_function, control_period, source_hrtim);</code> 2. Start the critical function.  <code>task.startCritical()</code> </p> <p>1. Create the critical task and link it to the function to be called and choose tim6 as the source.  <code>task.createCritical(critical_function, control_period, source_tim6);</code> 2. Start the critical function.  <code>task.startCritical()</code> </p> <p>Example</p> 20kHz Periodic task based on PWM10kHz Periodic task based on Timer6 <pre><code>    task.createCritical(my_critical_function, 50, source_hrtim); \n    task.startCritical();\n</code></pre> <pre><code>    task.createCritical(my_critical_function, 100, source_tim6);\n    task.startCritical();\n</code></pre> <p>Tip</p> <p>Having a control Task is required for synchronous measurements to work correctly.</p>"},{"location":"core/docs/scheduling/#non-time-critical-tasks","title":"Non time critical tasks","text":"<p>In the powerAPI, non time critical tasks are refered as background tasks.</p>"},{"location":"core/docs/scheduling/#priority-between-critical-and-non-critical-task","title":"Priority between critical and non-critical task","text":"<p>The control task has priority over any other task. It will preempts any background task. The control task can not be preempted. That is why it is also refered as an uninteruptible task.</p> <p></p>"},{"location":"core/docs/scheduling/#pseudo-periodicity-of-non-critical-task","title":"Pseudo periodicity of non-critical task","text":"<p>Non-critical tasks aren't synchronous, meaning they're not recurring at regular intervals. Instead, they operate in a pseudo-periodic manner: we can temporarily halt them for a specific duration, during which they remain inactive.  Below, in the illustration we suspend the background task for a period of 500ms. After 500ms we can execute again the background task, but we need to end the control task to do that (the critical task is uninteruptible).</p> <p></p>"},{"location":"core/docs/scheduling/#initialization-sequence_1","title":"Initialization sequence","text":"<p>Note</p> <p>1. Create the background task and link it to the function to be called. <code>task.createBackground(function)</code>  2. Start the background function. <code>task.startCritical()</code> </p> <p>Example</p> Spawning a background taskMaking it pseudo periodic <p><pre><code>    void my_background_function(){\n        do_stuff();\n    }\n    task.createBackground(my_background_function);\n</code></pre> In that case <code>do_stuff()</code> will execute continuously each time the processor is not occupied by the critical task.</p> <p><pre><code>    void my_background_function(){\n        do_stuff();\n        suspendBackgroundUs(500);\n    }\n</code></pre> In that case after executing <code>do_stuff();</code> the task will be suspended for 500us and resumed after. It creates a pseudo periodical task, runs every 500us + the time taken to execute <code>do_stuff()</code>.</p>"},{"location":"core/docs/scheduling/#class-taskapi","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p>"},{"location":"core/docs/scheduling/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"core/docs/scheduling/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/scheduling/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"core/docs/scheduling/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically. </li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is HRTIM, this value MUST be an integer multiple of the HRTIM period. </li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the HRTIM is the source, but this optional parameter can be provided to set TIM6 as the source in case the HRTIM is not used or if the task can't be correlated to an HRTIM event. Allowed values are source_hrtim and source_tim6. </li> </ul> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error defining the task. An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"core/docs/scheduling/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/scheduling/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"core/docs/scheduling/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"core/docs/scheduling/#function-stopcritical","title":"function stopCritical","text":"<p>Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. <pre><code>void TaskAPI::stopCritical () \n</code></pre></p>"},{"location":"core/docs/scheduling/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"core/docs/scheduling/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"core/docs/twistAPI/","title":"TWIST API","text":"<p>This API is designed to work with the TWIST hardware, providing a set of functions to manage and control the output power.</p>"},{"location":"core/docs/twistAPI/#features","title":"Features","text":"<p> - Versatile Control Modes: The API supports both voltage and peak current control modes, allowing you to choose the best option for your specific application. - Independent Leg Operation: Each of the two legs can operate independently with different topologies, such as boost or buck, offering greater flexibility in power management. - Configure different paramaters for power electronics (dead time, phase shift) - Simplified ADC value retrieval - Refer to TWIST hardware specifications for more detail on TWIST board.  </p>"},{"location":"core/docs/twistAPI/#initialization-sequence","title":"Initialization sequence","text":"<p>Note</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>twist.initAllBuck()</code>, <code>twist.initAllBoost()</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setAllAdcDecim(decim)</code>  4. Set the dead time <code>twist.setAllDeadTime(rise_deadTime_ns, fall_deadTime_ns)</code>  5. Set the phase shift in degree <code>twist.setAllPhaseShift(ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the duty cycle to control output voltage <code>twist.setAllDutyCycle(duty_cycle)</code>  8. Then start the converters <code>twist.startAll()</code> </p> <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost <code>twist.initLegBuck(LEG1/LEG2)</code>, <code>twist.initLegBoost(LEG1/LEG2)</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setLegAdcDecim(LEG1/LEG2, decim)</code> 4. Set the dead time <code>twist.setLegDeadTime(LEG1/LEG2,rise_deadTime_ns, fall_deadTime_ns)</code> 5. Set the phase shift in degree <code>twist.setLegPhaseShift(LEG1/LEG2, ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the duty cycle to control output voltage <code>twist.setLegDutyCycle(LEG1/LEG2, duty_cycle)</code> 8. Then start the converters <code>twist.startLeg(LEG1/LEG2)</code> </p> <p>1. Set the version of the board <code>twist.setVersion(shield_TWIST_VERSION)</code>  2. Choose the wished topology : buck, boost. You can select all the legs to be in the same topology or choose a specific configuration for each one <code>twist.initAllBuck(CURRENT_MODE)</code>, <code>twist.initAllBoost()</code> </p> <p>Optional steps 3. Set the adc decimation to divide the number of trigger event starting the adc conversion <code>twist.setAllAdcDecim(decim)</code>  4. Set the dead time <code>twist.setAllDeadTime(rise_deadTime_ns, fall_deadTime_ns)</code>  5. Set the phase shift in degree <code>twist.setAllPhaseShift(ps_degree)</code> </p> <p>6. Enable the ADC acquisition for twist to get voltage and current measures <code>data.enableTwistDefaultChannels()</code> 7. Set the slope compensation to control the output current<code>twist.setAllSlopeCompensation(1.4, 1.0)</code>  8. Then start the converters <code>twist.startAll()</code> </p> <p>Warning</p> <p>Only buck topology is supported for current mode control currently.</p> <p>Example</p> Voltage mode with all the legsVoltage mode with only LEG1Current mode with all the legs <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initAllBuck();\ntwist.setAllAdcDecim(1);\ntwist.setAllDeadTime(200,200);\ntwist.setAllPhaseShift(180);\ndata.enableTwistDefaultChannels();\ntwist.setAllDutyCycle(0.5);\ntwist.startAll();\n</code></pre> <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initLegBuck(LEG1);\ntwist.setLegAdcDecim(LEG1, 1);\ntwist.setLegDeadTime(LEG1, 200,200);\ntwist.setLegPhaseShift(LEG1, 180);\ndata.enableTwistDefaultChannels();\ntwist.setLegDutyCycle(LEG1, 0.5);\ntwist.startLeg(LEG1);\n</code></pre> <pre><code>twist.setVersion(shield_TWIST_V1_3);\ntwist.initAllBuck(CURRENT_MODE);\ntwist.setAllAdcDecim(1);\ntwist.setAllDeadTime(200,200);\ntwist.setAllPhaseShift(180);\ndata.enableTwistDefaultChannels();\ntwist.setAllSlopeCompensation(1.4, 1.0);\ntwist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#voltage-mode-and-current-mode","title":"Voltage mode and Current mode","text":"<p>There is two different way to control the power delivered by TWIST : voltage and current mode. </p>"},{"location":"core/docs/twistAPI/#voltage-mode","title":"Voltage mode","text":"<p>Voltage mode is a traditional and widely-used approach in power electronics, where the output voltage is regulated by controlling the duty cycle. The duty cycle is a crucial parameter that determines the proportion of time a switch (such as a transistor) is active during a complete switching period. By adjusting the duty cycle, you can effectively manage the power delivered to a load.</p> <p>A higher duty cycle indicates that the switch remains on for a more extended period, resulting in increased power delivery to the load. Conversely, a lower duty cycle means the switch is on for a shorter duration, thereby reducing the power supplied. Consequently, the average power and voltage applied to the load can be precisely controlled by fine-tuning the duty cycle.</p>  Voltage mode PWM schematic  Voltage mode PWM waveform  <p></p> <p></p>"},{"location":"core/docs/twistAPI/#current-mode","title":"Current mode","text":"<p>In peak current mode control,  we monitors the current flowing through the power switch. Once the current reaches a predetermined peak value, we promptly turns off the power switch. This mechanism helps maintain a constant output voltage by regulating the current flow.</p> <p>In this setup, a clock signal determines the switching frequency and triggers the switch to close. The controller then sends a reference peak current value. When the inductor's current reaches this reference value, the switch opens.</p>  Current mode schematic  Current mode waveform  <p> </p> <p> </p> <p>However, using a constant peak current reference can lead to subharmonic oscillations. To prevent this issue, we employ a technique called slope compensation. Instead of a constant value, the peak current reference is a sawtooth waveform. The final schematic with slope compensation is shown below:</p>  Final current mode schematic Final current mode waveform  <p> </p> <p></p> <p>The sawtooth signal <code>Slope compensation</code> is generated with the function <code>twist.setAllSlopeCompensation</code> or <code>twist.setLegSlopeCompensation</code>. These functions set the slope compensation based on the input parameters.  for example <code>twist.setAllSlopeCompensation(1.4, 1.0)</code> generates a sawtooth signal ranging from 1.4V to 1.0V. You can create a sawtooth signal between 2.048V and 0V as well.</p> <p>This sawtooth signal is then compared with the ADC's current value. When selecting the sawtooth parameters, it's essential to consider the conversion of current to voltage.</p> <p>On the TWIST board, a voltage value of 1.024V on the ADC corresponds to a current of 0A. The system has a gain of 100mV per ampere, meaning that for each ampere increase in current, the voltage value increases by 100 millivolts. </p>"},{"location":"core/docs/twistAPI/#snippets-examples","title":"Snippets examples","text":""},{"location":"core/docs/twistAPI/#buck-topology","title":"Buck topology","text":""},{"location":"core/docs/twistAPI/#2-legs-with-the-same-configuration","title":"2 legs with the same configuration","text":"Connection  Schematic  <pre><code>    twist.initAllBuck();\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#2-independant-leg-operations","title":"2 independant leg operations","text":"Connection  Schematic  <pre><code>    twist.initLegBuck(LEG1);\n    twist.initLegBuck(LEG2);\n    twist.setLegDutyCycle(LEG1, 0.3);\n    twist.setLegDutyCycle(LEG2, 0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#boost-topology","title":"Boost topology","text":"Connection  Schematic  <pre><code>    twist.initAllBoost();\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre>"},{"location":"core/docs/twistAPI/#inverter-topology","title":"Inverter topology","text":"Connection  Schematic  <pre><code>    twist.initLegBuck(LEG1);\n    twist.initLegBoost(LEG2);\n    twist.setAllDutyCycle(0.5);\n    twist.startAll();\n</code></pre> <p>Example</p> <p>Check the following examples for an application :     - Voltage mode buck     - Current mode buck     - Voltage mode boost </p>"},{"location":"core/docs/twistAPI/#class-twistapi","title":"Class TwistAPI","text":"<p>ClassList &gt; TwistAPI</p>"},{"location":"core/docs/twistAPI/#public-functions","title":"Public Functions","text":"Type Name void connectAllCapacitor () Connect the electrolyt capacitor to all the legs. void connectLegCapacitor (leg_t leg) Connect the electrolytic capacitor. void disconnectAllCapacitor () disconnect the electrolyt capacitor to all the legs. void disconnectLegCapacitor (leg_t leg) Disonnect the electrolytic capacitor. void initAllBoost () Initialise all the legs for boost topology, current mode is not supported for boost. void initAllBuck (hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE) Initialise all the legs for buck topology. void initAllMode (hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode) Initialize power modes for all legs. void initLegBoost (leg_t leg) Initialise all the legs for boost topology, current mode is not supported for boost. void initLegBuck (leg_t leg, hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE) Initialise a leg for buck topology. void initLegMode (leg_t leg, hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode) Initialize the power mode for a given leg. void setAllAdcDecim (uint16_t adc_decim) set ADC decimator for all legs void setAllDeadTime (uint16_t ns_rising_dt, uint16_t ns_falling_dt) set the dead time value for all legs void setAllDutyCycle (float32_t duty_all) Set the duty cycle for power control of all the legs. void setAllPhaseShift (int16_t phase_shift) Set the phase shift value for all the legs. void setAllSlopeCompensation (float32_t set_voltage, float32_t reset_voltage) Set the slope compensation in current mode for all the leg. void setAllTriggerValue (float32_t trigger_value) Set the trigger value for the ADC trigger of all the legs. void setLegAdcDecim (leg_t leg, uint16_t adc_decim) set ADC decimator for a leg void setLegDeadTime (leg_t leg, uint16_t ns_rising_dt, uint16_t ns_falling_dt) set the dead time value for a leg void setLegDutyCycle (leg_t leg, float32_t duty_leg) Set the duty cycle for a specific leg's power control. void setLegPhaseShift (leg_t leg, int16_t phase_shift) Set the phase shift value for a specific leg's power control. void setLegSlopeCompensation (leg_t leg, float32_t set_voltage, float32_t reset_voltage) Set the slope compensation in current mode for a leg. void setLegTriggerValue (leg_t leg, float32_t trigger_value) Set the trigger value for a specific leg's ADC trigger. void setVersion (twist_version_t twist_ver) Set the hardware version of the board. void startAll () Start power output for all legs. void startLeg (leg_t leg) Start power output for a specific leg. void stopAll () Stop power output for all legs. void stopLeg (leg_t leg) Stop power output for a specific leg."},{"location":"core/docs/twistAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"core/docs/twistAPI/#function-connectallcapacitor","title":"function connectAllCapacitor","text":"<p>Connect the electrolyt capacitor to all the legs. <pre><code>void TwistAPI::connectAllCapacitor () \n</code></pre></p>"},{"location":"core/docs/twistAPI/#function-connectlegcapacitor","title":"function connectLegCapacitor","text":"<p>Connect the electrolytic capacitor. <pre><code>void TwistAPI::connectLegCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which to connect the capacitor. </li> </ul>"},{"location":"core/docs/twistAPI/#function-disconnectallcapacitor","title":"function disconnectAllCapacitor","text":"<p>disconnect the electrolyt capacitor to all the legs. <pre><code>void TwistAPI::disconnectAllCapacitor () \n</code></pre></p>"},{"location":"core/docs/twistAPI/#function-disconnectlegcapacitor","title":"function disconnectLegCapacitor","text":"<p>Disonnect the electrolytic capacitor. <pre><code>void TwistAPI::disconnectLegCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which to disonnect the capacitor. </li> </ul>"},{"location":"core/docs/twistAPI/#function-initallboost","title":"function initAllBoost","text":"<p>Initialise all the legs for boost topology, current mode is not supported for boost. <pre><code>void TwistAPI::initAllBoost () \n</code></pre></p>"},{"location":"core/docs/twistAPI/#function-initallbuck","title":"function initAllBuck","text":"<p>Initialise all the legs for buck topology. <pre><code>void TwistAPI::initAllBuck (\n    hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"core/docs/twistAPI/#function-initallmode","title":"function initAllMode","text":"<p>Initialize power modes for all legs. <pre><code>void TwistAPI::initAllMode (\n    hrtim_switch_convention_t leg_convention,\n    hrtim_pwm_mode_t leg_mode\n) \n</code></pre></p> <p>This function initializes the power modes for each leg with the specified 'buck' and 'voltage_mode' settings.</p> <p>Parameters:</p> <ul> <li><code>leg_convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2 </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"core/docs/twistAPI/#function-initlegboost","title":"function initLegBoost","text":"<p>Initialise all the legs for boost topology, current mode is not supported for boost. <pre><code>void TwistAPI::initLegBoost (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize </li> </ul>"},{"location":"core/docs/twistAPI/#function-initlegbuck","title":"function initLegBuck","text":"<p>Initialise a leg for buck topology. <pre><code>void TwistAPI::initLegBuck (\n    leg_t leg,\n    hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"core/docs/twistAPI/#function-initlegmode","title":"function initLegMode","text":"<p>Initialize the power mode for a given leg. <pre><code>void TwistAPI::initLegMode (\n    leg_t leg,\n    hrtim_switch_convention_t leg_convention,\n    hrtim_pwm_mode_t leg_mode\n) \n</code></pre></p> <p>This function configures modulation, frequency, phase shift, dead time, and other parameters for power control of a specified leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize </li> <li><code>leg_convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2 </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"core/docs/twistAPI/#function-setalladcdecim","title":"function setAllAdcDecim","text":"<p>set ADC decimator for all legs <pre><code>void TwistAPI::setAllAdcDecim (\n    uint16_t adc_decim\n) \n</code></pre></p> <p>this function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if adc_decim = 1, nothing changes but with adc_decims = 2 you have twice less adc trigger.</p> <p>Parameters:</p> <ul> <li><code>adc_decim</code> - adc decimator, a number between 1 and 32 </li> </ul>"},{"location":"core/docs/twistAPI/#function-setalldeadtime","title":"function setAllDeadTime","text":"<p>set the dead time value for all legs <pre><code>void TwistAPI::setAllDeadTime (\n    uint16_t ns_rising_dt,\n    uint16_t ns_falling_dt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ns_rising_dt</code> - rising dead time value in ns </li> <li><code>ns_falling_dt</code> - falling dead time value in ns </li> </ul>"},{"location":"core/docs/twistAPI/#function-setalldutycycle","title":"function setAllDutyCycle","text":"<p>Set the duty cycle for power control of all the legs. <pre><code>void TwistAPI::setAllDutyCycle (\n    float32_t duty_all\n) \n</code></pre></p> <p>This function sets the same duty cycle for power control of all the legs. The duty cycle determines the ON/OFF ratio of the power signal for all legs.</p> <p>Parameters:</p> <ul> <li><code>duty_all</code> The duty cycle value to set (a floating-point number between 0.1 and 0.9). </li> </ul>"},{"location":"core/docs/twistAPI/#function-setallphaseshift","title":"function setAllPhaseShift","text":"<p>Set the phase shift value for all the legs. <pre><code>void TwistAPI::setAllPhaseShift (\n    int16_t phase_shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phase_shift</code> The phase shift value to set. </li> </ul>"},{"location":"core/docs/twistAPI/#function-setallslopecompensation","title":"function setAllSlopeCompensation","text":"<p>Set the slope compensation in current mode for all the leg. <pre><code>void TwistAPI::setAllSlopeCompensation (\n    float32_t set_voltage,\n    float32_t reset_voltage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>set_voltage</code> in volt, the DAC peak voltage for slope compensation (value between 0 and 2.048) </li> <li><code>reset_voltage</code> in volt, the DAC lowest voltage for slope compensation (value between 0 and 2.048)</li> </ul> <p>Warning:</p> <p>Be sure that set_voltage &gt; reset_voltage </p>"},{"location":"core/docs/twistAPI/#function-setalltriggervalue","title":"function setAllTriggerValue","text":"<p>Set the trigger value for the ADC trigger of all the legs. <pre><code>void TwistAPI::setAllTriggerValue (\n    float32_t trigger_value\n) \n</code></pre></p> <p>This function sets the same trigger value for the ADC trigger of all the legs. The trigger value determines the level at which the ADC trigger is activated for all legs.</p> <p>Parameters:</p> <ul> <li><code>trigger_value</code> The trigger value to set for all the legs between 0.0 and 1.0. </li> </ul>"},{"location":"core/docs/twistAPI/#function-setlegadcdecim","title":"function setLegAdcDecim","text":"<p>set ADC decimator for a leg <pre><code>void TwistAPI::setLegAdcDecim (\n    leg_t leg,\n    uint16_t adc_decim\n) \n</code></pre></p> <p>this function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if adc_decim = 1, nothing changes but with adc_decims = 2 you have twice less adc trigger.</p> <p>Parameters:</p> <ul> <li><code>leg</code> - leg for which to set adc decimator value </li> <li><code>adc_decim</code> - adc decimator, a number between 1 and 32 </li> </ul>"},{"location":"core/docs/twistAPI/#function-setlegdeadtime","title":"function setLegDeadTime","text":"<p>set the dead time value for a leg <pre><code>void TwistAPI::setLegDeadTime (\n    leg_t leg,\n    uint16_t ns_rising_dt,\n    uint16_t ns_falling_dt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> - the leg for which to set dead time value </li> <li><code>ns_rising_dt</code> - rising dead time value in ns </li> <li><code>ns_falling_dt</code> - falling dead time value in ns </li> </ul>"},{"location":"core/docs/twistAPI/#function-setlegdutycycle","title":"function setLegDutyCycle","text":"<p>Set the duty cycle for a specific leg's power control. <pre><code>void TwistAPI::setLegDutyCycle (\n    leg_t leg,\n    float32_t duty_leg\n) \n</code></pre></p> <p>This function sets the duty cycle for the power control of a specified leg. The duty cycle determines the ON/OFF ratio of the power signal for the leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the duty cycle. </li> <li><code>duty_leg</code> The duty cycle value to set (a floating-point number between 0.1 and 0.9). </li> </ul>"},{"location":"core/docs/twistAPI/#function-setlegphaseshift","title":"function setLegPhaseShift","text":"<p>Set the phase shift value for a specific leg's power control. <pre><code>void TwistAPI::setLegPhaseShift (\n    leg_t leg,\n    int16_t phase_shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the phase shift value. </li> <li><code>phase_shift</code> The phase shift value to set. </li> </ul>"},{"location":"core/docs/twistAPI/#function-setlegslopecompensation","title":"function setLegSlopeCompensation","text":"<p>Set the slope compensation in current mode for a leg. <pre><code>void TwistAPI::setLegSlopeCompensation (\n    leg_t leg,\n    float32_t set_voltage,\n    float32_t reset_voltage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize </li> <li><code>set_voltage</code> in volt, the DAC peak voltage for slope compensation (value between 0 and 2.048) </li> <li><code>reset_voltage</code> in volt, the DAC lowest voltage for slope compensation (value between 0 and 2.048)</li> </ul> <p>Warning:</p> <p>Be sure that set_voltage &gt; reset_voltage </p>"},{"location":"core/docs/twistAPI/#function-setlegtriggervalue","title":"function setLegTriggerValue","text":"<p>Set the trigger value for a specific leg's ADC trigger. <pre><code>void TwistAPI::setLegTriggerValue (\n    leg_t leg,\n    float32_t trigger_value\n) \n</code></pre></p> <p>This function sets the trigger value for the ADC trigger of a specified leg. The trigger value determines the level at which the ADC trigger is activated.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the ADC trigger value. </li> <li><code>trigger_value</code> The trigger value to set between 0.05 and 0.95. </li> </ul>"},{"location":"core/docs/twistAPI/#function-setversion","title":"function setVersion","text":"<p>Set the hardware version of the board. <pre><code>void TwistAPI::setVersion (\n    twist_version_t twist_ver\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>shield</code> shield version - shield_TWIST_V1_2, shield_TWIST_V1_3, shield_ownverter or shield_other</li> </ul> <p>Warning:</p> <p>You need to call this function BEFORE initializing a leg, after that it is not possible to change the shield version </p>"},{"location":"core/docs/twistAPI/#function-startall","title":"function startAll","text":"<p>Start power output for all legs. <pre><code>void TwistAPI::startAll () \n</code></pre></p>"},{"location":"core/docs/twistAPI/#function-startleg","title":"function startLeg","text":"<p>Start power output for a specific leg. <pre><code>void TwistAPI::startLeg (\n    leg_t leg\n) \n</code></pre></p> <p>This function initiates the power output for a specified leg by starting the PWM subunits associated with the leg's output pins. If the leg's output pins are not declared inactive in the device tree, the corresponding subunits are started. eg. If output1 is declared inactive in the device tree, PWMA1 will not start</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to start the power output. </li> </ul>"},{"location":"core/docs/twistAPI/#function-stopall","title":"function stopAll","text":"<p>Stop power output for all legs. <pre><code>void TwistAPI::stopAll () \n</code></pre></p>"},{"location":"core/docs/twistAPI/#function-stopleg","title":"function stopLeg","text":"<p>Stop power output for a specific leg. <pre><code>void TwistAPI::stopLeg (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to stop the power output. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/public_api/TwistAPI.h</code></p>"},{"location":"core/owntech/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board for PlatformIO.</p> <p>The <code>boards_dir</code> variable is defined in <code>platformio.ini</code>, making this the board directory for PlatformIO, which will use its file <code>spin.json</code>.</p> <p>Help link: - PlatformIO Custom Boards</p>"},{"location":"core/zephyr/boards/readme/","title":"Readme","text":"<p>This folder contains the definition of the Spin board and Twist shield for Zephyr.</p> <p>As per location (within <code>Zephyr</code> folder), this is the default board directory for Zephyr OS, which will use its sub-directories <code>arm/spin</code> and <code>shields/twist</code>.</p> <p>Help links: - Zephyr OS Board Porting Guide - Zephyr OS Application Development Custom Board</p>"},{"location":"examples/","title":"Index","text":"<p>Welcome to the owntech examples repository.</p> <p>Here you can find ready to be used example for spin and twist.</p>"},{"location":"examples/#example-for-twist","title":"Example for TWIST","text":"<ul> <li> <p>DC DC topology examples</p> <ul> <li>Buck voltage mode</li> <li>Buck current mode</li> <li>Boost voltage mode</li> <li>Interleaved Buck</li> </ul> </li> <li> <p>Microgrid examples</p> <ul> <li>AC client server</li> <li>AC peer to peer</li> <li>DC client server</li> <li>DC droop</li> </ul> </li> <li> <p>DC AC topology examples</p> <ul> <li>Grid forming</li> <li>Grid following</li> </ul> </li> </ul>"},{"location":"examples/#example-for-spin","title":"Example for SPIN","text":"<ul> <li> <p>ADC use examples</p> <ul> <li>Software trigerred ADC</li> <li>HRTIM trigerred ADC</li> </ul> </li> <li> <p>DAC use examples</p> <ul> <li>Signal generation</li> </ul> </li> <li> <p>LED use examples</p> <ul> <li>Blinky</li> </ul> </li> <li> <p>PWM use examples</p> <ul> <li>PWM duty cycle control</li> <li>PWM phase shift control</li> <li>Multiple PWM operation</li> </ul> </li> <li> <p>TIMER</p> <ul> <li>Incremental encoder</li> </ul> </li> </ul>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/","title":"Triggering measure from ADC via HRTIM trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>The spin uses the stm32G4 MCU, which has a high resolution timer (HRTIM) which can produce high resolution PWM. This example will show you how to use the HRTIM in order to trigger the measures. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#software-setup","title":"Software setup","text":"<p>The HRTIM has 6 differents timer (A,B,C,D,E,F) but you can choose up to two of them to trigger the measures. In this example we'll show you how you can use one of them the timer A.</p> <p>On the picture below, you can see the waveform of the timer A pwm, the carrier, the duty cycle and the colored zone represents the timing where the measures is trigerred. </p> <p> figure 2</p> <p>The measure is triggered with the same frequency as the switching frequency, the measure is done around the trough of the carrier on the positive slope. We will explain here which functions to call to setup the ADC trigger. </p> <p>First of all, we start by initializing the PWMA : </p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMA, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMA, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> The function <code>setAdcEdgeTrigger</code> allows us to choose where we want to trigger the measures : on the positive slope (EdgeTrigger_up) of the carrier like in fig.2, or the negative slope (EdgeTrigger_down) of the carrier.</p> <p>After the initialization of the PWM, we can link it to a trigger : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMA, ADCTRIG_1); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMA, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMA); // enable the trigger\n</code></pre> We are linking PWMA to a trigger, here ADCTRIG_1. There is a total of 4 trigger possible ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4. However, there is only two that works for data acquisition currently : ADCTRIG_1 and ADCTRIG_3.</p> <p><code>setAdcTriggerInstant</code> will set the moment when we trigger a measure with a parameter between 0 (corresponding to the trough of the carrier)and 1 (corresponding to the crest of the carrier). Here we took 0.06, so we'll get the data around the trough of the carrier (as we have seen on fig.2)</p> <p>And finally, we set the ADC2 to be set by the ADCTRIG_1, hrtim_ev1 means hrtim external event 1 which is ADCTRIG_1. </p> <p><pre><code>    spin.adc.configureTriggerSource(2, hrtim_ev1); // ADC 2 configured to be triggered by the PWM\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can also use ADCTRIG_3 to have PWMC trigger another ADC and get another measure. Below, we reproduce the same step but by using the ADC1 channel 2 localized on PA1 (pin number 30).</p> <p>start PWMC :</p> <p><pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    spin.pwm.setModulation(PWMC, UpDwn); // Modulation mode, here up-down (triangle wave carrier)\n    spin.pwm.setAdcEdgeTrigger(PWMC, EdgeTrigger_up); // Trigger on the positive slope\n\n    spin.pwm.initUnit(PWMC); // timer initialization\n</code></pre> link ADCTRIG_3 to PWMC : </p> <p><pre><code>    spin.pwm.setAdcTrigger(PWMC, ADCTRIG_3); // PWMA is linked to ADCTRIG_1\n    spin.pwm.setAdcTriggerInstant(PWMC, 0.06); // set the trigger instant\n    spin.pwm.enableAdcTrigger(PWMC); // enable the trigger\n</code></pre> then set ADC1 channel 5 to be trigerred by ADCTRIG_3 : </p> <pre><code>    spin.adc.configureTriggerSource(1, hrtim_ev3); // ADC 2 configured to be triggered by the PWM\n    data.enableAcquisition(1, 30); // ADC 2 enabled\n</code></pre> <p>Finally you can retrieve data from the ADC : </p> <pre><code>    data.triggerAcquisition(1);\n    adc_value = data.getLatest(1, 30);\n</code></pre>"},{"location":"examples/SPIN/ADC/adc_hrtim_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/","title":"Triggering measure from ADC via software trigger","text":"<p>An ADC, or Analog-to-Digital Converter, is a crucial component in modern electronics that converts continuous analog signals into discrete digital data. In simpler terms, it takes real-world phenomena, like sound or temperature, and turns them into numbers that a computer can understand and process. This conversion is essential for various applications, in power electronics it allows us to get real-time measures from the circuit like voltage and current. </p> <p>This example will show you how to get measures from the ADC by calling a function that will trigger the measures : this is what we call a software trigger.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>A signal generator to create a waveform to measure it from ADC, it can be sinewave, triangle wave...etc. This signal must between 0V and 2.048V</li> </ul> <p>Connect the signal generator to pin C4, and gnd. </p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#software-setup","title":"Software setup","text":"<p>The ADC 2 is used here, it is initialized like this : </p> <p><pre><code>    spin.adc.configureTriggerSource(2, software); // ADC 2 configured in software mode\n</code></pre> We use the 5th channel of the adc, which is the gpio C4 on the spin (also numbered as pin 35). To enable the acquisition from this pin, we use the function <code>enableAcquisition</code>: </p> <p><pre><code>data.enableAcquisition(2, 35) // Enable acquisition for ADC2, for channel 5 (localized in GPIO C4 / pin number 35)\n</code></pre> When we want to retrieve measures from ADC2 all we need to do is trigger ADC2 and retrieve measured value in GPIO C4 / pin number 35 :</p> <pre><code>    data.triggerAcquisition(2);\n    adc_value = data.getLatest(2, 35);\n</code></pre> <p>There is a total of 8 possible pin from where you can get analog measures :</p> GPIO PIN number ADC and channels PC4 35 ADC2 channel 5 PA1 30 ADC1 channel 2 / ADC2 channel 2 PA0 29 ADC1 channel 1 / ADC2 channel 1 PC3 27 ADC1 channel 9 / ADC2 channel 9 PC2 26 ADC1 channel 8 / ADC2 channel 8 PC1 25 ADC1 channel 7 / ADC2 channel 7 PC0 24 ADC1 channel 6 / ADC2 channel 6 PB15 6 ADC4 channel 5 <p>You can configure any of the above ADC with same steps.</p>"},{"location":"examples/SPIN/ADC/adc_software_trigger/#expetected-results","title":"Expetected results","text":"<p>The analog value measured from the adc is stored inside the variable <code>adc_value</code>, which is printed in the serial monitor every 100ms you can then watch the measured on ownplot. </p> <p>If everything went correctly, you should observe the same waveform on ownplot that you generate via the signal generator. </p>"},{"location":"examples/SPIN/DAC/signal_generation/","title":"Generating waveform with DAC","text":"<p>A DAC, or Digital-to-Analog Converter, converts digital signals into corresponding analog signals. It achieves this by assigning digital values to specific voltage, effectively generating continuous analog waveforms from discrete digital data. This functionality makes DACs essential for generating various waveforms in electronic systems.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> <li>An oscilloscope to watch the DAC output</li> </ul> <p>Connect the oscilloscope to gpio PA6 (the DAC output).</p>"},{"location":"examples/SPIN/DAC/signal_generation/#software-setup","title":"Software setup","text":"<p>In this example we will use DAC 2 channel 1 to output a sawtooth signal. </p> <p>We start by initializing the DAC :</p> <pre><code>    spin.dac.initConstValue(2); // DAC 2 initialization\n    spin.dac.setConstValue(2, 1, 0); // Setting DAC 2 channel 1 to 0\n</code></pre> <p>The function <code>setConstValue</code> will convert numerical value (from 0 to 4096) to a voltage (between 0 and 2.048) with the DAC. </p> <p>In the background task (called every 100ms), is increasing the value send to the DAC : </p> <pre><code>    dac_value = (dac_value + 100)%4096;\n    spin.dac.setConstValue(2, 1, dac_value);\n</code></pre> <p>You can also reproduce the same step to use DAC1 channel 1 localized in gpio PA4.</p>"},{"location":"examples/SPIN/DAC/signal_generation/#expected-result","title":"Expected result","text":"<p>You should see a sawtooth on the DAC output.</p>"},{"location":"examples/SPIN/LED/blinky/","title":"Blinking a led","text":"<p>Here is a simple example to start with SPIN : making a led blink.</p>"},{"location":"examples/SPIN/LED/blinky/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need : </p> <ul> <li>1 spin</li> <li>A usb-c cable to supply power to the spin, and also upload the code from computer</li> </ul>"},{"location":"examples/SPIN/LED/blinky/#software-setup","title":"Software setup","text":"<p>The led is toggled in the background task called each 1s, which means the leed will blink at the rate of 1s : </p> <pre><code>    spin.led.toggle();\n</code></pre>"},{"location":"examples/SPIN/LED/blinky/#expected-result","title":"Expected result","text":"<p>Visual result : the led should turn on and off. </p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/","title":"Setting the duty cycle","text":"<p>In the context of Pulse Width Modulation (PWM), the duty cycle refers to the proportion of time that a signal is in the \"on\" state compared to the total period of the signal. It represents the percentage of time during which the signal is at its maximum level.</p> <p>In power electronics, such as motor control, power supplies, and voltage regulation, PWM is a widely used technique for controlling the amount of power delivered to a load. The duty cycle of the PWM signal determines the average power delivered to the load. By adjusting the duty cycle, engineers can control the speed of motors, regulate voltage levels, and efficiently manage power consumption.</p> <p>In this example we'll see how to generate a PWM, an control the duty cycle.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with one of them : PWMA.</p> <p> Figure 1</p> <p>PWMA has two complementary channels :</p> <ul> <li>PWMA1 on gpio A8</li> <li>PWMA2 on gpio A9</li> </ul> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#software-setup","title":"Software setup","text":"<p>First we start by initializing the PWMA :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n    spin.pwm.initUnit(PWMA); // timer initialization\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n</code></pre> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/duty_cycle_setting/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe two complementary PWM and their evolution when you increase/decrease the duty cycle.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/","title":"Working with multiple PWM","text":"<p>The spin has a total of 5 PWM channels with 2 complementary output each. In this example, we'll detail how to use each of them.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p> figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch :</p> <p>-PWMA1 on gpio A8 -PWMC1 on gpio B12 -PWMD1 on gpio B14 -PWME1 on gpio C8 -PWMF1 on gpio C6</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#software-setup","title":"Software setup","text":"<p>This example is initializing every PWM, and making a phase shift 77\u00b0 (= 360/5\u00b0) as if we working in interleaved mode. See the  phase shift  example for more details.</p> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/multiple_pwm/#expected-result","title":"Expected result","text":"<p>You should observe 5 PWM with a phaseshift of 77\u00b0 between them.</p>"},{"location":"examples/SPIN/PWM/phase_shift/","title":"Phase shifting PWM","text":"<p>Phase shift in Pulse Width Modulation (PWM) refers to the intentional offset of the timing between multiple PWM signals. This offset alters the switching instants of the signals, affecting the distribution of power delivery and minimizing ripple in power electronic systems.</p> <p>Phase shifting PWM is used in interleaved topology for power electronics. In this example we'll show you how setup a phase shift for a 2 leg interleaved configuration for example.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>The spin can use up to 5 different PWM : PWMA, PWMC, PWMD, PWME and PWMF. This example will detail how to work with two of them in phase shifted mode : PWMA and PWMB.</p> <p> Figure 1</p> <p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>An oscilloscope to watch PWM waveform</li> </ul> <p>We can watch PWMA1 on gpio A8 and PWMC1 on gpio B12.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#software-setup","title":"Software setup","text":"<p>We start by initializing PWMA and PWMC :</p> <pre><code>    spin.pwm.setFrequency(200000); // Set frequency of pwm\n\n    /* PWM A initialization */\n    spin.pwm.initUnit(PWMA); // timer initialization\n    spin.pwm.startDualOutput(PWMA); // Start PWM\n\n    /* PWM C initialization */\n    spin.pwm.initUnit(PWMC); // timer initialization\n    spin.pwm.setPhaseShift(PWMC, 180); // Phase shift of 180\u00b0 for 2 legs interleaved configuration\n    spin.pwm.startDualOutput(PWMC); // Start PWM\n</code></pre> <p>The frequency for the pwm is initalized to 200kHz but you are free to choose another value.</p> <p>PWMC is shifted of 180\u00b0 from PWMA.</p> <p>The duty cycle is updated in the high-speed control task :</p> <pre><code>    spin.pwm.setDutyCycle(PWMA, duty_cycle);\n    spin.pwm.setDutyCycle(PWMC, duty_cycle);\n</code></pre> <p>The duty cycle is the same for both PWMA and PWMC.</p> <p>You can control the duty cycle from the serial monitor : - press <code>u</code> to increase the duty cycle - press <code>d</code> to decrease the duty cycle</p> <p>See ownplot if you would like a better graphical interface for the serial monitor.</p>"},{"location":"examples/SPIN/PWM/phase_shift/#expected-result","title":"Expected result","text":"<p>On the oscilloscope you should observe that PWMC1 is phase shifted of 180\u00b0 from PWMA1 (which means they are complementary).</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/","title":"Using the spin with an incremental encoder","text":"<p>An incremental encoder is a device that converts mechanical motion into digital signals. It typically consists of a rotating disk with evenly spaced slots and a sensor that detects these slots as the disk turns. The sensor generates electrical pulses corresponding to the motion, which can be used to track position, speed, or direction.</p> <p>in this example we'll see how to use an incremental encoder with spin.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need :</p> <ul> <li>A spin</li> <li>A usb-c cable to supply the spin</li> <li>A rotary incremental encoder</li> </ul> <p>Connect output A (clk) to gpio B6 and output B (dt) to gpio B7.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#software-setup","title":"Software setup","text":"<p>We initialize the incremental encoder :</p> <p><pre><code>    spin.timer.startLogTimer4IncrementalEncoder();\n</code></pre> The value from the incremental encoder is updated in the background task (called every 100ms). This value is displayed in the serial monitor.</p>"},{"location":"examples/SPIN/TIMER/incremental_encoder/#expected-result","title":"Expected result","text":"<p>You should see the value in the serial monitor either increasing or decresing depending on how you turning the rotary incremental encoder (clokc-wise or not).</p>"},{"location":"examples/TWIST/DC_AC/grid_following/","title":"Ac current source follower","text":"<p>In this example you need to have a first Twist with the Grid Forming example.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 15 \\Omega\\).</li> </ul> <p>In the second Twist we use a software phase locked loop ( \"PLL\" ). By this way we are synchronised with the grid voltage and we can then inject current with a power factor of one. The current is regulated using a proportional resonant (\"PR\") regulator.</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_following/#import-a-library","title":"Import a library","text":"<p>the \"pll\" and \"pr\" are provided by the OwnTech control library which must be included  in the file <code>platfomio.ini</code>.</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#define-a-regulator","title":"Define a regulator","text":"<p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.2F;\nstatic float32_t Kr = 3000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_following/#configure-the-pll","title":"Configure the PLL","text":"<p>You have to define a PLL: <pre><code>static PllSinus pll;\nstatic PllDatas pll_datas;\n</code></pre></p> <p>Then initialize it: <pre><code>float32_t rise_time = 50e-3;\npll.init(Ts, Vgrid_amplitude, f0, rise_time);\n</code></pre></p> <p>and use it: <pre><code>pll_datas = pll.calculateWithReturn(V1_low_value - V2_low_value);\n</code></pre></p> <p>The calculation return a structure with 3 fields:</p> <ol> <li>the pulsation <code>w</code> in [rad/s]</li> <li>the angle <code>angle</code> in [rad]</li> <li>the angle error <code>error</code> in [rad/s]</li> </ol>"},{"location":"examples/TWIST/DC_AC/grid_following/#link-between-voltage-output-and-duty-cycle","title":"Link between voltage output and duty cycle","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_AC/grid_following/#retrieve-recorded-datas","title":"Retrieve recorded datas","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/","title":"Ac Voltage Source","text":"<p>In this example we build an AC voltage source using a Twist and supply a resistor.</p> <p>The parameters are:</p> <ul> <li>\\(U_{DC} = 40 V\\)</li> <li>\\(R_{LOAD} = 30 \\Omega\\).</li> </ul>"},{"location":"examples/TWIST/DC_AC/grid_forming/#software-overview","title":"Software overview","text":""},{"location":"examples/TWIST/DC_AC/grid_forming/#import-libraries","title":"Import libraries","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#define-a-regulator","title":"Define a regulator","text":"<p>The voltage regulation will be done by a proportional resonant regulator. This component is provided by the OwnTech control library <code>control_lib</code>.</p> <p>The Proportional Resonant regulator is initialized with the lines above:</p> <pre><code>PrParams params = PrParams(Ts, Kp, Kr, w0, 0.0F, -Udc, Udc);\nprop_res.init(params);\n</code></pre> <p>The parameters are defined with these values:</p> <pre><code>static Pr prop_res; // controller instanciation. \nstatic float32_t Kp = 0.02F;\nstatic float32_t Kr = 4000.0F;\nstatic float32_t Ts = control_task_period * 1.0e-6F;\nstatic float32_t w0 = 2.0 * PI * 50.0;   // pulsation\nstatic float32_t Udc = 40.0F;\n</code></pre>"},{"location":"examples/TWIST/DC_AC/grid_forming/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have to put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/DC_AC/grid_forming/#link-between-voltage-reference-and-duty-cycles","title":"Link between voltage reference and duty cycles.","text":"<p>The voltage source is defined by the voltage difference: \\(U_{12} = V_{1low} - V_{2low}\\).</p> <p>Link with the duty cycle:</p> <ul> <li>The leg1 is fixed in buck mode then: \\(V_{1low} = \\alpha_1 . U_{DC}\\)</li> <li>The leg2 is fixed in boost mode then: \\(V_{2low} = (1-\\alpha_2) . U_{DC}\\)</li> </ul> <p>We change at the same time \\(\\alpha_1\\) and \\(\\alpha_2\\), then we have : \\(\\alpha_1 = \\alpha_2 = \\alpha\\).  And then: \\(U_{12} = (2.\\alpha - 1).U_{DC}\\)</p> <p>\\(\\alpha = \\dfrac{U_{12}}{2.U_{DC}}  + 0.5\\)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/","title":"Boost with PID controlled output voltage","text":"<p>A voltage mode boost converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps up voltage levels, making it useful in various electronic devices such as converting photovoltaic panel voltage.</p> <p>This example will implement a voltage mode boost converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (max 10V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import the OwnTech control library with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static Pid pid; // define a pid controller\n\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/boost_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/","title":"Buck current mode","text":""},{"location":"examples/TWIST/DC_DC/buck_current_mode/#overview","title":"Overview","text":"<p>A buck converter is a type of DC-DC converter used to efficiently regulate voltage levels. It works by converting a higher input voltage to a lower output voltage.</p> <p>Peak current control mode is a technique used in DC-DC converters to regulate the output voltage. In this mode, the converter controls the output voltage by monitoring the peak current flowing through the inductor. During each switching period when the peak current reaches a set limit, the converter switches off. This mode helps maintain stable output voltage by adjusting the duty cycle of the switching signal based on the peak current level, ensuring efficient and reliable power conversion.</p> <p>Currently only buck configuration is supported for current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#control-diagram","title":"Control diagram","text":"<p>The general implementation of the current mode follow this model.</p> <p> Source : STM32 AN5497</p> <p>check stm32 application note for more informations about current mode.</p>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#requirement-and-schematic","title":"Requirement and schematic","text":"<p>You will need :</p> <ul> <li>1 twist</li> <li>A DC power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#code-overview","title":"Code overview","text":"<p>We initialize the leg control in buck current mode with the lines above: </p> <pre><code> /* Initialize buck with current mode*/\n    twist.initAllBuck(CURRENT_MODE);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_current_mode/#important-functions","title":"Important functions","text":"<p>For current mode, there are two specific functions to control the current of both legs.</p> <pre><code>twist.setLegSlopeCompensation(LEG1, 1.4, 1.0);\ntwist.setLegSlopeCompensation(LEG2, 1.4, 1.0);\n</code></pre> <p>It sets in volt the higher and lower point of the sawtooth used for the slope compensation.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/","title":"Buck with PID controlled output voltage","text":"<p>A voltage mode buck converter regulates voltage by comparing the output voltage to a reference voltage. It adjusts the duty cycle of its switching signal to keep the output voltage stable. This type of converter efficiently steps down voltage levels, making it useful in various electronic devices like phone battery charger.</p> <p>This example will implement a voltage mode buck converter to control the output.</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#hardware-setup-and-requirement","title":"Hardware setup and requirement","text":"<p>You will need : - 1 TWIST - A dc power supply (20-60V) - A resistor (or a dc electronic load)</p>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#software-setup","title":"Software setup","text":"<p>We import control_pid library with src/owntech.ini via the line :</p> <pre><code>lib_deps=\n    control_pid = https://gitlab.laas.fr/owntech/power-api/opalib-control-pid.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>opalib_control_init_interleaved_pid(kp, ki, kd, control_task_period);\n</code></pre> <p>the initial parameters are :</p> <pre><code>static float32_t kp = 0.000215;\nstatic float32_t ki = 2.86;\nstatic float32_t kd = 0.0;\nstatic uint32_t control_task_period = 100;\n</code></pre>"},{"location":"examples/TWIST/DC_DC/buck_voltage_mode/#expected-result","title":"Expected result","text":"<p>This code will control the output voltage to have 15V, you can control the output voltage with the serial monitor :</p> <ul> <li>press <code>u</code> to increase the voltage</li> <li>press <code>d</code> to decrease the voltage</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/","title":"Interleaved operation","text":""},{"location":"examples/TWIST/DC_DC/interleaved/#overview","title":"Overview","text":"<p>In the case of a two-phase interleaved buck converter, the term \"interleaved\" implies that there are two power stages operating, and they are out of phase by 180 degrees. This means that while one power stage is in its on-state (conducting), the other is in its off-state (non-conducting), and vice versa.</p> <p>The 180-degree phase shift ensures that there is always at least one power stage active, reducing the overall ripple and improving the efficiency of the buck converter. The interleaved operation helps distribute the load more evenly, minimizing the stress on individual components and resulting in a more efficient power conversion process.</p> <p></p> <p></p> <p>This example will implement interleaved operation using the two legs of the TWIST.</p>"},{"location":"examples/TWIST/DC_DC/interleaved/#hardware-setup-and-requirements","title":"Hardware setup and requirements","text":"<p>You will need :</p> <ul> <li>1 TWIST</li> <li>A DC voltage power supply</li> <li>A resistor (or a DC electronic load)</li> </ul>"},{"location":"examples/TWIST/DC_DC/interleaved/#software-setup","title":"Software setup","text":"<p>We import <code>control_library</code> with platformio.ini via the line :</p> <pre><code>lib_deps=\n    control_lib = https://github.com/owntech-foundation/control_library.git\n</code></pre> <p>We can use this library to initialize a PID control with the function :</p> <pre><code>pid.init(pid_params);\n</code></pre> <p>the initial parameters are defined using the following lines :</p> <pre><code>static Pid pid; // define a pid controller.\n\nstatic float32_t Ts = control_task_period * 1.e-6F;\nstatic float32_t kp = 0.000215;\nstatic float32_t Ti = 7.5175e-5;\nstatic float32_t Td = 0.0;\nstatic float32_t N = 0.0;\nstatic float32_t upper_bound = 1.0F;\nstatic float32_t lower_bound = 0.0F;\nstatic PidParams pid_params(Ts, kp, Ti, Td, N, lower_bound, upper_bound);\n</code></pre>"},{"location":"examples/TWIST/DC_DC/interleaved/#expected-results","title":"Expected results","text":"<p>The voltage reference is initially 15V, but you can increase/decrease it with the serial monitor with 'u' and 'd' on you keyboard.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/","title":"Client/Server control AC/DC","text":""},{"location":"examples/TWIST/Microgrid/AC_client_server/#overview","title":"Overview","text":"<p>In a dual inverter setup with one inverter designated as the \"SERVER\" and the other as the \"CLIENT,\" the SERVER inverter is responsible for sending a current reference and frequency signal to the CLIENT inverter. The CLIENT inverter, in turn, has the task of tracking the current reference from the SERVER and generating an output current that is in phase with the SERVER.</p> <p>SERVER Inverter Operation:</p> <p>The SERVER inverter is considered the primary control unit in the system. The SERVER inverter sets the output voltage, then it generates a reference signal for both the desired current magnitude (amplitude) and frequency to send to the CLIENT.</p> <p>CLIENT Inverter Operation:</p> <p>The CLIENT inverter receives the current reference and frequency signals from the SERVER. It compares the received current reference with the actual output current it is producing. The CLIENT inverter then adjusts its output voltage and frequency to match the reference signal provided by the SERVER. The goal is to ensure that the current generated by the CLIENT is in sync (in phase) with the current produced by the SERVER.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>you will need :</p> <ul> <li>Two Twist</li> <li>A 40V DC power supply</li> <li>A 30\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#instruction-to-flash-the-code-and-use-python-script","title":"Instruction to flash the code, and use python script","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the server or the client.</p> <p>To flash the server, choose :</p> <pre><code>#define server\n</code></pre> <p>To flash the client, choose :</p> <pre><code>#define client\n</code></pre> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p> <p>There is also a current gain to control the current reference sent to the CLIENT :</p> <pre><code>tx_data.consigne.Iref_fromSERVER = k_gain*I1_low_value;\n</code></pre> <p>This allows you to increase or deacrese the current of the CLIENT. To increase the current gain, in the serial monitor press <code>l</code> to decrease it press <code>m</code>.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_client_server/#expected-result","title":"Expected result","text":"<p>If you set up correctly the project, you should have server and client output current in phase together.</p> <p></p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/","title":"Peer to peer AC control with an inverter and a synchronous rectifier","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#overview","title":"Overview","text":"<p>Peer-to-peer communication in power electronics involves two converters, a DC/AC converter producing a certain power and informing an AC/DC converter that it can consume this reference power.</p> <p></p> <p>DC/AC Converter (single phase inverter): This converter is responsible for converting direct current (DC) power into alternating current (AC) power. It may be connected to renewable energy sources (such as solar panels or wind turbines) or batteries, which produce DC power. The DC/AC converter's task is to generate AC power for use in the electrical network.</p> <p>AC/DC Converter (single phase synchronous rectifier): This converter performs the opposite function. It converts AC power back into DC power. This conversion is necessary when the electrical network requires DC power for various applications, such as charging batteries or powering DC devices.</p> <p>In a peer-to-peer communication system, these converters communicate with each other to optimize power exchange. The DC/AC converter informs the AC/DC converter of the available power it can deliver. This information includes details like the power's magnitude and frequency.</p> <p>An important aspect of this exchange is that the DC/AC converter must maintain an alternating current in phase opposition (180 degrees phase shift) with the input alternating voltage. This phase opposition ensures that power is effectively delivered to the load.</p> <p>A proportional resonant is used to keep the input alternative current in phase opposition with the Vac, a PI is used to control the output voltage Vdc.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#requirements-and-schematic","title":"Requirements and schematic","text":"<p>You will need :</p> <ul> <li>Two Twist</li> <li>A 50V DC power supply (input voltage for the inverter)</li> <li>A 6V DC power supply (external sensors/drivers suply for the synchronous rectifier)</li> <li>A 115\u03a9 resistive load</li> <li>A RJ45 cable</li> </ul> <p>It is important to check that the boards you are using have the correct voltage and current measures since they'll be used to compute the duty cycle.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#instruction-to-flash-the-code-and-view-some-results","title":"Instruction to flash the code, and view some results","text":""},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-flash-the-code","title":"To flash the code","text":"<p>This example depends on two libraries:</p> <ol> <li>control_library</li> <li>ScopeMimicry</li> </ol> <p>To use them, you have to add the following lines in platformio.ini file: <pre><code>lib_deps=\n    control_library = https://github.com/owntech-foundation/control_library.git\n    scope = https://github.com/owntech-foundation/scopemimicry.git \n</code></pre></p> <p>In src/main.cpp at the line n. 48 you have a macro that defines wether you are flashing the inverter or the synchronous rectifier.</p> <p>To flash the inverter, choose :</p> <pre><code>#define SERVER\n</code></pre> <p>To flash the synchronous rectifier, choose :</p> <pre><code>#define CLIENT\n</code></pre> <p>Here P_ref = 19W to have a 47V output DC voltage. You can change this value in line 87 of src/main.cpp file.</p> <p>After that, connect to the inverter serial monitor and press <code>p</code> to start power flow. Press <code>i</code> to stop.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#to-view-some-variables","title":"To view some variables.","text":"<p>After stop i.e. in IDLE mode you can retrieve some data by pressing 'r'. It calls a function <code>dump_scope_datas()</code> which send to the console variables recorded during the power flow phase.</p> <p>But before running, you have to add one line in the file <code>platfomio.ini</code></p> <pre><code>monitor_filters = recorded_datas\n</code></pre> <p>And you have put the python script <code>filter_datas_recorded.py</code> in a <code>monitor</code> directory which must be in you parent project directory. Then the script should capture the console stream to put it in a txt file named <code>year-month-day_hour_minutes_secondes_record.txt</code>.</p> <p>These files can be plotted using the <code>plot_data.py</code> python script if you have the <code>matplotlib</code> and <code>numpy</code> modules installed.</p>"},{"location":"examples/TWIST/Microgrid/AC_peer_to_peer/#expected-results","title":"Expected results","text":"<p>If everything goes well you'll have 47V delivered to the resistor.</p> <p>Here are some results for Vdc and Idc : </p> <p>And for Vac and Iac : </p> <p>By using the python script you can also watch MCU internal variables :</p> <p></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/","title":"Current Control Experiment with Analog Communication - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#overview","title":"Overview","text":"<p>This code example demonstrates a current control experiment utilizing analog communication between a master board and multiple slave boards. The master board operates in voltage control mode and sends current references to the slave boards, which work in current control mode. The goal is to regulate and synchronize current injection into an electrical network.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Two boards are used: a master board and one or more slave boards.</li> <li>The master board generates current references and communicates them to the slave boards via analog communication. Communication Current Mode</li> <li>Synchronization modules ensure coordination of PWM signals between master and slave boards.</li> <li>Compensation control is utilized to equilibrate current between different legs of the system. compensation control</li> </ul> Connexion diagram Microgrid structure <p>To run this example you would need: 1. a Voltage Source fixed at ~30V  2. 2 Twist boards  3. 1 RJ45 cable to make the communication link between boards. 4. A variable resistive load between approximatively 6 and 12 Ohm.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#communication-modules","title":"Communication Modules","text":""},{"location":"examples/TWIST/Microgrid/DC_client_server/#1-analog-communication","title":"1. Analog Communication","text":"<p>Analog communication facilitates the exchange of peak current references from the master board to the slave boards. This communication allows for current regulation and control within the system.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#2-synchronization","title":"2. Synchronization","text":"<p>Synchronization modules ensure that PWM signals are aligned and coordinated between the master and slave boards. This synchronization is crucial for maintaining accurate current control and injection.</p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#code-usage","title":"Code Usage","text":"<ol> <li>Upload <code>src/main.cpp</code> to the master board and each slave board.</li> <li>In the <code>main.cpp</code> file, navigate to line 114 to find the macro definition:</li> </ol> <pre><code>#define MASTER\n</code></pre> <p>Replace this macro with one of the following options based on the board you are flashing:</p> <p>For a slave board:    <pre><code>#define SLAVE\n</code></pre></p>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#example-workflow","title":"Example Workflow","text":"<ol> <li>Master Board Operation:</li> <li>The master board operates in voltage control mode.</li> <li>It generates current references within the 0-4000 range.</li> <li> <p>Using analog communication, it sends these references to the slave board(s).</p> </li> <li> <p>Slave Board Operation:</p> </li> <li>Each slave board operates in current control mode.</li> <li>It continuously monitors the analog communication from the master board.</li> <li>The slave board extracts the current reference and injects it into the electrical network.</li> <li> <p>Compensation control ensures balanced current distribution among the system's legs.</p> </li> <li> <p>Synchronization:</p> </li> <li>The synchronization modules guarantee that PWM signals are coordinated between the master and slave boards.</li> <li>This synchronization is vital for maintaining accurate and synchronized current injection.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_client_server/#conclusion","title":"Conclusion","text":"<p>This code example showcases a current control experiment that employs analog communication between a master board and multiple slave boards. By following the provided instructions and flashing the appropriate code, you can simulate and observe the regulation and synchronization of current injection into an electrical network. The combination of voltage control, current control, analog communication, and synchronization modules results in an efficient and coordinated system for current regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/","title":"Parallel Power Conversion Experiment - Code Example","text":""},{"location":"examples/TWIST/Microgrid/DC_droop/#overview","title":"Overview","text":"<p>This code example demonstrates an experiment involving three power converters connected in parallel to power a DC bus without communication. Each converter performs power conversion in buck mode and is programmed with a distinct droop factor (1.2, 1.1, and 1.6 respectively). The experiment aims to explore the behavior of parallel power conversion and observe the impact of different droop factors on the voltage regulation.</p>"},{"location":"examples/TWIST/Microgrid/DC_droop/#experimental-setup","title":"Experimental Setup","text":"<ul> <li>Three power converters are connected in parallel to the DC bus.</li> <li>Each power converter operates in voltage control mode and performs power conversion in buck mode.</li> <li>Individual droop factors of 1.2, 1.1, and 1.6 are programmed for the respective cards.</li> </ul> Connexion diagram Microgrid structure"},{"location":"examples/TWIST/Microgrid/DC_droop/#code-usage","title":"Code Usage","text":"<ol> <li>Flash <code>src/main.cpp</code> to each of the power converters.</li> <li>In the <code>main.cpp</code> file, go to line 80 to find the macro definition:</li> </ol> <pre><code>#define DROOP\n</code></pre> <p>Replace this macro with the relevant option for the board you are flashing:</p> <p>For a different board:    <pre><code>#define DROOP1\n</code></pre></p> <p>or</p> <pre><code>#define DROOP2\n</code></pre>"},{"location":"examples/TWIST/Microgrid/DC_droop/#example-workflow","title":"Example Workflow","text":"<ol> <li>Parallel Power Conversion:</li> <li>Three power converters are interconnected in parallel to supply power to the DC bus.</li> <li>Each converter performs power conversion using a buck mode.</li> <li> <p>Individual droop factors (1.2, 1.1, and 1.6) are applied to each converter.</p> </li> <li> <p>Voltage Regulation:</p> </li> <li>Monitor the behavior of the parallel power conversion system and observe how it manages voltage regulation under different conditions.</li> <li>Analyze the role of each card's droop factor in distributing the load and regulating the voltage on the DC bus.</li> </ol>"},{"location":"examples/TWIST/Microgrid/DC_droop/#conclusion","title":"Conclusion","text":"<p>By following the provided guidelines and uploading the code to the power cards, you can emulate and study the dynamics of parallel power conversion in buck mode. This experiment allows you to investigate the impact of varied droop factors on voltage regulation and observe how the power cards work together in parallel to provide power to the DC bus. The combination of voltage control, buck mode operation, and unique droop factors contributes to an efficient and synchronized power conversion system.</p>"},{"location":"examples/docs/home/","title":"Home","text":"<p>Opening a fully featured example is often the best way to get started.</p> <p>Tip</p> <p>Need help to launch an example ? Here it is !</p>"},{"location":"examples/docs/home/#browse-spin-examples","title":"Browse SPIN examples","text":"<p>Get on track using featured examples : </p> <ul> <li> <p> Blinky</p> <p>Get up and running in minutes</p> <p> Blinky</p> </li> <li> <p> Multiple PWM</p> <p>Lets play, lets do PWMs !</p> <p> Examples</p> </li> </ul> <ul> <li> <p> High resolution PWMs</p> <p>Unleash fully configurable and feature rich digital control signals</p> <p> Duty Cycle control  Phase Shift control </p> </li> <li> <p> Fast and precisely timed acquisitions</p> <p>Measurements done right in time</p> <p> Software Triggered Measures  Real Time Measurments</p> </li> </ul>"},{"location":"examples/docs/home/#browse-twist-examples","title":"Browse TWIST examples","text":""},{"location":"examples/docs/home/#dc-to-dc-applications","title":"DC to DC applications","text":"<ul> <li> <p> Buck</p> <p>Good starting point to deploy your first power application. </p> <p> Buck voltage mode </p> <p>Leverage embedded analog hardware, go for current mode !</p> <p> Buck current mode </p> <p>Interleaving, made easy</p> <p> Interleaved Buck </p> </li> <li> <p> Boost</p> <p>Need a boost ? Here you go !</p> <p> Boost voltage mode.</p> </li> </ul>"},{"location":"examples/docs/home/#dc-to-ac-applications","title":"DC to AC applications","text":"<ul> <li> <p> Grid forming Inverter</p> <p>Good starting point to discover AC world. </p> <p> Grid Forming Inverter  </p> </li> <li> <p> Grid Following Inverter</p> <p>Get in sync with the grid !</p> <p> Grid Following Inverter </p> </li> </ul>"},{"location":"examples/docs/home/#microgrid-applications","title":"Microgrid Applications","text":"<ul> <li> <p> DC Droop</p> <p>Sometimes, a simple droop is enough </p> <p> DC Droop  </p> </li> <li> <p> DC with communication</p> <p>Introduction to communication based DC microgrid</p> <p> Client - Server DC </p> </li> <li> <p> AC Client/Server</p> <p>Sharing the load is caring ! </p> <p> AC Client/Server  </p> </li> <li> <p> AC Peer2Peer</p> <p>Doing.. Legal Peer2Peer !</p> <p> AC Peer2Peer </p> </li> </ul>"},{"location":"powerAPI/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AdcHAL Handles the ADC for the spin board. </li> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class NgndHAL </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class TwistAPI </li> <li>class UartHAL Handles usart 1 for the SPIN board. </li> <li>class VersionHAL Handles the versioning for the spin board. </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>class safety </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t </li> <li>struct timer_driver_api </li> <li>struct timer_hrtim_t Timinig unit configuration - aggregates all the structures. </li> </ul>"},{"location":"powerAPI/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir core <ul> <li>dir zephyr <ul> <li>dir modules <ul> <li>dir owntech_adc_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file adc.c </li> <li>file adc.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_communication <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file CommunicationAPI.cpp </li> <li>file CommunicationAPI.h </li> </ul> </li> <li>dir src <ul> <li>file AnalogCommunication.cpp </li> <li>file AnalogCommunication.h </li> <li>file CanCommunication.cpp </li> <li>file CanCommunication.h </li> <li>file Rs485.cpp </li> <li>file Rs485.h </li> <li>file Rs485Communication.cpp </li> <li>file Rs485Communication.h </li> <li>file SyncCommunication.cpp </li> <li>file SyncCommunication.h </li> <li>file data_objects.cpp </li> <li>file data_objects.h Handling of ThingSet data objects. </li> <li>file thingset_isotp.cpp </li> <li>file thingset_pub_sub.cpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_comparator_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file comparator.c </li> <li>file comparator.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_dac_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file dac.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_data_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file DataAPI.cpp </li> <li>file DataAPI.h </li> <li>file data_api_internal.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_flash_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file nvs_storage.c </li> <li>file nvs_storage.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_hrtim_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file hrtim.h </li> <li>file hrtim_enum.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_ngnd_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file ngnd.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_power_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file TwistAPI.cpp </li> <li>file TwistAPI.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_safety_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SafetyAPI.cpp </li> <li>file SafetyAPI.h </li> <li>file safety_internal.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_spin_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file SpinAPI.h </li> </ul> </li> <li>dir src <ul> <li>file AdcHAL.cpp </li> <li>file AdcHAL.h </li> <li>file CompHAL.cpp </li> <li>file CompHAL.h </li> <li>file DacHAL.cpp </li> <li>file DacHAL.h </li> <li>file GpioHAL.cpp </li> <li>file GpioHAL.h </li> <li>file LedHAL.cpp </li> <li>file LedHAL.h </li> <li>file NgndHAL.cpp </li> <li>file NgndHAL.h </li> <li>file PwmHAL.cpp </li> <li>file PwmHAL.h </li> <li>file TimerHAL.cpp </li> <li>file TimerHAL.h </li> <li>file UartHAL.cpp </li> <li>file UartHAL.h </li> <li>file VersionHAL.cpp </li> <li>file VersionHAL.h </li> <li>file hardware_auto_configuration.cpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_task_api <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file TaskAPI.cpp </li> <li>file TaskAPI.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir owntech_timer_driver <ul> <li>dir zephyr <ul> <li>dir public_api <ul> <li>file timer.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"powerAPI/classAdcHAL/","title":"Class AdcHAL","text":"<p>ClassList &gt; AdcHAL</p> <p>Handles the ADC for the spin board. More...</p> <ul> <li><code>#include &lt;AdcHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classAdcHAL/#public-functions","title":"Public Functions","text":"Type Name void configureDiscontinuousMode (uint8_t adc_number, uint32_t dicontinuous_count) Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. void configureTriggerSource (uint8_t adc_number, adc_ev_src_t trigger_source) Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. void disableChannel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. void enableChannel (uint8_t adc_number, uint8_t channel) Add a channel to the list of channels to be acquired for an ADC. The order in which channels are acquired is determined by the order in which they are enabled. void enableDma (uint8_t adc_number, bool use_dma) ADC DMA mode configuration. Enables DMA and circular mode on an ADC. uint32_t getEnabledChannelsCount (uint8_t adc_number) Returns the number of enabled channels for an ADC. void startAllAdcs () Start all configured ADCs. void stopAllAdcs () Stop all configured ADCs. void triggerSoftwareConversion (uint8_t adc_number, uint8_t number_of_acquisitions) Triggers a conversion on an ADC which is configured as software triggered."},{"location":"powerAPI/classAdcHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions linked to the ADC for the SPIN board </p>"},{"location":"powerAPI/classAdcHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classAdcHAL/#function-configurediscontinuousmode","title":"function configureDiscontinuousMode","text":"<p>Set the discontinuous count for an ADC. By default, ADCs are not in discontinuous mode. <pre><code>void AdcHAL::configureDiscontinuousMode (\n    uint8_t adc_number,\n    uint32_t dicontinuous_count\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/classAdcHAL/#function-configuretriggersource","title":"function configureTriggerSource","text":"<p>Change the trigger source of an ADC. By default, triggger source for ADC 1/2 is on HRTIM1, and ADC 3/4 is software-triggered. <pre><code>void AdcHAL::configureTriggerSource (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure </li> <li><code>trigger_source</code> Source of the trigger </li> </ul>"},{"location":"powerAPI/classAdcHAL/#function-disablechannel","title":"function disableChannel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. <pre><code>void AdcHAL::disableChannel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>Note:</p> <p>If a channel has been enabled multiple times, then only the first occurence in the list will be removed.</p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/classAdcHAL/#function-enablechannel","title":"function enableChannel","text":"<p>Add a channel to the list of channels to be acquired for an ADC. The order in which channels are acquired is determined by the order in which they are enabled. <pre><code>void AdcHAL::enableChannel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/classAdcHAL/#function-enabledma","title":"function enableDma","text":"<p>ADC DMA mode configuration. Enables DMA and circular mode on an ADC. <pre><code>void AdcHAL::enableDma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Applied configuration will only be set when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC on which to enable DMA. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/classAdcHAL/#function-getenabledchannelscount","title":"function getEnabledChannelsCount","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t AdcHAL::getEnabledChannelsCount (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/classAdcHAL/#function-startalladcs","title":"function startAllAdcs","text":"<p>Start all configured ADCs. <pre><code>void AdcHAL::startAllAdcs () \n</code></pre></p>"},{"location":"powerAPI/classAdcHAL/#function-stopalladcs","title":"function stopAllAdcs","text":"<p>Stop all configured ADCs. <pre><code>void AdcHAL::stopAllAdcs () \n</code></pre></p>"},{"location":"powerAPI/classAdcHAL/#function-triggersoftwareconversion","title":"function triggerSoftwareConversion","text":"<p>Triggers a conversion on an ADC which is configured as software triggered. <pre><code>void AdcHAL::triggerSoftwareConversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>Note:</p> <p>Software trigger is default for all ADCs unless configured differently by the user or another module.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> <li><code>number_of_acquisitions</code> Number of channels to acquire. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/AdcHAL.h</code></p>"},{"location":"powerAPI/classAnalogCommunication/","title":"Class AnalogCommunication","text":"<p>ClassList &gt; AnalogCommunication</p>"},{"location":"powerAPI/classAnalogCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name float32_t getAnalogCommValue () Get the analog value. void init () Initializing analog communication (ADC and DAC) void setAnalogCommValue (uint32_t analog_bus_value) Set the analog value, the DAC output."},{"location":"powerAPI/classAnalogCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classAnalogCommunication/#function-getanalogcommvalue","title":"function getAnalogCommValue","text":"<p>Get the analog value. <pre><code>static float32_t AnalogCommunication::getAnalogCommValue () \n</code></pre></p> <p>Returns:</p> <p>Analog value (A value between 0 and 4096) </p>"},{"location":"powerAPI/classAnalogCommunication/#function-init","title":"function init","text":"<p>Initializing analog communication (ADC and DAC) <pre><code>static void AnalogCommunication::init () \n</code></pre></p>"},{"location":"powerAPI/classAnalogCommunication/#function-setanalogcommvalue","title":"function setAnalogCommValue","text":"<p>Set the analog value, the DAC output. <pre><code>static void AnalogCommunication::setAnalogCommValue (\n    uint32_t analog_bus_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>analog_bus_value</code> A value between 0 and 4096 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/classCanCommunication/","title":"Class CanCommunication","text":"<p>ClassList &gt; CanCommunication</p>"},{"location":"powerAPI/classCanCommunication/#public-functions","title":"Public Functions","text":"Type Name void enableCan () Enable can."},{"location":"powerAPI/classCanCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name uint16_t getBroadcastPeriod () Get the broadcast period. uint16_t getCanNodeAddr () Get the CAN node address. uint16_t getControlPeriod () Get the control period. bool getCtrlEnable () Get the control enable status. float32_t getCtrlReference () Get the control reference value. void setBroadcastPeriod (uint16_t time_100_ms) Set the broadcast period. void setCanNodeAddr (uint16_t addr) Set the CAN node address. void setControlPeriod (uint16_t time_100_ms) Set the control period. void setCtrlEnable (bool enable) Set the control enable status. void setCtrlReference (float32_t reference) Set the control reference value."},{"location":"powerAPI/classCanCommunication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classCanCommunication/#function-enablecan","title":"function enableCan","text":"<p>Enable can. <pre><code>void CanCommunication::enableCan () \n</code></pre></p>"},{"location":"powerAPI/classCanCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classCanCommunication/#function-getbroadcastperiod","title":"function getBroadcastPeriod","text":"<p>Get the broadcast period. <pre><code>static uint16_t CanCommunication::getBroadcastPeriod () \n</code></pre></p> <p>Returns:</p> <p>The broadcast period in 100 ms units. </p>"},{"location":"powerAPI/classCanCommunication/#function-getcannodeaddr","title":"function getCanNodeAddr","text":"<p>Get the CAN node address. <pre><code>static uint16_t CanCommunication::getCanNodeAddr () \n</code></pre></p> <p>Returns:</p> <p>The CAN node address. </p>"},{"location":"powerAPI/classCanCommunication/#function-getcontrolperiod","title":"function getControlPeriod","text":"<p>Get the control period. <pre><code>static uint16_t CanCommunication::getControlPeriod () \n</code></pre></p> <p>Returns:</p> <p>The control period in 100 ms units. </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlenable","title":"function getCtrlEnable","text":"<p>Get the control enable status. <pre><code>static bool CanCommunication::getCtrlEnable () \n</code></pre></p> <p>Returns:</p> <p>True if control is enabled, false otherwise. </p>"},{"location":"powerAPI/classCanCommunication/#function-getctrlreference","title":"function getCtrlReference","text":"<p>Get the control reference value. <pre><code>static float32_t CanCommunication::getCtrlReference () \n</code></pre></p> <p>Returns:</p> <p>The control reference value. </p>"},{"location":"powerAPI/classCanCommunication/#function-setbroadcastperiod","title":"function setBroadcastPeriod","text":"<p>Set the broadcast period. <pre><code>static void CanCommunication::setBroadcastPeriod (\n    uint16_t time_100_ms\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_100_ms</code> The broadcast period (in multiple of 100 ms) to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcannodeaddr","title":"function setCanNodeAddr","text":"<p>Set the CAN node address. <pre><code>static void CanCommunication::setCanNodeAddr (\n    uint16_t addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> The CAN node address to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setcontrolperiod","title":"function setControlPeriod","text":"<p>Set the control period. <pre><code>static void CanCommunication::setControlPeriod (\n    uint16_t time_100_ms\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>time_100_ms</code> The control period (in multiple of 100 ms) to set. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlenable","title":"function setCtrlEnable","text":"<p>Set the control enable status. <pre><code>static void CanCommunication::setCtrlEnable (\n    bool enable\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>enable</code> True to enable control, false to disable it. </li> </ul>"},{"location":"powerAPI/classCanCommunication/#function-setctrlreference","title":"function setCtrlReference","text":"<p>Set the control reference value. <pre><code>static void CanCommunication::setCtrlReference (\n    float32_t reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> The control reference value to set. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/classCommunicationAPI/","title":"Class CommunicationAPI","text":"<p>ClassList &gt; CommunicationAPI</p>"},{"location":"powerAPI/classCommunicationAPI/#public-attributes","title":"Public Attributes","text":"Type Name AnalogCommunication analog Contains all the function for analog communication. CanCommunication can Contains all the function for can communication. Rs485Communication rs485 Contains all the function for rs485 communication. SyncCommunication sync Contains all the function for sync communication."},{"location":"powerAPI/classCommunicationAPI/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/classCommunicationAPI/#variable-analog","title":"variable analog","text":"<p>Contains all the function for analog communication. <pre><code>AnalogCommunication CommunicationAPI::analog;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-can","title":"variable can","text":"<p>Contains all the function for can communication. <pre><code>CanCommunication CommunicationAPI::can;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-rs485","title":"variable rs485","text":"<p>Contains all the function for rs485 communication. <pre><code>Rs485Communication CommunicationAPI::rs485;\n</code></pre></p>"},{"location":"powerAPI/classCommunicationAPI/#variable-sync","title":"variable sync","text":"<p>Contains all the function for sync communication. <pre><code>SyncCommunication CommunicationAPI::sync;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/classCompHAL/","title":"Class CompHAL","text":"<p>ClassList &gt; CompHAL</p> <p>Handles comparator 1 and 3 of the SPIN board. More...</p> <ul> <li><code>#include &lt;CompHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classCompHAL/#public-functions","title":"Public Functions","text":"Type Name void initialize (uint8_t comparator_number) Initializes a comparator for the current mode control."},{"location":"powerAPI/classCompHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call the initialization function of either comparator </p>"},{"location":"powerAPI/classCompHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classCompHAL/#function-initialize","title":"function initialize","text":"<p>Initializes a comparator for the current mode control. <pre><code>void CompHAL::initialize (\n    uint8_t comparator_number\n) \n</code></pre></p> <p>Note:</p> <p>Current mode control deploys a comparator together with a DAC. This function must be called after setting up the DAC linked to the comparator. Note that comparator 1 is linked with DAC3 and comparator 3 with DAC1. Comparator 1 is linked with ilow1 and comparator 3 is linked with ilow2.</p> <p>Parameters:</p> <ul> <li><code>comparator_number</code> can be either 1 or 3</li> </ul> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/classDacHAL/","title":"Class DacHAL","text":"<p>ClassList &gt; DacHAL</p>"},{"location":"powerAPI/classDacHAL/#public-functions","title":"Public Functions","text":"Type Name void currentModeInit (uint8_t dac_number, hrtim_tu_t tu_src)  void initConstValue (uint8_t dac_number)  void setConstValue (uint8_t dac_number, uint8_t channel, uint32_t const_value)  void slopeCompensation (uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage)"},{"location":"powerAPI/classDacHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDacHAL/#function-currentmodeinit","title":"function currentModeInit","text":"<pre><code>void DacHAL::currentModeInit (\n    uint8_t dac_number,\n    hrtim_tu_t tu_src\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-initconstvalue","title":"function initConstValue","text":"<pre><code>void DacHAL::initConstValue (\n    uint8_t dac_number\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-setconstvalue","title":"function setConstValue","text":"<pre><code>void DacHAL::setConstValue (\n    uint8_t dac_number,\n    uint8_t channel,\n    uint32_t const_value\n) \n</code></pre>"},{"location":"powerAPI/classDacHAL/#function-slopecompensation","title":"function slopeCompensation","text":"<pre><code>void DacHAL::slopeCompensation (\n    uint8_t dac_number,\n    float32_t peak_voltage,\n    float32_t low_voltage\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/classDataAPI/","title":"Class DataAPI","text":"<p>ClassList &gt; DataAPI</p>"},{"location":"powerAPI/classDataAPI/#public-functions","title":"Public Functions","text":"Type Name float32_t convert (channel_t channel, uint16_t raw_value) Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. float32_t convert (uint8_t adc_num, uint8_t pin_num, uint16_t raw_value) Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. int8_t enableAcquisition (uint8_t adc_num, uint8_t pin_num) This function is used to enable acquisition on a Spin PIN with a given ADC. int8_t enableShieldChannel (uint8_t adc_num, channel_t channel_name) This function is used to enable a channel on a given ADC using its name on a shield, rather than the ADC channel number. This function requires the presence of an \"adc-channels\" node in the shield device-tree. void enableTwistDefaultChannels () This function is used to enable acquisition of all voltage/current channels on the Twist shield. Channels are attributed as follows: ADC1: - I1_LOW ADC2: - I2_LOW. DispatchMethod_t getDispatchMethod () Gets the dispatch method of the module. float32_t getLatest (channel_t channel, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. float32_t getLatest (uint8_t adc_num, uint8_t pin_num, uint8_t * dataValid=nullptr) This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. uint16_t * getRawValues (channel_t channel, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified channel. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. uint16_t * getRawValues (uint8_t adc_num, uint8_t pin_num, uint32_t &amp; number_of_values_acquired) Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. float32_t peek (channel_t channel) Function to access the latest value available from the channel, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. float32_t peek (uint8_t adc_num, uint8_t pin_num) Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. int8_t retrieveParametersFromMemory (channel_t channel) Use this function to read the gain and offset parameters of the board to is non-volatile memory. int8_t retrieveParametersFromMemory (uint8_t adc_num, uint8_t pin_num) Retreived previously configured conversion parameters from NVS. conversion_type_t retrieveStoredConversionType (channel_t channel) Use this function to get the current conversion type for the chosen channel. conversion_type_t retrieveStoredConversionType (uint8_t adc_num, uint8_t pin_num) Use this function to get the current conversion type for the chosen channel. float32_t retrieveStoredParameterValue (channel_t channel, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . float32_t retrieveStoredParameterValue (uint8_t adc_num, uint8_t pin_num, parameter_t parameter_name) Use this function to get the current conversion parameteres for the chosen channel . void setDispatchMethod (DispatchMethod_t dispatch_method) Sets the dispatch method of the module. void setParameters (channel_t channel, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setParameters (uint8_t adc_num, uint8_t pin_num, float32_t gain, float32_t offset) Use this function to tweak the conversion values for the channel if default values are not accurate enough. void setRepetitionsBetweenDispatches (uint32_t repetition) Indicates the repetition count between two external dispatches when it is handled externally by the Scheduling module. This value is used to calibrate buffers sizes. void setTwistChannelsUserCalibrationFactors () Retrieve stored parameters from Flash memory and configure ADC parameters. int8_t start () This functions manually starts the acquisition chain. bool started () Checks if the module is already started. int8_t storeParametersInMemory (channel_t channel) Use this function to write the gain and offset parameters of the board to is non-volatile memory. int8_t storeParametersInMemory (uint8_t adc_num, uint8_t pin_num) Store the currently configured conversion parameters of a given channel in NVS. void triggerAcquisition (uint8_t adc_num) Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired."},{"location":"powerAPI/classDataAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classDataAPI/#function-convert-12","title":"function convert [1/2]","text":"<p>Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convert (\n    channel_t channel,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which the value originates </li> <li><code>raw_value</code> Raw value obtained from which the value originates</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. Returns -5000 if the channel is not active. </p>"},{"location":"powerAPI/classDataAPI/#function-convert-22","title":"function convert [2/2]","text":"<p>Use this function to convert values obtained using matching data.get*RawValues() function to relevant unit for the data: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::convert (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint16_t raw_value\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which the value originates. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>raw_value</code> Raw value obtained from the channel buffer.</li> </ul> <p>Returns:</p> <p>Converted value in the relevant unit. If there is an error, returns -5000. </p>"},{"location":"powerAPI/classDataAPI/#function-enableacquisition","title":"function enableAcquisition","text":"<p>This function is used to enable acquisition on a Spin PIN with a given ADC. <pre><code>int8_t DataAPI::enableAcquisition (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>Not any pin can be used for acquisiton: the pin must be linked to a channel of the given ADC. Refer to Spin pinout image for PIN/ADC relations.</p> <p>Note:</p> <p>This function must be called before ADC is started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which acquisition is to be done. </li> <li><code>pin_num</code> Number of the Spin pin to acquire.</li> </ul> <p>Returns:</p> <p>0 if acquisition was correctly enabled, -1 if there was an error. </p>"},{"location":"powerAPI/classDataAPI/#function-enableshieldchannel","title":"function enableShieldChannel","text":"<p>This function is used to enable a channel on a given ADC using its name on a shield, rather than the ADC channel number. This function requires the presence of an \"adc-channels\" node in the shield device-tree. <pre><code>int8_t DataAPI::enableShieldChannel (\n    uint8_t adc_num,\n    channel_t channel_name\n) \n</code></pre></p> <p>Note:</p> <p>This function must be called before ADC is started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC on which channel is to be enabled. </li> <li><code>channel_name</code> Name of the channel using enumeration channel_t.</li> </ul> <p>Returns:</p> <p>0 if channel was correctly enabled, -1 if there was an error. </p>"},{"location":"powerAPI/classDataAPI/#function-enabletwistdefaultchannels","title":"function enableTwistDefaultChannels","text":"<p>This function is used to enable acquisition of all voltage/current channels on the Twist shield. Channels are attributed as follows: ADC1: - I1_LOW ADC2: - I2_LOW. <pre><code>void DataAPI::enableTwistDefaultChannels () \n</code></pre></p> <ul> <li>V1_LOW - V2_LOW</li> <li>V_HIGH - I_HIGH</li> </ul> <p>Note:</p> <p>This function will configure ADC 1 and 2 to be automatically triggered by the HRTIM, so the board must be configured as a power converted to enable HRTIM events. All other ADCs remain software triggered, thus will only be acquired when triggerAcquisition() is called.</p> <p>Note:</p> <p>This function must be called before ADC is started. </p>"},{"location":"powerAPI/classDataAPI/#function-getdispatchmethod","title":"function getDispatchMethod","text":"<p>Gets the dispatch method of the module. <pre><code>DispatchMethod_t DataAPI::getDispatchMethod () \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Returns:</p> <p>Dispatch method indicatinng when the dispatch is done. </p>"},{"location":"powerAPI/classDataAPI/#function-getlatest-12","title":"function getLatest [1/2]","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatest (\n    channel_t channel,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.get*RawValues() function for the matching channel, as data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain value. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-getlatest-22","title":"function getLatest [2/2]","text":"<p>This function returns the latest acquired measure expressed in the relevant unit for the channel: Volts, Amperes, or Degree Celcius. <pre><code>float32_t DataAPI::getLatest (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint8_t * dataValid=nullptr\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When using this functions, you loose the ability to access raw values using data.get*RawValues() function for the matching channel, as data.get*() function clears the buffer on each call.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain value. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>dataValid</code> Pointer to an uint8_t variable. This parameter is facultative. If this parameter is provided, it will be updated to indicate information about data. Possible values for this parameter will be:</li> <li>DATA_IS_OK if returned data is a newly acquired data,</li> <li>DATA_IS_OLD if returned data has already been provided before (no new data available since latest time this function was called),</li> <li>DATA_IS_MISSING if returned data is NO_VALUE.</li> </ul> <p>Returns:</p> <p>Latest acquired measure for the channel. If no value was acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-getrawvalues-12","title":"function getRawValues [1/2]","text":"<p>Function to access the acquired data for specified channel. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    channel_t channel,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use matching data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"powerAPI/classDataAPI/#function-getrawvalues-22","title":"function getRawValues [2/2]","text":"<p>Function to access the acquired data for specified pin. This function provides a buffer in which all data that have been acquired since last call are stored. The count of these values is returned as an output parameter: the user has to define a variable and pass it as the parameter of the function. The variable will be updated with the number of values that are available in the buffer. <pre><code>uint16_t * DataAPI::getRawValues (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    uint32_t &amp; number_of_values_acquired\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Note:</p> <p>When calling this function, it invalidates the buffer returned by a previous call to the same function. However, different channels buffers are independent from each other.</p> <p>Note:</p> <p>When using this functions, the user is responsible for data conversion. Use matching data.convert*() function for this purpose.</p> <p>Note:</p> <p>When using this function, DO NOT use the function to get the latest converted value for the same channel as this function will clear the buffer and disregard all values but the latest.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain values. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>number_of_values_acquired</code> Pass an uint32_t variable. This variable will be updated with the number of values that are present in the returned buffer.</li> </ul> <p>Returns:</p> <p>Pointer to a buffer in which the acquired values are stored. If number_of_values_acquired is 0, do not try to access the buffer as it may be nullptr. </p>"},{"location":"powerAPI/classDataAPI/#function-peek-12","title":"function peek [1/2]","text":"<p>Function to access the latest value available from the channel, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peek (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel from which to obtain value.</li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-peek-22","title":"function peek [2/2]","text":"<p>Function to access the latest value available from a pin, expressed in the relevant unit for the data: Volts, Amperes, or Degree Celcius. This function will not touch anything in the buffer, and thus can be called safely at any time after the module has been started. <pre><code>float32_t DataAPI::peek (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must have been started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC from which to obtain value. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> </ul> <p>Returns:</p> <p>Latest available value available from the given channel. If there was no value acquired in this channel yet, return value is NO_VALUE. </p>"},{"location":"powerAPI/classDataAPI/#function-retrieveparametersfrommemory-12","title":"function retrieveParametersFromMemory [1/2]","text":"<p>Use this function to read the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t DataAPI::retrieveParametersFromMemory (\n    channel_t channel\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to save the values. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-retrieveparametersfrommemory-22","title":"function retrieveParametersFromMemory [2/2]","text":"<p>Retreived previously configured conversion parameters from NVS. <pre><code>int8_t DataAPI::retrieveParametersFromMemory (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>pin_num</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested channel -5000: Channel not found. </p>"},{"location":"powerAPI/classDataAPI/#function-retrievestoredconversiontype-12","title":"function retrieveStoredConversionType [1/2]","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::retrieveStoredConversionType (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-retrievestoredconversiontype-22","title":"function retrieveStoredConversionType [2/2]","text":"<p>Use this function to get the current conversion type for the chosen channel. <pre><code>conversion_type_t DataAPI::retrieveStoredConversionType (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter.</li> </ul> <p>Returns:</p> <p>Returns the type of convertion of the given pin. Returns -5 if the channel is not active. </p>"},{"location":"powerAPI/classDataAPI/#function-retrievestoredparametervalue-12","title":"function retrieveStoredParameterValue [1/2]","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::retrieveStoredParameterValue (\n    channel_t channel,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-retrievestoredparametervalue-22","title":"function retrieveStoredParameterValue [2/2]","text":"<p>Use this function to get the current conversion parameteres for the chosen channel . <pre><code>float32_t DataAPI::retrieveStoredParameterValue (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    parameter_t parameter_name\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to get a conversion parameter. </li> <li><code>parameter_name</code> Paramater to be retreived: <code>gain</code> or <code>offset</code>.</li> </ul> <p>Returns:</p> <p>Returns the value of the parameter. Returns -5000 if the channel is not active. </p>"},{"location":"powerAPI/classDataAPI/#function-setdispatchmethod","title":"function setDispatchMethod","text":"<p>Sets the dispatch method of the module. <pre><code>void DataAPI::setDispatchMethod (\n    DispatchMethod_t dispatch_method\n) \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Parameters:</p> <ul> <li><code>dispatch_method</code> Indicates when the dispatch should be done (default value: DispatchMethod_t::on_dma_interrupt) </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setparameters-12","title":"function setParameters [1/2]","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setParameters (\n    channel_t channel,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the channel is enabled. The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to set conversion values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setparameters-22","title":"function setParameters [2/2]","text":"<p>Use this function to tweak the conversion values for the channel if default values are not accurate enough. <pre><code>void DataAPI::setParameters (\n    uint8_t adc_num,\n    uint8_t pin_num,\n    float32_t gain,\n    float32_t offset\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the pin is enabled. The DataAPI module must not have been started, neither explicitly nor by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC to set conversion values. </li> <li><code>pin_num</code> Number of the pin from which to obtain values. </li> <li><code>gain</code> Gain to be applied (multiplied) to the channel raw value. </li> <li><code>offset</code> Offset to be applied (added) to the channel value after gain has been applied. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-setrepetitionsbetweendispatches","title":"function setRepetitionsBetweenDispatches","text":"<p>Indicates the repetition count between two external dispatches when it is handled externally by the Scheduling module. This value is used to calibrate buffers sizes. <pre><code>void DataAPI::setRepetitionsBetweenDispatches (\n    uint32_t repetition\n) \n</code></pre></p> <p>Note:</p> <p>End-user should not worry about this function, which is used internally by the Scheduling module.</p> <p>Parameters:</p> <ul> <li><code>repetition</code> Number of repetitions between two calls of dispatch. Used to calibrate buffers sizes. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-settwistchannelsusercalibrationfactors","title":"function setTwistChannelsUserCalibrationFactors","text":"<p>Retrieve stored parameters from Flash memory and configure ADC parameters. <pre><code>void DataAPI::setTwistChannelsUserCalibrationFactors () \n</code></pre></p> <p>Note:</p> <p>This function requires Console to interact with the user. You must first call console_init() before calling this function.</p> <p>Note:</p> <p>This function can't be called before all Twist channels have been enabled (you can use enableTwistDefaultChannels() for that purpose). The DataAPI must not have been started, neither explicitly nor by starting the Uninterruptible task. </p>"},{"location":"powerAPI/classDataAPI/#function-start","title":"function start","text":"<p>This functions manually starts the acquisition chain. <pre><code>int8_t DataAPI::start () \n</code></pre></p> <p>Note:</p> <p>If your code uses an uninterruptible task, you do not need to start Data Acquisition manually, it will automatically be started at the same time as the task as their internal behavior are intrinsically linked. If for some reason you have an uninterruptible task in your code, but do not want the Scheduling module to be in charge of Data Acquisition, you need to indicate it when starting the uninterruptible task. In that case, Data Acquisition must be manually started using this function. Note that in taht case, dispatch will use DMA interrupts which consumes a non-negligible amount of processor time and it is not advised.</p> <p>Note:</p> <p>Data Acquisition must be started only after ADC module configuration has been fully carried out. No ADC configuration change is allowed after module has been started. If you're using the Twist shield and are not sure how to initialize ADCs, you can use data.enableTwistDefaultChannels() for that purpose.</p> <p>Note:</p> <p>Data Acquisition must be started before accessing any data.get*() or data.peek*() function. Other Data Acquisition functions are safe to use before starting the module.</p> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error. Error is triggered when dispatch method is set to be external, but the repetition value has not provided. Another source of error is trying to start Data Acquisition after it has already been started. </p>"},{"location":"powerAPI/classDataAPI/#function-started","title":"function started","text":"<p>Checks if the module is already started. <pre><code>bool DataAPI::started () \n</code></pre></p> <p>Returns:</p> <p>true is the module has been started, false otherwise. </p>"},{"location":"powerAPI/classDataAPI/#function-storeparametersinmemory-12","title":"function storeParametersInMemory [1/2]","text":"<p>Use this function to write the gain and offset parameters of the board to is non-volatile memory. <pre><code>int8_t DataAPI::storeParametersInMemory (\n    channel_t channel\n) \n</code></pre></p> <p>Note:</p> <p>This function should be called after updating the parameters using setParameters.</p> <p>Parameters:</p> <ul> <li><code>channel</code> Name of the shield channel to save the values. </li> </ul>"},{"location":"powerAPI/classDataAPI/#function-storeparametersinmemory-22","title":"function storeParametersInMemory [2/2]","text":"<p>Store the currently configured conversion parameters of a given channel in NVS. <pre><code>int8_t DataAPI::storeParametersInMemory (\n    uint8_t adc_num,\n    uint8_t pin_num\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_num</code> ADC number </li> <li><code>pin_num</code> SPIN pin number</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, negative value if there was an error: -1: There was an error, -5000: Channel not found. </p>"},{"location":"powerAPI/classDataAPI/#function-triggeracquisition","title":"function triggerAcquisition","text":"<p>Triggers an acquisition on a given ADC. Each channel configured on this ADC will be acquired one after the other until all configured channels have been acquired. <pre><code>void DataAPI::triggerAcquisition (\n    uint8_t adc_num\n) \n</code></pre></p> <p>Note:</p> <p>This function can't be called before the at least one channel is enabled on the ADC and the DataAPI module is started, either explicitly or by starting the Uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>adc_num</code> Number of the ADC on which to acquire channels. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/DataAPI.h</code></p>"},{"location":"powerAPI/classGpioHAL/","title":"Class GpioHAL","text":"<p>ClassList &gt; GpioHAL</p>"},{"location":"powerAPI/classGpioHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePin (uint8_t pin, gpio_flags_t flags) Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. uint8_t readPin (uint8_t pin) Get the current value of a pin configured as input. void resetPin (uint8_t pin) Reset the value of a pin configured as output to 0. void setPin (uint8_t pin) Set the value of a pin configured as output to 1. void togglePin (uint8_t pin) Toggle the value of a pin configured as output: void writePin (uint8_t pin, uint8_t value) Set the value of a pin configured as output to a given value."},{"location":"powerAPI/classGpioHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classGpioHAL/#function-configurepin","title":"function configurePin","text":"<p>Configure an I/O pin. This must be done prior to accessing any other function from this API on the pin. <pre><code>void GpioHAL::configurePin (\n    uint8_t pin,\n    gpio_flags_t flags\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>flags</code> Pin configuration flags. Authorized values:</li> <li>INPUT</li> <li>INPUT_PULLUP</li> <li>OUTPUT </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-readpin","title":"function readPin","text":"<p>Get the current value of a pin configured as input. <pre><code>uint8_t GpioHAL::readPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul> <p>Returns:</p> <p>Current value (0 or 1) of the pin. </p>"},{"location":"powerAPI/classGpioHAL/#function-resetpin","title":"function resetPin","text":"<p>Reset the value of a pin configured as output to 0. <pre><code>void GpioHAL::resetPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-setpin","title":"function setPin","text":"<p>Set the value of a pin configured as output to 1. <pre><code>void GpioHAL::setPin (\n    uint8_t pin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-togglepin","title":"function togglePin","text":"<p>Toggle the value of a pin configured as output: <pre><code>void GpioHAL::togglePin (\n    uint8_t pin\n) \n</code></pre></p> <ul> <li>if pin value is 1, it will be set to 0</li> <li>if pin value is 0, it will be set to 1.</li> </ul> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> </ul>"},{"location":"powerAPI/classGpioHAL/#function-writepin","title":"function writePin","text":"<p>Set the value of a pin configured as output to a given value. <pre><code>void GpioHAL::writePin (\n    uint8_t pin,\n    uint8_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pin</code> Number of the Spin pin OR STM32-style name of the pin, e.g. PA1, PB10, etc. See pin_t type for the full list of available STM32-style pins on Spin board. </li> <li><code>value</code> Value (0 or 1) to assign to the pin. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/classLedHAL/","title":"Class LedHAL","text":"<p>ClassList &gt; LedHAL</p>"},{"location":"powerAPI/classLedHAL/#public-functions","title":"Public Functions","text":"Type Name void toggle ()  void turnOff ()  void turnOn ()"},{"location":"powerAPI/classLedHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classLedHAL/#function-toggle","title":"function toggle","text":"<pre><code>void LedHAL::toggle () \n</code></pre>"},{"location":"powerAPI/classLedHAL/#function-turnoff","title":"function turnOff","text":"<pre><code>void LedHAL::turnOff () \n</code></pre>"},{"location":"powerAPI/classLedHAL/#function-turnon","title":"function turnOn","text":"<pre><code>void LedHAL::turnOn () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/classNgndHAL/","title":"Class NgndHAL","text":"<p>ClassList &gt; NgndHAL</p>"},{"location":"powerAPI/classNgndHAL/#public-functions","title":"Public Functions","text":"Type Name void turnOff () Turns the NGND switch OFF. It is used with versions of the TWIST board prior to 1.4. void turnOn () Turns the NGND switch ON. It is used with versions of the TWIST board prior to 1.4."},{"location":"powerAPI/classNgndHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classNgndHAL/#function-turnoff","title":"function turnOff","text":"<p>Turns the NGND switch OFF. It is used with versions of the TWIST board prior to 1.4. <pre><code>void NgndHAL::turnOff () \n</code></pre></p>"},{"location":"powerAPI/classNgndHAL/#function-turnon","title":"function turnOn","text":"<p>Turns the NGND switch ON. It is used with versions of the TWIST board prior to 1.4. <pre><code>void NgndHAL::turnOn () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/NgndHAL.h</code></p>"},{"location":"powerAPI/classPwmHAL/","title":"Class PwmHAL","text":"<p>ClassList &gt; PwmHAL</p> <p>Handles all pwm signals for the spin board. More...</p> <ul> <li><code>#include &lt;PwmHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classPwmHAL/#public-functions","title":"Public Functions","text":"Type Name void configurePeriodEvnt (hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback) This function configures the interrupt on repetition counter. void disableAdcTrigger (hrtim_tu_number_t tu_number) This function disables the adc trigger for the selected timing unit. void disablePeriodEvnt (hrtim_tu_t PWM_tu) This function disables the interrupt on repetition counter. void enableAdcTrigger (hrtim_tu_number_t tu_number) This function enables the adc trigger for the selected timing unit. void enablePeriodEvnt (hrtim_tu_t PWM_tu) This function enables the interrupt on repetition counter. hrtim_adc_edgetrigger_t getAdcEdgeTrigger (hrtim_tu_number_t pwmX) This function returns the adc trigger rollover mode for the selected timer. hrtim_adc_trigger_t getAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function returns the adc trigger linked to a timer unit. hrtim_external_trigger_t getEev (hrtim_tu_number_t pwmX) This function sets the external event linked to the timing unit used for the current mode. hrtim_pwm_mode_t getMode (hrtim_tu_number_t pwmX) This function returns the PWM mode (voltage or current mode) hrtim_cnt_t getModulation (hrtim_tu_number_t pwmX) This function returns the modulation type of the selected timing unit. uint16_t getPeriod (hrtim_tu_number_t pwmX) This function returns the period of the selected timing unit. uint32_t getPeriodEvntRep (hrtim_tu_t PWM_tu) This function returns the repetition counter value. uint32_t getPeriodUs (hrtim_tu_number_t pwmX) This function returns the period in \u00b5s of the selected timer. hrtim_switch_convention_t getSwitchConvention (hrtim_tu_number_t pwmX) This function returns the switching convention of the selected timing unit. void initFrequency (uint32_t init_frequency) This function initialize the frequency. void initFrequency (uint32_t init_frequency, uint32_t minimal_frequency) This functions initialize the frequency and also sets the minimal reachable frequency. void initUnit (hrtim_tu_number_t pwmX) This function initializes a timing unit. void setAdcDecimation (hrtim_tu_number_t pwmX, uint32_t decimation) This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. void setAdcEdgeTrigger (hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger) This function sets the adc trig rollover mode for the selected timer. void setAdcTrigger (hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig) This function sets the adc trigger linked to a timer unit. void setAdcTriggerInstant (hrtim_tu_number_t pwmX, float32_t trig_val) This function sets the comparator value at which the ADC is trigered. void setAdcTriggerPostScaler (hrtim_tu_number_t pwmX, uint32_t ps_ratio) This function sets the PostScaler value for the selected timing unit. void setDeadTime (hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns) This function sets the dead time for the selected timing unit. void setDutyCycle (hrtim_tu_number_t pwmX, float32_t duty_cycle) This function sets the duty cycle for the selected timing unit. void setEev (hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev) This function sets external event linked to the timing unit essential for the current mode. void setFrequency (uint32_t frequency_update) Change the frequency/period after it has been initialized. void setMode (hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode) This function sets a special pwm mode for voltage or current mode. void setModulation (hrtim_tu_number_t pwmX, hrtim_cnt_t modulation) This function sets the modulation mode for a given PWM unit. void setPeriodEvntRep (hrtim_tu_t PWM_tu, uint32_t repetition) This function sets the repetition counter to ISR period. void setPhaseShift (hrtim_tu_number_t pwmX, int16_t shift) This function sets the phase shift in respect to timer A for the selected timing unit. void setSwitchConvention (hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention) This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. void startDualOutput (hrtim_tu_number_t pwmX) This fonction starts both outputs of the selected HRTIM channel. void startSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel. void stopDualOutput (hrtim_tu_number_t pwmX) This function stops both outputs of the selected HRTIM channel. void stopSingleOutput (hrtim_tu_number_t tu, hrtim_output_number_t output) This function starts only one output of the selected HRTIM channel."},{"location":"powerAPI/classPwmHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to call functions related to the pwm. </p>"},{"location":"powerAPI/classPwmHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classPwmHAL/#function-configureperiodevnt","title":"function configurePeriodEvnt","text":"<p>This function configures the interrupt on repetition counter. <pre><code>void PwmHAL::configurePeriodEvnt (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> <li><code>callback</code> function to call each interupt </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-disableadctrigger","title":"function disableAdcTrigger","text":"<p>This function disables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::disableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-disableperiodevnt","title":"function disablePeriodEvnt","text":"<p>This function disables the interrupt on repetition counter. <pre><code>void PwmHAL::disablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-enableadctrigger","title":"function enableAdcTrigger","text":"<p>This function enables the adc trigger for the selected timing unit. <pre><code>void PwmHAL::enableAdcTrigger (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Warning:</p> <p>call this function only AFTER setting the adc trigger and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-enableperiodevnt","title":"function enablePeriodEvnt","text":"<p>This function enables the interrupt on repetition counter. <pre><code>void PwmHAL::enablePeriodEvnt (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getadcedgetrigger","title":"function getAdcEdgeTrigger","text":"<p>This function returns the adc trigger rollover mode for the selected timer. <pre><code>hrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both </p>"},{"location":"powerAPI/classPwmHAL/#function-getadctrigger","title":"function getAdcTrigger","text":"<p>This function returns the adc trigger linked to a timer unit. <pre><code>hrtim_adc_trigger_t PwmHAL::getAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4 </p>"},{"location":"powerAPI/classPwmHAL/#function-geteev","title":"function getEev","text":"<p>This function sets the external event linked to the timing unit used for the current mode. <pre><code>hrtim_external_trigger_t PwmHAL::getEev (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9 </p>"},{"location":"powerAPI/classPwmHAL/#function-getmode","title":"function getMode","text":"<p>This function returns the PWM mode (voltage or current mode) <pre><code>hrtim_pwm_mode_t PwmHAL::getMode (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWM mode - VOLTAGE_MODE or CURRENT_MODE</p> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-getmodulation","title":"function getModulation","text":"<p>This function returns the modulation type of the selected timing unit. <pre><code>hrtim_cnt_t PwmHAL::getModulation (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>Lft_aligned or UpDwn (center aligned) </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiod","title":"function getPeriod","text":"<p>This function returns the period of the selected timing unit. <pre><code>uint16_t PwmHAL::getPeriod (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>the period value in uint16 </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodevntrep","title":"function getPeriodEvntRep","text":"<p>This function returns the repetition counter value. <pre><code>uint32_t PwmHAL::getPeriodEvntRep (\n    hrtim_tu_t PWM_tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> </ul> <p>Returns:</p> <p>repetition counter value </p>"},{"location":"powerAPI/classPwmHAL/#function-getperiodus","title":"function getPeriodUs","text":"<p>This function returns the period in \u00b5s of the selected timer. <pre><code>uint32_t PwmHAL::getPeriodUs (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-getswitchconvention","title":"function getSwitchConvention","text":"<p>This function returns the switching convention of the selected timing unit. <pre><code>hrtim_switch_convention_t PwmHAL::getSwitchConvention (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul> <p>Returns:</p> <p>PWMx1 (high side convention) or PWMx2 (low-side convention) </p>"},{"location":"powerAPI/classPwmHAL/#function-initfrequency-12","title":"function initFrequency [1/2]","text":"<p>This function initialize the frequency. <pre><code>void PwmHAL::initFrequency (\n    uint32_t init_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>init_frequency</code> frequency in Hz</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing any timing unit. the frequency initialized becomes the MINIMUM possible. use it BEFORE initialization of the timing unit. </p>"},{"location":"powerAPI/classPwmHAL/#function-initfrequency-22","title":"function initFrequency [2/2]","text":"<p>This functions initialize the frequency and also sets the minimal reachable frequency. <pre><code>void PwmHAL::initFrequency (\n    uint32_t init_frequency,\n    uint32_t minimal_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>init_frequency</code> frequency in Hz </li> <li><code>minimal_frequency</code> desired minimal frequency in Hz</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing any timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-initunit","title":"function initUnit","text":"<p>This function initializes a timing unit. <pre><code>void PwmHAL::initUnit (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF</li> </ul> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcdecimation","title":"function setAdcDecimation","text":"<p>This function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if decimation = 1, nothing changes but with decimation = 2 you have twice less adc trigger. <pre><code>void PwmHAL::setAdcDecimation (\n    hrtim_tu_number_t pwmX,\n    uint32_t decimation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>decimation</code> decimation/post-scaler - a number between 1 and 32</li> </ul> <p>Warning:</p> <p>this function must be called AFTER initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadcedgetrigger","title":"function setAdcEdgeTrigger","text":"<p>This function sets the adc trig rollover mode for the selected timer. <pre><code>void PwmHAL::setAdcEdgeTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_edgetrigger_t adc_edge_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_edge_trigger</code> Rollover mode - EdgeTrigger_up, EdgeTrigger_down, EdgeTrigger_Both</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctrigger","title":"function setAdcTrigger","text":"<p>This function sets the adc trigger linked to a timer unit. <pre><code>void PwmHAL::setAdcTrigger (\n    hrtim_tu_number_t pwmX,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>adc_trig</code> adc trigger - ADCTRIG_1, ADCTRIG_2, ADCTRIG_3 et ADCTRIG_4</li> </ul> <p>Warning:</p> <p>Call this function BEFORE enabling the adc trigger and AFTER initializing the selected timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerinstant","title":"function setAdcTriggerInstant","text":"<p>This function sets the comparator value at which the ADC is trigered. <pre><code>void PwmHAL::setAdcTriggerInstant (\n    hrtim_tu_number_t pwmX,\n    float32_t trig_val\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>trig_val</code> a value between 0 and 1 </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setadctriggerpostscaler","title":"function setAdcTriggerPostScaler","text":"<p>This function sets the PostScaler value for the selected timing unit. <pre><code>void PwmHAL::setAdcTriggerPostScaler (\n    hrtim_tu_number_t pwmX,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>ps_ratio</code> post scaler ratio</li> </ul> <p>Warning:</p> <p>this function must be called after initialiazing a timing unit, and before enabling the adc trigger </p>"},{"location":"powerAPI/classPwmHAL/#function-setdeadtime","title":"function setDeadTime","text":"<p>This function sets the dead time for the selected timing unit. <pre><code>void PwmHAL::setDeadTime (\n    hrtim_tu_number_t pwmX,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>rise_ns</code> rising edge dead time in ns </li> <li><code>falling_ns</code> falling edge dead time in ns</li> </ul> <p>Warning:</p> <p>use this function BEFORE initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setdutycycle","title":"function setDutyCycle","text":"<p>This function sets the duty cycle for the selected timing unit. <pre><code>void PwmHAL::setDutyCycle (\n    hrtim_tu_number_t pwmX,\n    float32_t duty_cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>value</code> duty cycle value </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-seteev","title":"function setEev","text":"<p>This function sets external event linked to the timing unit essential for the current mode. <pre><code>void PwmHAL::setEev (\n    hrtim_tu_number_t pwmX,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>eev</code> external event trigger - EEV1,EEV2, EEV3, EEV3, EEV4, EEV5, EEV6, EEV7, EEV8, EEV9</li> </ul> <p>Warning:</p> <p>this function must be called before initialiazing a timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setfrequency","title":"function setFrequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void PwmHAL::setFrequency (\n    uint32_t frequency_update\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>frequency_update</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>The new frequency can't be inferior to the the one set in the initialization step Use it AFTER the initialization of the timing unit. </p>"},{"location":"powerAPI/classPwmHAL/#function-setmode","title":"function setMode","text":"<p>This function sets a special pwm mode for voltage or current mode. <pre><code>void PwmHAL::setMode (\n    hrtim_tu_number_t pwmX,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initialiazing the selected timing unit </p>"},{"location":"powerAPI/classPwmHAL/#function-setmodulation","title":"function setModulation","text":"<p>This function sets the modulation mode for a given PWM unit. <pre><code>void PwmHAL::setModulation (\n    hrtim_tu_number_t pwmX,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>modulation</code> PWM Modulation - Lft_aligned or UpDwn</li> </ul> <p>Warning:</p> <p>this function must be called BEFORE initializing the selected timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setperiodevntrep","title":"function setPeriodEvntRep","text":"<p>This function sets the repetition counter to ISR period. <pre><code>void PwmHAL::setPeriodEvntRep (\n    hrtim_tu_t PWM_tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_tu</code> PWM Unit - TIMA, TIMB, TIMC, TIMD, TIME or TIMF </li> <li><code>repetition</code> number of repetition before the interruption on repetition counter event </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-setphaseshift","title":"function setPhaseShift","text":"<p>This function sets the phase shift in respect to timer A for the selected timing unit. <pre><code>void PwmHAL::setPhaseShift (\n    hrtim_tu_number_t pwmX,\n    int16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>shift</code> phase shift value \u00b0 between -360 and 360</li> </ul> <p>Warning:</p> <p>use this function AFTER setting the frequency and initializing the chosen timer </p>"},{"location":"powerAPI/classPwmHAL/#function-setswitchconvention","title":"function setSwitchConvention","text":"<p>This function sets the switch convention for a given PWM unit i.e. you decide which one of the output of the timer can be controlled with duty cycle. <pre><code>void PwmHAL::setSwitchConvention (\n    hrtim_tu_number_t pwmX,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> <li><code>convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2</li> </ul> <p>Warning:</p> <p>this function must be called before the timer initialization </p>"},{"location":"powerAPI/classPwmHAL/#function-startdualoutput","title":"function startDualOutput","text":"<p>This fonction starts both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::startDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-startsingleoutput","title":"function startSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::startSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopdualoutput","title":"function stopDualOutput","text":"<p>This function stops both outputs of the selected HRTIM channel. <pre><code>void PwmHAL::stopDualOutput (\n    hrtim_tu_number_t pwmX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pwmX</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME or PWMF </li> </ul>"},{"location":"powerAPI/classPwmHAL/#function-stopsingleoutput","title":"function stopSingleOutput","text":"<p>This function starts only one output of the selected HRTIM channel. <pre><code>void PwmHAL::stopSingleOutput (\n    hrtim_tu_number_t tu,\n    hrtim_output_number_t output\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> PWM Unit - PWMA, PWMB, PWMC, PWMD, PWME, PWMF </li> <li><code>output</code> output to disable - TIMING_OUTPUT1, TIMING_OUTPUT2 </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/classRs485Communication/","title":"Class Rs485Communication","text":"<p>ClassList &gt; Rs485Communication</p>"},{"location":"powerAPI/classRs485Communication/#public-functions","title":"Public Functions","text":"Type Name void configure (uint8_t * transmission_bufer, uint8_t * reception_buffer, uint16_t data_size, void(*)() user_function, rs485_speed_t data_speed=SPEED_10M) configuration for RS485 communication using a 10Mbit/s speed void configureCustom (uint8_t * transmission_bufer, uint8_t * reception_buffer, uint16_t data_size, void(*)(void) user_function, uint32_t baudrate, bool oversampling_8) Custom configuration for RS485 communication to choose the communication speed. void startTransmission () start a transmission i.e. you send what is contained in the transmission buffer void turnOffCommunication () Turn off the RS485. void turnOnCommunication () Turn on the RS485 communication."},{"location":"powerAPI/classRs485Communication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classRs485Communication/#function-configure","title":"function configure","text":"<p>configuration for RS485 communication using a 10Mbit/s speed <pre><code>void Rs485Communication::configure (\n    uint8_t * transmission_bufer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)() user_function,\n    rs485_speed_t data_speed=SPEED_10M\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the recevied buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>data_speed</code> Transmission speed (by default to 10Mbits/s) </li> <li>SPEED_2M </li> <li>SPEED_5M </li> <li>SPEED_10M </li> <li>SPEED_20M</li> </ul> <p>Warning:</p> <p>the size of transmission_buffer and reception_buffer must be the same</p> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classRs485Communication/#function-configurecustom","title":"function configureCustom","text":"<p>Custom configuration for RS485 communication to choose the communication speed. <pre><code>void Rs485Communication::configureCustom (\n    uint8_t * transmission_bufer,\n    uint8_t * reception_buffer,\n    uint16_t data_size,\n    void(*)(void) user_function,\n    uint32_t baudrate,\n    bool oversampling_8\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transmission_buffer</code> Pointer to the transmitted buffer </li> <li><code>reception_buffer</code> Pointer to the recevied buffer </li> <li><code>data_size</code> Size of the sent and received data (in byte) </li> <li><code>user_function</code> Callback function called when we received data </li> <li><code>baudrate</code> communication speed in bit/s </li> <li><code>oversampling_8</code> True for oversampling (and multiply communication speed by 2), false if you want to keep the normal speed communication</li> </ul> <p>Warning:</p> <p>the size of transmission_buffer and reception_buffer must be the same </p>"},{"location":"powerAPI/classRs485Communication/#function-starttransmission","title":"function startTransmission","text":"<p>start a transmission i.e. you send what is contained in the transmission buffer <pre><code>void Rs485Communication::startTransmission () \n</code></pre></p>"},{"location":"powerAPI/classRs485Communication/#function-turnoffcommunication","title":"function turnOffCommunication","text":"<p>Turn off the RS485. <pre><code>void Rs485Communication::turnOffCommunication () \n</code></pre></p>"},{"location":"powerAPI/classRs485Communication/#function-turnoncommunication","title":"function turnOnCommunication","text":"<p>Turn on the RS485 communication. <pre><code>void Rs485Communication::turnOnCommunication () \n</code></pre></p> <p>Remark:</p> <p>The RS485 is automatically turned on when initializing with configureDefault or configure, no need to call this function </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/classSpinAPI/","title":"Class SpinAPI","text":"<p>ClassList &gt; SpinAPI</p> <p>Contains all the elements linked to peripherals of the spin board. </p> <ul> <li><code>#include &lt;SpinAPI.h&gt;</code></li> </ul>"},{"location":"powerAPI/classSpinAPI/#public-attributes","title":"Public Attributes","text":"Type Name AdcHAL adc Contains all the function of the STM32 ADC including configuration and synchronization with the HRTIM. CompHAL comp Contains all the function of the STM32 comparator used with the current mode. DacHAL dac Contains all the function of the STM32 DAC used to generate signals and handle the current mode. GpioHAL gpio Contains all the functions for the spin gpio. LedHAL led Contains all the function of the embedded LED. NgndHAL ngnd Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. PwmHAL pwm Contains all the function of the STM32 hrtim PWM generator. TimerHAL timer Contains all the function of the STM32 Timer4 functions that handle the encoder. UartHAL uart Contains all the function of the STM32 Usart1 functions. VersionHAL version Contains all the function related to the versioning of the microcontroller boards."},{"location":"powerAPI/classSpinAPI/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/classSpinAPI/#variable-adc","title":"variable adc","text":"<p>Contains all the function of the STM32 ADC including configuration and synchronization with the HRTIM. <pre><code>AdcHAL SpinAPI::adc;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-comp","title":"variable comp","text":"<p>Contains all the function of the STM32 comparator used with the current mode. <pre><code>CompHAL SpinAPI::comp;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-dac","title":"variable dac","text":"<p>Contains all the function of the STM32 DAC used to generate signals and handle the current mode. <pre><code>DacHAL SpinAPI::dac;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-gpio","title":"variable gpio","text":"<p>Contains all the functions for the spin gpio. <pre><code>GpioHAL SpinAPI::gpio;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-led","title":"variable led","text":"<p>Contains all the function of the embedded LED. <pre><code>LedHAL SpinAPI::led;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-ngnd","title":"variable ngnd","text":"<p>Contains all the function of the NGND switch compatible with TWISTs prior to 1.4. <pre><code>NgndHAL SpinAPI::ngnd;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-pwm","title":"variable pwm","text":"<p>Contains all the function of the STM32 hrtim PWM generator. <pre><code>PwmHAL SpinAPI::pwm;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-timer","title":"variable timer","text":"<p>Contains all the function of the STM32 Timer4 functions that handle the encoder. <pre><code>TimerHAL SpinAPI::timer;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-uart","title":"variable uart","text":"<p>Contains all the function of the STM32 Usart1 functions. <pre><code>UartHAL SpinAPI::uart;\n</code></pre></p>"},{"location":"powerAPI/classSpinAPI/#variable-version","title":"variable version","text":"<p>Contains all the function related to the versioning of the microcontroller boards. <pre><code>VersionHAL SpinAPI::version;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/classSyncCommunication/","title":"Class SyncCommunication","text":"<p>ClassList &gt; SyncCommunication</p>"},{"location":"powerAPI/classSyncCommunication/#public-static-functions","title":"Public Static Functions","text":"Type Name void initMaster () initialization synchronization as MASTER, the master send the synchronization pulsle. void initSlave (board_version_t board_version) initialization synchronization as SLAVE, the slave receive the synchronization pulsle."},{"location":"powerAPI/classSyncCommunication/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/classSyncCommunication/#function-initmaster","title":"function initMaster","text":"<p>initialization synchronization as MASTER, the master send the synchronization pulsle. <pre><code>static void SyncCommunication::initMaster () \n</code></pre></p> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/classSyncCommunication/#function-initslave","title":"function initSlave","text":"<p>initialization synchronization as SLAVE, the slave receive the synchronization pulsle. <pre><code>static void SyncCommunication::initSlave (\n    board_version_t board_version\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/classTaskAPI/","title":"Class TaskAPI","text":"<p>ClassList &gt; TaskAPI</p>"},{"location":"powerAPI/classTaskAPI/#public-functions","title":"Public Functions","text":"Type Name int8_t createBackground (task_function_t routine) Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. int8_t createCritical (task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source=source_hrtim) Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. void startBackground (uint8_t task_number) Use this function to start a previously defined background task using its task number. void startCritical (bool manage_data_acquisition=true) Use this function to start a previously defined a critical task. void stopBackground (uint8_t task_number) Use this function to stop a previously started background task using its task number. void stopCritical () Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. void suspendBackgroundMs (uint32_t duration_ms) This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. void suspendBackgroundUs (uint32_t duration_us) This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently."},{"location":"powerAPI/classTaskAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTaskAPI/#function-createbackground","title":"function createBackground","text":"<p>Creates a background task. Background tasks are asynchronous tasks that run in the background when there is no critical task running. <pre><code>int8_t TaskAPI::createBackground (\n    task_function_t routine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>routine</code> Pointer to the void(void) function that will act as the task main function. </li> </ul> <p>Returns:</p> <p>Number assigned to the task. Will be -1 if max number of asynchronous task has been reached. In such a case, the task definition is ignored. Increase maximum number of asynchronous tasks in prj.conf if required. </p>"},{"location":"powerAPI/classTaskAPI/#function-createcritical","title":"function createCritical","text":"<p>Creates a time critial task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. Use this function to define such a task. Only one task of this kind can be defined. This function can be used to redefine (replace) a previously defined uninterruptible synchronous task, but the previously defined task must have been suspended (or never started). An error will be returned if the previously defined task is still running. <pre><code>int8_t TaskAPI::createCritical (\n    task_function_t periodic_task,\n    uint32_t task_period_us,\n    scheduling_interrupt_source_t int_source=source_hrtim\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>periodic_task</code> Pointer to the void(void) function to be executed periodically. </li> <li><code>task_period_us</code> Period of the function in \u00b5s. Allowed range: 1 to 6553 \u00b5s. If interrupt source is HRTIM, this value MUST be an integer multiple of the HRTIM period. </li> <li><code>int_source</code> Interrupt source that triggers the task. By default, the HRTIM is the source, but this optional parameter can be provided to set TIM6 as the source in case the HRTIM is not used or if the task can't be correlated to an HRTIM event. Allowed values are source_hrtim and source_tim6. </li> </ul> <p>Returns:</p> <p>0 if everything went well, -1 if there was an error defining the task. An error can occur notably when an uninterruptible task has already been defined previously. </p>"},{"location":"powerAPI/classTaskAPI/#function-startbackground","title":"function startBackground","text":"<p>Use this function to start a previously defined background task using its task number. <pre><code>void TaskAPI::startBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-startcritical","title":"function startCritical","text":"<p>Use this function to start a previously defined a critical task. <pre><code>void TaskAPI::startCritical (\n    bool manage_data_acquisition=true\n) \n</code></pre></p> <p>A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task.</p> <p>If no value is provided for the parameter and Data Acquisition has not been started yet, Scheduling will automatically start Data Acquisition. Thus, make sure all ADC configuration has been carried out before starting the uninterruptible task.</p> <p>Parameters:</p> <ul> <li><code>manage_data_acquisition</code> Set to false if you want the Scheduling module to not be in charge of Data Acquisition scheduling. If set to false, Data Acquisition has to be manually started if you want to use it. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopbackground","title":"function stopBackground","text":"<p>Use this function to stop a previously started background task using its task number. <pre><code>void TaskAPI::stopBackground (\n    uint8_t task_number\n) \n</code></pre></p> <p>Background tasks are asynchronous tasks that run in the background when there is no critical task running. The task can be then resumed by calling startAsynchronousTask() again.</p> <p>Parameters:</p> <ul> <li><code>task_number</code> Number of the task to start, obtained using the defineAsynchronousTask() function. </li> </ul>"},{"location":"powerAPI/classTaskAPI/#function-stopcritical","title":"function stopCritical","text":"<p>Stop the previously started critical task. A critical task is an Uninterruptible Synchronous Task that uses a precise timer to execute a periodic, non-interruptible user task. The task can be then resumed by calling startCritical() again. <pre><code>void TaskAPI::stopCritical () \n</code></pre></p>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundms","title":"function suspendBackgroundMs","text":"<p>This function allows to suspend a background task for a specified duration expressed in milliseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundMs (\n    uint32_t duration_ms\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p>"},{"location":"powerAPI/classTaskAPI/#function-suspendbackgroundus","title":"function suspendBackgroundUs","text":"<p>This function allows to suspend a background task for a specified duration expressed in microseconds. For example, you can call this function at the end of a background task function, when there is no need for the task to run permanently. <pre><code>void TaskAPI::suspendBackgroundUs (\n    uint32_t duration_us\n) \n</code></pre></p> <p>DO NOT use this function in a critical task! </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/classTimerHAL/","title":"Class TimerHAL","text":"<p>ClassList &gt; TimerHAL</p> <p>Handles timer 4 for the SPIN board. More...</p> <ul> <li><code>#include &lt;TimerHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classTimerHAL/#public-functions","title":"Public Functions","text":"Type Name uint32_t getTimer4IncrementalEncoderValue () Gets the encoder step value. void startLogTimer4IncrementalEncoder () Launches the timer4 which is adapted for reading an encoder."},{"location":"powerAPI/classTimerHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize timer 4 and use it with an incremental encoder </p>"},{"location":"powerAPI/classTimerHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTimerHAL/#function-gettimer4incrementalencodervalue","title":"function getTimer4IncrementalEncoderValue","text":"<p>Gets the encoder step value. <pre><code>uint32_t TimerHAL::getTimer4IncrementalEncoderValue () \n</code></pre></p> <p>Returns:</p> <p>An uint32 value of the counter which corresponds to the step of the system. </p>"},{"location":"powerAPI/classTimerHAL/#function-startlogtimer4incrementalencoder","title":"function startLogTimer4IncrementalEncoder","text":"<p>Launches the timer4 which is adapted for reading an encoder. <pre><code>void TimerHAL::startLogTimer4IncrementalEncoder () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/classTwistAPI/","title":"Class TwistAPI","text":"<p>ClassList &gt; TwistAPI</p>"},{"location":"powerAPI/classTwistAPI/#public-functions","title":"Public Functions","text":"Type Name void connectAllCapacitor () Connect the electrolyt capacitor to all the legs. void connectLegCapacitor (leg_t leg) Connect the electrolytic capacitor. void disconnectAllCapacitor () disconnect the electrolyt capacitor to all the legs. void disconnectLegCapacitor (leg_t leg) Disonnect the electrolytic capacitor. void initAllBoost () Initialise all the legs for boost topology, current mode is not supported for boost. void initAllBuck (hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE) Initialise all the legs for buck topology. void initAllMode (hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode) Initialize power modes for all legs. void initLegBoost (leg_t leg) Initialise all the legs for boost topology, current mode is not supported for boost. void initLegBuck (leg_t leg, hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE) Initialise a leg for buck topology. void initLegMode (leg_t leg, hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode) Initialize the power mode for a given leg. void setAllAdcDecim (uint16_t adc_decim) set ADC decimator for all legs void setAllDeadTime (uint16_t ns_rising_dt, uint16_t ns_falling_dt) set the dead time value for all legs void setAllDutyCycle (float32_t duty_all) Set the duty cycle for power control of all the legs. void setAllPhaseShift (int16_t phase_shift) Set the phase shift value for all the legs. void setAllSlopeCompensation (float32_t set_voltage, float32_t reset_voltage) Set the slope compensation in current mode for all the leg. void setAllTriggerValue (float32_t trigger_value) Set the trigger value for the ADC trigger of all the legs. void setLegAdcDecim (leg_t leg, uint16_t adc_decim) set ADC decimator for a leg void setLegDeadTime (leg_t leg, uint16_t ns_rising_dt, uint16_t ns_falling_dt) set the dead time value for a leg void setLegDutyCycle (leg_t leg, float32_t duty_leg) Set the duty cycle for a specific leg's power control. void setLegPhaseShift (leg_t leg, int16_t phase_shift) Set the phase shift value for a specific leg's power control. void setLegSlopeCompensation (leg_t leg, float32_t set_voltage, float32_t reset_voltage) Set the slope compensation in current mode for a leg. void setLegTriggerValue (leg_t leg, float32_t trigger_value) Set the trigger value for a specific leg's ADC trigger. void setVersion (twist_version_t twist_ver) Set the hardware version of the board. void startAll () Start power output for all legs. void startLeg (leg_t leg) Start power output for a specific leg. void stopAll () Stop power output for all legs. void stopLeg (leg_t leg) Stop power output for a specific leg."},{"location":"powerAPI/classTwistAPI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classTwistAPI/#function-connectallcapacitor","title":"function connectAllCapacitor","text":"<p>Connect the electrolyt capacitor to all the legs. <pre><code>void TwistAPI::connectAllCapacitor () \n</code></pre></p>"},{"location":"powerAPI/classTwistAPI/#function-connectlegcapacitor","title":"function connectLegCapacitor","text":"<p>Connect the electrolytic capacitor. <pre><code>void TwistAPI::connectLegCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which to connect the capacitor. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-disconnectallcapacitor","title":"function disconnectAllCapacitor","text":"<p>disconnect the electrolyt capacitor to all the legs. <pre><code>void TwistAPI::disconnectAllCapacitor () \n</code></pre></p>"},{"location":"powerAPI/classTwistAPI/#function-disconnectlegcapacitor","title":"function disconnectLegCapacitor","text":"<p>Disonnect the electrolytic capacitor. <pre><code>void TwistAPI::disconnectLegCapacitor (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The selected leg for which to disonnect the capacitor. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-initallboost","title":"function initAllBoost","text":"<p>Initialise all the legs for boost topology, current mode is not supported for boost. <pre><code>void TwistAPI::initAllBoost () \n</code></pre></p>"},{"location":"powerAPI/classTwistAPI/#function-initallbuck","title":"function initAllBuck","text":"<p>Initialise all the legs for buck topology. <pre><code>void TwistAPI::initAllBuck (\n    hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-initallmode","title":"function initAllMode","text":"<p>Initialize power modes for all legs. <pre><code>void TwistAPI::initAllMode (\n    hrtim_switch_convention_t leg_convention,\n    hrtim_pwm_mode_t leg_mode\n) \n</code></pre></p> <p>This function initializes the power modes for each leg with the specified 'buck' and 'voltage_mode' settings.</p> <p>Parameters:</p> <ul> <li><code>leg_convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2 </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-initlegboost","title":"function initLegBoost","text":"<p>Initialise all the legs for boost topology, current mode is not supported for boost. <pre><code>void TwistAPI::initLegBoost (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-initlegbuck","title":"function initLegBuck","text":"<p>Initialise a leg for buck topology. <pre><code>void TwistAPI::initLegBuck (\n    leg_t leg,\n    hrtim_pwm_mode_t leg_mode=VOLTAGE_MODE\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> Leg to initialize </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-initlegmode","title":"function initLegMode","text":"<p>Initialize the power mode for a given leg. <pre><code>void TwistAPI::initLegMode (\n    leg_t leg,\n    hrtim_switch_convention_t leg_convention,\n    hrtim_pwm_mode_t leg_mode\n) \n</code></pre></p> <p>This function configures modulation, frequency, phase shift, dead time, and other parameters for power control of a specified leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize </li> <li><code>leg_convention</code> PWM Switch to be driven by the duty cycle. The other will be complementary - PWMx1 or PWMx2 </li> <li><code>leg_mode</code> PWM mode - VOLTAGE_MODE or CURRENT_MODE </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setalladcdecim","title":"function setAllAdcDecim","text":"<p>set ADC decimator for all legs <pre><code>void TwistAPI::setAllAdcDecim (\n    uint16_t adc_decim\n) \n</code></pre></p> <p>this function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if adc_decim = 1, nothing changes but with adc_decims = 2 you have twice less adc trigger.</p> <p>Parameters:</p> <ul> <li><code>adc_decim</code> - adc decimator, a number between 1 and 32 </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setalldeadtime","title":"function setAllDeadTime","text":"<p>set the dead time value for all legs <pre><code>void TwistAPI::setAllDeadTime (\n    uint16_t ns_rising_dt,\n    uint16_t ns_falling_dt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ns_rising_dt</code> - rising dead time value in ns </li> <li><code>ns_falling_dt</code> - falling dead time value in ns </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setalldutycycle","title":"function setAllDutyCycle","text":"<p>Set the duty cycle for power control of all the legs. <pre><code>void TwistAPI::setAllDutyCycle (\n    float32_t duty_all\n) \n</code></pre></p> <p>This function sets the same duty cycle for power control of all the legs. The duty cycle determines the ON/OFF ratio of the power signal for all legs.</p> <p>Parameters:</p> <ul> <li><code>duty_all</code> The duty cycle value to set (a floating-point number between 0.1 and 0.9). </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setallphaseshift","title":"function setAllPhaseShift","text":"<p>Set the phase shift value for all the legs. <pre><code>void TwistAPI::setAllPhaseShift (\n    int16_t phase_shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phase_shift</code> The phase shift value to set. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setallslopecompensation","title":"function setAllSlopeCompensation","text":"<p>Set the slope compensation in current mode for all the leg. <pre><code>void TwistAPI::setAllSlopeCompensation (\n    float32_t set_voltage,\n    float32_t reset_voltage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>set_voltage</code> in volt, the DAC peak voltage for slope compensation (value between 0 and 2.048) </li> <li><code>reset_voltage</code> in volt, the DAC lowest voltage for slope compensation (value between 0 and 2.048)</li> </ul> <p>Warning:</p> <p>Be sure that set_voltage &gt; reset_voltage </p>"},{"location":"powerAPI/classTwistAPI/#function-setalltriggervalue","title":"function setAllTriggerValue","text":"<p>Set the trigger value for the ADC trigger of all the legs. <pre><code>void TwistAPI::setAllTriggerValue (\n    float32_t trigger_value\n) \n</code></pre></p> <p>This function sets the same trigger value for the ADC trigger of all the legs. The trigger value determines the level at which the ADC trigger is activated for all legs.</p> <p>Parameters:</p> <ul> <li><code>trigger_value</code> The trigger value to set for all the legs between 0.0 and 1.0. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setlegadcdecim","title":"function setLegAdcDecim","text":"<p>set ADC decimator for a leg <pre><code>void TwistAPI::setLegAdcDecim (\n    leg_t leg,\n    uint16_t adc_decim\n) \n</code></pre></p> <p>this function sets the number of event which will be ignored between two events. ie. you divide the number of trigger in a fixed period. For example if adc_decim = 1, nothing changes but with adc_decims = 2 you have twice less adc trigger.</p> <p>Parameters:</p> <ul> <li><code>leg</code> - leg for which to set adc decimator value </li> <li><code>adc_decim</code> - adc decimator, a number between 1 and 32 </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setlegdeadtime","title":"function setLegDeadTime","text":"<p>set the dead time value for a leg <pre><code>void TwistAPI::setLegDeadTime (\n    leg_t leg,\n    uint16_t ns_rising_dt,\n    uint16_t ns_falling_dt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> - the leg for which to set dead time value </li> <li><code>ns_rising_dt</code> - rising dead time value in ns </li> <li><code>ns_falling_dt</code> - falling dead time value in ns </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setlegdutycycle","title":"function setLegDutyCycle","text":"<p>Set the duty cycle for a specific leg's power control. <pre><code>void TwistAPI::setLegDutyCycle (\n    leg_t leg,\n    float32_t duty_leg\n) \n</code></pre></p> <p>This function sets the duty cycle for the power control of a specified leg. The duty cycle determines the ON/OFF ratio of the power signal for the leg.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the duty cycle. </li> <li><code>duty_leg</code> The duty cycle value to set (a floating-point number between 0.1 and 0.9). </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setlegphaseshift","title":"function setLegPhaseShift","text":"<p>Set the phase shift value for a specific leg's power control. <pre><code>void TwistAPI::setLegPhaseShift (\n    leg_t leg,\n    int16_t phase_shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the phase shift value. </li> <li><code>phase_shift</code> The phase shift value to set. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setlegslopecompensation","title":"function setLegSlopeCompensation","text":"<p>Set the slope compensation in current mode for a leg. <pre><code>void TwistAPI::setLegSlopeCompensation (\n    leg_t leg,\n    float32_t set_voltage,\n    float32_t reset_voltage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg to initialize </li> <li><code>set_voltage</code> in volt, the DAC peak voltage for slope compensation (value between 0 and 2.048) </li> <li><code>reset_voltage</code> in volt, the DAC lowest voltage for slope compensation (value between 0 and 2.048)</li> </ul> <p>Warning:</p> <p>Be sure that set_voltage &gt; reset_voltage </p>"},{"location":"powerAPI/classTwistAPI/#function-setlegtriggervalue","title":"function setLegTriggerValue","text":"<p>Set the trigger value for a specific leg's ADC trigger. <pre><code>void TwistAPI::setLegTriggerValue (\n    leg_t leg,\n    float32_t trigger_value\n) \n</code></pre></p> <p>This function sets the trigger value for the ADC trigger of a specified leg. The trigger value determines the level at which the ADC trigger is activated.</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to set the ADC trigger value. </li> <li><code>trigger_value</code> The trigger value to set between 0.05 and 0.95. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-setversion","title":"function setVersion","text":"<p>Set the hardware version of the board. <pre><code>void TwistAPI::setVersion (\n    twist_version_t twist_ver\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>shield</code> shield version - shield_TWIST_V1_2, shield_TWIST_V1_3, shield_ownverter or shield_other</li> </ul> <p>Warning:</p> <p>You need to call this function BEFORE initializing a leg, after that it is not possible to change the shield version </p>"},{"location":"powerAPI/classTwistAPI/#function-startall","title":"function startAll","text":"<p>Start power output for all legs. <pre><code>void TwistAPI::startAll () \n</code></pre></p>"},{"location":"powerAPI/classTwistAPI/#function-startleg","title":"function startLeg","text":"<p>Start power output for a specific leg. <pre><code>void TwistAPI::startLeg (\n    leg_t leg\n) \n</code></pre></p> <p>This function initiates the power output for a specified leg by starting the PWM subunits associated with the leg's output pins. If the leg's output pins are not declared inactive in the device tree, the corresponding subunits are started. eg. If output1 is declared inactive in the device tree, PWMA1 will not start</p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to start the power output. </li> </ul>"},{"location":"powerAPI/classTwistAPI/#function-stopall","title":"function stopAll","text":"<p>Stop power output for all legs. <pre><code>void TwistAPI::stopAll () \n</code></pre></p>"},{"location":"powerAPI/classTwistAPI/#function-stopleg","title":"function stopLeg","text":"<p>Stop power output for a specific leg. <pre><code>void TwistAPI::stopLeg (\n    leg_t leg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>leg</code> The leg for which to stop the power output. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/public_api/TwistAPI.h</code></p>"},{"location":"powerAPI/classUartHAL/","title":"Class UartHAL","text":"<p>ClassList &gt; UartHAL</p> <p>Handles usart 1 for the SPIN board. More...</p> <ul> <li><code>#include &lt;UartHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classUartHAL/#public-functions","title":"Public Functions","text":"Type Name void usart1Init () Library initialization function for the usart communication. This function is declared on the private section of the .c file. char usart1ReadChar () This function sends back a single character waiting to be treated from the usart1. void usart1SwapRxTx () This function swaps the usart RX and TX pins. It should be called in conjunction with a board version setup. void usart1WriteChar (char data) This function transmits a single character through the usart 1."},{"location":"powerAPI/classUartHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to initialize and send messages via usart 1 </p>"},{"location":"powerAPI/classUartHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classUartHAL/#function-usart1init","title":"function usart1Init","text":"<p>Library initialization function for the usart communication. This function is declared on the private section of the .c file. <pre><code>void UartHAL::usart1Init () \n</code></pre></p>"},{"location":"powerAPI/classUartHAL/#function-usart1readchar","title":"function usart1ReadChar","text":"<p>This function sends back a single character waiting to be treated from the usart1. <pre><code>char UartHAL::usart1ReadChar () \n</code></pre></p> <p>Returns:</p> <p>This function returns a single char which is waiting to be treated if no char is waiting it returns an 'x' which should be treated as an error </p>"},{"location":"powerAPI/classUartHAL/#function-usart1swaprxtx","title":"function usart1SwapRxTx","text":"<p>This function swaps the usart RX and TX pins. It should be called in conjunction with a board version setup. <pre><code>void UartHAL::usart1SwapRxTx () \n</code></pre></p>"},{"location":"powerAPI/classUartHAL/#function-usart1writechar","title":"function usart1WriteChar","text":"<p>This function transmits a single character through the usart 1. <pre><code>void UartHAL::usart1WriteChar (\n    char data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> single char to be sent out </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/classVersionHAL/","title":"Class VersionHAL","text":"<p>ClassList &gt; VersionHAL</p> <p>Handles the versioning for the spin board. More...</p> <ul> <li><code>#include &lt;VersionHAL.h&gt;</code></li> </ul>"},{"location":"powerAPI/classVersionHAL/#public-functions","title":"Public Functions","text":"Type Name board_version_t getBoardVersion () return board version void setBoardVersion (board_version_t board_version) Sets the version of the microcontroller board. It can take the following values: nucleo_G474RE, O2_v_0_9, O2_v_1_1_2, SPIN_v_0_1, SPIN_v_0_9, SPIN_v_1_0, TWIST_v_1_1_2 TWIST_v_1_1_3, TWIST_v_1_1_4."},{"location":"powerAPI/classVersionHAL/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Use this element to defined your version of the SPIN board </p>"},{"location":"powerAPI/classVersionHAL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classVersionHAL/#function-getboardversion","title":"function getBoardVersion","text":"<p>return board version <pre><code>board_version_t VersionHAL::getBoardVersion () \n</code></pre></p> <p>Returns:</p> <p>Return one of these values : nucleo_G474RE, O2_v_0_9, O2_v_1_1_2, SPIN_v_0_1, SPIN_v_0_9, SPIN_v_1_0, TWIST_v_1_1_2 TWIST_v_1_1_3, TWIST_v_1_1_4 </p>"},{"location":"powerAPI/classVersionHAL/#function-setboardversion","title":"function setBoardVersion","text":"<p>Sets the version of the microcontroller board. It can take the following values: nucleo_G474RE, O2_v_0_9, O2_v_1_1_2, SPIN_v_0_1, SPIN_v_0_9, SPIN_v_1_0, TWIST_v_1_1_2 TWIST_v_1_1_3, TWIST_v_1_1_4. <pre><code>void VersionHAL::setBoardVersion (\n    board_version_t board_version\n) \n</code></pre></p> <p>Stand alone versions such as SPIN_v_X comprise only the spin board itself. Legacy versions such as nucleo or O2_X comprise the nucleo board or the old O2 boards. Twist versions comprise all the available Twist connected versions. </p> <p>Parameters:</p> <ul> <li><code>board_version</code> Enum representing the microcontroller version. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/VersionHAL.h</code></p>"},{"location":"powerAPI/structadc__hrtim__conf__t/","title":"Struct adc_hrtim_conf_t","text":"<p>ClassList &gt; adc_hrtim_conf_t</p> <p>Structure containing information to setup adc events, adc source links and adc triggers. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_adc_event_t adc_event hrtim_adc_edgetrigger_t adc_rollover hrtim_adc_source_t adc_source hrtim_adc_trigger_t adc_trigger"},{"location":"powerAPI/structadc__hrtim__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_event","title":"variable adc_event","text":"<pre><code>hrtim_adc_event_t adc_hrtim_conf_t::adc_event;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_rollover","title":"variable adc_rollover","text":"<pre><code>hrtim_adc_edgetrigger_t adc_hrtim_conf_t::adc_rollover;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_source","title":"variable adc_source","text":"<pre><code>hrtim_adc_source_t adc_hrtim_conf_t::adc_source;\n</code></pre>"},{"location":"powerAPI/structadc__hrtim__conf__t/#variable-adc_trigger","title":"variable adc_trigger","text":"<pre><code>hrtim_adc_trigger_t adc_hrtim_conf_t::adc_trigger;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structcomp__usage__conf__t/","title":"Struct comp_usage_conf_t","text":"<p>ClassList &gt; comp_usage_conf_t</p> <p>Structure containing the status of the usage of comparators and their values. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_comp_usage_t cmp1 uint16_t cmp1_value hrtim_comp_usage_t cmp2 uint16_t cmp2_value hrtim_comp_usage_t cmp3 uint16_t cmp3_value hrtim_comp_usage_t cmp4 uint16_t cmp4_value"},{"location":"powerAPI/structcomp__usage__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1","title":"variable cmp1","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp1;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp1_value","title":"variable cmp1_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp1_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2","title":"variable cmp2","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp2;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp2_value","title":"variable cmp2_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp2_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3","title":"variable cmp3","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp3;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp3_value","title":"variable cmp3_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp3_value;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4","title":"variable cmp4","text":"<pre><code>hrtim_comp_usage_t comp_usage_conf_t::cmp4;\n</code></pre>"},{"location":"powerAPI/structcomp__usage__conf__t/#variable-cmp4_value","title":"variable cmp4_value","text":"<pre><code>uint16_t comp_usage_conf_t::cmp4_value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structdac__driver__api/","title":"Struct dac_driver_api","text":"<p>ClassList &gt; dac_driver_api</p>"},{"location":"powerAPI/structdac__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name dac_api_fn_upd_reset fn_upd_reset dac_api_fn_upd_step fn_upd_step dac_api_pinconfigure pinconfigure dac_api_setconstvalue setconstvalue dac_api_setfunction setfunction dac_api_start start dac_api_stop stop"},{"location":"powerAPI/structdac__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_reset","title":"variable fn_upd_reset","text":"<pre><code>dac_api_fn_upd_reset dac_driver_api::fn_upd_reset;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-fn_upd_step","title":"variable fn_upd_step","text":"<pre><code>dac_api_fn_upd_step dac_driver_api::fn_upd_step;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-pinconfigure","title":"variable pinconfigure","text":"<pre><code>dac_api_pinconfigure dac_driver_api::pinconfigure;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setconstvalue","title":"variable setconstvalue","text":"<pre><code>dac_api_setconstvalue dac_driver_api::setconstvalue;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-setfunction","title":"variable setfunction","text":"<pre><code>dac_api_setfunction dac_driver_api::setfunction;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-start","title":"variable start","text":"<pre><code>dac_api_start dac_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structdac__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>dac_api_stop dac_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structdac__function__config__t/","title":"Struct dac_function_config_t","text":"<p>ClassList &gt; dac_function_config_t</p>"},{"location":"powerAPI/structdac__function__config__t/#public-attributes","title":"Public Attributes","text":"Type Name dac_function_t dac_function dac_polarity_t polarity uint32_t reset_data dac_trigger_t reset_trigger_source uint32_t step_data dac_trigger_t step_trigger_source"},{"location":"powerAPI/structdac__function__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structdac__function__config__t/#variable-dac_function","title":"variable dac_function","text":"<pre><code>dac_function_t dac_function_config_t::dac_function;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-polarity","title":"variable polarity","text":"<pre><code>dac_polarity_t dac_function_config_t::polarity;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_data","title":"variable reset_data","text":"<pre><code>uint32_t dac_function_config_t::reset_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-reset_trigger_source","title":"variable reset_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::reset_trigger_source;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_data","title":"variable step_data","text":"<pre><code>uint32_t dac_function_config_t::step_data;\n</code></pre>"},{"location":"powerAPI/structdac__function__config__t/#variable-step_trigger_source","title":"variable step_trigger_source","text":"<pre><code>dac_trigger_t dac_function_config_t::step_trigger_source;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/structgpio__conf__t/","title":"Struct gpio_conf_t","text":"<p>ClassList &gt; gpio_conf_t</p> <p>Structure containing all the information of the gpio linked to a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structgpio__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_output_units_t OUT_H hrtim_output_units_t OUT_L LL_GPIO_InitTypeDef switch_H LL_GPIO_InitTypeDef switch_L hrtim_gpio_clock_number_t tu_gpio_CLK GPIO_TypeDef * unit"},{"location":"powerAPI/structgpio__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structgpio__conf__t/#variable-out_h","title":"variable OUT_H","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-out_l","title":"variable OUT_L","text":"<pre><code>hrtim_output_units_t gpio_conf_t::OUT_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_h","title":"variable switch_H","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_H;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-switch_l","title":"variable switch_L","text":"<pre><code>LL_GPIO_InitTypeDef gpio_conf_t::switch_L;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-tu_gpio_clk","title":"variable tu_gpio_CLK","text":"<pre><code>hrtim_gpio_clock_number_t gpio_conf_t::tu_gpio_CLK;\n</code></pre>"},{"location":"powerAPI/structgpio__conf__t/#variable-unit","title":"variable unit","text":"<pre><code>GPIO_TypeDef* gpio_conf_t::unit;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structphase__shift__conf__t/","title":"Struct phase_shift_conf_t","text":"<p>ClassList &gt; phase_shift_conf_t</p> <p>Structure containing all the data regarding phase shifting for a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_tu_t compare_tu hrtim_reset_trig_t reset_trig uint16_t value"},{"location":"powerAPI/structphase__shift__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structphase__shift__conf__t/#variable-compare_tu","title":"variable compare_tu","text":"<pre><code>hrtim_tu_t phase_shift_conf_t::compare_tu;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-reset_trig","title":"variable reset_trig","text":"<pre><code>hrtim_reset_trig_t phase_shift_conf_t::reset_trig;\n</code></pre>"},{"location":"powerAPI/structphase__shift__conf__t/#variable-value","title":"variable value","text":"<pre><code>uint16_t phase_shift_conf_t::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structpwm__conf__t/","title":"Struct pwm_conf_t","text":"<p>ClassList &gt; pwm_conf_t</p> <p>Structure containing all the data regarding the pwm of a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structpwm__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t ckpsc uint16_t duty_cycle hrtim_external_trigger_t external_trigger uint16_t fall_dead_time uint32_t frequency hrtim_cnt_t modulation uint16_t period hrtim_pwm_mode_t pwm_mode hrtim_tu_t pwm_tu uint16_t rise_dead_time hrtim_tu_ON_OFF_t unit_on"},{"location":"powerAPI/structpwm__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structpwm__conf__t/#variable-ckpsc","title":"variable ckpsc","text":"<pre><code>uint8_t pwm_conf_t::ckpsc;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-duty_cycle","title":"variable duty_cycle","text":"<pre><code>uint16_t pwm_conf_t::duty_cycle;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-external_trigger","title":"variable external_trigger","text":"<pre><code>hrtim_external_trigger_t pwm_conf_t::external_trigger;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-fall_dead_time","title":"variable fall_dead_time","text":"<pre><code>uint16_t pwm_conf_t::fall_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-frequency","title":"variable frequency","text":"<pre><code>uint32_t pwm_conf_t::frequency;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-modulation","title":"variable modulation","text":"<pre><code>hrtim_cnt_t pwm_conf_t::modulation;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-period","title":"variable period","text":"<pre><code>uint16_t pwm_conf_t::period;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_mode","title":"variable pwm_mode","text":"<pre><code>hrtim_pwm_mode_t pwm_conf_t::pwm_mode;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-pwm_tu","title":"variable pwm_tu","text":"<pre><code>hrtim_tu_t pwm_conf_t::pwm_tu;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-rise_dead_time","title":"variable rise_dead_time","text":"<pre><code>uint16_t pwm_conf_t::rise_dead_time;\n</code></pre>"},{"location":"powerAPI/structpwm__conf__t/#variable-unit_on","title":"variable unit_on","text":"<pre><code>hrtim_tu_ON_OFF_t pwm_conf_t::unit_on;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/classsafety/","title":"Class safety","text":"<p>ClassList &gt; safety</p>"},{"location":"powerAPI/classsafety/#public-functions","title":"Public Functions","text":"Type Name void disableSafetyApi () disable the safet API fault detection task void enableSafetyApi () enable the safet API fault detection task bool getChannelError (channel_t channels_error) check if the channel faced an error (went over/under threshold) safety_reaction_t getChannelReaction () returns the reaction to do when encoutering an error. float32_t getChannelThresholdMax (channel_t channels_threshold) get the maximum threshold of the selected channel float32_t getChannelThresholdMin (channel_t channels_threshold) get the minimum threshold of the selected channel bool getChannelWatch (channel_t channels_watch) check if a channel is being monitored or not. void init_shield () Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the channels will be monitored to detect potential faults in voltage/current. void init_shield (channel_t * channels_watch, uint8_t channels_watch_number) Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the channels will be monitored to detect potential faults in voltage/current. int8_t retrieveThreshold (channel_t channel_threshold_retrieve) store the current minimum and maximum threshold in the flash (non volatile memory) void setChannelReaction (safety_reaction_t channels_reaction) Set the reaction to do if an error has been detected. Choose either open-circuit (both switches are opened and no power flows in the output) or short-circuit (high-side switch is opened, and low-side is closed maintaining the output in short-circuit) int8_t setChannelThresholdMax (channel_t * channels_threshold, float32_t * threshold_max, uint8_t channels_threshold_number) set the maximum threshold for the channels present in the list safety_channels. int8_t setChannelThresholdMin (channel_t * channels_threshold, float32_t * threshold_min, uint8_t channels_threshold_number) set the minimum threshold for the channels present in the list safety_channels. int8_t setChannelWatch (channel_t * channels_watch, uint8_t channels_watch_number) Enables the monitoring of the selected channels for safety. int8_t storeThreshold (channel_t channel_threshold_store) store the current minimum and maximum threshold in the flash (non volatile memory) int8_t unsetChannelWatch (channel_t * channels_watch, uint8_t channels_watch_number) Disables the monitoring of the selected channels for safety."},{"location":"powerAPI/classsafety/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/classsafety/#function-disablesafetyapi","title":"function disableSafetyApi","text":"<p>disable the safet API fault detection task <pre><code>void safety::disableSafetyApi () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-enablesafetyapi","title":"function enableSafetyApi","text":"<p>enable the safet API fault detection task <pre><code>void safety::enableSafetyApi () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-getchannelerror","title":"function getChannelError","text":"<p>check if the channel faced an error (went over/under threshold) <pre><code>bool safety::getChannelError (\n    channel_t channels_error\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_error</code> the channel to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>true if the channel faced an error, false if not </p>"},{"location":"powerAPI/classsafety/#function-getchannelreaction","title":"function getChannelReaction","text":"<p>returns the reaction to do when encoutering an error. <pre><code>safety_reaction_t safety::getChannelReaction () \n</code></pre></p> <p>Returns:</p> <p>Open_Circuit or Short_Circuit </p>"},{"location":"powerAPI/classsafety/#function-getchannelthresholdmax","title":"function getChannelThresholdMax","text":"<p>get the maximum threshold of the selected channel <pre><code>float32_t safety::getChannelThresholdMax (\n    channel_t channels_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_threshold</code> the channel to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>the maximum threshold </p>"},{"location":"powerAPI/classsafety/#function-getchannelthresholdmin","title":"function getChannelThresholdMin","text":"<p>get the minimum threshold of the selected channel <pre><code>float32_t safety::getChannelThresholdMin (\n    channel_t channels_threshold\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_threshold</code> the channel to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>the minimum threshold </p>"},{"location":"powerAPI/classsafety/#function-getchannelwatch","title":"function getChannelWatch","text":"<p>check if a channel is being monitored or not. <pre><code>bool safety::getChannelWatch (\n    channel_t channels_watch\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_watch</code> the channel to check </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>true if the channel is being monitored, false if not </p>"},{"location":"powerAPI/classsafety/#function-init_shield-12","title":"function init_shield [1/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the channels will be monitored to detect potential faults in voltage/current. <pre><code>void safety::init_shield () \n</code></pre></p> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-init_shield-22","title":"function init_shield [2/2]","text":"<p>Initializes thresholds min/max with the default value from the device tree, if values were stored and found in the flash they will be used instead. All the channels will be monitored to detect potential faults in voltage/current. <pre><code>void safety::init_shield (\n    channel_t * channels_watch,\n    uint8_t channels_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_watch</code> A list of the channels to watch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>channels_watch_number</code> The number of channels present in the list channels_watch.</li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-retrievethreshold","title":"function retrieveThreshold","text":"<p>store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t safety::retrieveThreshold (\n    channel_t channel_threshold_retrieve\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channel_threshold_retrieve</code> the channel for which we store the threshold in the NVS </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly retreived, negative value if there was an error: -1: NVS is empty -2: NVS contains data, but their version doesn't match current version -3: NVS data is corrupted -4: NVS contains data, but not for the requested channel </p>"},{"location":"powerAPI/classsafety/#function-setchannelreaction","title":"function setChannelReaction","text":"<p>Set the reaction to do if an error has been detected. Choose either open-circuit (both switches are opened and no power flows in the output) or short-circuit (high-side switch is opened, and low-side is closed maintaining the output in short-circuit) <pre><code>void safety::setChannelReaction (\n    safety_reaction_t channels_reaction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_reaction</code> the reaction to do </li> <li>Open_Circuit </li> <li>Short_Circuit</li> </ul> <p>Returns:</p> <p>none </p>"},{"location":"powerAPI/classsafety/#function-setchannelthresholdmax","title":"function setChannelThresholdMax","text":"<p>set the maximum threshold for the channels present in the list safety_channels. <pre><code>int8_t safety::setChannelThresholdMax (\n    channel_t * channels_threshold,\n    float32_t * threshold_max,\n    uint8_t channels_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_threshold</code> A list of the channels to set the threshold. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>threshold_max</code> A list of the maximum threshold to apply to the channels in safety_channels. </li> <li><code>channels_threshold_number</code> the number of channels present in the list channel_threshold</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if not. </p>"},{"location":"powerAPI/classsafety/#function-setchannelthresholdmin","title":"function setChannelThresholdMin","text":"<p>set the minimum threshold for the channels present in the list safety_channels. <pre><code>int8_t safety::setChannelThresholdMin (\n    channel_t * channels_threshold,\n    float32_t * threshold_min,\n    uint8_t channels_threshold_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_threshold</code> A list of the channels to set the threshold. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>threshold_min</code> A list of the minimum threshold to apply to the channels in safety_channels. </li> <li><code>channels_threshold_number</code> the number of channels present in the list channel_threshold</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if not. </p>"},{"location":"powerAPI/classsafety/#function-setchannelwatch","title":"function setChannelWatch","text":"<p>Enables the monitoring of the selected channels for safety. <pre><code>int8_t safety::setChannelWatch (\n    channel_t * channels_watch,\n    uint8_t channels_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_watch</code> A list of the channels to watch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>channels_watch_number</code> The number of channels present in the list channels_watch.</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if there was an error </p>"},{"location":"powerAPI/classsafety/#function-storethreshold","title":"function storeThreshold","text":"<p>store the current minimum and maximum threshold in the flash (non volatile memory) <pre><code>int8_t safety::storeThreshold (\n    channel_t channel_threshold_store\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channel_threshold_store</code> the channel for which we store the threshold in the NVS </li> <li>V1_LOW </li> <li>V2_LOW </li> <li>V_HIGH </li> <li>I1_LOW </li> <li>I2_LOW </li> <li>I_HIGH </li> <li>TEMP_SENSOR </li> <li>EXTRA_MEAS </li> <li>ANALOG_COMM</li> </ul> <p>Returns:</p> <p>0 if parameters were correcly stored, -1 if there was an error. </p>"},{"location":"powerAPI/classsafety/#function-unsetchannelwatch","title":"function unsetChannelWatch","text":"<p>Disables the monitoring of the selected channels for safety. <pre><code>int8_t safety::unsetChannelWatch (\n    channel_t * channels_watch,\n    uint8_t channels_watch_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>channels_watch</code> A list of the channels to unwatch. The variables in the list can be : V1_LOW, V2_LOW, V_HIGH, I1_LOW, I2_LOW, I_HIGH, TEMP_SENSOR, EXTRA_MEAS, ANALOG_COMM </li> <li><code>channels_watch_number</code> The number of channels present in the list channels_watch.</li> </ul> <p>Returns:</p> <p>0 if sucessfull, or -1 if there was an error </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/structswitch__conv__conf__t/","title":"Struct switch_conv_conf_t","text":"<p>ClassList &gt; switch_conv_conf_t</p> <p>Structure describing the switching convention of a given timing unit. </p> <ul> <li><code>#include &lt;hrtim_enum.h&gt;</code></li> </ul>"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes","title":"Public Attributes","text":"Type Name hrtim_switch_convention_t convention uint32_t reset_H uint32_t reset_L uint32_t set_H uint32_t set_L"},{"location":"powerAPI/structswitch__conv__conf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structswitch__conv__conf__t/#variable-convention","title":"variable convention","text":"<pre><code>hrtim_switch_convention_t switch_conv_conf_t::convention;\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_h","title":"variable reset_H","text":"<pre><code>uint32_t switch_conv_conf_t::reset_H[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-reset_l","title":"variable reset_L","text":"<pre><code>uint32_t switch_conv_conf_t::reset_L[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_h","title":"variable set_H","text":"<pre><code>uint32_t switch_conv_conf_t::set_H[2];\n</code></pre>"},{"location":"powerAPI/structswitch__conv__conf__t/#variable-set_l","title":"variable set_L","text":"<pre><code>uint32_t switch_conv_conf_t::set_L[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/structtimer__config__t/","title":"Struct timer_config_t","text":"<p>ClassList &gt; timer_config_t</p> <p>More...</p> <ul> <li><code>#include &lt;timer.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__config__t/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t timer_enable_encoder uint32_t timer_enable_irq pin_mode_t timer_enc_pin_mode timer_callback_t timer_irq_callback uint32_t timer_irq_t_usec"},{"location":"powerAPI/structtimer__config__t/#detailed-description","title":"Detailed Description","text":"<p>timer_enable_irq : set to 1 to enable interrupt on timer overflow. timer_enable_encoder : set to 1 for timer to act as an incremental coder counter.</p> <p>*** IRQ mode (ignored if timer_enable_irq=0) *** * timer_irq_callback : pointer to a void(void) function that will be called on timer overflow. * timer_irq_t_usec : period of the interrupt in microsecond (2 to 6553 \u00b5s)</p> <p>*** Incremental code mode (ignored if timer_enable_encoder=0) *** * timer_pin_mode : Pin mode for incremental coder interface.</p> <p>NOTE: At this time, only irq mode is supported on TIM6/TIM7, and only incremental coder mode is suppported on TIM4, which makes this configuration structure almost pointless (except for callback definition). However, it is built this way with future evolutions of the driver in mind. </p>"},{"location":"powerAPI/structtimer__config__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_encoder","title":"variable timer_enable_encoder","text":"<pre><code>uint32_t timer_config_t::timer_enable_encoder;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enable_irq","title":"variable timer_enable_irq","text":"<pre><code>uint32_t timer_config_t::timer_enable_irq;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_enc_pin_mode","title":"variable timer_enc_pin_mode","text":"<pre><code>pin_mode_t timer_config_t::timer_enc_pin_mode;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_callback","title":"variable timer_irq_callback","text":"<pre><code>timer_callback_t timer_config_t::timer_irq_callback;\n</code></pre>"},{"location":"powerAPI/structtimer__config__t/#variable-timer_irq_t_usec","title":"variable timer_irq_t_usec","text":"<pre><code>uint32_t timer_config_t::timer_irq_t_usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__driver__api/","title":"Struct timer_driver_api","text":"<p>ClassList &gt; timer_driver_api</p>"},{"location":"powerAPI/structtimer__driver__api/#public-attributes","title":"Public Attributes","text":"Type Name timer_api_config config timer_api_get_count get_count timer_api_start start timer_api_stop stop"},{"location":"powerAPI/structtimer__driver__api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__driver__api/#variable-config","title":"variable config","text":"<pre><code>timer_api_config timer_driver_api::config;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-get_count","title":"variable get_count","text":"<pre><code>timer_api_get_count timer_driver_api::get_count;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-start","title":"variable start","text":"<pre><code>timer_api_start timer_driver_api::start;\n</code></pre>"},{"location":"powerAPI/structtimer__driver__api/#variable-stop","title":"variable stop","text":"<pre><code>timer_api_stop timer_driver_api::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/structtimer__hrtim__t/","title":"Struct timer_hrtim_t","text":"<p>ClassList &gt; timer_hrtim_t</p> <p>Timinig unit configuration - aggregates all the structures. </p> <ul> <li><code>#include &lt;hrtim.h&gt;</code></li> </ul>"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes","title":"Public Attributes","text":"Type Name adc_hrtim_conf_t adc_hrtim comp_usage_conf_t comp_usage gpio_conf_t gpio_conf phase_shift_conf_t phase_shift pwm_conf_t pwm_conf switch_conv_conf_t switch_conv"},{"location":"powerAPI/structtimer__hrtim__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/structtimer__hrtim__t/#variable-adc_hrtim","title":"variable adc_hrtim","text":"<pre><code>adc_hrtim_conf_t timer_hrtim_t::adc_hrtim;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-comp_usage","title":"variable comp_usage","text":"<pre><code>comp_usage_conf_t timer_hrtim_t::comp_usage;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-gpio_conf","title":"variable gpio_conf","text":"<pre><code>gpio_conf_t timer_hrtim_t::gpio_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-phase_shift","title":"variable phase_shift","text":"<pre><code>phase_shift_conf_t timer_hrtim_t::phase_shift;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-pwm_conf","title":"variable pwm_conf","text":"<pre><code>pwm_conf_t timer_hrtim_t::pwm_conf;\n</code></pre>"},{"location":"powerAPI/structtimer__hrtim__t/#variable-switch_conv","title":"variable switch_conv","text":"<pre><code>switch_conv_conf_t timer_hrtim_t::switch_conv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"powerAPI/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/","title":"Dir docs/core","text":"<p>FileList &gt; core</p>"},{"location":"powerAPI/dir_771164b9325b04f1442f7a3ffa8ecb89/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/</code></p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/","title":"Dir docs/core/zephyr","text":"<p>FileList &gt; core &gt; zephyr</p>"},{"location":"powerAPI/dir_09002e7ce91f09aeb040dfd1861a47f4/#directories","title":"Directories","text":"Type Name dir modules <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/</code></p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/","title":"Dir docs/core/zephyr/modules","text":"<p>FileList &gt; core &gt; zephyr &gt; modules</p>"},{"location":"powerAPI/dir_6d0fb8ab814c517e7f155fb837e32f72/#directories","title":"Directories","text":"Type Name dir owntech_adc_driver dir owntech_communication dir owntech_comparator_driver dir owntech_dac_driver dir owntech_data_api dir owntech_flash_driver dir owntech_hrtim_driver dir owntech_ngnd_driver dir owntech_power_api dir owntech_safety_api dir owntech_spin_api dir owntech_task_api dir owntech_timer_driver <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/</code></p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver</p>"},{"location":"powerAPI/dir_e0b0ebd8181eadf56b45f70b679dd6ce/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/</code></p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_fc55e1a77480d908ce2594a494dae021/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/","title":"Dir docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_1a23096fc67cd9ffce086a2218b577f7/#files","title":"Files","text":"Type Name file adc.c file adc.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/adc_8c/","title":"File adc.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t adc_discontinuous_mode   = = {0} adc_ev_src_t adc_trigger_sources   = = {0} bool enable_dma   = = {0} uint32_t enabled_channels   = = {0} uint32_t enabled_channels_count   = = {0}"},{"location":"powerAPI/adc_8c/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the triger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/adc_8c/#variable-adc_discontinuous_mode","title":"variable adc_discontinuous_mode","text":"<pre><code>uint32_t adc_discontinuous_mode[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-adc_trigger_sources","title":"variable adc_trigger_sources","text":"<pre><code>adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enable_dma","title":"variable enable_dma","text":"<pre><code>bool enable_dma[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels","title":"variable enabled_channels","text":"<pre><code>uint32_t enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC];\n</code></pre>"},{"location":"powerAPI/adc_8c/#variable-enabled_channels_count","title":"variable enabled_channels_count","text":"<pre><code>uint32_t enabled_channels_count[NUMBER_OF_ADCS];\n</code></pre>"},{"location":"powerAPI/adc_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8c/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the triger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>triggger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8c/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8c/#function-adc_start","title":"function adc_start","text":"<p>Starts all configured ADCs. <pre><code>void adc_start () \n</code></pre></p>"},{"location":"powerAPI/adc_8c/#function-adc_stop","title":"function adc_stop","text":"<p>Stops all configured ADCs. <pre><code>void adc_stop () \n</code></pre></p>"},{"location":"powerAPI/adc_8c/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.c</code></p>"},{"location":"powerAPI/adc_8c_source/","title":"File adc.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// STM32 LL\n#include &lt;stm32_ll_adc.h&gt;\n\n// Current module private functions\n#include \"../src/adc_core.h\"\n\n// Current file header\n#include \"adc.h\"\n\n\n// Constants\n\n#define NUMBER_OF_ADCS 5\n#define NUMBER_OF_CHANNELS_PER_ADC 16\n\n\n// Local variables\n\nstatic adc_ev_src_t adc_trigger_sources[NUMBER_OF_ADCS]    = {0};\nstatic uint32_t     adc_discontinuous_mode[NUMBER_OF_ADCS] = {0};\nstatic uint32_t     enabled_channels_count[NUMBER_OF_ADCS] = {0};\nstatic bool         enable_dma[NUMBER_OF_ADCS]             = {0};\n\nstatic uint32_t     enabled_channels[NUMBER_OF_ADCS][NUMBER_OF_CHANNELS_PER_ADC] = {0};\n\n\n// Public API\n\nvoid adc_configure_trigger_source(uint8_t adc_number, adc_ev_src_t trigger_source)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_trigger_sources[adc_number-1] = trigger_source;\n\n}\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number, uint32_t discontinuous_count)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    adc_discontinuous_mode[adc_number-1] = discontinuous_count;\n}\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    if (enabled_channels_count[adc_index] == NUMBER_OF_CHANNELS_PER_ADC)\n        return;\n\n    enabled_channels[adc_index][enabled_channels_count[adc_index]] = channel;\n    enabled_channels_count[adc_index]++;\n}\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    uint8_t adc_index = adc_number-1;\n\n    for (int i = 0 ; i &lt; NUMBER_OF_CHANNELS_PER_ADC ; i++)\n    {\n        if (enabled_channels[adc_index][i] == channel)\n        {\n            for (int j = i ; j &lt; NUMBER_OF_CHANNELS_PER_ADC-1 ; j++)\n            {\n                enabled_channels[adc_index][i] = enabled_channels[adc_index][i+1];\n            }\n            enabled_channels[adc_index][NUMBER_OF_CHANNELS_PER_ADC-1] = 0;\n\n            enabled_channels_count[adc_index]--;\n\n            break;\n        }\n    }\n}\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return 0;\n\n    uint8_t adc_index = adc_number-1;\n\n    return enabled_channels_count[adc_index];\n}\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma)\n{\n    if ( (adc_number == 0) || (adc_number &gt; NUMBER_OF_ADCS) )\n        return;\n\n    enable_dma[adc_number-1] = use_dma;\n}\n\nvoid adc_start()\n{\n    // Initialize ADCs\n\n    adc_core_init();\n\n    // Pre-enable configuration\n\n    // Nothing here for now.\n\n    // If some channels have to be set as differential,\n    // or ADCs have to be set as dual mode,\n    // this shoud be done here.\n\n    // Enable ADCs\n\n    for (int adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        adc_core_enable(adc_num);\n    }\n\n    // Post-enable configuration\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            for (int channel_index = 0 ; channel_index &lt; NUMBER_OF_CHANNELS_PER_ADC ; channel_index++)\n            {\n                if (enabled_channels[adc_index][channel_index] == 0)\n                    break;\n\n                adc_core_configure_channel(adc_num, enabled_channels[adc_index][channel_index], channel_index+1);\n            }\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_dma_mode(adc_num, enable_dma[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            adc_core_configure_discontinuous_mode(adc_num, adc_discontinuous_mode[adc_index]);\n        }\n    }\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if (enabled_channels_count[adc_index] &gt; 0)\n        {\n            // Convert to LL constants\n            uint32_t trig;\n            switch (adc_trigger_sources[adc_index])\n            {\n            case hrtim_ev1:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG1;\n                break;\n            case hrtim_ev2:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG2;\n                break;\n            case hrtim_ev3:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG3;\n                break;\n            case hrtim_ev4:\n                trig = LL_ADC_REG_TRIG_EXT_HRTIM_TRG4;\n                break;\n            case software:\n            default:\n                trig = LL_ADC_REG_TRIG_SOFTWARE;\n                break;\n            }\n\n            adc_core_configure_trigger_source(adc_num, LL_ADC_REG_TRIG_EXT_RISING, trig);\n        }\n    }\n\n    // Start ADCs\n\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp; (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_start(adc_num, enabled_channels_count[adc_index]);\n        }\n    }\n}\n\nvoid adc_stop()\n{\n    for (uint8_t adc_num = 1 ; adc_num &lt;= NUMBER_OF_ADCS ; adc_num++)\n    {\n        uint8_t adc_index = adc_num-1;\n        if ( (enabled_channels_count[adc_index] &gt; 0) &amp;&amp; (adc_trigger_sources[adc_index] != software) )\n        {\n            adc_core_stop(adc_num);\n        }\n    }\n}\n\nvoid adc_trigger_software_conversion(uint8_t adc_number, uint8_t number_of_acquisitions)\n{\n    adc_core_start(adc_number, number_of_acquisitions);\n}\n</code></pre>"},{"location":"powerAPI/adc_8h/","title":"File adc.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/adc_8h/#public-types","title":"Public Types","text":"Type Name enum adc_ev_src_t"},{"location":"powerAPI/adc_8h/#public-functions","title":"Public Functions","text":"Type Name void adc_add_channel (uint8_t adc_number, uint8_t channel) Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. void adc_configure_discontinuous_mode (uint8_t adc_number, uint32_t discontinuous_count) Registers the discontinuous count for an ADC. void adc_configure_trigger_source (uint8_t adc_number, adc_ev_src_t trigger_source) Registers the triger source for an ADC. void adc_configure_use_dma (uint8_t adc_number, bool use_dma) Configures an ADC to use DMA. uint32_t adc_get_enabled_channels_count (uint8_t adc_number) Returns the number of enabled channels for an ADC. void adc_remove_channel (uint8_t adc_number, uint8_t channel) Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. void adc_start () Starts all configured ADCs. void adc_stop () Stops all configured ADCs. void adc_trigger_software_conversion (uint8_t adc_number, uint8_t number_of_acquisitions) This function triggers a single conversion in the case of a software triggered ADC."},{"location":"powerAPI/adc_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/adc_8h/#enum-adc_ev_src_t","title":"enum adc_ev_src_t","text":"<pre><code>enum adc_ev_src_t {\n    software = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4\n};\n</code></pre>"},{"location":"powerAPI/adc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/adc_8h/#function-adc_add_channel","title":"function adc_add_channel","text":"<p>Adds a channel to the list of channels to be acquired for an ADC. The order in which channels are added determine the order in which they will be acquired. <pre><code>void adc_add_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_discontinuous_mode","title":"function adc_configure_discontinuous_mode","text":"<p>Registers the discontinuous count for an ADC. <pre><code>void adc_configure_discontinuous_mode (\n    uint8_t adc_number,\n    uint32_t discontinuous_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>discontinuous_count</code> Number of channels to acquire on each trigger event. 0 to disable discontinuous mode (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_trigger_source","title":"function adc_configure_trigger_source","text":"<p>Registers the triger source for an ADC. <pre><code>void adc_configure_trigger_source (\n    uint8_t adc_number,\n    adc_ev_src_t trigger_source\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>triggger_source</code> Source of the trigger. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_configure_use_dma","title":"function adc_configure_use_dma","text":"<p>Configures an ADC to use DMA. <pre><code>void adc_configure_use_dma (\n    uint8_t adc_number,\n    bool use_dma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>use_dma</code> Set to true to use DMA for this ADC, false to not use it (default). </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_get_enabled_channels_count","title":"function adc_get_enabled_channels_count","text":"<p>Returns the number of enabled channels for an ADC. <pre><code>uint32_t adc_get_enabled_channels_count (\n    uint8_t adc_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to fetch. </li> </ul> <p>Returns:</p> <p>Number of enabled channels on the given ADC. </p>"},{"location":"powerAPI/adc_8h/#function-adc_remove_channel","title":"function adc_remove_channel","text":"<p>Removes a channel from the list of channels that are acquired by an ADC. If a channel has been added multiple times, then only the first occurence in the list will be removed. <pre><code>void adc_remove_channel (\n    uint8_t adc_number,\n    uint8_t channel\n) \n</code></pre></p> <p>This will only be applied when ADC is started. If ADC is already started, it must be stopped then started again.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC to configure. </li> <li><code>channel</code> Number of the channel to to no longer be acquired. </li> </ul>"},{"location":"powerAPI/adc_8h/#function-adc_start","title":"function adc_start","text":"<p>Starts all configured ADCs. <pre><code>void adc_start () \n</code></pre></p>"},{"location":"powerAPI/adc_8h/#function-adc_stop","title":"function adc_stop","text":"<p>Stops all configured ADCs. <pre><code>void adc_stop () \n</code></pre></p>"},{"location":"powerAPI/adc_8h/#function-adc_trigger_software_conversion","title":"function adc_trigger_software_conversion","text":"<p>This function triggers a single conversion in the case of a software triggered ADC. <pre><code>void adc_trigger_software_conversion (\n    uint8_t adc_number,\n    uint8_t number_of_acquisitions\n) \n</code></pre></p> <p>This function must only be called after ADC has been started.</p> <p>Parameters:</p> <ul> <li><code>adc_number</code> Number of the ADC. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_adc_driver/zephyr/public_api/adc.h</code></p>"},{"location":"powerAPI/adc_8h_source/","title":"File adc.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_adc_driver &gt; zephyr &gt; public_api &gt; adc.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef ADC_H_\n#define ADC_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public enums\n\ntypedef enum\n{\n    software  = 0,\n    hrtim_ev1 = 1,\n    hrtim_ev2 = 2,\n    hrtim_ev3 = 3,\n    hrtim_ev4 = 4,\n} adc_ev_src_t;\n\n\n// Public API\n\nvoid adc_configure_trigger_source(uint8_t adc_number, adc_ev_src_t trigger_source);\n\nvoid adc_configure_discontinuous_mode(uint8_t adc_number, uint32_t discontinuous_count);\n\nvoid adc_add_channel(uint8_t adc_number, uint8_t channel);\n\nvoid adc_remove_channel(uint8_t adc_number, uint8_t channel);\n\nuint32_t adc_get_enabled_channels_count(uint8_t adc_number);\n\nvoid adc_configure_use_dma(uint8_t adc_number, bool use_dma);\n\n\nvoid adc_start();\n\nvoid adc_stop();\n\nvoid adc_trigger_software_conversion(uint8_t adc_number, uint8_t number_of_acquisitions);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // ADC_H_\n</code></pre>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/","title":"Dir docs/core/zephyr/modules/owntech_communication","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication</p>"},{"location":"powerAPI/dir_c4fe9b0224a9586dd317852c3c5604f8/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/</code></p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr</p>"},{"location":"powerAPI/dir_ed8beaa694e779377b0049b01e5ade22/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/</code></p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_acc3fb8fb6f052bdbe10ff0fa1d04fcf/#files","title":"Files","text":"Type Name file CommunicationAPI.cpp file CommunicationAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp/","title":"File CommunicationAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8cpp/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.cpp</code></p>"},{"location":"powerAPI/CommunicationAPI_8cpp_source/","title":"File CommunicationAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"CommunicationAPI.h\"\n\nCommunicationAPI communication;\n</code></pre>"},{"location":"powerAPI/CommunicationAPI_8h/","title":"File CommunicationAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CommunicationAPI_8h/#classes","title":"Classes","text":"Type Name class CommunicationAPI"},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name CommunicationAPI communication"},{"location":"powerAPI/CommunicationAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CommunicationAPI_8h/#variable-communication","title":"variable communication","text":"<pre><code>CommunicationAPI communication;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/public_api/CommunicationAPI.h</code></p>"},{"location":"powerAPI/CommunicationAPI_8h_source/","title":"File CommunicationAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; public_api &gt; CommunicationAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMMUNICATIONAPI_H\n#define COMMUNICATIONAPI_H\n\n#include \"../src/AnalogCommunication.h\"\n#include \"../src/CanCommunication.h\"\n#include \"../src/Rs485Communication.h\"\n#include \"../src/SyncCommunication.h\"\n\nclass CommunicationAPI\n{\n    public : \n        AnalogCommunication analog;\n\n        CanCommunication can;\n\n        Rs485Communication rs485;\n\n        SyncCommunication sync;\n\n};\n\nextern CommunicationAPI communication;\n\n#endif // COMMUNICATIONAPI_H\n</code></pre>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/","title":"Dir docs/core/zephyr/modules/owntech_communication/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_1a412f239039e530bef8001f48cd80a4/#files","title":"Files","text":"Type Name file AnalogCommunication.cpp file AnalogCommunication.h file CanCommunication.cpp file CanCommunication.h file Rs485.cpp file Rs485.h file Rs485Communication.cpp file Rs485Communication.h file SyncCommunication.cpp file SyncCommunication.h file data_objects.cpp file data_objects.h Handling of ThingSet data objects. file thingset_isotp.cpp file thingset_pub_sub.cpp <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp/","title":"File AnalogCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.cpp</code></p>"},{"location":"powerAPI/AnalogCommunication_8cpp_source/","title":"File AnalogCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* Header */\n#include \"AnalogCommunication.h\"\n\n/* OwnTech Power API */\n#include \"DataAPI.h\"\n#include \"SpinAPI.h\"\n\n/* LL drivers */\n#include \"stm32_ll_gpio.h\"\n\n#define ADC_NUM 2\n#define DAC_NUM 2\n#define DAC_CHAN 1\n\nvoid AnalogCommunication::init()\n{\n    /* Initialize the GPIO PC4 (pin number 35) to analog mode\n       to use the ADC */\n    LL_GPIO_SetPinMode      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_MODE_ANALOG);\n    LL_GPIO_SetPinSpeed     (GPIOC, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOC, LL_GPIO_PIN_4, LL_GPIO_PULL_NO);\n\n    data.enableShieldChannel(ADC_NUM, ANALOG_COMM);\n\n    /* Initialize the DAC */\n    spin.dac.initConstValue(ADC_NUM);\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, 0);\n}\n\nfloat32_t AnalogCommunication::getAnalogCommValue()\n{\n    float32_t ret =  data.getLatest(ANALOG_COMM);\n    return ret;\n}\n\nvoid AnalogCommunication::setAnalogCommValue(uint32_t analog_bus_value)\n{\n    spin.dac.setConstValue(DAC_NUM, DAC_CHAN, analog_bus_value);\n}\n</code></pre>"},{"location":"powerAPI/AnalogCommunication_8h/","title":"File AnalogCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/AnalogCommunication_8h/#classes","title":"Classes","text":"Type Name class AnalogCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/AnalogCommunication.h</code></p>"},{"location":"powerAPI/AnalogCommunication_8h_source/","title":"File AnalogCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; AnalogCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef ANALOGCOMMUNICATION_H_\n#define ANALOGCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n\n// Static class definition\n\nclass AnalogCommunication\n{\n\npublic:\n    static void init();\n\n    static float32_t getAnalogCommValue();\n\n    static void setAnalogCommValue(uint32_t analog_bus_value);\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_ANALOG\n\n#endif // ANALOGCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/CanCommunication_8cpp/","title":"File CanCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t broadcast_time uint16_t control_time"},{"location":"powerAPI/CanCommunication_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/CanCommunication_8cpp/#variable-broadcast_time","title":"variable broadcast_time","text":"<pre><code>uint16_t broadcast_time;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/CanCommunication_8cpp/#variable-control_time","title":"variable control_time","text":"<pre><code>uint16_t control_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.cpp</code></p>"},{"location":"powerAPI/CanCommunication_8cpp_source/","title":"File CanCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* Header */\n#include \"CanCommunication.h\"\n#include \"data_objects.h\"\n\n/* Zephyr driver*/\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n// Extern variable defined in this module\n\nextern uint16_t broadcast_time;\nextern uint16_t control_time;\n\n\nuint16_t CanCommunication::getCanNodeAddr()\n{\n    return can_node_addr;\n}\n\nbool CanCommunication::getCtrlEnable()\n{\n    return ctrl_enable;\n}\n\nfloat32_t CanCommunication::getCtrlReference()\n{\n    return reference_value;\n}\n\nuint16_t CanCommunication::getBroadcastPeriod()\n{\n    return broadcast_time;\n}\n\nuint16_t CanCommunication::getControlPeriod()\n{\n    return control_time;\n}\n\n\nvoid CanCommunication::setCanNodeAddr(uint16_t addr)\n{\n    can_node_addr = addr;\n}\n\nvoid CanCommunication::setCtrlEnable(bool enable)\n{\n    ctrl_enable = enable;\n}\n\nvoid CanCommunication::setCtrlReference(float32_t reference)\n{\n    reference_value = reference;\n}\n\nvoid CanCommunication::setBroadcastPeriod(uint16_t time_100_ms)\n{\n    broadcast_time = time_100_ms;\n}\n\nvoid CanCommunication::setControlPeriod(uint16_t time_100_ms)\n{\n    control_time = time_100_ms;\n}\n\nvoid CanCommunication::enableCan()\n{\n    const struct gpio_dt_spec can_standby_spec = GPIO_DT_SPEC_GET(CAN_STANDBY_DEVICE, gpios);\n    gpio_pin_configure_dt(&amp;can_standby_spec, GPIO_OUTPUT_INACTIVE);\n}\n</code></pre>"},{"location":"powerAPI/CanCommunication_8h/","title":"File CanCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CanCommunication_8h/#classes","title":"Classes","text":"Type Name class CanCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/CanCommunication.h</code></p>"},{"location":"powerAPI/CanCommunication_8h_source/","title":"File CanCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; CanCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef CANCOMMUNICATION_H_\n#define CANCOMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;arm_math.h&gt;\n\n#define CAN_STANDBY_DEVICE DT_CHILD(DT_PATH(can_standby_switch), can_standby_gpio_pin)\n\n// Static class definition\n\nclass CanCommunication\n{\n\npublic:\n    static uint16_t getCanNodeAddr();\n\n    static bool getCtrlEnable();\n\n    static float32_t getCtrlReference();\n\n    static uint16_t getBroadcastPeriod();\n\n    static uint16_t getControlPeriod();\n\n    static void setCanNodeAddr(uint16_t addr);\n\n    static void setCtrlEnable(bool enable);\n\n    static void setCtrlReference(float32_t reference);\n\n    static void setBroadcastPeriod(uint16_t time_100_ms);\n\n    static void setControlPeriod(uint16_t time_100_ms);\n\n    void enableCan();\n};\n\n#endif // CANCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/","title":"File Rs485.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name struct uart_event evt struct uart_config uart_cfg"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name uint32_t baud   = = 21250000 / (2) const struct device * dma1   = = DEVICE_DT_GET(DT_NODELABEL(dma1)) uint16_t dma_buffer_size uint8_t * rx_usart_val uint8_t * tx_usart_val const struct device * uart_dev   = = DEVICE_DT_GET(DT_NODELABEL(usart3)) dma_callbackRXfunc_t user_fnc   = = NULL"},{"location":"powerAPI/Rs485_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () initialize dma 1 channel 7 for receiving data in circular mode void dma_channel_init_tx () initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. void init_usrBaudrate (uint32_t usr_baud) initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) initialize user transmission and reception buffer void init_usrDataSize (uint16_t size) initialize DMA data size to send and receive void init_usrFunc (dma_callbackRXfunc_t fnc_callback) initialize user function called every RX callback void oversamp_set (usart_oversampling_t oversampling) set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. void serial_init (void) initialize USART3 void serial_start () enable usart void serial_stop () disable usart void serial_tx_on () reload dma buffer TX"},{"location":"powerAPI/Rs485_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _dma_callback_rx ()  void _dma_callback_tx (const struct device * dev, void * user_data, uint32_t channel, int status)"},{"location":"powerAPI/Rs485_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-evt","title":"variable evt","text":"<pre><code>struct uart_event evt;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_cfg","title":"variable uart_cfg","text":"<pre><code>struct uart_config uart_cfg;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#variable-baud","title":"variable baud","text":"<pre><code>uint32_t baud;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma1","title":"variable dma1","text":"<pre><code>const struct device* dma1;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-dma_buffer_size","title":"variable dma_buffer_size","text":"<pre><code>uint16_t dma_buffer_size;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-rx_usart_val","title":"variable rx_usart_val","text":"<pre><code>uint8_t* rx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-tx_usart_val","title":"variable tx_usart_val","text":"<pre><code>uint8_t* tx_usart_val;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#variable-user_fnc","title":"variable user_fnc","text":"<pre><code>dma_callbackRXfunc_t user_fnc;\n</code></pre>"},{"location":"powerAPI/Rs485_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>initialize dma 1 channel 7 for receiving data in circular mode <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_demode","title":"function init_DEmode","text":"<p>initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>initialize user transmission and reception buffer <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>initialize DMA data size to send and receive <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>initialize user function called every RX callback <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8cpp/#function-oversamp_set","title":"function oversamp_set","text":"<p>set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_init","title":"function serial_init","text":"<p>initialize USART3 <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_start","title":"function serial_start","text":"<p>enable usart <pre><code>void serial_start () \n</code></pre></p> <p>to start or restart communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_stop","title":"function serial_stop","text":"<p>disable usart <pre><code>void serial_stop () \n</code></pre></p> <p>to stop communication </p>"},{"location":"powerAPI/Rs485_8cpp/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>reload dma buffer TX <pre><code>void serial_tx_on () \n</code></pre></p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p>"},{"location":"powerAPI/Rs485_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_rx","title":"function _dma_callback_rx","text":"<pre><code>static void _dma_callback_rx () \n</code></pre> <p>DMA callback RX clear reception flag, then call user functions </p>"},{"location":"powerAPI/Rs485_8cpp/#function-_dma_callback_tx","title":"function _dma_callback_tx","text":"<pre><code>static void _dma_callback_tx (\n    const struct device * dev,\n    void * user_data,\n    uint32_t channel,\n    int status\n) \n</code></pre> <p>DMA callback TX clear transmission flag, and disabled DMA channel TX. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.cpp</code></p>"},{"location":"powerAPI/Rs485_8cpp_source/","title":"File Rs485.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/* ll drivers */\n#include &lt;stm32_ll_dma.h&gt;\n#include &lt;stm32_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n/* Zephyr drivers */\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/drivers/dma.h&gt;\n\n/* Header */\n#include \"Rs485.h\"\n\n#define DMA_USART DMA1 // DMA used\n\n#define STM32_DMA_HAL_OVERRIDE 0x7F\n\n/* Warning : if you change the channels number, you'll have to change some code line manually*/\n#define ZEPHYR_DMA_CHANNEL_TX 6 // transmission dma channel for zephyr driver\n#define ZEPHYR_DMA_CHANNEL_RX 7 // reception dma channel for zephyr driver\n\n/* Warning : if you change the channels, you'll have to change some code line manually*/\n#define LL_DMA_CHANNEL_TX LL_DMA_CHANNEL_6 // transmission dma channel for LL driver\n#define LL_DMA_CHANNEL_RX LL_DMA_CHANNEL_7 // reception dma channel for LL driver\n\n/* DT definitions */\nstatic const struct device *dma1 = DEVICE_DT_GET(DT_NODELABEL(dma1));\nstatic const struct device *uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart3));\n\n/* USART initialization parameters */\nstatic uint32_t baud = 21250000 / (2); /* initial baudrate to  10.625Mhz */\nstruct uart_config uart_cfg;\nstruct uart_event evt;\n\n/* DMA buffer for transmission and reception */\nstatic uint8_t* tx_usart_val;\nstatic uint8_t* rx_usart_val;\n\nstatic uint16_t dma_buffer_size;\n\nstatic dma_callbackRXfunc_t user_fnc = NULL; // user function to call in RX callback\n\n\nstatic void _dma_callback_tx(const struct device *dev, void *user_data, uint32_t channel, int status)\n{\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // Disable DMA channel after sending datas\n\n    LL_USART_ClearFlag_TXFE(USART3);\n    LL_USART_ClearFlag_TC(USART3); // clear transmission complete flag USART\n    LL_DMA_ClearFlag_TC6(DMA_USART); // clear transmission complete dma channel TX\n}\n\nstatic void _dma_callback_rx()\n{\n    LL_DMA_ClearFlag_TC7(DMA_USART); // clear transmission complete flag\n\n    if(user_fnc != NULL){\n        user_fnc();\n    }\n}\n\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer)\n{\n    tx_usart_val = tx_buffer;\n    rx_usart_val = rx_buffer;\n}\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback)\n{\n    user_fnc = fnc_callback;\n}\n\nvoid init_usrBaudrate(uint32_t usr_baud)\n{\n    baud = usr_baud;\n}\n\nvoid init_usrDataSize(uint16_t size)\n{\n    dma_buffer_size = size;\n}\n\nvoid serial_init(void)\n{\n    uart_config_get(uart_dev, &amp;uart_cfg);\n    uart_cfg.baudrate = baud;\n    uart_cfg.flow_ctrl = UART_CFG_FLOW_CTRL_NONE;\n    uart_cfg.data_bits = UART_CFG_DATA_BITS_8;\n    uart_cfg.parity = UART_CFG_PARITY_NONE;\n    uart_cfg.stop_bits = UART_CFG_STOP_BITS_1;\n\n    uart_configure(uart_dev, &amp;uart_cfg);\n\n    LL_USART_ConfigAsyncMode(USART3);\n\n    /* Enable DMA request*/\n    LL_USART_EnableDMAReq_TX(USART3);\n    LL_USART_EnableDMAReq_RX(USART3);\n\n    // disable Interrupts for TX (not used for DMA)\n    LL_USART_DisableIT_TC(USART3);         // Disable Transmission Complete Interrupt\n    LL_USART_DisableIT_TXE_TXFNF(USART3);  // Disable Transmission Data Register Empty Interrupt for DMA to provide data\n                                           //  disable interrupts for RX (not used with DMA)\n    LL_USART_DisableIT_RXNE_RXFNE(USART3); // Disable Receiver Data Register Not Empty Interrupt for DMA to fetch data\n\n    LL_USART_Enable(USART3);\n}\n\nvoid init_DEmode(void)\n{\n    LL_USART_Disable(USART3);\n\n    LL_GPIO_InitTypeDef GPIO_InitStruct = {0}; // GPIO initialization\n\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB); // Enable GPIO clock\n\n    /* Set GPIO_InitStruct */\n    GPIO_InitStruct.Pin = LL_GPIO_PIN_14;\n    GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\n    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\n    GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\n    GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\n    LL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);\n\n    LL_USART_EnableDEMode(USART3); // Enable DE mode\n\n    LL_USART_SetDESignalPolarity(USART3, LL_USART_DE_POLARITY_HIGH); // Polarity is high ie. PB14 will be at high level when sending datas\n\n    /* Assertion time is set to maximum */\n    LL_USART_SetDEAssertionTime(USART3, 31);\n    LL_USART_SetDEDeassertionTime(USART3, 31);\n\n    LL_USART_Enable(USART3);\n}\n\n\nvoid oversamp_set(usart_oversampling_t oversampling)\n{\n    LL_USART_Disable(USART3);\n    LL_USART_SetOverSampling(USART3, oversampling);\n    LL_USART_Enable(USART3);\n}\n\nvoid dma_channel_init_tx()\n{\n    /*Configure DMA */\n    struct dma_config dma_config_s = {0};\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    dma_config_s.dma_callback = _dma_callback_tx;          // Callback\n    dma_config_s.linked_channel = STM32_DMA_HAL_OVERRIDE;  // Hal override\n\n    /* DMA configuration with LL drivers */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;TDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(tx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_TX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    dma_config(dma1, ZEPHYR_DMA_CHANNEL_TX, &amp;dma_config_s); // Indicates Callback function to zephyr driver\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // Disabling channel for initial set-up\n\n    /* initialize DMA */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size); // DMA data size\n    LL_DMA_SetChannelPriorityLevel(DMA_USART, LL_DMA_CHANNEL_TX, LL_DMA_PRIORITY_VERYHIGH); // DMA channel priority\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_TX, &amp;DMA_InitStruct);\n\n    /* Clearing flag */\n    LL_DMA_ClearFlag_TC6(DMA_USART);\n    LL_DMA_ClearFlag_HT6(DMA_USART);\n\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_TX); // Enable transfert complete interruption\n\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_TX); // Disable half-transfert interruption\n}\n\n\nvoid dma_channel_init_rx()\n{\n    /* Configure DMA */\n    LL_DMA_InitTypeDef DMA_InitStruct = {0};\n\n    /* Initialization of DMA */\n    DMA_InitStruct.Direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;\n    DMA_InitStruct.PeriphOrM2MSrcAddress = (uint32_t)(&amp;(USART3-&gt;RDR));\n    DMA_InitStruct.MemoryOrM2MDstAddress = (uint32_t)(rx_usart_val);\n    DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;\n    DMA_InitStruct.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\n    DMA_InitStruct.PeriphOrM2MSrcIncMode = LL_DMA_PERIPH_NOINCREMENT;\n    DMA_InitStruct.MemoryOrM2MDstIncMode = LL_DMA_MEMORY_INCREMENT;\n    DMA_InitStruct.PeriphRequest = LL_DMAMUX_REQ_USART3_RX;\n    DMA_InitStruct.NbData = dma_buffer_size;\n\n    IRQ_DIRECT_CONNECT(17, 0, _dma_callback_rx, IRQ_ZERO_LATENCY);\n    irq_enable(17);\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_RX); // Disabling channel for initial set-up\n\n     /* initialize DMA */\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_RX, dma_buffer_size); // DMA data size\n    LL_DMA_SetChannelPriorityLevel(DMA_USART, LL_DMA_CHANNEL_RX, LL_DMA_PRIORITY_VERYHIGH); // DMA channel priority\n    LL_DMA_Init(DMA_USART, LL_DMA_CHANNEL_RX, &amp;DMA_InitStruct);\n\n    /* Clearing flag */\n    LL_DMA_ClearFlag_TC7(DMA_USART);\n    LL_DMA_ClearFlag_HT7(DMA_USART);\n\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_RX); // Enabling channel\n\n    LL_DMA_EnableIT_TC(DMA_USART, LL_DMA_CHANNEL_RX); // Enable transfert complete interruption\n\n    LL_DMA_DisableIT_HT(DMA_USART, LL_DMA_CHANNEL_RX); // Disable half-transfert interruption\n}\n\n\nvoid serial_tx_on()\n{\n    LL_DMA_ClearFlag_TC6(DMA_USART); // Making sure the flag is cleared before transmission\n\n    LL_DMA_DisableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // disable channel to reload TX buffer\n\n    /* reloading TX buffer */\n    LL_DMA_SetMemoryAddress(DMA_USART, LL_DMA_CHANNEL_TX, (uint32_t)(tx_usart_val));\n    LL_DMA_SetDataLength(DMA_USART, LL_DMA_CHANNEL_TX, dma_buffer_size);\n\n    LL_DMA_EnableChannel(DMA_USART, LL_DMA_CHANNEL_TX); // re-enable the channel\n}\n\nvoid serial_stop()\n{\n    LL_USART_Disable(USART3);\n}\n\nvoid serial_start()\n{\n    LL_USART_Enable(USART3);\n}\n</code></pre>"},{"location":"powerAPI/Rs485_8h/","title":"File Rs485.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dma_callbackRXfunc_t enum usart_oversampling_t"},{"location":"powerAPI/Rs485_8h/#public-functions","title":"Public Functions","text":"Type Name void dma_channel_init_rx () initialize dma 1 channel 7 for receiving data in circular mode void dma_channel_init_tx () initialize dma 1 channel 6 for sending data via USART3. void init_DEmode (void) initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. void init_usrBaudrate (uint32_t usr_baud) initialize baudrate with user choice. void init_usrBuffer (uint8_t * tx_buffer, uint8_t * rx_buffer) initialize user transmission and reception buffer void init_usrDataSize (uint16_t size) initialize DMA data size to send and receive void init_usrFunc (dma_callbackRXfunc_t fnc_callback) initialize user function called every RX callback void oversamp_set (usart_oversampling_t oversampling) set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. void serial_init (void) initialize USART3 void serial_start () enable usart void serial_stop () disable usart void serial_tx_on () reload dma buffer TX"},{"location":"powerAPI/Rs485_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485_8h/#typedef-dma_callbackrxfunc_t","title":"typedef dma_callbackRXfunc_t","text":"<pre><code>typedef void(* dma_callbackRXfunc_t) ();\n</code></pre>"},{"location":"powerAPI/Rs485_8h/#enum-usart_oversampling_t","title":"enum usart_oversampling_t","text":"<pre><code>enum usart_oversampling_t {\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n};\n</code></pre>"},{"location":"powerAPI/Rs485_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_rx","title":"function dma_channel_init_rx","text":"<p>initialize dma 1 channel 7 for receiving data in circular mode <pre><code>void dma_channel_init_rx () \n</code></pre></p> <p>DMA channel RX initialization, this channel is set on circular mode. </p>"},{"location":"powerAPI/Rs485_8h/#function-dma_channel_init_tx","title":"function dma_channel_init_tx","text":"<p>initialize dma 1 channel 6 for sending data via USART3. <pre><code>void dma_channel_init_tx () \n</code></pre></p> <p>This is the TX dma channel initialization. The channel is not enabled here to avoid sending data unexpectedly, this channel is enabled only with serial_tx_on when data must be sent. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_demode","title":"function init_DEmode","text":"<p>initialize Driver Enable mode for RS485 hardware flowcontrol. pin B14 is set to level high when data is transmitted. <pre><code>void init_DEmode (\n    void\n) \n</code></pre></p> <p>Initialize driver enable mode for RS485 flowcontrol. See RM0440 37.5.20 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbaudrate","title":"function init_usrBaudrate","text":"<p>initialize baudrate with user choice. <pre><code>void init_usrBaudrate (\n    uint32_t usr_baud\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>usr_baud</code> baud in bits per second </li> </ul> <p>Note:</p> <p>baudrate is initialized by default to 10Mbps if this function is not used</p> <p>Initialize baudrate by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrbuffer","title":"function init_usrBuffer","text":"<p>initialize user transmission and reception buffer <pre><code>void init_usrBuffer (\n    uint8_t * tx_buffer,\n    uint8_t * rx_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tx_buffer</code> transmission buffer </li> <li><code>rx_buffer</code> reception buffer</li> </ul> <p>Initialize RX and TX buffer by user </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrdatasize","title":"function init_usrDataSize","text":"<p>initialize DMA data size to send and receive <pre><code>void init_usrDataSize (\n    uint16_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> size of the data in byte (max 65535)</li> </ul> <p>Set the size of data we send ie. the number of bytes. eg. : size = 5 means that we send 5 byte (40 bits) of data to USART 3. </p>"},{"location":"powerAPI/Rs485_8h/#function-init_usrfunc","title":"function init_usrFunc","text":"<p>initialize user function called every RX callback <pre><code>void init_usrFunc (\n    dma_callbackRXfunc_t fnc_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fnc_callback</code> void function with no parameters, use NULL if there is no function to call</li> </ul> <p>Initialize usr function to use in the RX callback </p>"},{"location":"powerAPI/Rs485_8h/#function-oversamp_set","title":"function oversamp_set","text":"<p>set oversampling which is by default oversampling_16. With oversampling_8 we increase speed by 2 but decrease USART sampling by half making it more sensitive to noise. <pre><code>void oversamp_set (\n    usart_oversampling_t oversampling\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>oversampling</code> choice of oversampling </li> <li>OVER8 oversampling_8 </li> <li>OVER16 oversampling_16</li> </ul> <p>Set the oversampling. See RM0440 37.5.7 for more details. </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_init","title":"function serial_init","text":"<p>initialize USART3 <pre><code>void serial_init (\n    void\n) \n</code></pre></p> <p>This function initialise USART3 peripheral </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_start","title":"function serial_start","text":"<p>enable usart <pre><code>void serial_start () \n</code></pre></p> <p>to start or restart communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_stop","title":"function serial_stop","text":"<p>disable usart <pre><code>void serial_stop () \n</code></pre></p> <p>to stop communication </p>"},{"location":"powerAPI/Rs485_8h/#function-serial_tx_on","title":"function serial_tx_on","text":"<p>reload dma buffer TX <pre><code>void serial_tx_on () \n</code></pre></p> <p>Note:</p> <p>after reloading the buffer, usart will start sending datas</p> <p>Reload DMA TX buffer. This functions enable TX channel to start sending the datas </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485.h</code></p>"},{"location":"powerAPI/Rs485_8h_source/","title":"File Rs485.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef RS485_H_\n#define RS485_H_\n\n#include &lt;zephyr/kernel.h&gt;\n\n#include &lt;stm32_ll_usart.h&gt;\n\ntypedef void (*dma_callbackRXfunc_t)();\n\ntypedef enum{\n    OVER8 = LL_USART_OVERSAMPLING_8,\n    OVER16 = LL_USART_OVERSAMPLING_16\n}usart_oversampling_t;\n\nvoid init_usrBuffer(uint8_t* tx_buffer, uint8_t* rx_buffer);\n\nvoid init_usrFunc(dma_callbackRXfunc_t fnc_callback);\n\nvoid init_usrBaudrate(uint32_t usr_baud);\n\nvoid init_usrDataSize(uint16_t size);\n\nvoid serial_init(void);\n\nvoid init_DEmode(void);\n\nvoid oversamp_set(usart_oversampling_t oversampling);\n\nvoid dma_channel_init_tx();\n\nvoid dma_channel_init_rx();\n\nvoid serial_tx_on();\n\nvoid serial_stop();\n\nvoid serial_start();\n\n#endif // RS485_H_\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8cpp/","title":"File Rs485Communication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.cpp</code></p>"},{"location":"powerAPI/Rs485Communication_8cpp_source/","title":"File Rs485Communication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"Rs485.h\"\n#include \"Rs485Communication.h\"\n\nvoid Rs485Communication::configure(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(), rs485_speed_t data_speed)\n{\n    init_usrBuffer(transmission_bufer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n\n    switch(data_speed)\n    {\n        case SPEED_2M:\n            init_usrBaudrate(2656250);\n            break;\n        case SPEED_5M:\n            init_usrBaudrate(5312500);\n            break;\n        case SPEED_10M:\n            init_usrBaudrate(10625000);\n            break;\n        default:\n            init_usrBaudrate(10625000);\n            break;\n    }\n    init_usrBaudrate(10625000);\n\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n\n    if(data_speed == SPEED_20M) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::configureCustom(uint8_t* transmission_bufer, uint8_t* reception_buffer, uint16_t data_size, void (*user_function)(void), uint32_t baudrate, bool oversampling_8)\n{\n    init_usrBuffer(transmission_bufer, reception_buffer);\n    init_usrFunc(user_function);\n    init_usrDataSize(data_size);\n    init_usrBaudrate(baudrate);\n    dma_channel_init_tx();\n    dma_channel_init_rx();\n    serial_init();\n    init_DEmode();\n    if(oversampling_8 == true) oversamp_set(OVER8);\n    else oversamp_set(OVER16);\n}\n\nvoid Rs485Communication::startTransmission()\n{\n    serial_tx_on();\n}\n\nvoid Rs485Communication::turnOnCommunication()\n{\n    serial_start();\n}\n\nvoid Rs485Communication::turnOffCommunication()\n{\n    serial_stop();\n}\n</code></pre>"},{"location":"powerAPI/Rs485Communication_8h/","title":"File Rs485Communication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/Rs485Communication_8h/#classes","title":"Classes","text":"Type Name class Rs485Communication"},{"location":"powerAPI/Rs485Communication_8h/#public-types","title":"Public Types","text":"Type Name enum rs485_speed_t"},{"location":"powerAPI/Rs485Communication_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/Rs485Communication_8h/#enum-rs485_speed_t","title":"enum rs485_speed_t","text":"<pre><code>enum rs485_speed_t {\n    SPEED_2M,\n    SPEED_5M,\n    SPEED_10M,\n    SPEED_20M\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/Rs485Communication.h</code></p>"},{"location":"powerAPI/Rs485Communication_8h_source/","title":"File Rs485Communication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; Rs485Communication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef RS485COMMUNICATION_H_\n#define RS485COMMUNICATION_H_\n\n#include &lt;stdint.h&gt;\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485\n\ntypedef enum {\n    SPEED_2M,  // 2Mbits/s speed communication\n    SPEED_5M,  // 5Mbits/s speed communication\n    SPEED_10M, // 10Mbits/s speed communication\n    SPEED_20M, // 20Mbits/s speed communication\n}rs485_speed_t;\n\n// Static class definition\n\nclass Rs485Communication\n{\n    public :\n        void configure(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(), \n                            rs485_speed_t data_speed = SPEED_10M);\n\n        void configureCustom(uint8_t *transmission_bufer, uint8_t *reception_buffer, uint16_t data_size, void (*user_function)(void), uint32_t baudrate, bool oversampling_8);\n\n        void startTransmission();\n\n        void turnOnCommunication();\n\n        void turnOffCommunication();\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_RS485\n\n#endif // RS485COMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8cpp/","title":"File SyncCommunication.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.cpp</code></p>"},{"location":"powerAPI/SyncCommunication_8cpp_source/","title":"File SyncCommunication.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// LL driver\n#include \"stm32_ll_hrtim.h\"\n#include \"stm32_ll_gpio.h\"\n#include \"stm32g4xx_ll_bus.h\"\n\n// Header\n#include \"SyncCommunication.h\"\n\nvoid SyncCommunication::initMaster()\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_A);\n\n    // SYNCOUT[1:0] and SYNCSRC[1:0] bitfield configuration in HRTIM_MCR\n    LL_HRTIM_ConfigSyncOut(HRTIM1, LL_HRTIM_SYNCOUT_POSITIVE_PULSE, LL_HRTIM_SYNCOUT_SRC_TIMA_START);\n\n    // HRTIM_SCOUT pin configuration\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n    // the SyncIN pin is disabled here, it will be enabled in the ctrl task to ensure synchronization between master and slave.\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_1, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_1, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_1, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_1, LL_GPIO_AF_13);\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_A);\n}\n\nvoid SyncCommunication::initSlave(board_version_t board_version)\n{\n    LL_HRTIM_TIM_CounterDisable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    //  HRTIM synchronization input source\n    LL_HRTIM_SetSyncInSrc(HRTIM1, LL_HRTIM_SYNCIN_SRC_EXTERNAL_EVENT);\n\n    // Enable the master timer reset when receiving a synchronization input event\n    LL_HRTIM_TIM_EnableResetOnSync(HRTIM1, LL_HRTIM_TIMER_MASTER);\n\n    // HRTIM_SCIN pin configuration\n    LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);\n\n    if(board_version != TWIST_v_1_1_4)\n    {\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_6, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_6, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_6, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_6, LL_GPIO_AF_12);\n    }\n    else\n    {\n    LL_GPIO_SetPinMode      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_MODE_ALTERNATE);\n    LL_GPIO_SetPinSpeed     (GPIOB, LL_GPIO_PIN_2, LL_GPIO_SPEED_FREQ_VERY_HIGH);\n    LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_2, LL_GPIO_OUTPUT_PUSHPULL);\n    LL_GPIO_SetPinPull      (GPIOB, LL_GPIO_PIN_2, LL_GPIO_PULL_NO);\n    LL_GPIO_SetAFPin_0_7    (GPIOB, LL_GPIO_PIN_2, LL_GPIO_AF_13);\n\n    }\n\n    LL_HRTIM_TIM_CounterEnable(HRTIM1, LL_HRTIM_TIMER_MASTER);\n}\n</code></pre>"},{"location":"powerAPI/SyncCommunication_8h/","title":"File SyncCommunication.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SyncCommunication_8h/#classes","title":"Classes","text":"Type Name class SyncCommunication <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/SyncCommunication.h</code></p>"},{"location":"powerAPI/SyncCommunication_8h_source/","title":"File SyncCommunication.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; SyncCommunication.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SYNCCOMMUNICATION_H_\n#define SYNCCOMMUNICATION_H_\n\n#ifdef CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC\n\n#include &lt;stdint.h&gt;\n\n// OWNTECH API\n#include \"SpinAPI.h\"\n\n\n// Static class definition\n\nclass SyncCommunication\n{\n\npublic:\n\n    static void initMaster();\n\n    static void initSlave(board_version_t board_version);\n};\n\n#endif // CONFIG_OWNTECH_COMMUNICATION_ENABLE_SYNC\n\n#endif // SYNCCOMMUNICATION_H_\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/","title":"File data_objects.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__objects_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr   = = 0x60 bool ctrl_enable   = = false char device_id   = =\"Twist\" const char device_type   = = \"Synchronous Buck\" const char firmware_version   = = \"0.0.1\" const char hardware_version   = = \"0.9\" float32_t i1_low_value   = = 0 float32_t i2_low_value   = = 0 float32_t i_high_value   = = 0 const char manufacturer   = = \"OwnTech\" float32_t reference_value   = = 0 float32_t temp_value   = = 0 float32_t v1_low_value   = = 0 float32_t v2_low_value   = = 0 float32_t v_high_value   = = 0"},{"location":"powerAPI/data__objects_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name ThingSetDataObject data_objects"},{"location":"powerAPI/data__objects_8cpp/#public-functions","title":"Public Functions","text":"Type Name void dataObjectsUpdateMeasures ()  ThingSet ts (data_objects, sizeof(data_objects)/sizeof(ThingSetDataObject))"},{"location":"powerAPI/data__objects_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-ctrl_enable","title":"variable ctrl_enable","text":"<pre><code>bool ctrl_enable;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-device_id","title":"variable device_id","text":"<pre><code>char device_id[9];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-device_type","title":"variable device_type","text":"<pre><code>const char device_type[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-firmware_version","title":"variable firmware_version","text":"<pre><code>const char firmware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-hardware_version","title":"variable hardware_version","text":"<pre><code>const char hardware_version[];\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i1_low_value","title":"variable i1_low_value","text":"<pre><code>float32_t i1_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i2_low_value","title":"variable i2_low_value","text":"<pre><code>float32_t i2_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-i_high_value","title":"variable i_high_value","text":"<pre><code>float32_t i_high_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-manufacturer","title":"variable manufacturer","text":"<pre><code>const char manufacturer[];\n</code></pre> <p>Author:</p> <p>Martin J\u00e4ger martin@libre.solar </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p>"},{"location":"powerAPI/data__objects_8cpp/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-temp_value","title":"variable temp_value","text":"<pre><code>float32_t temp_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v1_low_value","title":"variable v1_low_value","text":"<pre><code>float32_t v1_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v2_low_value","title":"variable v2_low_value","text":"<pre><code>float32_t v2_low_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#variable-v_high_value","title":"variable v_high_value","text":"<pre><code>float32_t v_high_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#variable-data_objects","title":"variable data_objects","text":"<pre><code>ThingSetDataObject data_objects[];\n</code></pre> <p>Thing Set Data Objects (see thingset.io for specification) </p>"},{"location":"powerAPI/data__objects_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__objects_8cpp/#function-dataobjectsupdatemeasures","title":"function dataObjectsUpdateMeasures","text":"<pre><code>void dataObjectsUpdateMeasures () \n</code></pre>"},{"location":"powerAPI/data__objects_8cpp/#function-ts","title":"function ts","text":"<pre><code>ThingSet ts (\n    data_objects,\n    sizeof(data_objects)/sizeof(ThingSetDataObject)\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/data_objects.cpp</code></p>"},{"location":"powerAPI/data__objects_8cpp_source/","title":"File data_objects.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include \"data_objects.h\"\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;soc.h&gt;\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#include \"thingset.h\"\n#include \"DataAcquisition.h\"\n\n\n// can be used to configure custom data objects in separate file instead\n// (e.g. data_nodes_custom.cpp)\n\nconst char manufacturer[] = \"OwnTech\";\nconst char device_type[] = \"Synchronous Buck\";\nconst char hardware_version[] = \"0.9\";\nconst char firmware_version[] = \"0.0.1\";\nchar device_id[9]=\"Twist\";\n\nfloat32_t v1_low_value = 0; //store value of V1_low (app task)\nfloat32_t v2_low_value = 0; //store value of V2_low (app task)\nfloat32_t v_high_value = 0; //store value of Vhigh (app task)\n\nfloat32_t i1_low_value = 0; //store value of i1_low (app task)\nfloat32_t i2_low_value = 0; //store value of i2_low (app task)\nfloat32_t i_high_value = 0; //store value of ihigh (app task)\n\nfloat32_t temp_value = 0; //store value of temperature (app task)\n\nfloat32_t reference_value = 0; //store value of reference (master-slave mode)\n\nbool ctrl_enable = false; //store value of the enable (master-slave mode)\n\nuint16_t can_node_addr = 0x60;\n\n\n\nvoid dataObjectsUpdateMeasures()\n{\n    if (dataAcquisition.started() == true)\n    {\n        v1_low_value = dataAcquisition.peek(V1_LOW);\n        v2_low_value = dataAcquisition.peek(V2_LOW);\n        v_high_value = dataAcquisition.peek(V_HIGH);\n        i1_low_value = dataAcquisition.peek(I1_LOW);\n        i2_low_value = dataAcquisition.peek(I2_LOW);\n        i_high_value = dataAcquisition.peek(I_HIGH);\n        // Do not update this value for now, as the measure is not enabled\n        //temp_value = peekTemperature();\n    }\n}\n\n/* clang-format off */\nstatic ThingSetDataObject data_objects[] = {\n\n    TS_GROUP(ID_DEVICE, \"Device\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Manufacturer\"\n            }\n        }*/\n        TS_ITEM_STRING(0x20, \"cManufacturer\", manufacturer, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Device Type\"\n            }\n        }*/\n        TS_ITEM_STRING(0x21, \"cType\", device_type, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Hardware Version\"\n            }\n        }*/\n        TS_ITEM_STRING(0x22, \"cHardwareVersion\", hardware_version, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        /*{\n            \"title\": {\n                \"en\": \"Firmware Version\"\n            }\n        }*/\n        TS_ITEM_STRING(0x23, \"cFirmwareVersion\", firmware_version, 0,\n            ID_DEVICE, TS_ANY_R, 0),\n\n        TS_SUBSET(0x0B, \"mCAN\", SUBSET_CAN, ID_ROOT, TS_ANY_RW),\n\n\n    TS_GROUP(ID_MEASUREMENTS, \"Measurements\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 1 Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x31, \"rMeas_V1_low_V\", &amp;v1_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 2 Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x32, \"rMeas_V2_low_V\", &amp;v2_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"High Side Voltage Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x33, \"rMeas_V_high_V\", &amp;v_high_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 1 Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x34, \"rMeas_I1_low_A\", &amp;i1_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Low Side 2 Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x35, \"rMeas_I2_low_A\", &amp;i2_low_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"High Side Current Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x36, \"rMeas_I_high_A\", &amp;i_high_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n        /*{\n            \"title\": {\n                \"en\": \"Temperature Measurement\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x37, \"rMeas_temp_degC\", &amp;temp_value, 2,\n            ID_MEASUREMENTS, TS_ANY_R, SUBSET_CAN),\n\n\n\n\n    /*\n     * Control parameters (IDs &gt;= 0x8000)\n     *\n     */\n    TS_GROUP(ID_CTRL, \"Control\", TS_NO_CALLBACK, ID_ROOT),\n\n        /*{\n            \"title\": {\n                \"en\": \"Current control target\"\n            }\n        }*/\n        TS_ITEM_FLOAT(0x8001, \"zCtrl_Reference\", &amp;reference_value, 1,\n            ID_CTRL, TS_ANY_RW, SUBSET_CTRL),\n\n        /*{\n            \"title\": {\n                \"en\": \"Enable/Disable signal\"\n            }\n        }*/\n        TS_ITEM_BOOL(0x8002, \"zCtrl_Enable\", &amp;ctrl_enable,\n            ID_CTRL, TS_ANY_RW, SUBSET_CTRL),\n};\n/* clang-format on */\n\nThingSet ts(data_objects, sizeof(data_objects) / sizeof(ThingSetDataObject));\n</code></pre>"},{"location":"powerAPI/data__objects_8h/","title":"File data_objects.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the source code of this file</p> <p>Handling of ThingSet data objects. </p>"},{"location":"powerAPI/data__objects_8h/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr bool ctrl_enable float32_t reference_value"},{"location":"powerAPI/data__objects_8h/#public-functions","title":"Public Functions","text":"Type Name void dataObjectsUpdateMeasures ()"},{"location":"powerAPI/data__objects_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/data__objects_8h/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-ctrl_enable","title":"variable ctrl_enable","text":"<pre><code>bool ctrl_enable;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#variable-reference_value","title":"variable reference_value","text":"<pre><code>float32_t reference_value;\n</code></pre>"},{"location":"powerAPI/data__objects_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__objects_8h/#function-dataobjectsupdatemeasures","title":"function dataObjectsUpdateMeasures","text":"<pre><code>void dataObjectsUpdateMeasures () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/data_objects.h</code></p>"},{"location":"powerAPI/data__objects_8h_source/","title":"File data_objects.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; data_objects.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef DATA_OBJECTS_H_\n#define DATA_OBJECTS_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;arm_math.h&gt;\n\n/*\n * Groups / first layer data object IDs\n */\n\n#define ID_ROOT         0x00\n#define ID_DEVICE       0x01\n#define ID_MEASUREMENTS 0x08\n#define ID_PUB          0x100\n#define ID_CTRL         0x8000\n\n/*\n * Subset definitions for statements and publish/subscribe\n */\n#define SUBSET_SER  (1U &lt;&lt; 0)   // UART serial\n#define SUBSET_CAN  (1U &lt;&lt; 1)   // CAN bus\n#define SUBSET_CTRL (1U &lt;&lt; 3)   // control data sent and received via CAN\n\n/*\n * Exposed variables\n */\n\nextern bool      ctrl_enable;\nextern uint16_t  can_node_addr;\nextern float32_t reference_value;\n\n/*\n * Modifiers\n */\n\nvoid dataObjectsUpdateMeasures();\n\n\n#endif // DATA_OBJECTS_H_\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/","title":"File thingset_isotp.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_isotp.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t can_node_addr const struct isotp_fc_opts fc_opts   = = { .bs = 8, .stmin = 1 } struct isotp_msg_id rx_addr   = = { .id_type = CAN_EXTENDED_IDENTIFIER, .use_ext_addr = 0, .use_fixed_addr = 1, } ThingSet ts struct isotp_msg_id tx_addr   = = { .id_type = CAN_EXTENDED_IDENTIFIER, .use_ext_addr = 0, .use_fixed_addr = 1, }"},{"location":"powerAPI/thingset__isotp_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * can_dev   = = DEVICE_DT_GET(DT_NODELABEL(can1)) struct isotp_recv_ctx recv_ctx struct isotp_send_ctx send_ctx"},{"location":"powerAPI/thingset__isotp_8cpp/#public-functions","title":"Public Functions","text":"Type Name K_THREAD_DEFINE (can_isotp, RX_THREAD_STACK_SIZE, can_isotp_thread, NULL, NULL, NULL, RX_THREAD_PRIORITY, 0, 1500)  void can_isotp_thread ()  void send_complete_cb (int error_nr, void * arg)"},{"location":"powerAPI/thingset__isotp_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-fc_opts","title":"variable fc_opts","text":"<pre><code>const struct isotp_fc_opts fc_opts;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-rx_addr","title":"variable rx_addr","text":"<pre><code>struct isotp_msg_id rx_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-ts","title":"variable ts","text":"<pre><code>ThingSet ts;\n</code></pre> <p>Date:</p> <p>2024 </p> <p>Author:</p> <p>Martin J\u00e4ger martin@libre.solar </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-tx_addr","title":"variable tx_addr","text":"<pre><code>struct isotp_msg_id tx_addr;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#variable-can_dev","title":"variable can_dev","text":"<pre><code>const struct device* can_dev;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-recv_ctx","title":"variable recv_ctx","text":"<pre><code>struct isotp_recv_ctx recv_ctx;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#variable-send_ctx","title":"variable send_ctx","text":"<pre><code>struct isotp_send_ctx send_ctx;\n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/thingset__isotp_8cpp/#function-k_thread_define","title":"function K_THREAD_DEFINE","text":"<pre><code>K_THREAD_DEFINE (\n    can_isotp,\n    RX_THREAD_STACK_SIZE,\n    can_isotp_thread,\n    NULL,\n    NULL,\n    NULL,\n    RX_THREAD_PRIORITY,\n    0,\n    1500\n) \n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#function-can_isotp_thread","title":"function can_isotp_thread","text":"<pre><code>void can_isotp_thread () \n</code></pre>"},{"location":"powerAPI/thingset__isotp_8cpp/#function-send_complete_cb","title":"function send_complete_cb","text":"<pre><code>void send_complete_cb (\n    int error_nr,\n    void * arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_isotp.cpp</code></p>"},{"location":"powerAPI/thingset__isotp_8cpp_source/","title":"File thingset_isotp.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_isotp.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include &lt;zephyr/canbus/isotp.h&gt;\n#include \"thingset.h\"\n#include \"CommunicationAPI.h\"\n\nextern ThingSet ts;\nextern uint16_t can_node_addr;\nstatic const struct device* can_dev = DEVICE_DT_GET(DT_NODELABEL(can1));\n\n#define RX_THREAD_STACK_SIZE 1024\n#define RX_THREAD_PRIORITY 2\n\nconst struct isotp_fc_opts fc_opts = {\n    .bs = 8,                // block size\n    .stmin = 1              // minimum separation time = 100 ms\n};\n\nstruct isotp_msg_id rx_addr = {\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .use_ext_addr = 0,      // Normal ISO-TP addressing (using only CAN ID)\n    .use_fixed_addr = 1,    // enable SAE J1939 compatible addressing\n};\n\nstruct isotp_msg_id tx_addr = {\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .use_ext_addr = 0,      // Normal ISO-TP addressing (using only CAN ID)\n    .use_fixed_addr = 1,    // enable SAE J1939 compatible addressing\n};\n\nstatic struct isotp_recv_ctx recv_ctx;\nstatic struct isotp_send_ctx send_ctx;\n\nvoid send_complete_cb(int error_nr, void *arg)\n{\n    ARG_UNUSED(arg);\n}\n\nvoid can_isotp_thread()\n{\n    int ret, rem_len, resp_len;\n    unsigned int req_len;\n    struct net_buf *buf;\n    static uint8_t rx_buffer[600];      // large enough to receive a 512k flash page for DFU\n    static uint8_t tx_buffer[1000];\n\n    communication.can.enableCan();\n\n    if (!device_is_ready(can_dev)) {\n        return;\n    }\n\n    while (1) {\n        /* re-assign address in every loop as it may have been changed via ThingSet */\n        rx_addr.ext_id = TS_CAN_BASE_REQRESP | TS_CAN_PRIO_REQRESP | TS_CAN_TARGET_SET(can_node_addr);\n        tx_addr.ext_id = TS_CAN_BASE_REQRESP | TS_CAN_PRIO_REQRESP | TS_CAN_SOURCE_SET(can_node_addr);\n\n        ret = isotp_bind(&amp;recv_ctx, can_dev, &amp;rx_addr, &amp;tx_addr, &amp;fc_opts, K_FOREVER);\n        if (ret != ISOTP_N_OK) {\n            return;\n        }\n\n        req_len = 0;\n        do {\n            rem_len = isotp_recv_net(&amp;recv_ctx, &amp;buf, K_FOREVER);\n            if (rem_len &lt; 0) {\n                break;\n            }\n            if (req_len + buf-&gt;len &lt;= sizeof(rx_buffer)) {\n                memcpy(&amp;rx_buffer[req_len], buf-&gt;data, buf-&gt;len);\n            }\n            req_len += buf-&gt;len;\n            net_buf_unref(buf);\n        } while (rem_len);\n\n        // we need to unbind the receive ctx so that control frames are received in the send ctx\n        isotp_unbind(&amp;recv_ctx);\n\n        if (req_len &gt; sizeof(rx_buffer)) {\n            tx_buffer[0] = TS_STATUS_REQUEST_TOO_LARGE;\n            resp_len = 1;\n        }\n        else if (req_len &gt; 0 &amp;&amp; rem_len == 0) {\n            resp_len = ts.process(rx_buffer, req_len, tx_buffer, sizeof(tx_buffer));\n        }\n        else {\n            tx_buffer[0] = TS_STATUS_INTERNAL_SERVER_ERR;\n            resp_len = 1;\n        }\n\n        if (resp_len &gt; 0) {\n            ret = isotp_send(&amp;send_ctx, can_dev, tx_buffer, resp_len,\n                        &amp;recv_ctx.tx_addr, &amp;recv_ctx.rx_addr, send_complete_cb, NULL);\n        }\n    }\n}\n\nK_THREAD_DEFINE(can_isotp, RX_THREAD_STACK_SIZE, can_isotp_thread, NULL, NULL, NULL,\n    RX_THREAD_PRIORITY, 0, 1500);\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/","title":"File thingset_pub_sub.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_pub_sub.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t broadcast_time   = = 10 uint16_t can_node_addr uint16_t control_time   = = 10 const struct can_filter ctrl_filter   = = { .id = TS_CAN_BASE_CONTROL, .rtr = CAN_DATAFRAME, .id_type = CAN_EXTENDED_IDENTIFIER, .id_mask = TS_CAN_TYPE_MASK, .rtr_mask = 1 } ThingSet ts"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * can_dev   = = DEVICE_DT_GET(DT_NODELABEL(can1))"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-functions","title":"Public Functions","text":"Type Name CAN_MSGQ_DEFINE (sub_msgq, 10)  K_THREAD_DEFINE (can_pubsub, 1024, can_pubsub_thread, NULL, NULL, NULL, 6, 0, 1000)  void can_pub_isr (uint32_t err_flags, void * arg)  void can_pub_send (uint32_t can_id, uint8_t can_data, uint8_t data_len)  void can_pubsub_thread ()  void send_ts_can_pub_message (uint16_t tag)  void update_ts_data_nodes (struct can_frame rx_frame)"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-broadcast_time","title":"variable broadcast_time","text":"<pre><code>uint16_t broadcast_time;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-can_node_addr","title":"variable can_node_addr","text":"<pre><code>uint16_t can_node_addr;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-control_time","title":"variable control_time","text":"<pre><code>uint16_t control_time;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-ctrl_filter","title":"variable ctrl_filter","text":"<pre><code>const struct can_filter ctrl_filter;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-ts","title":"variable ts","text":"<pre><code>ThingSet ts;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#variable-can_dev","title":"variable can_dev","text":"<pre><code>const struct device* can_dev;\n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_msgq_define","title":"function CAN_MSGQ_DEFINE","text":"<pre><code>CAN_MSGQ_DEFINE (\n    sub_msgq,\n    10\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-k_thread_define","title":"function K_THREAD_DEFINE","text":"<pre><code>K_THREAD_DEFINE (\n    can_pubsub,\n    1024,\n    can_pubsub_thread,\n    NULL,\n    NULL,\n    NULL,\n    6,\n    0,\n    1000\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pub_isr","title":"function can_pub_isr","text":"<pre><code>void can_pub_isr (\n    uint32_t err_flags,\n    void * arg\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pub_send","title":"function can_pub_send","text":"<pre><code>void can_pub_send (\n    uint32_t can_id,\n    uint8_t can_data,\n    uint8_t data_len\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-can_pubsub_thread","title":"function can_pubsub_thread","text":"<pre><code>void can_pubsub_thread () \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-send_ts_can_pub_message","title":"function send_ts_can_pub_message","text":"<pre><code>void send_ts_can_pub_message (\n    uint16_t tag\n) \n</code></pre>"},{"location":"powerAPI/thingset__pub__sub_8cpp/#function-update_ts_data_nodes","title":"function update_ts_data_nodes","text":"<pre><code>void update_ts_data_nodes (\n    struct can_frame rx_frame\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_communication/zephyr/src/thingset_pub_sub.cpp</code></p>"},{"location":"powerAPI/thingset__pub__sub_8cpp_source/","title":"File thingset_pub_sub.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_communication &gt; zephyr &gt; src &gt; thingset_pub_sub.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) The Libre Solar Project Contributors\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#define CONFIG_THINGSET_CAN 1\n\n#if CONFIG_THINGSET_CAN\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/drivers/can.h&gt;\n\n#include \"data_objects.h\"\n#include \"thingset.h\"\n#include \"CommunicationAPI.h\"\n\n\nextern ThingSet ts;\nextern uint16_t can_node_addr;\nuint16_t broadcast_time = 10; //the time of the measurement variables broadcast (multiples of 100ms)\nuint16_t control_time = 10;  //the time of the control variables broadcast/receive (multiples of 100ms)\nstatic const struct device* can_dev = DEVICE_DT_GET(DT_NODELABEL(can1));\n\n// below defines should go into the ThingSet library\n#define TS_CAN_SOURCE_GET(id)           (((uint32_t)id &amp; TS_CAN_SOURCE_MASK) &gt;&gt; TS_CAN_SOURCE_POS)\n#define TS_CAN_DATA_ID_GET(id)          (((uint32_t)id &amp; TS_CAN_DATA_ID_MASK) &gt;&gt; TS_CAN_DATA_ID_POS)\n\nCAN_MSGQ_DEFINE(sub_msgq, 10);\n\nconst struct can_filter ctrl_filter = {\n    .id = TS_CAN_BASE_CONTROL,\n    .rtr = CAN_DATAFRAME,\n    .id_type = CAN_EXTENDED_IDENTIFIER,\n    .id_mask = TS_CAN_TYPE_MASK,\n    .rtr_mask = 1\n};\n\nvoid can_pub_isr(uint32_t err_flags, void *arg)\n{\n    // Do nothing. Publication messages are fire and forget.\n}\n\nvoid can_pub_send(uint32_t can_id, uint8_t can_data[8], uint8_t data_len)\n{\n    if (!device_is_ready(can_dev))\n    {\n        return;\n    }\n\n    struct can_frame frame = {0};\n    frame.id_type = CAN_EXTENDED_IDENTIFIER;\n    frame.rtr     = CAN_DATAFRAME;\n    frame.id      = can_id;\n    memcpy(frame.data, can_data, 8);\n\n\n    if (data_len &gt;= 0)\n    {\n        frame.dlc = data_len;\n\n        can_send(can_dev, &amp;frame, K_MSEC(10), can_pub_isr, NULL);\n    }\n}\n\nvoid send_ts_can_pub_message(uint16_t tag)\n{\n    int data_len = 0;\n    int start_pos = 0;\n    uint32_t can_id;\n    uint8_t can_data[8];\n\n    do\n    {\n        data_len = ts.bin_pub_can(start_pos, tag, can_node_addr, can_id, can_data);\n        if (data_len &gt;= 0)\n        {\n            can_pub_send(can_id, can_data, data_len);\n        }\n    } while (data_len &gt;= 0);\n}\n\nvoid update_ts_data_nodes(struct can_frame rx_frame)\n{\n    // process message\n    uint16_t data_id = TS_CAN_DATA_ID_GET(rx_frame.id);\n    uint8_t sender_addr = TS_CAN_SOURCE_GET(rx_frame.id);\n\n    // control message received?\n    if (data_id &gt; 0x8000 &amp;&amp; sender_addr &lt; can_node_addr) {\n        uint8_t buf[5 + 8];     // ThingSet bin headers + CAN frame payload\n        buf[0] = 0x1F;          // ThingSet pub message\n        buf[1] = 0xA1;          // CBOR: map with 1 element\n        buf[2] = 0x19;          // CBOR: uint16 follows\n        buf[3] = data_id &gt;&gt; 8;\n        buf[4] = data_id;\n        memcpy(&amp;buf[5], rx_frame.data, 8);\n\n        // int status = ts.bin_sub(buf, 5 + rx_frame.dlc, TS_WRITE_MASK, SUBSET_CTRL);\n        int status = ts.bin_import(buf + 1, 4 + rx_frame.dlc, TS_WRITE_MASK, SUBSET_CTRL);\n        if (status == TS_STATUS_CHANGED) {\n\n        }\n    }\n}\n\n\nvoid can_pubsub_thread()\n{\n    communication.can.enableCan();\n\n    if (!device_is_ready(can_dev))\n    {\n        return;\n    }\n\n    int filter_id = can_add_rx_filter_msgq(can_dev, &amp;sub_msgq, &amp;ctrl_filter);\n    if (filter_id &lt; 0) {\n        return;\n    }\n\n    int64_t next_pub = k_uptime_get();\n    uint32_t count = 0;\n\n    while (1) {\n\n        // task_wdt_feed(wdt_channel);\n\n        if (count % broadcast_time == 0) {\n            // normal objects: only every second\n            dataObjectsUpdateMeasures();\n            send_ts_can_pub_message(SUBSET_CAN);\n        }\n\n        if (count % control_time == 0) {\n            // control objects: every 100 ms\n            send_ts_can_pub_message(SUBSET_CTRL);\n        }\n\n        struct can_frame rx_frame;\n\n        // wait for incoming messages until the next pub message has to be sent out\n        while (k_msgq_get(&amp;sub_msgq, &amp;rx_frame, K_TIMEOUT_ABS_MS(next_pub)) != -EAGAIN)\n        {\n            update_ts_data_nodes(rx_frame);\n        }\n\n        next_pub += 100;       // 100 ms period (currently fixed)\n        count++;\n    }\n}\n\nK_THREAD_DEFINE(can_pubsub, 1024, can_pubsub_thread, NULL, NULL, NULL, 6, 0, 1000);\n\n#endif /* CONFIG_THINGSET_CAN */\n</code></pre>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver</p>"},{"location":"powerAPI/dir_5e1fc12cba5504c19e6728f660c9416f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/</code></p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d1334978536d898e33969dcd9ce58335/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/","title":"Dir docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_cd6387a1b9260a1118a1ac8d0c26218a/#files","title":"Files","text":"Type Name file comparator.c file comparator.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/comparator_8c/","title":"File comparator.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8c/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init ()  void comparator3_init ()"},{"location":"powerAPI/comparator_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8c/#function-comparator1_init","title":"function comparator1_init","text":"<pre><code>void comparator1_init () \n</code></pre> <p>Date:</p> <p>2022 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/comparator_8c/#function-comparator3_init","title":"function comparator3_init","text":"<pre><code>void comparator3_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.c</code></p>"},{"location":"powerAPI/comparator_8c_source/","title":"File comparator.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current module private functions\n#include \"../src/comparator_driver.h\"\n\n\nvoid comparator1_init()\n{\n    comparator_comp1_init();\n}\n\nvoid comparator3_init()\n{\n    comparator_comp3_init();\n}\n</code></pre>"},{"location":"powerAPI/comparator_8h/","title":"File comparator.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/comparator_8h/#public-functions","title":"Public Functions","text":"Type Name void comparator1_init ()  void comparator3_init ()"},{"location":"powerAPI/comparator_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/comparator_8h/#function-comparator1_init","title":"function comparator1_init","text":"<pre><code>void comparator1_init () \n</code></pre> <p>Date:</p> <p>2022 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p>"},{"location":"powerAPI/comparator_8h/#function-comparator3_init","title":"function comparator3_init","text":"<pre><code>void comparator3_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_comparator_driver/zephyr/public_api/comparator.h</code></p>"},{"location":"powerAPI/comparator_8h_source/","title":"File comparator.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_comparator_driver &gt; zephyr &gt; public_api &gt; comparator.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMPARATOR_H_\n#define COMPARATOR_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid comparator1_init();\nvoid comparator3_init();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // COMPARATOR_H_\n</code></pre>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver</p>"},{"location":"powerAPI/dir_0abf48445921be3f7255b53ec13b4b20/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/</code></p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_d911d2f35409edfb85ce6db3facf1635/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/","title":"Dir docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_a3b70d2e2f59c7f0c24476313fdba7da/#files","title":"Files","text":"Type Name file dac.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/dac_8h/","title":"File dac.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/dac_8h/#classes","title":"Classes","text":"Type Name struct dac_driver_api struct dac_function_config_t"},{"location":"powerAPI/dac_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* dac_api_fn_upd_reset typedef void(* dac_api_fn_upd_step typedef void(* dac_api_pinconfigure typedef void(* dac_api_setconstvalue typedef void(* dac_api_setfunction typedef void(* dac_api_start typedef void(* dac_api_stop enum dac_function_t enum dac_pin_config_t enum dac_polarity_t enum dac_trigger_t"},{"location":"powerAPI/dac_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void dac_function_update_reset (const struct device * dev, uint8_t channel, uint32_t reset_data)  void dac_function_update_step (const struct device * dev, uint8_t channel, uint32_t step_data)  void dac_pin_configure (const struct device * dev, uint8_t channel, dac_pin_config_t pin_config)  void dac_set_const_value (const struct device * dev, uint8_t channel, uint32_t value)  void dac_set_function (const struct device * dev, uint8_t channel, const dac_function_config_t * function_config)  void dac_start (const struct device * dev, uint8_t channel)  void dac_stop (const struct device * dev, uint8_t channel)"},{"location":"powerAPI/dac_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_reset","title":"typedef dac_api_fn_upd_reset","text":"<pre><code>typedef void(* dac_api_fn_upd_reset) (const struct device *dev, uint8_t channel, uint32_t reset_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_fn_upd_step","title":"typedef dac_api_fn_upd_step","text":"<pre><code>typedef void(* dac_api_fn_upd_step) (const struct device *dev, uint8_t channel, uint32_t step_data);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_pinconfigure","title":"typedef dac_api_pinconfigure","text":"<pre><code>typedef void(* dac_api_pinconfigure) (const struct device *dev, uint8_t channel, dac_pin_config_t config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setconstvalue","title":"typedef dac_api_setconstvalue","text":"<pre><code>typedef void(* dac_api_setconstvalue) (const struct device *dev, uint8_t channel, uint32_t value);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_setfunction","title":"typedef dac_api_setfunction","text":"<pre><code>typedef void(* dac_api_setfunction) (const struct device *dev, uint8_t channel, const dac_function_config_t *config);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_start","title":"typedef dac_api_start","text":"<pre><code>typedef void(* dac_api_start) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#typedef-dac_api_stop","title":"typedef dac_api_stop","text":"<pre><code>typedef void(* dac_api_stop) (const struct device *dev, uint8_t channel);\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_function_t","title":"enum dac_function_t","text":"<pre><code>enum dac_function_t {\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_pin_config_t","title":"enum dac_pin_config_t","text":"<pre><code>enum dac_pin_config_t {\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_polarity_t","title":"enum dac_polarity_t","text":"<pre><code>enum dac_polarity_t {\n    dac_polarity_decrement,\n    dac_polarity_increment\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#enum-dac_trigger_t","title":"enum dac_trigger_t","text":"<pre><code>enum dac_trigger_t {\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n};\n</code></pre>"},{"location":"powerAPI/dac_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/dac_8h/#function-dac_function_update_reset","title":"function dac_function_update_reset","text":"<pre><code>static inline void dac_function_update_reset (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t reset_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_function_update_step","title":"function dac_function_update_step","text":"<pre><code>static inline void dac_function_update_step (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t step_data\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_pin_configure","title":"function dac_pin_configure","text":"<pre><code>static inline void dac_pin_configure (\n    const struct device * dev,\n    uint8_t channel,\n    dac_pin_config_t pin_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_const_value","title":"function dac_set_const_value","text":"<pre><code>static inline void dac_set_const_value (\n    const struct device * dev,\n    uint8_t channel,\n    uint32_t value\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_set_function","title":"function dac_set_function","text":"<pre><code>static inline void dac_set_function (\n    const struct device * dev,\n    uint8_t channel,\n    const dac_function_config_t * function_config\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_start","title":"function dac_start","text":"<pre><code>static inline void dac_start (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre>"},{"location":"powerAPI/dac_8h/#function-dac_stop","title":"function dac_stop","text":"<pre><code>static inline void dac_stop (\n    const struct device * dev,\n    uint8_t channel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_dac_driver/zephyr/public_api/dac.h</code></p>"},{"location":"powerAPI/dac_8h_source/","title":"File dac.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_dac_driver &gt; zephyr &gt; public_api &gt; dac.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DAC_H_\n#define DAC_H_\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public devices names\n\n#define DAC1_DEVICE DT_NODELABEL(dac1)\n#define DAC2_DEVICE DT_NODELABEL(dac2)\n#define DAC3_DEVICE DT_NODELABEL(dac3)\n\n\n// Configuration types\n\ntypedef enum\n{\n    dac_function_noise,\n    dac_function_triangle,\n    dac_function_sawtooth\n} dac_function_t;\n\ntypedef enum\n{\n    dac_polarity_decrement,\n    dac_polarity_increment\n} dac_polarity_t;\n\ntypedef enum\n{\n    hrtim_trig1,\n    hrtim_trig2,\n    hrtim_trig3,\n    hrtim_trig4,\n    hrtim_trig5,\n    hrtim_trig6\n} dac_trigger_t;\n\ntypedef struct\n{\n    dac_function_t dac_function;\n    dac_trigger_t  reset_trigger_source;\n    dac_trigger_t  step_trigger_source;\n    dac_polarity_t polarity;\n    uint32_t       reset_data;\n    uint32_t       step_data;\n} dac_function_config_t;\n\ntypedef enum\n{\n    dac_pin_internal,\n    dac_pin_external,\n    dac_pin_internal_and_external\n} dac_pin_config_t;\n\n// API\n\ntypedef void (*dac_api_setconstvalue) (const struct device* dev, uint8_t channel, uint32_t value);\ntypedef void (*dac_api_setfunction)   (const struct device* dev, uint8_t channel, const dac_function_config_t* config);\ntypedef void (*dac_api_fn_upd_reset)  (const struct device* dev, uint8_t channel, uint32_t reset_data);\ntypedef void (*dac_api_fn_upd_step)   (const struct device* dev, uint8_t channel, uint32_t step_data);\ntypedef void (*dac_api_pinconfigure)  (const struct device* dev, uint8_t channel, dac_pin_config_t config);\ntypedef void (*dac_api_start)         (const struct device* dev, uint8_t channel);\ntypedef void (*dac_api_stop)          (const struct device* dev, uint8_t channel);\n\n__subsystem struct dac_driver_api\n{\n    dac_api_setconstvalue setconstvalue;\n    dac_api_setfunction   setfunction;\n    dac_api_fn_upd_reset  fn_upd_reset;\n    dac_api_fn_upd_step   fn_upd_step;\n    dac_api_pinconfigure  pinconfigure;\n    dac_api_start         start;\n    dac_api_stop          stop;\n};\n\nstatic inline void dac_set_const_value(const struct device* dev, uint8_t channel, uint32_t value)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setconstvalue(dev, channel, value);\n}\n\nstatic inline void dac_set_function(const struct device* dev, uint8_t channel, const dac_function_config_t* function_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;setfunction(dev, channel, function_config);\n}\n\nstatic inline void dac_function_update_reset(const struct device* dev, uint8_t channel, uint32_t reset_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_reset(dev, channel, reset_data);\n}\n\nstatic inline void dac_function_update_step(const struct device* dev, uint8_t channel, uint32_t step_data)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;fn_upd_step(dev, channel, step_data);\n}\n\nstatic inline void dac_pin_configure(const struct device* dev, uint8_t channel, dac_pin_config_t pin_config)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;pinconfigure(dev, channel, pin_config);\n}\n\nstatic inline void dac_start(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev, channel);\n}\n\nstatic inline void dac_stop(const struct device* dev, uint8_t channel)\n{\n    const struct dac_driver_api* api = (const struct dac_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev, channel);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // DAC_H_\n</code></pre>"},{"location":"powerAPI/dir_a549afb1504a6cae23e88efc51d50dd5/","title":"Dir docs/core/zephyr/modules/owntech_data_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api</p>"},{"location":"powerAPI/dir_a549afb1504a6cae23e88efc51d50dd5/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/</code></p>"},{"location":"powerAPI/dir_e68c454e5b7b38289ca5658bb88f5006/","title":"Dir docs/core/zephyr/modules/owntech_data_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr</p>"},{"location":"powerAPI/dir_e68c454e5b7b38289ca5658bb88f5006/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/</code></p>"},{"location":"powerAPI/dir_395e94c4eb2e271e16f52d3df300cdd3/","title":"Dir docs/core/zephyr/modules/owntech_data_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_395e94c4eb2e271e16f52d3df300cdd3/#files","title":"Files","text":"Type Name file DataAPI.cpp file DataAPI.h file data_api_internal.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/DataAPI_8cpp/","title":"File DataAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; DataAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DataAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name DataAPI data"},{"location":"powerAPI/DataAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8cpp/#variable-data","title":"variable data","text":"<pre><code>DataAPI data;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Thomas Walter thomas.walter@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/DataAPI.cpp</code></p>"},{"location":"powerAPI/DataAPI_8cpp_source/","title":"File DataAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; DataAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;string.h&gt;\n\n// Current class header\n#include \"DataAPI.h\"\n\n// OwnTech Power API\n#include \"SpinAPI.h\"\n\n// Current module private functions\n#include \"../src/data_dispatch.h\"\n#ifdef CONFIG_SHIELD_TWIST\n#include \"../src/shield_channels.h\"\n#endif\n\n\n// Public object to interact with the class\n\nDataAPI data;\n\n\n// Public functions accessible only when using Twist\n\n#ifdef CONFIG_SHIELD_TWIST\n\nint8_t DataAPI::enableShieldChannel(uint8_t adc_num, channel_t channel_name)\n{\n    shield_channels_enable_adc_channel(adc_num, channel_name);\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel_name);\n    return this-&gt;enableChannel(channel_info.adc_num, channel_info.channel_num);\n}\n\nvoid DataAPI::enableTwistDefaultChannels()\n{\n    spin.adc.configureTriggerSource(1, hrtim_ev1);\n    spin.adc.configureTriggerSource(2, hrtim_ev3);\n    spin.adc.configureTriggerSource(3, software);\n    spin.adc.configureTriggerSource(4, software);\n    spin.adc.configureTriggerSource(5, software);\n\n    spin.adc.configureDiscontinuousMode(1,1);\n    spin.adc.configureDiscontinuousMode(2, 1);\n\n    this-&gt;enableShieldChannel(1, I1_LOW);\n    this-&gt;enableShieldChannel(1, V1_LOW);\n    this-&gt;enableShieldChannel(1, V_HIGH);\n\n    this-&gt;enableShieldChannel(2, I2_LOW);\n    this-&gt;enableShieldChannel(2, V2_LOW);\n    this-&gt;enableShieldChannel(2, I_HIGH);\n}\n\nuint16_t* DataAPI::getRawValues(channel_t channel, uint32_t&amp; number_of_values_acquired)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return this-&gt;getChannelRawValues(channel_info.adc_num, channel_info.channel_num, number_of_values_acquired);\n}\n\nfloat32_t DataAPI::peek(channel_t channel)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return this-&gt;peekChannel(channel_info.adc_num, channel_info.channel_num);\n}\n\nfloat32_t DataAPI::getLatest(channel_t channel, uint8_t* dataValid)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return this-&gt;getChannelLatest(channel_info.adc_num, channel_info.channel_num, dataValid);\n}\n\nfloat32_t DataAPI::convert(channel_t channel, uint16_t raw_value)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return data_conversion_convert_raw_value(channel_info.adc_num, channel_info.channel_num, raw_value);\n}\n\nvoid DataAPI::setParameters(channel_t channel, float32_t gain, float32_t offset)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    data_conversion_set_conversion_parameters_linear(channel_info.adc_num, channel_info.channel_num, gain, offset);\n}\n\nfloat32_t DataAPI::retrieveStoredParameterValue(channel_t channel, parameter_t parameter_name)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return data_conversion_get_parameter(channel_info.adc_num,channel_info.channel_num, parameter_name);\n\n}\n\nconversion_type_t DataAPI::retrieveStoredConversionType(channel_t channel)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return data_conversion_get_conversion_type(channel_info.adc_num,channel_info.channel_num);\n}\n\nint8_t DataAPI::retrieveParametersFromMemory(channel_t channel)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return data_conversion_retrieve_channel_parameters_from_nvs(channel_info.adc_num, channel_info.channel_num);\n}\n\nint8_t DataAPI::storeParametersInMemory(channel_t channel)\n{\n    channel_info_t channel_info = shield_channels_get_enabled_channel_info(channel);\n    return data_conversion_store_channel_parameters_in_nvs(channel_info.adc_num, channel_info.channel_num);\n}\n\nvoid DataAPI::setTwistChannelsUserCalibrationFactors()\n{\n    shield_channels_set_user_acquisition_parameters();\n}\n\n\n#endif // CONFIG_SHIELD_TWIST\n\n\n// Public functions\n\nint8_t DataAPI::enableAcquisition(uint8_t adc_num, uint8_t pin_num)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n        return -1;\n\n    return this-&gt;enableChannel(adc_num, channel_num);\n}\n\nint8_t DataAPI::start()\n{\n    if (this-&gt;is_started == true)\n        return -1;\n\n    // Initialize conversion\n    data_conversion_init();\n\n    // Initialize data dispatch\n    switch (this-&gt;dispatch_method)\n    {\n        case DispatchMethod_t::on_dma_interrupt:\n            // Dispatch is handled automatically by Data Dispatch on interrupt\n            data_dispatch_init(interrupt, 0);\n            break;\n        case DispatchMethod_t::externally_triggered:\n            // Dispatch is triggered by an external call\n            if (this-&gt;repetition_count_between_dispatches == 0)\n                return -1;\n\n            data_dispatch_init(task, this-&gt;repetition_count_between_dispatches);\n    }\n\n    // Launch ADC conversion\n    spin.adc.startAllAdcs();\n\n    this-&gt;is_started = true;\n\n    return 0;\n}\n\nbool DataAPI::started()\n{\n    return this-&gt;is_started;\n}\n\nvoid DataAPI::setDispatchMethod(DispatchMethod_t dispatch_method)\n{\n    this-&gt;dispatch_method = dispatch_method;\n}\n\nDispatchMethod_t DataAPI::getDispatchMethod()\n{\n    return this-&gt;dispatch_method;\n}\n\nvoid DataAPI::setRepetitionsBetweenDispatches(uint32_t repetition)\n{\n    this-&gt;repetition_count_between_dispatches = repetition;\n}\n\nvoid DataAPI::triggerAcquisition(uint8_t adc_num)\n{\n    uint8_t enabled_channels = spin.adc.getEnabledChannelsCount(adc_num);\n    spin.adc.triggerSoftwareConversion(adc_num, enabled_channels);\n}\n\nuint16_t* DataAPI::getRawValues(uint8_t adc_num, uint8_t pin_num, uint32_t&amp; number_of_values_acquired)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return this-&gt;getChannelRawValues(adc_num, channel_num, number_of_values_acquired);\n}\n\nfloat32_t DataAPI::peek(uint8_t adc_num, uint8_t pin_num)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return NO_VALUE;\n    }\n\n    return this-&gt;peekChannel(adc_num, channel_num);\n}\n\nfloat32_t DataAPI::getLatest(uint8_t adc_num, uint8_t pin_num, uint8_t* dataValid)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    return this-&gt;getChannelLatest(adc_num, channel_num, dataValid);\n}\n\nfloat32_t DataAPI::convert(uint8_t adc_num, uint8_t pin_num, uint16_t raw_value)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nvoid DataAPI::setParameters(uint8_t adc_num, uint8_t pin_num, float32_t gain, float32_t offset)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return;\n    }\n\n    data_conversion_set_conversion_parameters_linear(adc_num, channel_num, gain, offset);\n}\n\n\nint8_t DataAPI::storeParametersInMemory(uint8_t adc_num, uint8_t pin_num)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_store_channel_parameters_in_nvs(adc_num, channel_num);\n}\n\n\nint8_t DataAPI::retrieveParametersFromMemory(uint8_t adc_num, uint8_t pin_num)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_retrieve_channel_parameters_from_nvs(adc_num, channel_num);\n}\n\nfloat32_t DataAPI::retrieveStoredParameterValue(uint8_t adc_num, uint8_t pin_num, parameter_t parameter_name)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return ERROR_CHANNEL_NOT_FOUND;\n    }\n\n    return data_conversion_get_parameter(adc_num,channel_num, parameter_name);\n\n}\n\nconversion_type_t DataAPI::retrieveStoredConversionType(uint8_t adc_num, uint8_t pin_num)\n{\n    uint8_t channel_num = this-&gt;getChannelNumber(adc_num, pin_num);\n    if (channel_num == 0)\n    {\n        return no_channel_error;\n    }\n\n    return data_conversion_get_conversion_type(adc_num,channel_num);\n}\n\n\n\n\n// Private functions\n\nint8_t DataAPI::enableChannel(uint8_t adc_num, uint8_t channel_num)\n{\n    if (this-&gt;is_started == true)\n        return -1;\n\n    if ( (adc_num == 0) || (adc_num &gt; ADC_COUNT) )\n        return -1;\n\n    if ( (channel_num == 0) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return -1;\n\n    // Enable channel\n    spin.adc.enableDma(adc_num, true);\n    spin.adc.enableChannel(adc_num, channel_num);\n\n    // Remember rank\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n    this-&gt;current_rank[adc_index]++;\n    this-&gt;channels_ranks[adc_index][channel_index] = this-&gt;current_rank[adc_index];\n\n    return 0;\n}\n\nuint16_t* DataAPI::getChannelRawValues(uint8_t adc_num, uint8_t channel_num, uint32_t&amp; number_of_values_acquired)\n{\n    if (this-&gt;is_started == false)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    uint8_t channel_rank = this-&gt;getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        number_of_values_acquired = 0;\n        return nullptr;\n    }\n\n    return data_dispatch_get_acquired_values(adc_num, channel_rank, number_of_values_acquired);\n}\n\nfloat32_t DataAPI::peekChannel(uint8_t adc_num, uint8_t channel_num)\n{\n    if (this-&gt;is_started == false)\n    {\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = this-&gt;getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        return NO_VALUE;\n    }\n\n    uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num, channel_rank);\n    if (raw_value == PEEK_NO_VALUE)\n    {\n        return NO_VALUE;\n    }\n\n    return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n}\n\nfloat32_t DataAPI::getChannelLatest(uint8_t adc_num, uint8_t channel_num, uint8_t* dataValid)\n{\n    if (this-&gt;is_started == false)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint8_t channel_rank = this-&gt;getChannelRank(adc_num, channel_num);\n    if (channel_rank == 0)\n    {\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_MISSING;\n        }\n        return NO_VALUE;\n    }\n\n    uint32_t data_count;\n    uint16_t* buffer = data_dispatch_get_acquired_values(adc_num, channel_rank, data_count);\n\n    if (data_count &gt; 0)\n    {\n        uint16_t raw_value = buffer[data_count - 1];\n        if (dataValid != nullptr)\n        {\n            *dataValid = DATA_IS_OK;\n        }\n        return data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n    }\n    else\n    {\n        uint16_t raw_value = data_dispatch_peek_acquired_value(adc_num, channel_rank);\n\n        float32_t peekValue;\n        if (raw_value != PEEK_NO_VALUE)\n        {\n            peekValue = data_conversion_convert_raw_value(adc_num, channel_num, raw_value);\n        }\n        else\n        {\n            peekValue = NO_VALUE;\n        }\n\n        if (dataValid != nullptr)\n        {\n            if (peekValue != NO_VALUE)\n            {\n                *dataValid = DATA_IS_OLD;\n            }\n            else\n            {\n                *dataValid = DATA_IS_MISSING;\n            }\n        }\n        return peekValue;\n    }\n}\n\nuint8_t DataAPI::getChannelRank(uint8_t adc_num, uint8_t channel_num)\n{\n    if ( (adc_num &gt; ADC_COUNT) || (channel_num &gt; CHANNELS_PER_ADC) )\n        return 0;\n\n    uint8_t adc_index = adc_num-1;\n    uint8_t channel_index = channel_num-1;\n\n    return this-&gt;channels_ranks[adc_index][channel_index];\n}\n\nuint8_t DataAPI::getChannelNumber(uint8_t adc_num, uint8_t twist_pin)\n{\n    switch (adc_num)\n    {\n    case 1:\n        switch (twist_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 2:\n                return 11;\n                break;\n            case 5:\n                return 5;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 31:\n                return 5;\n                break;\n            case 37:\n                return 12;\n                break;\n            case 50:\n                return 3;\n                break;\n            case 51:\n                return 4;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 2:\n        switch (twist_pin)\n        {\n            case 1:\n                return 14;\n                break;\n            case 6:\n                return 15;\n                break;\n            case 24:\n                return 6;\n                break;\n            case 25:\n                return 7;\n                break;\n            case 26:\n                return 8;\n                break;\n            case 27:\n                return 9;\n                break;\n            case 29:\n                return 1;\n                break;\n            case 30:\n                return 2;\n                break;\n            case 32:\n                return 13;\n                break;\n            case 34:\n                return 3;\n                break;\n            case 35:\n                return 5;\n                break;\n            case 42:\n                return 12;\n                break;\n            case 43:\n                return 11;\n                break;\n            case 44:\n                return 4;\n                break;\n            case 45:\n                return 17;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 3:\n        switch (twist_pin)\n        {\n            case 4:\n                return 5;\n                break;\n            case 31:\n                return 12;\n                break;\n            case 37:\n                return 1;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 4:\n        switch (twist_pin)\n        {\n            case 2:\n                return 3;\n                break;\n            case 5:\n                return 4;\n                break;\n            case 6:\n                return 5;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    case 5:\n        switch (twist_pin)\n        {\n            case 12:\n                return 1;\n                break;\n            case 14:\n                return 2;\n                break;\n            default:\n                return 0;\n                break;\n        }\n        break;\n    default:\n        return 0;\n        break;\n    }\n}\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/","title":"File DataAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; DataAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DataAPI_8h/#classes","title":"Classes","text":"Type Name class DataAPI"},{"location":"powerAPI/DataAPI_8h/#public-types","title":"Public Types","text":"Type Name enum DispatchMethod_t enum channel_t enum uint8_t parameter_t"},{"location":"powerAPI/DataAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t DATA_IS_MISSING   = = 2 const uint8_t DATA_IS_OK   = = 0 const uint8_t DATA_IS_OLD   = = 1 const float32_t NO_VALUE   = = -10000 DataAPI data"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t ADC_COUNT   = = 5 const uint8_t CHANNELS_PER_ADC   = = 19"},{"location":"powerAPI/DataAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#enum-dispatchmethod_t","title":"enum DispatchMethod_t","text":"<pre><code>enum DispatchMethod_t {\n    on_dma_interrupt,\n    externally_triggered\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-channel_t","title":"enum channel_t","text":"<pre><code>enum channel_t {\n    UNDEFINED_CHANNEL = 0,\n    DT_FOREACH_STATUS_OKAY =(adc_channels, CHANNEL_TOKEN)\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#enum-parameter_t","title":"enum parameter_t","text":"<pre><code>enum parameter_t {\n    gain = 1,\n    offset = 2\n};\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-data_is_missing","title":"variable DATA_IS_MISSING","text":"<pre><code>const uint8_t DATA_IS_MISSING;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_ok","title":"variable DATA_IS_OK","text":"<pre><code>const uint8_t DATA_IS_OK;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data_is_old","title":"variable DATA_IS_OLD","text":"<pre><code>const uint8_t DATA_IS_OLD;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-no_value","title":"variable NO_VALUE","text":"<pre><code>const float32_t NO_VALUE;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-data","title":"variable data","text":"<pre><code>DataAPI data;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Thomas Walter thomas.walter@laas.fr </p>"},{"location":"powerAPI/DataAPI_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DataAPI_8h/#variable-adc_count","title":"variable ADC_COUNT","text":"<pre><code>const uint8_t ADC_COUNT;\n</code></pre>"},{"location":"powerAPI/DataAPI_8h/#variable-channels_per_adc","title":"variable CHANNELS_PER_ADC","text":"<pre><code>const uint8_t CHANNELS_PER_ADC;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/DataAPI.h</code></p>"},{"location":"powerAPI/DataAPI_8h_source/","title":"File DataAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; DataAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DATAAPI_H_\n#define DATAAPI_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n// ARM CMSIS library\n#include &lt;arm_math.h&gt;\n\n// Current module private functions\n#include \"../src/data_conversion.h\"\n\n#define ADC_1 1\n#define ADC_2 2\n#define ADC_3 3\n#define ADC_4 4\n\n#define ERROR_CHANNEL_OFF -5\n#define ERROR_CHANNEL_NOT_FOUND -5000\n\ntypedef enum : uint8_t\n{\n    gain = 1,\n    offset = 2\n\n} parameter_t;\n\n// Device-tree related macro\n\n#ifdef CONFIG_SHIELD_TWIST\n#define CHANNEL_TOKEN(node_id) DT_STRING_TOKEN(node_id, channel_name),\n#endif\n\n\n// Type definitions\n\n#ifdef CONFIG_SHIELD_TWIST\ntypedef enum\n{\n    UNDEFINED_CHANNEL = 0,\n    DT_FOREACH_STATUS_OKAY(adc_channels, CHANNEL_TOKEN)\n} channel_t;\n#endif\n\nenum class DispatchMethod_t\n{\n    on_dma_interrupt,\n    externally_triggered\n};\n\n\n\n// Constants definitions\n\nstatic const uint8_t ADC_COUNT        = 5;\nstatic const uint8_t CHANNELS_PER_ADC = 19;\n\n// Define \"no value\" as an impossible, out of range value\nconst float32_t NO_VALUE = -10000;\n\nconst uint8_t DATA_IS_OK      = 0;\nconst uint8_t DATA_IS_OLD     = 1;\nconst uint8_t DATA_IS_MISSING = 2;\n\n// Static class definition\n\nclass DataAPI\n{\npublic:\n\n#ifdef CONFIG_SHIELD_TWIST\n\n    int8_t enableShieldChannel(uint8_t adc_num, channel_t channel_name);\n\n    void enableTwistDefaultChannels();\n\n    uint16_t* getRawValues(channel_t channel, uint32_t&amp; number_of_values_acquired);\n\n    float32_t peek(channel_t channel);\n\n    float32_t getLatest(channel_t channel, uint8_t* dataValid = nullptr);\n\n    float32_t convert(channel_t channel, uint16_t raw_value);\n\n    void setParameters(channel_t channel, float32_t gain, float32_t offset);\n\n    float32_t retrieveStoredParameterValue(channel_t channel, parameter_t parameter_name);\n\n    conversion_type_t retrieveStoredConversionType(channel_t channel);\n\n\n    int8_t storeParametersInMemory(channel_t channel);\n\n    int8_t retrieveParametersFromMemory(channel_t channel);\n\n\n    void setTwistChannelsUserCalibrationFactors();\n\n#endif\n\n    int8_t enableAcquisition(uint8_t adc_num, uint8_t pin_num);\n\n    int8_t start();\n\n    bool started();\n\n    void setDispatchMethod(DispatchMethod_t dispatch_method);\n\n    DispatchMethod_t getDispatchMethod();\n\n    void setRepetitionsBetweenDispatches(uint32_t repetition);\n\n    void triggerAcquisition(uint8_t adc_num);\n\n\n    // Accessor API\n\n    uint16_t* getRawValues(uint8_t adc_num, uint8_t pin_num, uint32_t&amp; number_of_values_acquired);\n\n    float32_t peek(uint8_t adc_num, uint8_t pin_num);\n\n    float32_t getLatest(uint8_t adc_num, uint8_t pin_num, uint8_t* dataValid = nullptr);\n\n    float32_t convert(uint8_t adc_num, uint8_t pin_num, uint16_t raw_value);\n\n    void setParameters(uint8_t adc_num, uint8_t pin_num, float32_t gain, float32_t offset);\n\n    float32_t retrieveStoredParameterValue(uint8_t adc_num, uint8_t pin_num, parameter_t parameter_name);\n\n    conversion_type_t retrieveStoredConversionType(uint8_t adc_num, uint8_t pin_num);\n\n\n    int8_t storeParametersInMemory(uint8_t adc_num, uint8_t pin_num);\n\n    int8_t retrieveParametersFromMemory(uint8_t adc_num, uint8_t pin_num);\n\n\n\nprivate:\n    int8_t enableChannel(uint8_t adc_num, uint8_t channel_num);\n    uint16_t* getChannelRawValues(uint8_t adc_num, uint8_t channel_num, uint32_t&amp; number_of_values_acquired);\n    float32_t peekChannel(uint8_t adc_num, uint8_t channel_num);\n    float32_t getChannelLatest(uint8_t adc_num, uint8_t channel_num, uint8_t* dataValid = nullptr);\n    uint8_t getChannelRank(uint8_t adc_num, uint8_t channel_num);\n    uint8_t getChannelNumber(uint8_t adc_num, uint8_t twist_pin);\n\nprivate:\n    bool is_started = false;\n    uint8_t channels_ranks[ADC_COUNT][CHANNELS_PER_ADC] = {0};\n    uint8_t current_rank[ADC_COUNT] = {0};\n    DispatchMethod_t dispatch_method = DispatchMethod_t::on_dma_interrupt;\n    uint32_t repetition_count_between_dispatches = 0;\n\n};\n\n\n// Public object to interact with the class\n\nextern DataAPI data;\n\n\n#endif // DATAAPI_H_\n</code></pre>"},{"location":"powerAPI/data__api__internal_8h/","title":"File data_api_internal.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; data_api_internal.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/data__api__internal_8h/#public-functions","title":"Public Functions","text":"Type Name void data_dispatch_do_full_dispatch () Force full dispatch."},{"location":"powerAPI/data__api__internal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/data__api__internal_8h/#function-data_dispatch_do_full_dispatch","title":"function data_dispatch_do_full_dispatch","text":"<p>Force full dispatch. <pre><code>void data_dispatch_do_full_dispatch () \n</code></pre></p> <p>For internal use only, do not call in user code. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_data_api/zephyr/public_api/data_api_internal.h</code></p>"},{"location":"powerAPI/data__api__internal_8h_source/","title":"File data_api_internal.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_data_api &gt; zephyr &gt; public_api &gt; data_api_internal.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DATA_API_INTERNAL_H_\n#define DATA_API_INTERNAL_H_\n\n\nvoid data_dispatch_do_full_dispatch();\n\n\n#endif // DATA_API_INTERNAL_H_\n</code></pre>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver</p>"},{"location":"powerAPI/dir_47b8019f52d29447200a9fe029247d2f/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/</code></p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_b20d16dae1dc20106d56014478318b72/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/","title":"Dir docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_ce5a725b60c8953eacf539a6c77604d3/#files","title":"Files","text":"Type Name file nvs_storage.c file nvs_storage.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/nvs__storage_8c/","title":"File nvs_storage.c","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint16_t current_storage_version   = = 0x0001 struct nvs_fs fs   = = { .offset       = FIXED_PARTITION_OFFSET(NVS_PARTITION), .flash_device = FIXED_PARTITION_DEVICE(NVS_PARTITION) } bool initialized   = = false uint16_t storage_version_in_nvs   = = 0"},{"location":"powerAPI/nvs__storage_8c/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data ()  uint16_t nvs_storage_get_current_version ()  uint16_t nvs_storage_get_version_in_nvs ()  int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size)  int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size)"},{"location":"powerAPI/nvs__storage_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name int8_t _nvs_storage_init ()  int8_t _nvs_storage_store_version ()"},{"location":"powerAPI/nvs__storage_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#variable-current_storage_version","title":"variable current_storage_version","text":"<pre><code>const uint16_t current_storage_version;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p>"},{"location":"powerAPI/nvs__storage_8c/#variable-fs","title":"variable fs","text":"<pre><code>struct nvs_fs fs;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#variable-initialized","title":"variable initialized","text":"<pre><code>bool initialized;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#variable-storage_version_in_nvs","title":"variable storage_version_in_nvs","text":"<pre><code>uint16_t storage_version_in_nvs;\n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_init","title":"function _nvs_storage_init","text":"<pre><code>static int8_t _nvs_storage_init () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8c/#function-_nvs_storage_store_version","title":"function _nvs_storage_store_version","text":"<pre><code>static int8_t _nvs_storage_store_version () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.c</code></p>"},{"location":"powerAPI/nvs__storage_8c_source/","title":"File nvs_storage.c","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.c</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Include\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/fs/nvs.h&gt;\n#include &lt;zephyr/drivers/flash.h&gt;\n#include &lt;zephyr/storage/flash_map.h&gt;\n\n// CMSIS\n#include &lt;arm_math.h&gt;\n\n// Current file header\n#include \"nvs_storage.h\"\n\n\n// Constants and variables\nstatic const uint16_t current_storage_version = 0x0001;\nstatic uint16_t storage_version_in_nvs = 0;\nstatic bool initialized = false;\n\n// Device-tree related macros\n#define NVS_PARTITION storage_partition\n#define STORAGE_NODE  DT_NODE_BY_FIXED_PARTITION_LABEL(NVS_PARTITION)\n\n// Flash memory file system\nstatic struct nvs_fs fs =\n{\n    .offset       = FIXED_PARTITION_OFFSET(NVS_PARTITION),\n    .flash_device = FIXED_PARTITION_DEVICE(NVS_PARTITION)\n};\n\n\n// Private functions\n\nstatic int8_t _nvs_storage_store_version()\n{\n    if (storage_version_in_nvs == current_storage_version)\n    {\n        // Ok, nothing to do\n        return 0;\n    }\n    else if (storage_version_in_nvs == 0)\n    {\n        // No version in NVS: this is the first use of NVS, store current version number.\n        int rc = nvs_write(&amp;fs, VERSION, &amp;current_storage_version, 2);\n\n        if (rc == 2)\n        {\n            storage_version_in_nvs = current_storage_version;\n            return 0;\n        }\n\n        return -1;\n    }\n    else\n    {\n        // There is already a version number in NVS, but it differs from current API version.\n        // This is currently treated as an error and requires to explicitely clear NVS.\n        return -1;\n    }\n}\n\nstatic int8_t _nvs_storage_init()\n{\n    if (initialized == true)\n        return 0;\n\n    if (!device_is_ready(fs.flash_device))\n    {\n        printk(\"Flash device %s is not ready\\n\", fs.flash_device-&gt;name);\n        return -1;\n    }\n\n    /* Handle non volatile memory used to store ADC parameters\n     * Flash partition reserved to user data storage is 4kB long\n     * We have to mount the file system then we extract one\n     * memory page that is 2kB long that contains the data\n     * and read the relevant addresses to init ADC parameters.\n     */\n\n    struct flash_pages_info info;\n    int rc = flash_get_page_info_by_offs(fs.flash_device, fs.offset, &amp;info);\n    if (rc != 0)\n    {\n        printk(\"Unable to get page info\\n\");\n        return -1;\n    }\n    fs.sector_size = info.size;\n    fs.sector_count = 2U;\n\n    rc = nvs_mount(&amp;fs);\n    if (rc != 0)\n    {\n        printk(\"Flash Init failed\\n\");\n        return -1;\n    }\n\n    // Init OK\n    initialized = true;\n\n    // Check version in storage\n    rc = nvs_storage_retrieve_data(VERSION, &amp;storage_version_in_nvs, 2);\n\n    if (rc &lt; 0)\n    {\n        // No version in NVS: this is the first use of NVS.\n        storage_version_in_nvs = 0;\n    }\n    else if (storage_version_in_nvs != current_storage_version)\n    {\n        printk(\"WARNING: stored version in NVS is different from current module version! Stored data may not have the expected format.\\n\");\n        // -2 indicates that the current version stored in NVS is different from current code version.\n        return -2;\n    }\n\n    return 0;\n}\n\n\n// Public Functions\n\nint8_t nvs_storage_store_data(uint16_t data_id, const void* data, uint8_t data_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = _nvs_storage_store_version();\n    if (rc != 0)\n    {\n        return rc;\n    }\n\n    rc = nvs_write(&amp;fs, data_id, data, data_size);\n\n    return rc;\n}\n\nint8_t nvs_storage_retrieve_data(uint16_t data_id, void* data_buffer, uint8_t data_buffer_size)\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return error;\n    }\n\n    int rc = nvs_read(&amp;fs, data_id, data_buffer, 1);\n\n    if (rc &gt; 1) // There is more than 1 byte of data\n    {\n        if (rc &gt; data_buffer_size)\n        {\n            // Indicate that provided buffer is too small to retreive data\n            return -1;\n        }\n\n        rc = nvs_read(&amp;fs, data_id, data_buffer, rc);\n    }\n\n    return rc;\n}\n\nint8_t nvs_storage_clear_all_stored_data()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return nvs_clear(&amp;fs);\n}\n\nuint16_t nvs_storage_get_current_version()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return current_storage_version;\n}\n\nuint16_t nvs_storage_get_version_in_nvs()\n{\n    if (initialized == false)\n    {\n        int8_t error = _nvs_storage_init();\n        if (error != 0) return 0;\n    }\n\n    return storage_version_in_nvs;\n}\n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/","title":"File nvs_storage.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/nvs__storage_8h/#public-types","title":"Public Types","text":"Type Name enum nvs_category_t"},{"location":"powerAPI/nvs__storage_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t nvs_storage_clear_all_stored_data ()  uint16_t nvs_storage_get_current_version ()  uint16_t nvs_storage_get_version_in_nvs ()  int8_t nvs_storage_retrieve_data (uint16_t data_id, void * data_buffer, uint8_t data_buffer_size)  int8_t nvs_storage_store_data (uint16_t data_id, const void * data, uint8_t data_size)"},{"location":"powerAPI/nvs__storage_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#enum-nvs_category_t","title":"enum nvs_category_t","text":"<pre><code>enum nvs_category_t {\n    VERSION = 0x0100,\n    ADC_CALIBRATION = 0x0200,\n    MEASURE_THRESHOLD = 0x0300\n};\n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_clear_all_stored_data","title":"function nvs_storage_clear_all_stored_data","text":"<pre><code>int8_t nvs_storage_clear_all_stored_data () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_current_version","title":"function nvs_storage_get_current_version","text":"<pre><code>uint16_t nvs_storage_get_current_version () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_get_version_in_nvs","title":"function nvs_storage_get_version_in_nvs","text":"<pre><code>uint16_t nvs_storage_get_version_in_nvs () \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_retrieve_data","title":"function nvs_storage_retrieve_data","text":"<pre><code>int8_t nvs_storage_retrieve_data (\n    uint16_t data_id,\n    void * data_buffer,\n    uint8_t data_buffer_size\n) \n</code></pre>"},{"location":"powerAPI/nvs__storage_8h/#function-nvs_storage_store_data","title":"function nvs_storage_store_data","text":"<pre><code>int8_t nvs_storage_store_data (\n    uint16_t data_id,\n    const void * data,\n    uint8_t data_size\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_flash_driver/zephyr/public_api/nvs_storage.h</code></p>"},{"location":"powerAPI/nvs__storage_8h_source/","title":"File nvs_storage.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_flash_driver &gt; zephyr &gt; public_api &gt; nvs_storage.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef NVS_STORAGE_H_\n#define NVS_STORAGE_H_\n\n\n#include &lt;stdint.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Type definitions\n\n// NVS categories must be on the upper half\n// of the 2-bytes value, hence end with 00\ntypedef enum\n{\n    VERSION          = 0x0100,\n    ADC_CALIBRATION  = 0x0200,\n    MEASURE_THRESHOLD = 0x0300,\n}nvs_category_t;\n\n// API\n\nint8_t nvs_storage_store_data(uint16_t data_id, const void* data, uint8_t data_size);\nint8_t nvs_storage_retrieve_data(uint16_t data_id, void* data_buffer, uint8_t data_buffer_size);\nint8_t nvs_storage_clear_all_stored_data();\n\nuint16_t nvs_storage_get_current_version();\nuint16_t nvs_storage_get_version_in_nvs();\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // NVS_STORAGE_H_\n</code></pre>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver</p>"},{"location":"powerAPI/dir_9bdb70ffe78507e4a3f4bf6bbcfe5795/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/</code></p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_5726d3ce904599e290c14ea43bd5e0ac/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/","title":"Dir docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_f50115c0b0057abe0315b5e6b1574f35/#files","title":"Files","text":"Type Name file hrtim.h file hrtim_enum.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/hrtim_8h/","title":"File hrtim.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim_8h/#classes","title":"Classes","text":"Type Name struct timer_hrtim_t Timinig unit configuration - aggregates all the structures."},{"location":"powerAPI/hrtim_8h/#public-attributes","title":"Public Attributes","text":"Type Name timer_hrtim_t * tu_channel"},{"location":"powerAPI/hrtim_8h/#public-functions","title":"Public Functions","text":"Type Name void DualDAC_init (hrtim_tu_number_t tu) Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). uint32_t hrtim_PeriodicEvent_GetRep (hrtim_tu_t tu) Gets the current value of the repetition counter. void hrtim_PeriodicEvent_SetRep (hrtim_tu_t tu, uint32_t repetition) Changes the repetition counter value to control the ISR interrupt. void hrtim_PeriodicEvent_configure (hrtim_tu_t tu, uint32_t repetition, hrtim_callback_t callback) Configures interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_dis (hrtim_tu_t tu) Disables interrupt on repetition counter for the chosen timing unit. void hrtim_PeriodicEvent_en (hrtim_tu_t tu) Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (hrtim_tu_number_t tu_number) Returns the adc rollover mode. void hrtim_adc_rollover_set (hrtim_tu_number_t tu_number, hrtim_adc_edgetrigger_t adc_rollover) Configures the adc rollover mode. hrtim_adc_trigger_t hrtim_adc_triger_get (hrtim_tu_number_t tu_number) Returns the adc trigger. void hrtim_adc_triger_set (hrtim_tu_number_t tu_number, hrtim_adc_trigger_t adc_trig) Sets the adc trigger number for a timing unit. void hrtim_adc_trigger_dis (hrtim_tu_number_t tu_number) Disbables a ADCx trigger event. void hrtim_adc_trigger_en (hrtim_tu_number_t tu_number) Configures and enables an ADC trigger event. void hrtim_adc_trigger_set_postscaler (hrtim_tu_number_t tu_number, uint32_t ps_ratio) Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. void hrtim_change_frequency (uint32_t new_frequency) Change the frequency/period after it has been initialized. void hrtim_cmpl_pwm_out1 (hrtim_tu_number_t tu_number) Activates OUT 1 (switch H) with a given switching convention. void hrtim_cmpl_pwm_out2 (hrtim_tu_number_t tu_number) Activates OUT 2 (switch L) with a given switching convention. void hrtim_cnt_dis (hrtim_tu_number_t tu_number) Disables a timing unit counter. void hrtim_cnt_en (hrtim_tu_number_t tu_number) Enables a timing unit counter. void hrtim_dt_init (hrtim_tu_number_t tu_number) Initialize the dead-time for the PWM. void hrtim_dt_set (hrtim_tu_number_t tu_number, uint16_t rise_ns, uint16_t fall_ns) Sets up a dead time in nano second for given complementary outputs. void hrtim_duty_cycle_set (hrtim_tu_number_t tu_number, uint16_t value) Updates the duty cycle of a timing unit. hrtim_external_trigger_t hrtim_eev_get (hrtim_tu_number_t tu_number) Returns the external event trigger used in current mode. void hrtim_eev_set (hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev) Sets the external event used in current mode for a timing unit. void hrtim_frequency_set (uint32_t frequency_set, uint32_t frequency_min) Sets the period of a given timing unit. int hrtim_get_apb2_clock () Gets the APB2 clock. hrtim_cnt_t hrtim_get_modulation (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. hrtim_tu_ON_OFF_t hrtim_get_status (hrtim_tu_number_t tu_number) Returns if the timer was initialized with default value or not. hrtim_switch_convention_t hrtim_get_switch_convention (hrtim_tu_number_t tu_number) Gets the switching convention of a given timing unit. void hrtim_init_default_all () this function initalize all the default parameters for each timing unit structure void hrtim_master_cmp_set (hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_out_dis (hrtim_tu_number_t tu_number) Disables the output of a given timingg unit. void hrtim_out_dis_single (hrtim_output_units_t PWM_OUT) Disables only one output of a given timing unit. void hrtim_out_en (hrtim_tu_number_t tu_number) Enables the output of a given timing unit. void hrtim_out_en_single (hrtim_output_units_t PWM_OUT) Enables only one output of a given timing unit. uint16_t hrtim_period_Master_get () Returns the period of a master timer. uint32_t hrtim_period_Master_get_us () Returns the period of the master timer in microseconds. uint16_t hrtim_period_get (hrtim_tu_number_t tu_number) Returns the period of a given timing unit. uint32_t hrtim_period_get_us (hrtim_tu_number_t tu_number) Returns the period of a given timing unit in microseconds. void hrtim_phase_shift_set (hrtim_tu_number_t tu_number, uint16_t shift) Shifts the PWM of a timing unit. hrtim_pwm_mode_t hrtim_pwm_mode_get (hrtim_tu_number_t tu_number) Returns timing unit pwm mode. void hrtim_pwm_mode_set (hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode) Sets the pwm mode : voltage or current mode. void hrtim_rst_evt_dis (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Disables a timer counter reset event. void hrtim_rst_evt_en (hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt) Enables a timer counter reset event. void hrtim_set_modulation (hrtim_tu_number_t tu_number, hrtim_cnt_t modulation) Sets the switching convention of a given timing unit. void hrtim_set_switch_convention (hrtim_tu_number_t tu_number, hrtim_switch_convention_t convention) Sets the switching convention of a given timing unit. void hrtim_tu_cmp_set (hrtim_tu_number_t tu_number, hrtim_cmp_t cmp, uint16_t value) Sets one of the four comparators of the HRTIM master timer. void hrtim_tu_gpio_init (hrtim_tu_number_t tu_number) Initializes the gpio elements of a given timing unit. uint16_t hrtim_tu_init (hrtim_tu_number_t tu_number) Initializes a given timing unit."},{"location":"powerAPI/hrtim_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/hrtim_8h/#variable-tu_channel","title":"variable tu_channel","text":"<pre><code>timer_hrtim_t* tu_channel[HRTIM_STU_NUMOF];\n</code></pre>"},{"location":"powerAPI/hrtim_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hrtim_8h/#function-dualdac_init","title":"function DualDAC_init","text":"<p>Initializes dual DAC reset and trigger. The selected timing unit CMP2 will trigger the step (Decrement/Increment of sawtooth) and the reset (return to initial value). <pre><code>void DualDAC_init (\n    hrtim_tu_number_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu</code> timing unit </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_getrep","title":"function hrtim_PeriodicEvent_GetRep","text":"<p>Gets the current value of the repetition counter. <pre><code>uint32_t hrtim_PeriodicEvent_GetRep (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul> <p>Returns:</p> <p>Value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_setrep","title":"function hrtim_PeriodicEvent_SetRep","text":"<p>Changes the repetition counter value to control the ISR interrupt. <pre><code>void hrtim_PeriodicEvent_SetRep (\n    hrtim_tu_t tu,\n    uint32_t repetition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li> <p>TIMF </p> </li> <li> <p><code>repetion</code> value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_configure","title":"function hrtim_PeriodicEvent_configure","text":"<p>Configures interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_configure (\n    hrtim_tu_t tu,\n    uint32_t repetition,\n    hrtim_callback_t callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li> <p>TIMF </p> </li> <li> <p><code>repetition</code> value between 1 and 256 for the repetition counter: period of the event wrt. periods of the HRTIM. E.g. when set to 10, one event will be triggered every 10 HRTIM period. </p> </li> <li><code>callback</code> Pointer to a void(void) function that will be called when the event is triggerred. </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_dis","title":"function hrtim_PeriodicEvent_dis","text":"<p>Disables interrupt on repetition counter for the chosen timing unit. <pre><code>void hrtim_PeriodicEvent_dis (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_periodicevent_en","title":"function hrtim_PeriodicEvent_en","text":"<p>Enables interrupt on repetition counter for the chosen timing unit. The periodic event configuration must have been done previously. <pre><code>void hrtim_PeriodicEvent_en (\n    hrtim_tu_t tu\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_src</code> timing unit which will be the source for the ISR: </li> <li>MSTR </li> <li>TIMA </li> <li>TIMB </li> <li>TIMC </li> <li>TIMD </li> <li>TIME </li> <li>TIMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_get","title":"function hrtim_adc_rollover_get","text":"<p>Returns the adc rollover mode. <pre><code>hrtim_adc_edgetrigger_t hrtim_adc_rollover_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF</li> </ul> <p>Returns:</p> <p>adc_rollover rollover mode :  * EdgeTrigger_up  * EdgeTrigger_down  * EdgeTrigger_Both </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_rollover_set","title":"function hrtim_adc_rollover_set","text":"<p>Configures the adc rollover mode. <pre><code>void hrtim_adc_rollover_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_edgetrigger_t adc_rollover\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_rollover</code> rollover mode </p> </li> <li>EdgeTrigger_up </li> <li>EdgeTrigger_down </li> <li>EdgeTrigger_Both </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_triger_get","title":"function hrtim_adc_triger_get","text":"<p>Returns the adc trigger. <pre><code>hrtim_adc_trigger_t hrtim_adc_triger_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <ul> <li>ADCTRIG_1 = ADC trigger 1, </li> <li>ADCTRIG_2 = ADC trigger 2, </li> <li>ADCTRIG_3 = ADC trigger 3, </li> <li>ADCTRIG_4 = ADC trigger 4 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_triger_set","title":"function hrtim_adc_triger_set","text":"<p>Sets the adc trigger number for a timing unit. <pre><code>void hrtim_adc_triger_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_adc_trigger_t adc_trig\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_trig</code> pwm mode: </p> </li> <li>ADCTRIG_1 </li> <li>ADCTRIG_2 </li> <li>ADCTRIG_3 </li> <li>ADCTRIG_4 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_dis","title":"function hrtim_adc_trigger_dis","text":"<p>Disbables a ADCx trigger event. <pre><code>void hrtim_adc_trigger_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_en","title":"function hrtim_adc_trigger_en","text":"<p>Configures and enables an ADC trigger event. <pre><code>void hrtim_adc_trigger_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_adc_trigger_set_postscaler","title":"function hrtim_adc_trigger_set_postscaler","text":"<p>Sets the HRTIM event postsaler. Postscaler ratio indicates how many potential events will be ignored between two events which are effectively generated. <pre><code>void hrtim_adc_trigger_set_postscaler (\n    hrtim_tu_number_t tu_number,\n    uint32_t ps_ratio\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ps_ratio</code> Post scaler ratio (0 = no post scaler, default) </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_change_frequency","title":"function hrtim_change_frequency","text":"<p>Change the frequency/period after it has been initialized. <pre><code>void hrtim_change_frequency (\n    uint32_t new_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>new_frequency</code> The new frequency in Hz </li> </ul> <p>Warning:</p> <p>the new frequency can't be inferior to the the one set in the initialization step </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cmpl_pwm_out1","title":"function hrtim_cmpl_pwm_out1","text":"<p>Activates OUT 1 (switch H) with a given switching convention. <pre><code>void hrtim_cmpl_pwm_out1 (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cmpl_pwm_out2","title":"function hrtim_cmpl_pwm_out2","text":"<p>Activates OUT 2 (switch L) with a given switching convention. <pre><code>void hrtim_cmpl_pwm_out2 (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_dis","title":"function hrtim_cnt_dis","text":"<p>Disables a timing unit counter. <pre><code>void hrtim_cnt_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_cnt_en","title":"function hrtim_cnt_en","text":"<p>Enables a timing unit counter. <pre><code>void hrtim_cnt_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_init","title":"function hrtim_dt_init","text":"<p>Initialize the dead-time for the PWM. <pre><code>void hrtim_dt_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_dt_set","title":"function hrtim_dt_set","text":"<p>Sets up a dead time in nano second for given complementary outputs. <pre><code>void hrtim_dt_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t rise_ns,\n    uint16_t fall_ns\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>rise_ns</code> The desired dead time of the rising edge in nano second </p> </li> <li><code>fall_ns</code> The desired dead time of the falling edge in nano second </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_duty_cycle_set","title":"function hrtim_duty_cycle_set","text":"<p>Updates the duty cycle of a timing unit. <pre><code>void hrtim_duty_cycle_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>value</code> The desired duty cycle value </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_get","title":"function hrtim_eev_get","text":"<p>Returns the external event trigger used in current mode. <pre><code>hrtim_external_trigger_t hrtim_eev_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <ul> <li>EEV1 = external event 1, </li> <li>EEV2 = external event 2, </li> <li>EEV3 = external event 3, </li> <li>EEV4 = external event 4, </li> <li>EEV5 = external event 5, </li> <li>EEV6 = external event 6, </li> <li>EEV7 = external event 7, </li> <li>EEV8 = external event 8, </li> <li>EEV9 = external event 9 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_eev_set","title":"function hrtim_eev_set","text":"<p>Sets the external event used in current mode for a timing unit. <pre><code>void hrtim_eev_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_external_trigger_t eev\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>adc_trig</code> pwm mode: </p> </li> <li>EEV1 </li> <li>EEV2 </li> <li>EEV3 </li> <li>EEV4 </li> <li>EEV5 </li> <li>EEV6 </li> <li>EEV7 </li> <li>EEV8 </li> <li>EEV9 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_frequency_set","title":"function hrtim_frequency_set","text":"<p>Sets the period of a given timing unit. <pre><code>void hrtim_frequency_set (\n    uint32_t frequency_set,\n    uint32_t frequency_min\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>tu_number</code> Timing unit number: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_apb2_clock","title":"function hrtim_get_apb2_clock","text":"<p>Gets the APB2 clock. <pre><code>int hrtim_get_apb2_clock () \n</code></pre></p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_modulation","title":"function hrtim_get_modulation","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_cnt_t hrtim_get_modulation (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>modulation:  * Lft_aligned,  * UpDwn </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_status","title":"function hrtim_get_status","text":"<p>Returns if the timer was initialized with default value or not. <pre><code>hrtim_tu_ON_OFF_t hrtim_get_status (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>true or false </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_get_switch_convention","title":"function hrtim_get_switch_convention","text":"<p>Gets the switching convention of a given timing unit. <pre><code>hrtim_switch_convention_t hrtim_get_switch_convention (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Switching convention of the given time unit  * HIGH = 0,  * LOW = 1 </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_init_default_all","title":"function hrtim_init_default_all","text":"<p>this function initalize all the default parameters for each timing unit structure <pre><code>void hrtim_init_default_all () \n</code></pre></p> <p>Warning:</p> <p>this function must be called before changing any timing unit parameters (frequency, phase_shift) </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_master_cmp_set","title":"function hrtim_master_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_master_cmp_set (\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmp</code> Master comparators: </li> <li>MCMP1R = 1, </li> <li>MCMP2R = 2 </li> <li>MCMP3R = 3, </li> <li> <p>MCMP4R = 4 </p> </li> <li> <p><code>value</code> Comparator new value to set: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis","title":"function hrtim_out_dis","text":"<p>Disables the output of a given timingg unit. <pre><code>void hrtim_out_dis (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_dis_single","title":"function hrtim_out_dis_single","text":"<p>Disables only one output of a given timing unit. <pre><code>void hrtim_out_dis_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: </li> <li>PWMA1 </li> <li>PWMA2 </li> <li>PWMB1 </li> <li>PWMB2 </li> <li>PWMC1 </li> <li>PWMC2 </li> <li>PWMD1 </li> <li>PWMD2 </li> <li>PWME1 </li> <li>PWME2 </li> <li>PWMF1 </li> <li>PWMF2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en","title":"function hrtim_out_en","text":"<p>Enables the output of a given timing unit. <pre><code>void hrtim_out_en (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_out_en_single","title":"function hrtim_out_en_single","text":"<p>Enables only one output of a given timing unit. <pre><code>void hrtim_out_en_single (\n    hrtim_output_units_t PWM_OUT\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>PWM_OUT</code> Output pin to be chosen: </li> <li>PWMA1 </li> <li>PWMA2 </li> <li>PWMB1 </li> <li>PWMB2 </li> <li>PWMC1 </li> <li>PWMC2 </li> <li>PWMD1 </li> <li>PWMD2 </li> <li>PWME1 </li> <li>PWME2 </li> <li>PWMF1 </li> <li>PWMF2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get","title":"function hrtim_period_Master_get","text":"<p>Returns the period of a master timer. <pre><code>uint16_t hrtim_period_Master_get () \n</code></pre></p> <p>Returns:</p> <p>Period of the master timer </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_master_get_us","title":"function hrtim_period_Master_get_us","text":"<p>Returns the period of the master timer in microseconds. <pre><code>uint32_t hrtim_period_Master_get_us () \n</code></pre></p> <p>Returns:</p> <p>Period of the timer master in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get","title":"function hrtim_period_get","text":"<p>Returns the period of a given timing unit. <pre><code>uint16_t hrtim_period_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Period of the timing unit </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_period_get_us","title":"function hrtim_period_get_us","text":"<p>Returns the period of a given timing unit in microseconds. <pre><code>uint32_t hrtim_period_get_us (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>Period of the timing unit in microseconds </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_phase_shift_set","title":"function hrtim_phase_shift_set","text":"<p>Shifts the PWM of a timing unit. <pre><code>void hrtim_phase_shift_set (\n    hrtim_tu_number_t tu_number,\n    uint16_t shift\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>shift</code> The desired phase shift value </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_get","title":"function hrtim_pwm_mode_get","text":"<p>Returns timing unit pwm mode. <pre><code>hrtim_pwm_mode_t hrtim_pwm_mode_get (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Returns:</p> <p>CURRENT_MODE or VOLTAGE_MODE </p>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_pwm_mode_set","title":"function hrtim_pwm_mode_set","text":"<p>Sets the pwm mode : voltage or current mode. <pre><code>void hrtim_pwm_mode_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_pwm_mode_t mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF</p> </li> <li> <p><code>mode</code> pwm mode: </p> </li> <li>VOLTAGE_MODE </li> <li>CURRENT_MODE </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_dis","title":"function hrtim_rst_evt_dis","text":"<p>Disables a timer counter reset event. <pre><code>void hrtim_rst_evt_dis (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>evt</code> Reset EVent: </p> </li> <li>MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER, </li> <li>MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1, </li> <li>MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2, </li> <li>MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3, </li> <li>MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4, </li> <li>PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_rst_evt_en","title":"function hrtim_rst_evt_en","text":"<p>Enables a timer counter reset event. <pre><code>void hrtim_rst_evt_en (\n    hrtim_tu_number_t tu_number,\n    hrtim_reset_trig_t evt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>evt</code> Reset EVent: </p> </li> <li>MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER, </li> <li>MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1, </li> <li>MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2, </li> <li>MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3, </li> <li>MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4, </li> <li>PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_modulation","title":"function hrtim_set_modulation","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_modulation (\n    hrtim_tu_number_t tu_number,\n    hrtim_cnt_t modulation\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>modulation</code> modulation: </p> </li> <li>Lft_aligned = LL_HRTIM_COUNTING_MODE_UP, </li> <li>UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_set_switch_convention","title":"function hrtim_set_switch_convention","text":"<p>Sets the switching convention of a given timing unit. <pre><code>void hrtim_set_switch_convention (\n    hrtim_tu_number_t tu_number,\n    hrtim_switch_convention_t convention\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li> <p>PWMF </p> </li> <li> <p><code>convention</code> Switching convention: </p> </li> <li>PWMx1 </li> <li>PWMx2 </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_cmp_set","title":"function hrtim_tu_cmp_set","text":"<p>Sets one of the four comparators of the HRTIM master timer. <pre><code>void hrtim_tu_cmp_set (\n    hrtim_tu_number_t tu_number,\n    hrtim_cmp_t cmp,\n    uint16_t value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmp</code> Master comparators: </li> <li>CMP1xR = 1, </li> <li>CMP2xR = 2, </li> <li>CMP3xR = 3, </li> <li> <p>CMP4xR = 4 </p> </li> <li> <p><code>value</code> Comparator new value to set: </p> </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_gpio_init","title":"function hrtim_tu_gpio_init","text":"<p>Initializes the gpio elements of a given timing unit. <pre><code>void hrtim_tu_gpio_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul>"},{"location":"powerAPI/hrtim_8h/#function-hrtim_tu_init","title":"function hrtim_tu_init","text":"<p>Initializes a given timing unit. <pre><code>uint16_t hrtim_tu_init (\n    hrtim_tu_number_t tu_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tu_number</code> Timing unit number: </li> <li>PWMA </li> <li>PWMB </li> <li>PWMC </li> <li>PWMD </li> <li>PWME </li> <li>PWMF </li> </ul> <p>Returns:</p> <p>timing unit period </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim.h</code></p>"},{"location":"powerAPI/hrtim_8h_source/","title":"File hrtim.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n/*\n * @date   2023\n *\n * @author Cl\u00e9ment Foucher &lt;clement.foucher@laas.fr&gt;\n * @author Luiz Villa &lt;luiz.villa@laas.fr&gt;\n * @author Ayoub Farah Hassan &lt;ayoub.farah-hassan@laas.fr&gt;\n */\n\n#ifndef HRTIM_H_\n#define HRTIM_H_\n\n#include &lt;stdint.h&gt;\n#include \"arm_math.h\"\n#include &lt;zephyr/kernel.h&gt;\n#include \"hrtim_enum.h\"\n\n#define TU_DEFAULT_DT (100U)       /* dead-time in ns */\n#define TU_DEFAULT_FREQ (200000U)  /* frequency in Hz */\n#define TU_DEFAULT_PERIOD (27200U) /* default period for 200kHz in bits */\n\n#ifdef HRTIM_MCR_TFCEN\n#define HRTIM_STU_NUMOF (6U) \n#else\n#define HRTIM_STU_NUMOF (5U)\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef struct\n{\n    pwm_conf_t pwm_conf;            /* Pulse Width Modulation Configuration */\n    phase_shift_conf_t phase_shift; /* Phase shift configuration */\n    gpio_conf_t gpio_conf;          /* Pulse width */\n    switch_conv_conf_t switch_conv; /* Switch Convention */\n    adc_hrtim_conf_t adc_hrtim;     /* ADC - HRTIM setup*/\n    comp_usage_conf_t comp_usage;   /* Usage of comp1 to comp4 */\n} timer_hrtim_t;\n\nextern timer_hrtim_t *tu_channel[HRTIM_STU_NUMOF];\n\n\nint hrtim_get_apb2_clock();\n\nvoid hrtim_init_default_all();\n\nuint16_t hrtim_tu_init(hrtim_tu_number_t tu_number);\n\nhrtim_tu_ON_OFF_t hrtim_get_status(hrtim_tu_number_t tu_number);\n\nvoid hrtim_tu_gpio_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_out_en_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_out_dis_single(hrtim_output_units_t PWM_OUT);\n\nvoid hrtim_set_modulation(hrtim_tu_number_t tu_number, hrtim_cnt_t modulation);\n\nhrtim_cnt_t hrtim_get_modulation(hrtim_tu_number_t tu_number);\n\nvoid hrtim_set_switch_convention(hrtim_tu_number_t tu_number, hrtim_switch_convention_t convention);\n\nhrtim_switch_convention_t hrtim_get_switch_convention(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cmpl_pwm_out1(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cmpl_pwm_out2(hrtim_tu_number_t tu_number);\n\nvoid hrtim_frequency_set(uint32_t frequency_set, uint32_t frequency_min);\n\nuint16_t hrtim_period_get(hrtim_tu_number_t tu_number);\n\nuint16_t hrtim_period_Master_get();\n\nuint32_t hrtim_period_get_us(hrtim_tu_number_t tu_number);\n\nuint32_t hrtim_period_Master_get_us();\n\nvoid hrtim_tu_cmp_set(hrtim_tu_number_t tu_number, hrtim_cmp_t cmp, uint16_t value);\n\nvoid hrtim_master_cmp_set(hrtim_cmp_t cmp, uint16_t value);\n\nvoid hrtim_dt_set(hrtim_tu_number_t tu_number, uint16_t rise_ns, uint16_t fall_ns);\n\nvoid hrtim_duty_cycle_set(hrtim_tu_number_t tu_number, uint16_t value);\n\nvoid hrtim_phase_shift_set(hrtim_tu_number_t tu_number, uint16_t shift);\n\nvoid hrtim_dt_init(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cnt_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_cnt_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_rst_evt_en(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_rst_evt_dis(hrtim_tu_number_t tu_number, hrtim_reset_trig_t evt);\n\nvoid hrtim_adc_trigger_set_postscaler(hrtim_tu_number_t tu_number, uint32_t ps_ratio);\n\nvoid hrtim_adc_trigger_en(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_trigger_dis(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_rollover_set(hrtim_tu_number_t tu_number, hrtim_adc_edgetrigger_t adc_rollover);\n\nhrtim_adc_edgetrigger_t hrtim_adc_rollover_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_PeriodicEvent_configure(hrtim_tu_t tu, uint32_t repetition, hrtim_callback_t callback);\n\nvoid hrtim_PeriodicEvent_en(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_dis(hrtim_tu_t tu);\n\nvoid hrtim_PeriodicEvent_SetRep(hrtim_tu_t tu, uint32_t repetition);\n\nuint32_t hrtim_PeriodicEvent_GetRep(hrtim_tu_t tu);\n\nvoid DualDAC_init(hrtim_tu_number_t tu);\n\nvoid hrtim_pwm_mode_set(hrtim_tu_number_t tu_number, hrtim_pwm_mode_t mode);\n\nhrtim_pwm_mode_t hrtim_pwm_mode_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_adc_triger_set(hrtim_tu_number_t tu_number, hrtim_adc_trigger_t adc_trig);\n\nhrtim_adc_trigger_t hrtim_adc_triger_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_eev_set(hrtim_tu_number_t tu_number, hrtim_external_trigger_t eev);\n\nhrtim_external_trigger_t hrtim_eev_get(hrtim_tu_number_t tu_number);\n\nvoid hrtim_change_frequency(uint32_t new_frequency);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // HRTIM_H_\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/","title":"File hrtim_enum.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hrtim__enum_8h/#classes","title":"Classes","text":"Type Name struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. struct switch_conv_conf_t Structure describing the switching convention of a given timing unit."},{"location":"powerAPI/hrtim__enum_8h/#public-types","title":"Public Types","text":"Type Name enum hrtim_adc_edgetrigger_t enum hrtim_adc_event_t HRTIM ADC event update. enum hrtim_adc_source_t HRTIM ADC Event Number and its associated source There are a huge number of possibilities, for now this code explores only a few. enum hrtim_adc_t HRTIM ADC trigger registers definition. enum hrtim_adc_trigger_t HRTIM ADC trigger. typedef void(* hrtim_callback_t callback function enum hrtim_cmp_t HRTIM comparators definition. enum hrtim_cnt_t HRTIM counting mode setting. enum hrtim_comp_usage_t enum hrtim_external_trigger_t External eventcoming from comparator used for current mode. enum hrtim_gpio_clock_number_t HRTIM gpio clock units definition. enum hrtim_out_t timing unit output 1 or 2 enum hrtim_output_number_t enum hrtim_output_reset_t HRTIM output reset units definition. enum hrtim_output_set_t HRTIM output set units definition. enum hrtim_output_units_t HRTIM output units definition. enum hrtim_pwm_mode_t Special PWM mode for current mode. enum hrtim_reset_trig_t HRTIM reset trig source definitions. enum hrtim_switch_convention_t HRTIM TU switch convention PWMx1 : control high-side mosfet PWMx2 : control low-side mosfet. enum hrtim_tu_ON_OFF_t describe if a timing unit has been initialized enum hrtim_tu_number_t HRTIM timing units number definition. enum hrtim_tu_t HRTIM timing units definition."},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t HRTIM_CHANNELS   = = 6"},{"location":"powerAPI/hrtim__enum_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_edgetrigger_t","title":"enum hrtim_adc_edgetrigger_t","text":"<pre><code>enum hrtim_adc_edgetrigger_t {\n    EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n    EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n    EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_event_t","title":"enum hrtim_adc_event_t","text":"<p>HRTIM ADC event update. <pre><code>enum hrtim_adc_event_t {\n    PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n    PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n    PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n    PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n    PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n    PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_source_t","title":"enum hrtim_adc_source_t","text":"<p>HRTIM ADC Event Number and its associated source There are a huge number of possibilities, for now this code explores only a few. <pre><code>enum hrtim_adc_source_t {\n    TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n    TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n    TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n    TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n    TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n    TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n};\n</code></pre></p> <p>Warning:</p> <p>prioritize cmp3, cmp4 and cmp2 might be used for current mode, and cmp1 for duty cycle </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_t","title":"enum hrtim_adc_t","text":"<p>HRTIM ADC trigger registers definition. <pre><code>enum hrtim_adc_t {\n    ADC1R = 1,\n    ADC2R = 2,\n    ADC3R = 3,\n    ADC4R = 4\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_adc_trigger_t","title":"enum hrtim_adc_trigger_t","text":"<p>HRTIM ADC trigger. <pre><code>enum hrtim_adc_trigger_t {\n    ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n    ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n    ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n    ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n    ADCTRIG_NONE\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#typedef-hrtim_callback_t","title":"typedef hrtim_callback_t","text":"<p>callback function <pre><code>typedef void(* hrtim_callback_t) ();\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cmp_t","title":"enum hrtim_cmp_t","text":"<p>HRTIM comparators definition. <pre><code>enum hrtim_cmp_t {\n    CMP1xR = 1,\n    CMP2xR = 2,\n    CMP3xR = 3,\n    CMP4xR = 4,\n    MCMP1R = 5,\n    MCMP2R = 6,\n    MCMP3R = 7,\n    MCMP4R = 8,\n    MCMPER = 10\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_cnt_t","title":"enum hrtim_cnt_t","text":"<p>HRTIM counting mode setting. <pre><code>enum hrtim_cnt_t {\n    Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n    UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_comp_usage_t","title":"enum hrtim_comp_usage_t","text":"<pre><code>enum hrtim_comp_usage_t {\n    USED = true,\n    FREE = false\n};\n</code></pre> <p>comparator usage for a timing unit </p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_external_trigger_t","title":"enum hrtim_external_trigger_t","text":"<p>External eventcoming from comparator used for current mode. <pre><code>enum hrtim_external_trigger_t {\n    EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n    EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n    EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n    EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n    EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n    EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n    EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n    EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n    EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_gpio_clock_number_t","title":"enum hrtim_gpio_clock_number_t","text":"<p>HRTIM gpio clock units definition. <pre><code>enum hrtim_gpio_clock_number_t {\n    CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n    CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n    CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_out_t","title":"enum hrtim_out_t","text":"<p>timing unit output 1 or 2 <pre><code>enum hrtim_out_t {\n    OUT1 = 1,\n    OUT2 = 2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_number_t","title":"enum hrtim_output_number_t","text":"<pre><code>enum hrtim_output_number_t {\n    TIMING_OUTPUT1,\n    TIMING_OUTPUT2\n};\n</code></pre>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_reset_t","title":"enum hrtim_output_reset_t","text":"<p>HRTIM output reset units definition. <pre><code>enum hrtim_output_reset_t {\n    RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n    RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n    RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n    RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n    RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n    RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_set_t","title":"enum hrtim_output_set_t","text":"<p>HRTIM output set units definition. <pre><code>enum hrtim_output_set_t {\n    SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n    SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n    SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n    SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n    SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n    SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_output_units_t","title":"enum hrtim_output_units_t","text":"<p>HRTIM output units definition. <pre><code>enum hrtim_output_units_t {\n    PWMA1 = LL_HRTIM_OUTPUT_TA1,\n    PWMA2 = LL_HRTIM_OUTPUT_TA2,\n    PWMB1 = LL_HRTIM_OUTPUT_TB1,\n    PWMB2 = LL_HRTIM_OUTPUT_TB2,\n    PWMC1 = LL_HRTIM_OUTPUT_TC1,\n    PWMC2 = LL_HRTIM_OUTPUT_TC2,\n    PWMD1 = LL_HRTIM_OUTPUT_TD1,\n    PWMD2 = LL_HRTIM_OUTPUT_TD2,\n    PWME1 = LL_HRTIM_OUTPUT_TE1,\n    PWME2 = LL_HRTIM_OUTPUT_TE2,\n    PWMF1 = LL_HRTIM_OUTPUT_TF1,\n    PWMF2 = LL_HRTIM_OUTPUT_TF2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_pwm_mode_t","title":"enum hrtim_pwm_mode_t","text":"<p>Special PWM mode for current mode. <pre><code>enum hrtim_pwm_mode_t {\n    VOLTAGE_MODE = 0,\n    CURRENT_MODE = 1\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_reset_trig_t","title":"enum hrtim_reset_trig_t","text":"<p>HRTIM reset trig source definitions. <pre><code>enum hrtim_reset_trig_t {\n    MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n    MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n    MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n    MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n    MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n    PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_switch_convention_t","title":"enum hrtim_switch_convention_t","text":"<p>HRTIM TU switch convention PWMx1 : control high-side mosfet PWMx2 : control low-side mosfet. <pre><code>enum hrtim_switch_convention_t {\n    PWMx1 = 0,\n    PWMx2 = 1\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_on_off_t","title":"enum hrtim_tu_ON_OFF_t","text":"<p>describe if a timing unit has been initialized <pre><code>enum hrtim_tu_ON_OFF_t {\n    UNIT_ON = true,\n    UNIT_OFF = false\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_number_t","title":"enum hrtim_tu_number_t","text":"<p>HRTIM timing units number definition. <pre><code>enum hrtim_tu_number_t {\n    PWMA = 0,\n    PWMB = 1,\n    PWMC = 2,\n    PWMD = 3,\n    PWME = 4,\n    PWMF = 5\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#enum-hrtim_tu_t","title":"enum hrtim_tu_t","text":"<p>HRTIM timing units definition. <pre><code>enum hrtim_tu_t {\n    TIMA = LL_HRTIM_TIMER_A,\n    TIMB = LL_HRTIM_TIMER_B,\n    TIMC = LL_HRTIM_TIMER_C,\n    TIMD = LL_HRTIM_TIMER_D,\n    TIME = LL_HRTIM_TIMER_E,\n    TIMF = LL_HRTIM_TIMER_F,\n    MSTR = LL_HRTIM_TIMER_MASTER\n};\n</code></pre></p>"},{"location":"powerAPI/hrtim__enum_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hrtim__enum_8h/#variable-hrtim_channels","title":"variable HRTIM_CHANNELS","text":"<pre><code>const uint8_t HRTIM_CHANNELS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_hrtim_driver/zephyr/public_api/hrtim_enum.h</code></p>"},{"location":"powerAPI/hrtim__enum_8h_source/","title":"File hrtim_enum.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_hrtim_driver &gt; zephyr &gt; public_api &gt; hrtim_enum.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef HRTIM_ENUM_H_\n#define HRTIM_ENUM_H_\n\n#include &lt;stm32_ll_hrtim.h&gt;\n#include &lt;stm32g4xx_ll_gpio.h&gt;\n#include &lt;stm32_ll_bus.h&gt;\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    typedef void (*hrtim_callback_t)();\n\n    static const uint8_t HRTIM_CHANNELS = 6;\n\n\n    typedef enum\n    {\n        TIMA = LL_HRTIM_TIMER_A,\n        TIMB = LL_HRTIM_TIMER_B,\n        TIMC = LL_HRTIM_TIMER_C,\n        TIMD = LL_HRTIM_TIMER_D,\n        TIME = LL_HRTIM_TIMER_E,\n        TIMF = LL_HRTIM_TIMER_F,\n        MSTR = LL_HRTIM_TIMER_MASTER\n    } hrtim_tu_t;\n\n    typedef enum\n    {\n        PWMA = 0,\n        PWMB = 1,\n        PWMC = 2,\n        PWMD = 3,\n        PWME = 4,\n        PWMF = 5\n    } hrtim_tu_number_t;\n\n    typedef enum\n    {\n        CLK_GPIOA = LL_AHB2_GRP1_PERIPH_GPIOA,\n        CLK_GPIOB = LL_AHB2_GRP1_PERIPH_GPIOB,\n        CLK_GPIOC = LL_AHB2_GRP1_PERIPH_GPIOC\n    } hrtim_gpio_clock_number_t;\n\n    typedef enum\n    {\n        MSTR_PER = LL_HRTIM_RESETTRIG_MASTER_PER,\n        MSTR_CMP1 = LL_HRTIM_RESETTRIG_MASTER_CMP1,\n        MSTR_CMP2 = LL_HRTIM_RESETTRIG_MASTER_CMP2,\n        MSTR_CMP3 = LL_HRTIM_RESETTRIG_MASTER_CMP3,\n        MSTR_CMP4 = LL_HRTIM_RESETTRIG_MASTER_CMP4,\n        PWMA_CMP2 = LL_HRTIM_RESETTRIG_OTHER1_CMP2\n    } hrtim_reset_trig_t;\n\n    typedef enum\n    {\n        VOLTAGE_MODE = 0,\n        CURRENT_MODE = 1\n    } hrtim_pwm_mode_t;\n\n    typedef enum\n    {\n        SET_NONE = LL_HRTIM_OUTPUTSET_NONE,\n        SET_CMP1 = LL_HRTIM_OUTPUTSET_TIMCMP1,\n        SET_CMP2 = LL_HRTIM_OUTPUTSET_TIMCMP2,\n        SET_CMP3 = LL_HRTIM_OUTPUTSET_TIMCMP3,\n        SET_CMP4 = LL_HRTIM_OUTPUTSET_TIMCMP4,\n        SET_PER = LL_HRTIM_OUTPUTSET_TIMPER\n    } hrtim_output_set_t;\n\n    typedef enum\n    {\n        RST_NONE = LL_HRTIM_OUTPUTRESET_NONE,\n        RST_CMP1 = LL_HRTIM_OUTPUTRESET_TIMCMP1,\n        RST_CMP2 = LL_HRTIM_OUTPUTRESET_TIMCMP2,\n        RST_CMP3 = LL_HRTIM_OUTPUTRESET_TIMCMP3,\n        RST_CMP4 = LL_HRTIM_OUTPUTRESET_TIMCMP4,\n        RST_PER = LL_HRTIM_OUTPUTRESET_TIMPER\n    } hrtim_output_reset_t;\n\n    typedef enum\n    {\n        PWMA1 = LL_HRTIM_OUTPUT_TA1,\n        PWMA2 = LL_HRTIM_OUTPUT_TA2,\n        PWMB1 = LL_HRTIM_OUTPUT_TB1,\n        PWMB2 = LL_HRTIM_OUTPUT_TB2,\n        PWMC1 = LL_HRTIM_OUTPUT_TC1,\n        PWMC2 = LL_HRTIM_OUTPUT_TC2,\n        PWMD1 = LL_HRTIM_OUTPUT_TD1,\n        PWMD2 = LL_HRTIM_OUTPUT_TD2,\n        PWME1 = LL_HRTIM_OUTPUT_TE1,\n        PWME2 = LL_HRTIM_OUTPUT_TE2,\n        PWMF1 = LL_HRTIM_OUTPUT_TF1,\n        PWMF2 = LL_HRTIM_OUTPUT_TF2\n    } hrtim_output_units_t;\n\n    typedef enum\n    {\n        TIMING_OUTPUT1,\n        TIMING_OUTPUT2,\n    }hrtim_output_number_t;\n\n    typedef enum\n    {\n        ADCTRIG_1 = LL_HRTIM_ADCTRIG_1,\n        ADCTRIG_2 = LL_HRTIM_ADCTRIG_2,\n        ADCTRIG_3 = LL_HRTIM_ADCTRIG_3,\n        ADCTRIG_4 = LL_HRTIM_ADCTRIG_4,\n        ADCTRIG_NONE,\n    } hrtim_adc_trigger_t;\n\n    typedef enum\n    {\n        PWMA_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_A,\n        PWMB_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_B,\n        PWMC_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_C,\n        PWMD_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_D,\n        PWME_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_E,\n        PWMF_UPDT = LL_HRTIM_ADCTRIG_UPDATE_TIMER_F\n    } hrtim_adc_event_t;\n\n    typedef enum\n    {\n        TIMA_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMACMP3,\n        TIMB_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMBCMP3,\n        TIMC_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMCCMP3,\n        TIMD_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMDCMP3,\n        TIME_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMECMP3,\n        TIMF_CMP3 = LL_HRTIM_ADCTRIG_SRC13_TIMFCMP3\n    } hrtim_adc_source_t;\n\n    typedef enum\n    {\n        CMP1xR = 1,\n        CMP2xR = 2,\n        CMP3xR = 3,\n        CMP4xR = 4,\n        MCMP1R = 5,\n        MCMP2R = 6,\n        MCMP3R = 7,\n        MCMP4R = 8,\n        MCMPER = 10\n    } hrtim_cmp_t;\n\n    typedef enum\n    {\n        OUT1 = 1,\n        OUT2 = 2\n    } hrtim_out_t;\n\n    typedef enum\n    {\n        PWMx1 = 0,\n        PWMx2 = 1\n    } hrtim_switch_convention_t;\n\n    typedef enum\n    {\n        USED = true,\n        FREE = false\n    } hrtim_comp_usage_t;\n\n    typedef enum\n    {\n        UNIT_ON = true,\n        UNIT_OFF = false\n    } hrtim_tu_ON_OFF_t;\n\n    typedef enum\n    {\n        ADC1R = 1,\n        ADC2R = 2,\n        ADC3R = 3,\n        ADC4R = 4\n    } hrtim_adc_t;\n\n    typedef enum\n    {\n        EdgeTrigger_up = LL_HRTIM_ROLLOVER_MODE_PER,\n        EdgeTrigger_down = LL_HRTIM_ROLLOVER_MODE_RST,\n        EdgeTrigger_Both = LL_HRTIM_ROLLOVER_MODE_BOTH\n    } hrtim_adc_edgetrigger_t;\n\n    typedef enum\n    {\n        EEV1 = LL_HRTIM_OUTPUTRESET_EEV_1,\n        EEV2 = LL_HRTIM_OUTPUTRESET_EEV_2,\n        EEV3 = LL_HRTIM_OUTPUTRESET_EEV_3,\n        EEV4 = LL_HRTIM_OUTPUTRESET_EEV_4,\n        EEV5 = LL_HRTIM_OUTPUTRESET_EEV_5,\n        EEV6 = LL_HRTIM_OUTPUTRESET_EEV_6,\n        EEV7 = LL_HRTIM_OUTPUTRESET_EEV_7,\n        EEV8 = LL_HRTIM_OUTPUTRESET_EEV_8,\n        EEV9 = LL_HRTIM_OUTPUTRESET_EEV_9\n    } hrtim_external_trigger_t;\n\n    typedef enum\n    {\n        Lft_aligned = LL_HRTIM_COUNTING_MODE_UP,\n        UpDwn = LL_HRTIM_COUNTING_MODE_UP_DOWN // also known as center aligned\n\n    } hrtim_cnt_t;\n\n\n    typedef struct\n    {\n        hrtim_tu_t pwm_tu;                         /* Timing Unit associated with the PWM */\n        uint16_t rise_dead_time;                   /* Rising Edge Dead time */\n        uint16_t fall_dead_time;                   /* Falling Edge Dead time */\n        uint16_t duty_cycle;                       /* Current value of its duty cycle */\n        uint16_t period;                           /* Period used by the unit */\n        uint32_t frequency;                        /* Frequency used by the unit */\n        hrtim_cnt_t modulation;                    /* Type of modulation used for this unit */\n        hrtim_tu_ON_OFF_t unit_on;                 /* State of the time unit (ON/OFF) */\n        uint8_t ckpsc;                             /* Holds the clock pre-scaler of the timing unit */\n        hrtim_pwm_mode_t pwm_mode;                 /* pwm mode for voltage mode or current mode */\n        hrtim_external_trigger_t external_trigger; /* external trigger event for current mode */\n    } pwm_conf_t;\n\n    typedef struct\n    {\n        uint16_t value;                /* Value of the phase shift */\n        hrtim_tu_t compare_tu;         /* Compare timing unit used to make the phase shift */\n        hrtim_reset_trig_t reset_trig; /* Pulse width */\n    } phase_shift_conf_t;\n\n    typedef struct\n    {\n        GPIO_TypeDef *unit;                    /* The GPIO structure to which the TU pins belong */\n        LL_GPIO_InitTypeDef switch_H;          /* Details of the high-side switch gpio */\n        hrtim_output_units_t OUT_H;            /* High-side switch hrtim output unit */\n        LL_GPIO_InitTypeDef switch_L;          /* Details of the low-side switch */\n        hrtim_output_units_t OUT_L;            /* Low-side switch hrtim output unit */\n        hrtim_gpio_clock_number_t tu_gpio_CLK; /* Gpio clock unit */\n    } gpio_conf_t;\n\n    typedef struct\n    {\n        hrtim_switch_convention_t convention; /* High-side or Low-side switch convention */\n        uint32_t set_H[2];                    /* Set event used to the High-side switch on the high-side convention */\n        uint32_t reset_H[2];                  /* Set event used to the Low-side switch on the high-side convention */\n        uint32_t set_L[2];                    /* Set event used to the High-side switch on the high-side convention */\n        uint32_t reset_L[2];                  /* Set event used to the Low-side switch on the high-side convention */\n    } switch_conv_conf_t;\n\n    typedef struct\n    {\n        hrtim_adc_event_t adc_event;       /* ADC event linked to this PWM time unit */\n        hrtim_adc_source_t adc_source;     /* ADC time unit linked to this event */\n        hrtim_adc_trigger_t adc_trigger;   /* ADC trigger between source and event */\n        hrtim_adc_edgetrigger_t adc_rollover; /* ADC rollover only relevant in center aligned */\n    } adc_hrtim_conf_t;\n\n    typedef struct\n    {\n        hrtim_comp_usage_t cmp1; /* Sets if the COMP 1 of the tu is being used */\n        uint16_t cmp1_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp2; /* Sets if the COMP 2 of the tu is being used */\n        uint16_t cmp2_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp3; /* Sets if the COMP 3 of the tu is being used */\n        uint16_t cmp3_value;     /* Sets if the COMP 1 of the tu is being used */\n        hrtim_comp_usage_t cmp4; /* Sets if the COMP 4 of the tu is being used */\n        uint16_t cmp4_value;     /* Sets if the COMP 1 of the tu is being used */\n    } comp_usage_conf_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // COMPARATOR_DRIVER_H_\n</code></pre>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver</p>"},{"location":"powerAPI/dir_487909855ff81a58e51ecefcc10df3bb/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/</code></p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_c984519a7bdbe6c0d73dd876f54bf8c6/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/","title":"Dir docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_b84e60c9f86d8ee8d4badbb0cfc94e11/#files","title":"Files","text":"Type Name file ngnd.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/ngnd_8h/","title":"File ngnd.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/ngnd_8h/#public-functions","title":"Public Functions","text":"Type Name void ngnd_set (const struct device * dev, int value)"},{"location":"powerAPI/ngnd_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/ngnd_8h/#function-ngnd_set","title":"function ngnd_set","text":"<pre><code>void ngnd_set (\n    const struct device * dev,\n    int value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_ngnd_driver/zephyr/public_api/ngnd.h</code></p>"},{"location":"powerAPI/ngnd_8h_source/","title":"File ngnd.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_ngnd_driver &gt; zephyr &gt; public_api &gt; ngnd.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2020-2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef NGND_H_\n#define NGND_H_\n\n\n// Zephyr\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public device name\n\n#define NGND_DEVICE DT_NODELABEL(ngnd)\n\n\n// API\n\nvoid ngnd_set(const struct device* dev, int value);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // NGND_H_\n</code></pre>"},{"location":"powerAPI/dir_cd4faed35847176dcc5b7bcd69c9a669/","title":"Dir docs/core/zephyr/modules/owntech_power_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api</p>"},{"location":"powerAPI/dir_cd4faed35847176dcc5b7bcd69c9a669/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/</code></p>"},{"location":"powerAPI/dir_d7ae7ccaa158b4bef6f2317c7758639a/","title":"Dir docs/core/zephyr/modules/owntech_power_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr</p>"},{"location":"powerAPI/dir_d7ae7ccaa158b4bef6f2317c7758639a/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/</code></p>"},{"location":"powerAPI/dir_483dd9146a51f5f74f5a28f650628f05/","title":"Dir docs/core/zephyr/modules/owntech_power_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_483dd9146a51f5f74f5a28f650628f05/#files","title":"Files","text":"Type Name file TwistAPI.cpp file TwistAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/TwistAPI_8cpp/","title":"File TwistAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr &gt; public_api &gt; TwistAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TwistAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name TwistAPI twist"},{"location":"powerAPI/TwistAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TwistAPI_8cpp/#variable-twist","title":"variable twist","text":"<pre><code>TwistAPI twist;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/public_api/TwistAPI.cpp</code></p>"},{"location":"powerAPI/TwistAPI_8cpp_source/","title":"File TwistAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr &gt; public_api &gt; TwistAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"TwistAPI.h\"\n#include \"../src/power_init.h\"\n\n#include \"SpinAPI.h\"\n\nTwistAPI twist;\n\nhrtim_tu_number_t TwistAPI::spinNumberToTu(uint16_t spin_number)\n{\n    if(spin_number == 12 || spin_number == 14)\n    {\n        return PWMA;\n    }\n    else if(spin_number == 15)\n    {\n        return PWMB;\n    }\n    else if(spin_number == 2 || spin_number == 4)\n    {\n        return PWMC;\n    }\n    else if(spin_number == 5 || spin_number == 6)\n    {\n        return PWMD;\n    }\n    else if(spin_number == 10 || spin_number == 11)\n    {\n        return PWME;\n    }\n    else if(spin_number == 7 || spin_number == 9)\n    {\n        return PWMF;\n    }\n    else\n    {\n        return PWMA;\n    }\n}\n\nvoid TwistAPI::setVersion(twist_version_t twist_ver)\n{\n    if (twist_init == false)\n    {\n        twist_version = twist_ver;\n        twist_init = true;\n    }\n}\n\nvoid TwistAPI::initLegMode(leg_t leg, hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode)\n{\n    spin.pwm.initFrequency(timer_frequency); // Configure PWM frequency\n\n    spin.pwm.setModulation(spinNumberToTu(dt_pwm_pin[leg]), dt_modulation[leg]); // Set modulation\n\n    spin.pwm.setAdcEdgeTrigger(spinNumberToTu(dt_pwm_pin[leg]), dt_edge_trigger[leg]); // Configure ADC rollover in center aligned mode\n\n    if (leg_mode == CURRENT_MODE)\n    {\n        if (dt_current_pin[leg] == CM_DAC3)\n            spin.pwm.setEev(spinNumberToTu(dt_pwm_pin[leg]), EEV4);\n        else if (dt_current_pin[leg] == CM_DAC1)\n            spin.pwm.setEev(spinNumberToTu(dt_pwm_pin[leg]), EEV5);\n\n        /* Configure current mode */\n        spin.pwm.setMode(spinNumberToTu(dt_pwm_pin[leg]), CURRENT_MODE);\n\n    }\n\n    spin.pwm.setSwitchConvention(spinNumberToTu(dt_pwm_pin[leg]), leg_convention); // choose which output of the timer unit to control whith duty cycle\n\n    spin.pwm.initUnit(spinNumberToTu(dt_pwm_pin[leg])); // Initialize leg unit\n\n    spin.pwm.setPhaseShift(spinNumberToTu(dt_pwm_pin[leg]), dt_phase_shift[leg]); // Configure PWM initial phase shift\n\n    spin.pwm.setDeadTime(spinNumberToTu(dt_pwm_pin[leg]), dt_rising_deadtime[leg], dt_falling_deadtime[leg]); // Configure PWM dead time\n\n    if (dt_adc[leg] != ADCTRIG_NONE)\n    {\n        spin.pwm.setAdcDecimation(spinNumberToTu(dt_pwm_pin[leg]), dt_adc_decim[leg]);\n\n        spin.pwm.setAdcTrigger(spinNumberToTu(dt_pwm_pin[leg]), dt_adc[leg]);\n\n        spin.pwm.enableAdcTrigger(spinNumberToTu(dt_pwm_pin[leg]));\n    }\n\n    if (leg_mode == CURRENT_MODE)\n    {\n\n        if (dt_current_pin[leg] == CM_DAC1)\n        {\n            spin.dac.currentModeInit( 1, tu_channel[spinNumberToTu(dt_pwm_pin[leg])]-&gt;pwm_conf.pwm_tu);\n            spin.comp.initialize(3);\n        }\n\n        else if (dt_current_pin[leg] == CM_DAC3)\n        {\n            spin.dac.currentModeInit( 3, tu_channel[spinNumberToTu(dt_pwm_pin[leg])]-&gt;pwm_conf.pwm_tu);\n            spin.comp.initialize(1);\n        }\n    }\n\n    for(uint8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        if(dt_pin_driver[i] != 0) spin.gpio.configurePin(dt_pin_driver[i], OUTPUT);\n        if(dt_pin_capacitor[i] != 0) spin.gpio.configurePin(dt_pin_capacitor[i], OUTPUT);\n    }\n\n    if (twist_init == false) twist_init = true; // When a leg has been initialized, shield version should not be modified\n}\n\nvoid TwistAPI::initAllMode(hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        initLegMode(static_cast&lt;leg_t&gt;(i), leg_convention, leg_mode);\n    }\n}\n\nvoid TwistAPI::setLegDutyCycle(leg_t leg, float32_t duty_leg)\n{\n    if (duty_leg &gt; 0.9)\n        duty_leg = 0.9;\n    else if (duty_leg &lt; 0.1)\n        duty_leg = 0.1;\n    uint16_t value = duty_leg * tu_channel[spinNumberToTu(dt_pwm_pin[leg])]-&gt;pwm_conf.period;\n    hrtim_duty_cycle_set(spinNumberToTu(dt_pwm_pin[leg]), value);\n}\n\nvoid TwistAPI::setAllDutyCycle(float32_t duty_all)\n{\n    if (duty_all &gt; 0.9)\n        duty_all = 0.9;\n    else if (duty_all &lt; 0.1)\n        duty_all = 0.1;\n\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegDutyCycle(static_cast&lt;leg_t&gt;(i), duty_all);\n    }\n}\n\nvoid TwistAPI::startLeg(leg_t leg)\n{\n    if(dt_pin_driver[leg] != 0) spin.gpio.setPin(dt_pin_driver[leg]);\n\n    /* start PWM*/\n    if (!dt_output1_inactive[leg])\n        spin.pwm.startSingleOutput(spinNumberToTu(dt_pwm_pin[leg]), TIMING_OUTPUT1);\n    if (!dt_output2_inactive[leg])\n        spin.pwm.startSingleOutput(spinNumberToTu(dt_pwm_pin[leg]), TIMING_OUTPUT2);\n}\n\nvoid TwistAPI::connectLegCapacitor(leg_t leg)\n{\n    if(dt_pin_capacitor[leg] != 0) spin.gpio.setPin(dt_pin_capacitor[leg]);\n}\n\nvoid TwistAPI::startAll()\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        startLeg(static_cast&lt;leg_t&gt;(i));\n    }\n}\n\nvoid TwistAPI::connectAllCapacitor()\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        connectLegCapacitor(static_cast&lt;leg_t&gt;(i));\n    }\n}\n\nvoid TwistAPI::stopLeg(leg_t leg)\n{\n    /* Stop PWM */\n    spin.pwm.stopDualOutput(spinNumberToTu(dt_pwm_pin[leg]));\n\n    if(dt_pin_driver[leg] != 0) spin.gpio.resetPin(dt_pin_driver[leg]);\n}\n\nvoid TwistAPI::disconnectLegCapacitor(leg_t leg)\n{\n    if(dt_pin_capacitor[leg] != 0) spin.gpio.resetPin(dt_pin_capacitor[leg]);\n}\n\nvoid TwistAPI::stopAll()\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        stopLeg(static_cast&lt;leg_t&gt;(i));\n    }\n}\n\nvoid TwistAPI::disconnectAllCapacitor()\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        disconnectLegCapacitor(static_cast&lt;leg_t&gt;(i));\n    }\n}\n\nvoid TwistAPI::setLegSlopeCompensation(leg_t leg, float32_t set_voltage, float32_t reset_voltage)\n{\n    switch (dt_current_pin[leg])\n    {\n    case CM_DAC1:\n        spin.dac.slopeCompensation(1, set_voltage, reset_voltage);\n        break;\n    case CM_DAC3:\n        spin.dac.slopeCompensation(3, set_voltage, reset_voltage);\n        break;\n    default:\n        break;\n    }\n}\n\nvoid TwistAPI::setAllSlopeCompensation(float32_t set_voltage, float32_t reset_voltage)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegSlopeCompensation(static_cast&lt;leg_t&gt;(i), set_voltage, reset_voltage);\n    }\n}\n\nvoid TwistAPI::setLegTriggerValue(leg_t leg, float32_t trigger_value)\n{\n    if (trigger_value &gt; 0.95)\n        trigger_value = 0.95;\n    else if (trigger_value &lt; 0.05)\n        trigger_value = 0.05;\n    spin.pwm.setAdcTriggerInstant(spinNumberToTu(dt_pwm_pin[leg]), trigger_value);\n\n}\n\nvoid TwistAPI::setAllTriggerValue(float32_t trigger_value)\n{\n    if (trigger_value &gt; 0.95)\n        trigger_value = 0.95;\n    else if (trigger_value &lt; 0.05)\n        trigger_value = 0.05;\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegTriggerValue(static_cast&lt;leg_t&gt;(i), trigger_value);\n    }\n}\n\nvoid TwistAPI::setLegPhaseShift(leg_t leg, int16_t phase_shift)\n{\n    spin.pwm.setPhaseShift(spinNumberToTu(dt_pwm_pin[leg]), phase_shift);\n\n}\n\nvoid TwistAPI::setAllPhaseShift(int16_t phase_shift)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegPhaseShift(static_cast&lt;leg_t&gt;(i), phase_shift);\n    }\n}\n\nvoid TwistAPI::setLegDeadTime(leg_t leg, uint16_t ns_rising_dt, uint16_t ns_falling_dt)\n{\n    spin.pwm.setDeadTime(spinNumberToTu(dt_pwm_pin[leg]), ns_rising_dt, ns_falling_dt);\n}\n\nvoid TwistAPI::setAllDeadTime(uint16_t ns_rising_dt, uint16_t ns_falling_dt)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegDeadTime(static_cast&lt;leg_t&gt;(i), ns_rising_dt, ns_falling_dt);\n    }\n}\n\nvoid TwistAPI::setLegAdcDecim(leg_t leg, uint16_t adc_decim)\n{\n    spin.pwm.setAdcDecimation(spinNumberToTu(dt_pwm_pin[leg]), adc_decim);\n}\n\nvoid TwistAPI::setAllAdcDecim(uint16_t adc_decim)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        setLegAdcDecim(static_cast&lt;leg_t&gt;(i), adc_decim);\n    }\n}\n\nvoid TwistAPI::initLegBuck(leg_t leg, hrtim_pwm_mode_t leg_mode)\n{\n    if (spinNumberToTu(dt_pwm_pin[leg]) == PWMA &amp;&amp; twist_version == shield_TWIST_V1_2)\n        initLegMode(leg, PWMx2, leg_mode);\n    else\n        initLegMode(leg, PWMx1, leg_mode);\n}\n\nvoid TwistAPI::initAllBuck(hrtim_pwm_mode_t leg_mode)\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        initLegBuck(static_cast&lt;leg_t&gt;(i), leg_mode);\n    }\n}\n\nvoid TwistAPI::initLegBoost(leg_t leg)\n{\n    if (spinNumberToTu(dt_pwm_pin[leg]) == PWMA &amp;&amp; twist_version == shield_TWIST_V1_2)\n        initLegMode(leg, PWMx1, VOLTAGE_MODE);\n    else\n        initLegMode(leg, PWMx2, VOLTAGE_MODE);\n}\n\nvoid TwistAPI::initAllBoost()\n{\n    for (int8_t i = 0; i &lt; dt_leg_count; i++)\n    {\n        initLegBoost(static_cast&lt;leg_t&gt;(i));\n    }\n}\n</code></pre>"},{"location":"powerAPI/TwistAPI_8h/","title":"File TwistAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr &gt; public_api &gt; TwistAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TwistAPI_8h/#classes","title":"Classes","text":"Type Name class TwistAPI"},{"location":"powerAPI/TwistAPI_8h/#public-types","title":"Public Types","text":"Type Name enum leg_t enum twist_version_t"},{"location":"powerAPI/TwistAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name TwistAPI twist"},{"location":"powerAPI/TwistAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/TwistAPI_8h/#enum-leg_t","title":"enum leg_t","text":"<pre><code>enum leg_t {\n    DT_FOREACH_CHILD_STATUS_OKAY =(DT_NODELABEL(power_shield), LEG_TOKEN)\n};\n</code></pre>"},{"location":"powerAPI/TwistAPI_8h/#enum-twist_version_t","title":"enum twist_version_t","text":"<pre><code>enum twist_version_t {\n    shield_TWIST_V1_2 = 0,\n    shield_TWIST_V1_3,\n    shield_TWIST_V1_4,\n    shield_ownverter,\n    shield_other\n};\n</code></pre>"},{"location":"powerAPI/TwistAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TwistAPI_8h/#variable-twist","title":"variable twist","text":"<pre><code>TwistAPI twist;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_power_api/zephyr/public_api/TwistAPI.h</code></p>"},{"location":"powerAPI/TwistAPI_8h_source/","title":"File TwistAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_power_api &gt; zephyr &gt; public_api &gt; TwistAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef POWER_H_\n#define POWER_H_\n\n#include &lt;zephyr/kernel.h&gt;\n#include \"arm_math.h\"\n#include \"hrtim_enum.h\"\n\n#define LEG_TOKEN(node_id) DT_STRING_TOKEN(node_id, leg_name),\n\n/* All the leg with okay status in the device tree */\ntypedef enum\n{\n    DT_FOREACH_CHILD_STATUS_OKAY(DT_NODELABEL(power_shield), LEG_TOKEN)\n} leg_t;\n\n/* Enum to define the hardware version */\ntypedef enum\n{\n    shield_TWIST_V1_2 = 0,\n    shield_TWIST_V1_3,\n    shield_TWIST_V1_4,\n    shield_ownverter,\n    shield_other,\n} twist_version_t;\n\nclass TwistAPI\n{\nprivate:\n    twist_version_t twist_version = shield_other; // shield version\n    bool twist_init = false;                        // check if shield version has been initalized or not\n\n    hrtim_tu_number_t spinNumberToTu(uint16_t spin_number); // return timing unit from spin pin number\n\npublic:\n    void setVersion(twist_version_t twist_ver);\n\n    void initLegMode(leg_t leg, hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode);\n\n    void initAllMode(hrtim_switch_convention_t leg_convention, hrtim_pwm_mode_t leg_mode);\n\n    void setLegDutyCycle(leg_t leg, float32_t duty_leg);\n\n    void setAllDutyCycle(float32_t duty_all);\n\n    void startLeg(leg_t leg);\n\n    void connectLegCapacitor(leg_t leg);\n\n    void startAll();\n\n    void connectAllCapacitor();\n\n    void stopLeg(leg_t leg);\n\n    void disconnectLegCapacitor(leg_t leg);\n\n    void stopAll();\n\n    void disconnectAllCapacitor();\n\n    void setLegTriggerValue(leg_t leg, float32_t trigger_value);\n\n    void setAllTriggerValue(float32_t trigger_value);\n\n    void setLegPhaseShift(leg_t leg, int16_t phase_shift);\n\n    void setAllPhaseShift(int16_t phase_shift);\n\n    void setLegSlopeCompensation(leg_t leg, float32_t set_voltage, float32_t reset_voltage);\n\n    void setAllSlopeCompensation(float32_t set_voltage, float32_t reset_voltage);\n\n    void setLegDeadTime(leg_t leg, uint16_t ns_rising_dt, uint16_t ns_falling_dt);\n\n    void setAllDeadTime(uint16_t ns_rising_dt, uint16_t ns_falling_dt);\n\n    void setLegAdcDecim(leg_t leg, uint16_t adc_decim);\n\n    void setAllAdcDecim(uint16_t adc_decim);\n\n    void initLegBuck(leg_t leg, hrtim_pwm_mode_t leg_mode = VOLTAGE_MODE);\n\n    void initAllBuck(hrtim_pwm_mode_t leg_mode = VOLTAGE_MODE);\n\n    void initLegBoost(leg_t leg);\n\n    void initAllBoost();\n};\n\n// Public object to interact with the class\nextern TwistAPI twist;\n\n#endif // TWISTAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/","title":"Dir docs/core/zephyr/modules/owntech_safety_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api</p>"},{"location":"powerAPI/dir_6577260132b49845d494a112d8acd7c7/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/</code></p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr</p>"},{"location":"powerAPI/dir_2f6071fc869091a6d1e6d7b806fecbf0/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/</code></p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/","title":"Dir docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_08eec7c34983a0acd3982b6352a40f84/#files","title":"Files","text":"Type Name file SafetyAPI.cpp file SafetyAPI.h file safety_internal.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp/","title":"File SafetyAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name safety Safety"},{"location":"powerAPI/SafetyAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8cpp/#variable-safety","title":"variable Safety","text":"<pre><code>safety Safety;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.cpp</code></p>"},{"location":"powerAPI/SafetyAPI_8cpp_source/","title":"File SafetyAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"SafetyAPI.h\"\n#include \"../src/safety_shield.h\"\n#include \"../src/safety_setting.h\"\n\nsafety Safety;\n\nvoid safety::init_shield()\n{\n    safety_init_shield(true);\n}\n\nvoid safety::init_shield(channel_t* channels_watch, uint8_t channels_watch_number)\n{\n    safety_init_shield(false);\n    safety_set_channel_watch(channels_watch, channels_watch_number);\n}\n\nint8_t safety::setChannelWatch(channel_t* channels_watch, uint8_t channels_watch_number)\n{\n    int8_t status =  safety_set_channel_watch(channels_watch, channels_watch_number);\n    return status;\n}\n\nint8_t safety::unsetChannelWatch(channel_t* channels_watch, uint8_t channels_watch_number)\n{\n    int8_t status =  safety_unset_channel_watch(channels_watch, channels_watch_number);\n    return status;\n}\n\nbool safety::getChannelWatch(channel_t  channels_watch)\n{\n    bool Is_watched = safety_get_channel_watch(channels_watch);\n    return Is_watched;\n}\n\nvoid safety::setChannelReaction(safety_reaction_t channels_reaction)\n{\n    safety_set_channel_reaction(channels_reaction);\n\n}\n\nsafety_reaction_t safety::getChannelReaction()\n{\n    safety_reaction_t channels_reaction = safety_get_channel_reaction();\n    return channels_reaction;\n}\n\nint8_t safety::setChannelThresholdMax(channel_t *channels_threshold, float32_t *threshold_max, uint8_t channels_threshold_number)\n{\n    uint8_t ret =  safety_set_channel_threshold_max(channels_threshold, threshold_max, channels_threshold_number);\n    return ret;\n}\n\nint8_t safety::setChannelThresholdMin(channel_t *channels_threshold, float32_t *threshold_min, uint8_t channels_threshold_number)\n{\n    uint8_t ret =  safety_set_channel_threshold_min(channels_threshold, threshold_min, channels_threshold_number);\n    return ret;\n}\n\nfloat32_t safety::getChannelThresholdMax(channel_t channels_threshold)\n{\n    float32_t threshold = safety_get_channel_threshold_max(channels_threshold);\n    return threshold;\n}\n\nfloat32_t safety::getChannelThresholdMin(channel_t channels_threshold)\n{\n    float32_t threshold = safety_get_channel_threshold_min(channels_threshold);\n    return threshold;\n}\n\nbool safety::getChannelError(channel_t channels_error)\n{\n    bool error_status = safety_get_channel_error(channels_error);\n    return error_status;\n}\n\nvoid safety::enableSafetyApi()\n{\n    safety_enable_task();\n}\n\nvoid safety::disableSafetyApi()\n{\n    safety_disable_task();\n}\n\nint8_t safety::storeThreshold(channel_t channel_threshold_store)\n{\n    uint8_t ret = safety_store_threshold_in_nvs(channel_threshold_store);\n    return ret;\n}\n\nint8_t safety::retrieveThreshold(channel_t channel_threshold_retrieve)\n{\n    uint8_t ret = safety_retrieve_threshold_in_nvs(channel_threshold_retrieve);\n    return ret;\n}\n</code></pre>"},{"location":"powerAPI/SafetyAPI_8h/","title":"File SafetyAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SafetyAPI_8h/#classes","title":"Classes","text":"Type Name class safety"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name safety Safety"},{"location":"powerAPI/SafetyAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SafetyAPI_8h/#variable-safety","title":"variable Safety","text":"<pre><code>safety Safety;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/SafetyAPI.h</code></p>"},{"location":"powerAPI/SafetyAPI_8h_source/","title":"File SafetyAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; SafetyAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SAFETY_H_\n#define SAFETY_H_\n\n#include \"arm_math.h\"\n#include \"DataAPI.h\"\n#include \"../src/safety_enum.h\"\n\n\nclass safety{\n\n    public:\n\n    void init_shield();\n\n    void init_shield(channel_t* channels_watch, uint8_t channels_watch_number);\n\n    int8_t setChannelWatch(channel_t* channels_watch, uint8_t channels_watch_number);\n\n    int8_t unsetChannelWatch(channel_t* channels_watch, uint8_t channels_watch_number);\n\n    bool getChannelWatch(channel_t  channels_watch);\n\n    void setChannelReaction(safety_reaction_t channels_reaction);\n\n    safety_reaction_t getChannelReaction();\n\n    int8_t setChannelThresholdMax(channel_t *channels_threshold, float32_t *threshold_max, uint8_t channels_threshold_number);\n\n    int8_t setChannelThresholdMin(channel_t *channels_threshold, float32_t *threshold_min, uint8_t channels_threshold_number);\n\n    float32_t getChannelThresholdMax(channel_t channels_threshold);\n\n    float32_t getChannelThresholdMin(channel_t channels_threshold);\n\n    bool getChannelError(channel_t channels_error);\n\n\n    void enableSafetyApi();\n\n    void disableSafetyApi();\n\n    int8_t storeThreshold(channel_t channel_threshold_store);\n\n    int8_t retrieveThreshold(channel_t channel_threshold_retrieve);\n};\n\nextern safety Safety;\n\n#endif // SAFETY_H_\n</code></pre>"},{"location":"powerAPI/safety__internal_8h/","title":"File safety_internal.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/safety__internal_8h/#public-functions","title":"Public Functions","text":"Type Name int8_t safety_task () This function first watch the measure from the monitored channels, and compare it with the threshold values max/min to detect faults. If an error was detected, the siwtches will either in open-circuit mode or in short-circuit mode."},{"location":"powerAPI/safety__internal_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/safety__internal_8h/#function-safety_task","title":"function safety_task","text":"<p>This function first watch the measure from the monitored channels, and compare it with the threshold values max/min to detect faults. If an error was detected, the siwtches will either in open-circuit mode or in short-circuit mode. <pre><code>int8_t safety_task () \n</code></pre></p> <p>Returns:</p> <p>0 if we did not detect any error, -1 else </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_safety_api/zephyr/public_api/safety_internal.h</code></p>"},{"location":"powerAPI/safety__internal_8h_source/","title":"File safety_internal.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_safety_api &gt; zephyr &gt; public_api &gt; safety_internal.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SAFETY_INTERNAL_H_\n#define SAFETY_INTERNAL_H_\n\n#include \"arm_math.h\"\n\nint8_t safety_task();\n\n#endif // SAFETY_INTERNAL_H_\n</code></pre>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/","title":"Dir docs/core/zephyr/modules/owntech_spin_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api</p>"},{"location":"powerAPI/dir_87330bcbf7fe698536ea5946c1b90585/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/</code></p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr</p>"},{"location":"powerAPI/dir_83abe2f3de580445b50d57f614c989e1/#directories","title":"Directories","text":"Type Name dir public_api dir src <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/</code></p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_9feddb36ca121fb6172e0f3e47b6ec72/#files","title":"Files","text":"Type Name file SpinAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/SpinAPI_8h/","title":"File SpinAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/SpinAPI_8h/#classes","title":"Classes","text":"Type Name class SpinAPI Contains all the elements linked to peripherals of the spin board."},{"location":"powerAPI/SpinAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/SpinAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/SpinAPI_8h/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/public_api/SpinAPI.h</code></p>"},{"location":"powerAPI/SpinAPI_8h_source/","title":"File SpinAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; public_api &gt; SpinAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef SPINAPI_H_\n#define SPINAPI_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// Private sources include\n#include \"../src/LedHAL.h\"\n#include \"../src/DacHAL.h\"\n#include \"../src/CompHAL.h\"\n#include \"../src/PwmHAL.h\"\n#include \"../src/AdcHAL.h\"\n#include \"../src/UartHAL.h\"\n#include \"../src/TimerHAL.h\"\n#include \"../src/VersionHAL.h\"\n#include \"../src/GpioHAL.h\"\n\n\n#ifdef CONFIG_SHIELD_TWIST\n    #include \"../src/NgndHAL.h\"\n#endif\n\n\n\nclass SpinAPI\n{\n\npublic:\n\n    GpioHAL gpio;\n\n    LedHAL led;\n\n    DacHAL dac;\n\n    CompHAL comp;\n\n    PwmHAL pwm;\n\n    AdcHAL adc;\n\n    UartHAL uart;\n\n    TimerHAL timer;\n\n    VersionHAL version;\n\n#ifdef CONFIG_SHIELD_TWIST\n    NgndHAL ngnd;\n#endif\n\n};\n\n\n// Public object to interact with the class\n\nextern SpinAPI spin;\n\n\n#endif // SPINAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/","title":"Dir docs/core/zephyr/modules/owntech_spin_api/zephyr/src","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src</p>"},{"location":"powerAPI/dir_b0a9bfd1c37d418dc07d30cb79a776da/#files","title":"Files","text":"Type Name file AdcHAL.cpp file AdcHAL.h file CompHAL.cpp file CompHAL.h file DacHAL.cpp file DacHAL.h file GpioHAL.cpp file GpioHAL.h file LedHAL.cpp file LedHAL.h file NgndHAL.cpp file NgndHAL.h file PwmHAL.cpp file PwmHAL.h file TimerHAL.cpp file TimerHAL.h file UartHAL.cpp file UartHAL.h file VersionHAL.cpp file VersionHAL.h file hardware_auto_configuration.cpp <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/</code></p>"},{"location":"powerAPI/AdcHAL_8cpp/","title":"File AdcHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; AdcHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/AdcHAL.cpp</code></p>"},{"location":"powerAPI/AdcHAL_8cpp_source/","title":"File AdcHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; AdcHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// OwnTech Power API\n#include \"adc.h\"\n\n// Current file header\n#include \"AdcHAL.h\"\n\n\nbool AdcHAL::adcInitialized = false;\n\n\nvoid AdcHAL::initializeAllAdcs()\n{\n    if (adcInitialized == false)\n    {\n        // Perform default configuration\n        adc_configure_trigger_source(1, software);\n        adc_configure_trigger_source(2, software);\n        adc_configure_trigger_source(3, software);\n        adc_configure_trigger_source(4, software);\n        adc_configure_trigger_source(5, software);\n\n        adcInitialized = 1;\n    }\n}\n\nvoid AdcHAL::configureTriggerSource(uint8_t adc_number, adc_ev_src_t trigger_source)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_configure_trigger_source(adc_number, trigger_source);\n}\n\nvoid AdcHAL::configureDiscontinuousMode(uint8_t adc_number, uint32_t discontinuous_count)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_configure_discontinuous_mode(adc_number, discontinuous_count);\n}\n\nvoid AdcHAL::enableChannel(uint8_t adc_num, uint8_t channel)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_add_channel(adc_num, channel);\n}\n\nvoid AdcHAL::disableChannel(uint8_t adc_num, uint8_t channel)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_remove_channel(adc_num, channel);\n}\n\nuint32_t AdcHAL::getEnabledChannelsCount(uint8_t adc_number)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    return adc_get_enabled_channels_count(adc_number);\n}\n\nvoid AdcHAL::enableDma(uint8_t adc_num, bool use_dma)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_configure_use_dma(adc_num, use_dma);\n}\n\nvoid AdcHAL::startAllAdcs()\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_start();\n}\n\nvoid AdcHAL::stopAllAdcs()\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_stop();\n}\n\nvoid AdcHAL::triggerSoftwareConversion(uint8_t adc_number, uint8_t number_of_acquisitions)\n{\n    // Make sure module is initialized\n\n    if (adcInitialized == false)\n    {\n        initializeAllAdcs();\n    }\n\n    // Proceed\n\n    adc_trigger_software_conversion(adc_number, number_of_acquisitions);\n}\n</code></pre>"},{"location":"powerAPI/AdcHAL_8h/","title":"File AdcHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; AdcHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/AdcHAL_8h/#classes","title":"Classes","text":"Type Name class AdcHAL Handles the ADC for the spin board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/AdcHAL.h</code></p>"},{"location":"powerAPI/AdcHAL_8h_source/","title":"File AdcHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; AdcHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef ADCHAL_H_\n#define ADCHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// OwnTech API\n#include \"adc.h\"\n\n\n\n\nclass AdcHAL\n{\npublic:\n\n    void configureTriggerSource(uint8_t adc_number, adc_ev_src_t trigger_source);\n\n    void configureDiscontinuousMode(uint8_t adc_number, uint32_t dicontinuous_count);\n\n    void enableDma(uint8_t adc_number, bool use_dma);\n\n    void enableChannel(uint8_t adc_number, uint8_t channel);\n\n    void disableChannel(uint8_t adc_number, uint8_t channel);\n\n    uint32_t getEnabledChannelsCount(uint8_t adc_number);\n\n    void triggerSoftwareConversion(uint8_t adc_number, uint8_t number_of_acquisitions);\n\n    void startAllAdcs();\n\n    void stopAllAdcs();\n\nprivate:\n\n    void initializeAllAdcs();\n\n    static bool adcInitialized;\n\n\n};\n\n\n\n#endif // ADCHAL_H_\n</code></pre>"},{"location":"powerAPI/CompHAL_8cpp/","title":"File CompHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.cpp</code></p>"},{"location":"powerAPI/CompHAL_8cpp_source/","title":"File CompHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// OwnTech low level module\n#include \"comparator.h\"\n\n// Current file header\n#include \"CompHAL.h\"\n\n\nvoid CompHAL::initialize(uint8_t comparator_number){\n\n    if (comparator_number == 1){\n        comparator1_init();\n    } else if(comparator_number ==3){\n        comparator3_init();\n    }\n}\n</code></pre>"},{"location":"powerAPI/CompHAL_8h/","title":"File CompHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/CompHAL_8h/#classes","title":"Classes","text":"Type Name class CompHAL Handles comparator 1 and 3 of the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/CompHAL.h</code></p>"},{"location":"powerAPI/CompHAL_8h_source/","title":"File CompHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; CompHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef COMPHAL_H_\n#define COMPHAL_H_\n\nclass CompHAL\n{\npublic:\n    void initialize(uint8_t comparator_number);\n};\n\n\n\n#endif // COMPHAL_H_\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/","title":"File DacHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * dac1   = = DEVICE_DT_GET(DAC1_DEVICE) const struct device * dac2   = = DEVICE_DT_GET(DAC2_DEVICE) const struct device * dac3   = = DEVICE_DT_GET(DAC3_DEVICE)"},{"location":"powerAPI/DacHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/DacHAL_8cpp/#variable-dac1","title":"variable dac1","text":"<pre><code>const struct device* dac1;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac2","title":"variable dac2","text":"<pre><code>const struct device* dac2;\n</code></pre>"},{"location":"powerAPI/DacHAL_8cpp/#variable-dac3","title":"variable dac3","text":"<pre><code>const struct device* dac3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.cpp</code></p>"},{"location":"powerAPI/DacHAL_8cpp_source/","title":"File DacHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n// Owntech drivers\n#include \"dac.h\"\n#include \"hrtim.h\"\n\n// Current file header\n#include \"DacHAL.h\"\n\n// Define the voltage reference used for ADC.\n// It depends on the board used (On nucleo, choose Vref = 2.48V).\n\n#define VREF 2.048f\n\nstatic const struct device* dac1 = DEVICE_DT_GET(DAC1_DEVICE);\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\nstatic const struct device* dac3 = DEVICE_DT_GET(DAC3_DEVICE);\n\nvoid DacHAL::initConstValue(uint8_t dac_number)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        dac_dev = dac2; // sets the dac 2 as default\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, 1, 0);\n        dac_pin_configure(dac_dev, 1, dac_pin_external);\n        dac_start(dac_dev, 1);\n    }\n}\n\nvoid DacHAL::setConstValue(uint8_t dac_number, uint8_t channel, uint32_t const_value)\n{\n    const struct device* dac_dev;\n\n    if (dac_number == 1)\n    {\n        dac_dev = dac1;\n    }\n    else if (dac_number == 3)\n    {\n        dac_dev = dac3;\n    }\n    else\n    {\n        dac_dev = dac2; // sets the dac 2 as default\n    }\n\n    if (device_is_ready(dac_dev) == true)\n    {\n        dac_set_const_value(dac_dev, channel, const_value);\n    }\n}\n\nvoid DacHAL::currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src)\n{\n    if (dac_number == 1){// DAC 1\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac1, 1, &amp;function_config);\n        dac_pin_configure(dac1, 1, dac_pin_internal_and_external);\n        dac_start(dac1, 1);\n    } else if(dac_number == 3){\n        // DAC 3\n        dac_function_config_t function_config =\n        {\n            .dac_function = dac_function_sawtooth,\n            .reset_trigger_source = hrtim_trig1,\n            .step_trigger_source = hrtim_trig1,\n            .polarity = dac_polarity_decrement,\n            .reset_data = 4000,\n            .step_data = 200\n        };\n\n        switch (tu_src)\n        {\n        case TIMB:\n            function_config.reset_trigger_source = hrtim_trig2;\n            function_config.step_trigger_source = hrtim_trig2;\n            break;\n\n        case TIMC:\n            function_config.reset_trigger_source = hrtim_trig3;\n            function_config.step_trigger_source = hrtim_trig3;\n            break;\n\n        case TIMD:\n            function_config.reset_trigger_source = hrtim_trig4;\n            function_config.step_trigger_source = hrtim_trig4;\n            break;\n\n        case TIME:\n            function_config.reset_trigger_source = hrtim_trig5;\n            function_config.step_trigger_source = hrtim_trig5;\n            break;\n\n        case TIMF:\n            function_config.reset_trigger_source = hrtim_trig6;\n            function_config.step_trigger_source = hrtim_trig6;\n            break;\n\n        default:\n            break;\n        }\n\n        dac_set_function(dac3, 1, &amp;function_config);\n        dac_pin_configure(dac3, 1, dac_pin_internal);\n        dac_start(dac3, 1);\n    } else {\n        //does nothing - Should return an error\n    }\n}\n\n\nvoid DacHAL::slopeCompensation(uint8_t dac_number, float32_t set_voltage, float32_t reset_voltage)\n{\n    float32_t Dv = set_voltage - reset_voltage;\n\n        if (Dv &lt; 0)\n            Dv = 0;\n\n        if (Dv &gt; set_voltage)\n        {\n            Dv = set_voltage;\n            if (Dv &gt; VREF)\n                Dv = VREF;\n        }\n\n        uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n        if (set_data &gt; 4095U)\n            set_data = 4095U;\n\n    if (dac_number == 1){\n\n        dac_function_update_reset(dac1, 1, set_data);\n\n        uint32_t reset_data = (uint32_t)(Dv * 65536U) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n        dac_function_update_step(dac1, 1, reset_data);\n    } else if (dac_number == 3){\n\n\n        dac_function_update_reset(dac3, 1, set_data);\n\n        uint32_t reset_data = (uint32_t)(Dv * 65536) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n        dac_function_update_step(dac3, 1, reset_data);\n    }\n}\n\n\n\n// void DacHAL::dacConfigDac3CurrentmodeInit(hrtim_tu_t tu_src)\n// {\n//  // DAC 3\n//  dac_function_config_t function_config =\n//  {\n//      .dac_function = dac_function_sawtooth,\n//      .reset_trigger_source = hrtim_trig1,\n//      .step_trigger_source = hrtim_trig1,\n//      .polarity = dac_polarity_decrement,\n//      .reset_data = 4000,\n//      .step_data = 200\n//  };\n\n//  switch (tu_src)\n//  {\n//  case TIMB:\n//      function_config.reset_trigger_source = hrtim_trig2;\n//      function_config.step_trigger_source = hrtim_trig2;\n//      break;\n\n//  case TIMC:\n//      function_config.reset_trigger_source = hrtim_trig3;\n//      function_config.step_trigger_source = hrtim_trig3;\n//      break;\n\n//  case TIMD:\n//      function_config.reset_trigger_source = hrtim_trig4;\n//      function_config.step_trigger_source = hrtim_trig4;\n//      break;\n\n//  case TIME:\n//      function_config.reset_trigger_source = hrtim_trig5;\n//      function_config.step_trigger_source = hrtim_trig5;\n//      break;\n\n//  case TIMF:\n//      function_config.reset_trigger_source = hrtim_trig6;\n//      function_config.step_trigger_source = hrtim_trig6;\n//      break;\n\n//  default:\n//      break;\n//  }\n\n//  dac_set_function(dac3, 1, &amp;function_config);\n//  dac_pin_configure(dac3, 1, dac_pin_internal);\n//  dac_start(dac3, 1);\n// }\n\n// void DacHAL::slopeCompensationDac3(float32_t set_voltage, float32_t reset_voltage)\n// {\n//  float32_t Dv = set_voltage - reset_voltage;\n\n//  if (Dv &lt; 0)\n//      Dv = 0;\n\n//  if (Dv &gt; set_voltage)\n//  {\n//      Dv = set_voltage;\n//      if (Dv &gt; VREF)\n//          Dv = VREF;\n//  }\n\n//  uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n//  if (set_data &gt; 4095U)\n//      set_data = 4095U;\n\n//  dac_function_update_reset(dac3, 1, set_data);\n\n//  uint32_t reset_data = (uint32_t)(Dv * 65536) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n//  dac_function_update_step(dac3, 1, reset_data);\n// }\n\n// void DacHAL::slopeCompensationDac1(float32_t set_voltage, float32_t reset_voltage)\n// {\n//  float32_t Dv = set_voltage - reset_voltage;\n\n//  if (Dv &lt; 0)\n//      Dv = 0;\n\n//  if (Dv &gt; set_voltage)\n//      Dv = set_voltage;\n\n//  if (Dv &gt; VREF)\n//      Dv = VREF;\n\n//  uint32_t set_data = (uint32_t)(4096U * set_voltage) / (VREF);\n\n//  if (set_data &gt; 4095U)\n//      set_data = 4095U;\n\n//  dac_function_update_reset(dac1, 1, set_data);\n\n//  uint32_t reset_data = (uint32_t)(Dv * 65536U) / (VREF * 100); // divided by 100 because we have 100 voltage steps\n\n//  dac_function_update_step(dac1, 1, reset_data);\n// }\n</code></pre>"},{"location":"powerAPI/DacHAL_8h/","title":"File DacHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/DacHAL_8h/#classes","title":"Classes","text":"Type Name class DacHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/DacHAL.h</code></p>"},{"location":"powerAPI/DacHAL_8h_source/","title":"File DacHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; DacHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef DACHAL_H_\n#define DACHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n//OwnTech Modules\n#include \"hrtim_enum.h\"\n\n\nclass DacHAL\n{\npublic:\n    void initConstValue(uint8_t dac_number);\n    void setConstValue(uint8_t dac_number, uint8_t channel, uint32_t const_value);\n    void slopeCompensation(uint8_t dac_number, float32_t peak_voltage, float32_t low_voltage);\n    void currentModeInit(uint8_t dac_number, hrtim_tu_t tu_src);\n};\n\n\n\n#endif // DAC_HAL_H_\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/","title":"File GpioHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A   = = DEVICE_DT_GET(DT_NODELABEL(gpioa))Owntech GPIO API. const struct device *const GPIO_B   = = DEVICE_DT_GET(DT_NODELABEL(gpiob)) const struct device *const GPIO_C   = = DEVICE_DT_GET(DT_NODELABEL(gpioc)) const struct device *const GPIO_D   = = DEVICE_DT_GET(DT_NODELABEL(gpiod)) const gpio_flags_t INPUT   = = GPIO_INPUT const gpio_flags_t INPUT_PULLUP   = = GPIO_INPUT | GPIO_PULL_UP const gpio_flags_t OUTPUT   = = GPIO_OUTPUT"},{"location":"powerAPI/GpioHAL_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8cpp/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.cpp</code></p>"},{"location":"powerAPI/GpioHAL_8cpp_source/","title":"File GpioHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#include \"GpioHAL.h\"\n\nconst struct device* const GPIO_A = DEVICE_DT_GET(DT_NODELABEL(gpioa));\nconst struct device* const GPIO_B = DEVICE_DT_GET(DT_NODELABEL(gpiob));\nconst struct device* const GPIO_C = DEVICE_DT_GET(DT_NODELABEL(gpioc));\nconst struct device* const GPIO_D = DEVICE_DT_GET(DT_NODELABEL(gpiod));\n\nconst gpio_flags_t INPUT        = GPIO_INPUT;\nconst gpio_flags_t INPUT_PULLUP = GPIO_INPUT | GPIO_PULL_UP;\nconst gpio_flags_t OUTPUT       = GPIO_OUTPUT;\n\n\nvoid GpioHAL::configurePin(uint8_t pin, gpio_flags_t flags)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_configure(port, pin_number, flags);\n    }\n}\n\nvoid GpioHAL::setPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 1);\n    }\n}\n\nvoid GpioHAL::resetPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, 0);\n    }\n}\n\nvoid GpioHAL::togglePin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_toggle(port, pin_number);\n    }\n}\n\nvoid GpioHAL::writePin(uint8_t pin, uint8_t value)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        gpio_pin_set(port, pin_number, value);\n    }\n}\n\nuint8_t GpioHAL::readPin(uint8_t pin)\n{\n    gpio_pin_t pin_number = this-&gt;getPinNumber(pin);\n    const struct device* port = this-&gt;getGpioDevice(pin);\n    if (port != nullptr)\n    {\n        return (uint8_t) gpio_pin_get(port, pin_number);\n    }\n\n    return 0;\n}\n\ngpio_pin_t GpioHAL::getPinNumber(uint8_t pin)\n{\n    if ( (pin &amp; 0x80) != 0) // Nucleo format\n    {\n        return (((uint8_t)pin) &amp; 0x0F);\n    }\n    else // Pin number\n    {\n        if      (pin == 1)  return 11;\n        else if (pin == 2)  return 12;\n        else if (pin == 4)  return 13;\n        else if (pin == 5)  return 14;\n        else if (pin == 6)  return 15;\n        else if (pin == 7)  return 6;\n        else if (pin == 9)  return 7;\n        else if (pin == 10) return 8;\n        else if (pin == 11) return 9;\n        else if (pin == 12) return 8;\n        else if (pin == 14) return 9;\n        else if (pin == 15) return 10;\n        else if (pin == 16) return 10;\n        else if (pin == 17) return 11;\n        else if (pin == 19) return 12;\n        else if (pin == 20) return 4;\n        else if (pin == 21) return 9;\n        else if (pin == 22) return 13;\n        else if (pin == 24) return 0;\n        else if (pin == 25) return 1;\n        else if (pin == 26) return 2;\n        else if (pin == 27) return 3;\n        else if (pin == 29) return 0;\n        else if (pin == 30) return 1;\n        else if (pin == 31) return 0;\n        else if (pin == 32) return 5;\n        else if (pin == 34) return 6;\n        else if (pin == 35) return 4;\n        else if (pin == 37) return 1;\n        else if (pin == 41) return 10;\n        else if (pin == 42) return 2;\n        else if (pin == 43) return 5;\n        else if (pin == 44) return 7;\n        else if (pin == 45) return 4;\n        else if (pin == 46) return 13;\n        else if (pin == 47) return 14;\n        else if (pin == 48) return 15;\n        else if (pin == 49) return 2;\n        else if (pin == 50) return 3;\n        else if (pin == 51) return 2;\n        else if (pin == 52) return 3;\n        else if (pin == 53) return 5;\n        else if (pin == 55) return 6;\n        else if (pin == 56) return 7;\n        else if (pin == 58) return 8;\n    }\n    return 0xFF;\n}\n\nconst struct device* GpioHAL::getGpioDevice(uint8_t pin)\n{\n    if ( (pin &amp; 0x80) != 0) // Nucleo format\n    {\n        uint8_t deviceNumber = ((uint8_t)pin) &amp; 0xF0;\n        switch (deviceNumber)\n        {\n            case PA:\n                return GPIO_A;\n                break;\n            case PB:\n                return GPIO_B;\n                break;\n            case PC:\n                return GPIO_C;\n                break;\n            case PD:\n                return GPIO_D;\n                break;\n        }\n    }\n    else // Pin number\n    {\n        switch (pin)\n        {\n            case 12:\n            case 14:\n            case 15:\n            case 29:\n            case 30:\n            case 32:\n            case 34:\n            case 44:\n            case 45:\n            case 46:\n            case 47:\n            case 48:\n            case 51:\n            case 52:\n                return GPIO_A;\n                break;\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n            case 6:\n            case 20:\n            case 21:\n            case 31:\n            case 37:\n            case 41:\n            case 42:\n            case 50:\n            case 53:\n            case 55:\n            case 56:\n            case 58:\n                return GPIO_B;\n                break;\n            case 7:\n            case 9:\n            case 10:\n            case 11:\n            case 16:\n            case 17:\n            case 19:\n            case 22:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 35:\n            case 43:\n                return GPIO_C;\n                break;\n            case 49:\n                return GPIO_D;\n                break;\n        }\n    }\n\n    return nullptr;\n}\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/","title":"File GpioHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/GpioHAL_8h/#classes","title":"Classes","text":"Type Name class GpioHAL"},{"location":"powerAPI/GpioHAL_8h/#public-types","title":"Public Types","text":"Type Name enum uint8_t pin_t"},{"location":"powerAPI/GpioHAL_8h/#public-attributes","title":"Public Attributes","text":"Type Name const struct device *const GPIO_A Owntech GPIO API. const struct device *const GPIO_B const struct device *const GPIO_C const struct device *const GPIO_D const gpio_flags_t INPUT const gpio_flags_t INPUT_PULLUP const gpio_flags_t OUTPUT"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const uint8_t P0   = = 0x0 const uint8_t P1   = = 0x1 const uint8_t P10   = = 0xA const uint8_t P11   = = 0xB const uint8_t P12   = = 0xC const uint8_t P13   = = 0xD const uint8_t P14   = = 0xE const uint8_t P15   = = 0xF const uint8_t P2   = = 0x2 const uint8_t P3   = = 0x3 const uint8_t P4   = = 0x4 const uint8_t P5   = = 0x5 const uint8_t P6   = = 0x6 const uint8_t P7   = = 0x7 const uint8_t P8   = = 0x8 const uint8_t P9   = = 0x9 const uint8_t PA   = = 0x80 | 0x00 const uint8_t PB   = = 0x80 | 0x10 const uint8_t PC   = = 0x80 | 0x20 const uint8_t PD   = = 0x80 | 0x30"},{"location":"powerAPI/GpioHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#enum-pin_t","title":"enum pin_t","text":"<pre><code>enum pin_t {\n    PA0 = PA | P0,\n    PA1 = PA | P1,\n    PA2 = PA | P2,\n    PA3 = PA | P3,\n    PA4 = PA | P4,\n    PA5 = PA | P5,\n    PA6 = PA | P6,\n    PA7 = PA | P7,\n    PA8 = PA | P8,\n    PA9 = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0 = PB | P0,\n    PB1 = PB | P1,\n    PB2 = PB | P2,\n    PB3 = PB | P3,\n    PB4 = PB | P4,\n    PB5 = PB | P5,\n    PB6 = PB | P6,\n    PB7 = PB | P7,\n    PB8 = PB | P8,\n    PB9 = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0 = PC | P0,\n    PC1 = PC | P1,\n    PC2 = PC | P2,\n    PC3 = PC | P3,\n    PC4 = PC | P4,\n    PC5 = PC | P5,\n    PC6 = PC | P6,\n    PC7 = PC | P7,\n    PC8 = PC | P8,\n    PC9 = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0 = PD | P0,\n    PD1 = PD | P1,\n    PD2 = PD | P2,\n    PD3 = PD | P3\n};\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_a","title":"variable GPIO_A","text":"<p>Owntech GPIO API. <pre><code>const struct device* const GPIO_A;\n</code></pre></p> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_b","title":"variable GPIO_B","text":"<pre><code>const struct device* const GPIO_B;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_c","title":"variable GPIO_C","text":"<pre><code>const struct device* const GPIO_C;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-gpio_d","title":"variable GPIO_D","text":"<pre><code>const struct device* const GPIO_D;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input","title":"variable INPUT","text":"<pre><code>const gpio_flags_t INPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-input_pullup","title":"variable INPUT_PULLUP","text":"<pre><code>const gpio_flags_t INPUT_PULLUP;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-output","title":"variable OUTPUT","text":"<pre><code>const gpio_flags_t OUTPUT;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/GpioHAL_8h/#variable-p0","title":"variable P0","text":"<pre><code>const uint8_t P0;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p1","title":"variable P1","text":"<pre><code>const uint8_t P1;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p10","title":"variable P10","text":"<pre><code>const uint8_t P10;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p11","title":"variable P11","text":"<pre><code>const uint8_t P11;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p12","title":"variable P12","text":"<pre><code>const uint8_t P12;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p13","title":"variable P13","text":"<pre><code>const uint8_t P13;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p14","title":"variable P14","text":"<pre><code>const uint8_t P14;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p15","title":"variable P15","text":"<pre><code>const uint8_t P15;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p2","title":"variable P2","text":"<pre><code>const uint8_t P2;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p3","title":"variable P3","text":"<pre><code>const uint8_t P3;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p4","title":"variable P4","text":"<pre><code>const uint8_t P4;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p5","title":"variable P5","text":"<pre><code>const uint8_t P5;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p6","title":"variable P6","text":"<pre><code>const uint8_t P6;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p7","title":"variable P7","text":"<pre><code>const uint8_t P7;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p8","title":"variable P8","text":"<pre><code>const uint8_t P8;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-p9","title":"variable P9","text":"<pre><code>const uint8_t P9;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pa","title":"variable PA","text":"<pre><code>const uint8_t PA;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pb","title":"variable PB","text":"<pre><code>const uint8_t PB;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pc","title":"variable PC","text":"<pre><code>const uint8_t PC;\n</code></pre>"},{"location":"powerAPI/GpioHAL_8h/#variable-pd","title":"variable PD","text":"<pre><code>const uint8_t PD;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/GpioHAL.h</code></p>"},{"location":"powerAPI/GpioHAL_8h_source/","title":"File GpioHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; GpioHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef GPIOHAL_H_\n#define GPIOHAL_H_\n\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n\n// Public constants\n\nextern const struct device* const GPIO_A;\nextern const struct device* const GPIO_B;\nextern const struct device* const GPIO_C;\nextern const struct device* const GPIO_D;\n\nextern const gpio_flags_t INPUT;\nextern const gpio_flags_t INPUT_PULLUP;\nextern const gpio_flags_t OUTPUT;\n\n// 0x80 is used to indicate nucleo-style pin\nstatic const uint8_t PA = 0x80 | 0x00;\nstatic const uint8_t PB = 0x80 | 0x10;\nstatic const uint8_t PC = 0x80 | 0x20;\nstatic const uint8_t PD = 0x80 | 0x30;\n\nstatic const uint8_t P0  = 0x0;\nstatic const uint8_t P1  = 0x1;\nstatic const uint8_t P2  = 0x2;\nstatic const uint8_t P3  = 0x3;\nstatic const uint8_t P4  = 0x4;\nstatic const uint8_t P5  = 0x5;\nstatic const uint8_t P6  = 0x6;\nstatic const uint8_t P7  = 0x7;\nstatic const uint8_t P8  = 0x8;\nstatic const uint8_t P9  = 0x9;\nstatic const uint8_t P10 = 0xA;\nstatic const uint8_t P11 = 0xB;\nstatic const uint8_t P12 = 0xC;\nstatic const uint8_t P13 = 0xD;\nstatic const uint8_t P14 = 0xE;\nstatic const uint8_t P15 = 0xF;\n\n\n// Public types\n\ntypedef enum : uint8_t\n{\n    PA0  = PA | P0,\n    PA1  = PA | P1,\n    PA2  = PA | P2,\n    PA3  = PA | P3,\n    PA4  = PA | P4,\n    PA5  = PA | P5,\n    PA6  = PA | P6,\n    PA7  = PA | P7,\n    PA8  = PA | P8,\n    PA9  = PA | P9,\n    PA10 = PA | P10,\n    PA11 = PA | P11,\n    PA12 = PA | P12,\n    PA13 = PA | P13,\n    PA14 = PA | P14,\n    PA15 = PA | P15,\n    PB0  = PB | P0,\n    PB1  = PB | P1,\n    PB2  = PB | P2,\n    PB3  = PB | P3,\n    PB4  = PB | P4,\n    PB5  = PB | P5,\n    PB6  = PB | P6,\n    PB7  = PB | P7,\n    PB8  = PB | P8,\n    PB9  = PB | P9,\n    PB10 = PB | P10,\n    PB11 = PB | P11,\n    PB12 = PB | P12,\n    PB13 = PB | P13,\n    PB14 = PB | P14,\n    PB15 = PB | P15,\n    PC0  = PC | P0,\n    PC1  = PC | P1,\n    PC2  = PC | P2,\n    PC3  = PC | P3,\n    PC4  = PC | P4,\n    PC5  = PC | P5,\n    PC6  = PC | P6,\n    PC7  = PC | P7,\n    PC8  = PC | P8,\n    PC9  = PC | P9,\n    PC10 = PC | P10,\n    PC11 = PC | P11,\n    PC12 = PC | P12,\n    PC13 = PC | P13,\n    PC14 = PC | P14,\n    PC15 = PC | P15,\n    PD0  = PD | P0,\n    PD1  = PD | P1,\n    PD2  = PD | P2,\n    PD3  = PD | P3\n} pin_t;\n\n\n// Class definition\n\nclass GpioHAL\n{\npublic:\n\n    void configurePin(uint8_t pin, gpio_flags_t flags);\n\n    void setPin(uint8_t pin);\n\n    void resetPin(uint8_t pin);\n\n    void togglePin(uint8_t pin);\n\n    void writePin(uint8_t pin, uint8_t value);\n\n    uint8_t readPin(uint8_t pin);\n\nprivate:\n    gpio_pin_t getPinNumber(uint8_t pin);\n    const struct device* getGpioDevice(uint8_t pin);\n\n};\n\n#endif // GPIOHAL_H_\n</code></pre>"},{"location":"powerAPI/LedHAL_8cpp/","title":"File LedHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name struct gpio_dt_spec led_pin_spec   = = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios)"},{"location":"powerAPI/LedHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/LedHAL_8cpp/#variable-led_pin_spec","title":"variable led_pin_spec","text":"<pre><code>struct gpio_dt_spec led_pin_spec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.cpp</code></p>"},{"location":"powerAPI/LedHAL_8cpp_source/","title":"File LedHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n// Current file header\n#include \"LedHAL.h\"\n\n\nbool LedHAL::ledInitialized = false;\n\nstatic struct gpio_dt_spec led_pin_spec = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\n\n\nvoid LedHAL::initialize()\n{\n    gpio_pin_configure_dt(&amp;led_pin_spec, GPIO_OUTPUT_INACTIVE);\n    ledInitialized = true;\n}\n\nvoid LedHAL::turnOn()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 1);\n}\n\nvoid LedHAL::turnOff()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_set_dt(&amp;led_pin_spec, 0);\n}\n\nvoid LedHAL::toggle()\n{\n    if (ledInitialized == false)\n    {\n        initialize();\n    }\n\n    gpio_pin_toggle_dt(&amp;led_pin_spec);\n}\n</code></pre>"},{"location":"powerAPI/LedHAL_8h/","title":"File LedHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/LedHAL_8h/#classes","title":"Classes","text":"Type Name class LedHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/LedHAL.h</code></p>"},{"location":"powerAPI/LedHAL_8h_source/","title":"File LedHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; LedHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef LEDHAL_H_\n#define LEDHAL_H_\n\nclass LedHAL\n{\npublic:\n    void turnOn();\n    void turnOff();\n    void toggle();\n\nprivate:\n    // Private functions\n    void initialize();\n\n    // Private variables\n    static bool ledInitialized;\n\n};\n\n\n\n#endif // LED_H_\n</code></pre>"},{"location":"powerAPI/NgndHAL_8cpp/","title":"File NgndHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; NgndHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/NgndHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * ngnd_switch   = = DEVICE_DT_GET(NGND_DEVICE)"},{"location":"powerAPI/NgndHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/NgndHAL_8cpp/#variable-ngnd_switch","title":"variable ngnd_switch","text":"<pre><code>const struct device* ngnd_switch;\n</code></pre> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/NgndHAL.cpp</code></p>"},{"location":"powerAPI/NgndHAL_8cpp_source/","title":"File NgndHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; NgndHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Owntech driver\n#include \"ngnd.h\"\n\n// Current file header\n#include \"NgndHAL.h\"\n\n\nstatic const struct device* ngnd_switch = DEVICE_DT_GET(NGND_DEVICE);\n\n\nvoid NgndHAL::turnOn()\n{\n    if (device_is_ready(ngnd_switch) == true)\n    {\n        ngnd_set(ngnd_switch, 1);\n    }\n}\n\nvoid NgndHAL::turnOff()\n{\n    if (device_is_ready(ngnd_switch) == true)\n    {\n        ngnd_set(ngnd_switch, 0);\n    }\n}\n</code></pre>"},{"location":"powerAPI/NgndHAL_8h/","title":"File NgndHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; NgndHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/NgndHAL_8h/#classes","title":"Classes","text":"Type Name class NgndHAL <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/NgndHAL.h</code></p>"},{"location":"powerAPI/NgndHAL_8h_source/","title":"File NgndHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; NgndHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef NGNDHAL_H_\n#define NGNDHAL_H_\n\n\nclass NgndHAL\n{\npublic:\n\n    void turnOn();\n\n    void turnOff();\n\nprivate:\n\n\n};\n\n\n\n#endif // LED_H_\n</code></pre>"},{"location":"powerAPI/PwmHAL_8cpp/","title":"File PwmHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.cpp</code></p>"},{"location":"powerAPI/PwmHAL_8cpp_source/","title":"File PwmHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// OwnTech Power API\n\n// Current file header\n#include \"PwmHAL.h\"\n#include \"hrtim.h\" // PWM management layer by inverter leg interface\n\nvoid PwmHAL::initUnit(hrtim_tu_number_t pwmX)\n{\n    hrtim_tu_init(pwmX);\n}\n\nvoid PwmHAL::startDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_en(pwmX);\n}\n\nvoid PwmHAL::stopDualOutput(hrtim_tu_number_t pwmX)\n{\n    hrtim_out_dis(pwmX);\n}\n\nvoid PwmHAL::startSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_en_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_en_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_en_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_en_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_en_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_en_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::stopSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output)\n{\n    if (output == TIMING_OUTPUT1)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA1);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB1);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC1);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD1);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME1);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF1);\n            break;\n        default:\n            break;\n        }\n    }\n    else if (output == TIMING_OUTPUT2)\n    {\n        switch (tu)\n        {\n        case PWMA:\n            hrtim_out_dis_single(PWMA2);\n            break;\n        case PWMB:\n            hrtim_out_dis_single(PWMB2);\n            break;\n        case PWMC:\n            hrtim_out_dis_single(PWMC2);\n            break;\n        case PWMD:\n            hrtim_out_dis_single(PWMD2);\n            break;\n        case PWME:\n            hrtim_out_dis_single(PWME2);\n            break;\n        case PWMF:\n            hrtim_out_dis_single(PWMF2);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid PwmHAL::setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_set_modulation(pwmX, modulation);\n}\n\nvoid PwmHAL::setSwitchConvention(hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_set_switch_convention(pwmX, convention);\n}\n\nvoid PwmHAL::initFrequency(uint32_t init_frequency, uint32_t minimal_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_frequency_set(init_frequency, minimal_frequency);\n}\n\nvoid PwmHAL::initFrequency(uint32_t init_frequency)\n{\n    if (!hrtim_get_status(PWMA))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_frequency_set(init_frequency, init_frequency);\n}\n\nvoid PwmHAL::setDeadTime(hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_dt_set(pwmX, rise_ns, fall_ns);\n}\n\nvoid PwmHAL::setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle)\n{\n    uint16_t value = duty_cycle * tu_channel[pwmX]-&gt;pwm_conf.period;\n    hrtim_duty_cycle_set(pwmX, value);\n}\n\nvoid PwmHAL::setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift)\n{\n    int16_t phase_shift_degree = shift % 360; // modulo\n    if (phase_shift_degree &lt; 0)\n        phase_shift_degree += 360; // case of negative phase\n    uint16_t period;\n    if (pwmX != PWMB)\n    {\n        period = hrtim_period_get(pwmX);\n        if (hrtim_get_modulation(pwmX) == UpDwn)\n            period = 2 * period;\n    }\n    else if (pwmX == PWMB)\n    {\n        period = hrtim_period_get(PWMA);\n    }\n    uint16_t phase_shift_int = (period * phase_shift_degree) / 360;\n    hrtim_phase_shift_set(pwmX, phase_shift_int);\n}\n\nhrtim_cnt_t PwmHAL::getModulation(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_modulation(pwmX);\n}\n\nhrtim_switch_convention_t PwmHAL::getSwitchConvention(hrtim_tu_number_t pwmX)\n{\n    return hrtim_get_switch_convention(pwmX);\n}\n\nuint16_t PwmHAL::getPeriod(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get(pwmX);\n}\n\nvoid PwmHAL::setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio)\n{\n    hrtim_adc_trigger_set_postscaler(pwmX, ps_ratio);\n}\n\nvoid PwmHAL::enableAdcTrigger(hrtim_tu_number_t pwmX)\n{\n    uint16_t initial_trigger_value; // initial trigger value when you enable the adc trigger\n    hrtim_adc_trigger_en(pwmX);\n    if (hrtim_get_modulation(pwmX) == UpDwn)\n    {\n        initial_trigger_value = 0.06 * hrtim_period_get(pwmX);\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n    else\n    {\n        initial_trigger_value = 100;\n        hrtim_tu_cmp_set(pwmX, CMP3xR, initial_trigger_value);\n    }\n}\n\nvoid PwmHAL::setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val)\n{\n    uint16_t triger_value_int = trig_val * hrtim_period_get(pwmX);\n    hrtim_tu_cmp_set(pwmX, CMP3xR, triger_value_int);\n}\n\nvoid PwmHAL::disableAdcTrigger(hrtim_tu_number_t tu_number)\n{\n    hrtim_adc_trigger_dis(tu_number);\n}\n\nvoid PwmHAL::configurePeriodEvnt(hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback)\n{\n    hrtim_PeriodicEvent_configure(PWM_tu, repetition, callback);\n}\n\nvoid PwmHAL::enablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_en(PWM_tu);\n}\n\nvoid PwmHAL::disablePeriodEvnt(hrtim_tu_t PWM_tu)\n{\n    hrtim_PeriodicEvent_dis(PWM_tu);\n}\n\nvoid PwmHAL::setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition)\n{\n    hrtim_PeriodicEvent_SetRep(PWM_tu, repetition);\n}\n\nuint32_t PwmHAL::getPeriodEvntRep(hrtim_tu_t PWM_tu)\n{\n    return hrtim_PeriodicEvent_GetRep(PWM_tu);\n}\n\nuint32_t PwmHAL::getPeriodUs(hrtim_tu_number_t pwmX)\n{\n    return hrtim_period_get_us(pwmX);\n}\n\nvoid PwmHAL::setAdcEdgeTrigger(hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_adc_rollover_set(pwmX, adc_edge_trigger);\n}\n\nhrtim_adc_edgetrigger_t PwmHAL::getAdcEdgeTrigger(hrtim_tu_number_t pwmX)\n{\n    return hrtim_adc_rollover_get(pwmX);\n}\n\nvoid PwmHAL::setAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_adc_triger_set(pwmX, adc_trig);\n}\n\nhrtim_adc_trigger_t PwmHAL::getAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig)\n{\n    return hrtim_adc_triger_get(pwmX);\n}\n\nvoid PwmHAL::setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_pwm_mode_set(pwmX, mode);\n}\n\nhrtim_pwm_mode_t PwmHAL::getMode(hrtim_tu_number_t pwmX)\n{\n    return hrtim_pwm_mode_get(pwmX);\n}\n\nvoid PwmHAL::setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev)\n{\n    if (!hrtim_get_status(pwmX))\n        hrtim_init_default_all(); // initialize default parameters before\n    hrtim_eev_set(pwmX, eev);\n}\n\nhrtim_external_trigger_t PwmHAL::getEev(hrtim_tu_number_t pwmX)\n{\n    return hrtim_eev_get(pwmX);\n}\n\nvoid PwmHAL::setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation)\n{\n    if (decimation &gt; 32)\n        decimation = 32;\n    else if (decimation &lt; 1)\n        decimation = 1;\n    hrtim_adc_trigger_set_postscaler(pwmX, decimation - 1);\n}\n\nvoid PwmHAL::setFrequency(uint32_t frequency_update)\n{\n    hrtim_change_frequency(frequency_update);\n}\n</code></pre>"},{"location":"powerAPI/PwmHAL_8h/","title":"File PwmHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/PwmHAL_8h/#classes","title":"Classes","text":"Type Name class PwmHAL Handles all pwm signals for the spin board."},{"location":"powerAPI/PwmHAL_8h/#public-types","title":"Public Types","text":"Type Name enum inverter_modulation_t enum leg_operation_t"},{"location":"powerAPI/PwmHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/PwmHAL_8h/#enum-inverter_modulation_t","title":"enum inverter_modulation_t","text":"<pre><code>enum inverter_modulation_t {\n    unipolar,\n    bipolar\n};\n</code></pre> <p>Inverter leg operation type. </p>"},{"location":"powerAPI/PwmHAL_8h/#enum-leg_operation_t","title":"enum leg_operation_t","text":"<pre><code>enum leg_operation_t {\n    buck,\n    boost\n};\n</code></pre> <p>Switch leg operation type. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/PwmHAL.h</code></p>"},{"location":"powerAPI/PwmHAL_8h_source/","title":"File PwmHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; PwmHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef PWMHAL_H_\n#define PWMHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// OwnTech API\n#include \"adc.h\"\n#include \"hrtim_enum.h\"\n\ntypedef enum\n{\n     buck,\n     boost\n} leg_operation_t;\n\ntypedef enum\n{\n     unipolar,\n     bipolar\n} inverter_modulation_t;\n\nclass PwmHAL\n{\npublic:\n     // HRTIM configuration\n\n     void initUnit(hrtim_tu_number_t pwmX);\n\n     void startDualOutput(hrtim_tu_number_t pwmX);\n\n     void stopDualOutput(hrtim_tu_number_t pwmX);\n\n     void startSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void stopSingleOutput(hrtim_tu_number_t tu, hrtim_output_number_t output);\n\n     void setModulation(hrtim_tu_number_t pwmX, hrtim_cnt_t modulation);\n\n     void setSwitchConvention(hrtim_tu_number_t pwmX, hrtim_switch_convention_t convention);\n\n     void initFrequency(uint32_t init_frequency);\n\n     void initFrequency(uint32_t init_frequency, uint32_t minimal_frequency);\n\n     void setDeadTime(hrtim_tu_number_t pwmX, uint16_t rise_ns, uint16_t fall_ns);\n\n     void setDutyCycle(hrtim_tu_number_t pwmX, float32_t duty_cycle);\n\n     void setPhaseShift(hrtim_tu_number_t pwmX, int16_t shift);\n\n     void setMode(hrtim_tu_number_t pwmX, hrtim_pwm_mode_t mode);\n\n     hrtim_pwm_mode_t getMode(hrtim_tu_number_t pwmX);\n\n     void setEev(hrtim_tu_number_t pwmX, hrtim_external_trigger_t eev);\n\n     hrtim_external_trigger_t getEev(hrtim_tu_number_t pwmX);\n\n     hrtim_cnt_t getModulation(hrtim_tu_number_t pwmX);\n\n     hrtim_switch_convention_t getSwitchConvention(hrtim_tu_number_t pwmX);\n\n     uint16_t getPeriod(hrtim_tu_number_t pwmX);\n\n     void setAdcTriggerPostScaler(hrtim_tu_number_t pwmX, uint32_t ps_ratio);\n\n     void setAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig);\n\n     hrtim_adc_trigger_t getAdcTrigger(hrtim_tu_number_t pwmX, hrtim_adc_trigger_t adc_trig);\n\n     void enableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void disableAdcTrigger(hrtim_tu_number_t tu_number);\n\n     void setAdcTriggerInstant(hrtim_tu_number_t pwmX, float32_t trig_val);\n\n     void setAdcEdgeTrigger(hrtim_tu_number_t pwmX, hrtim_adc_edgetrigger_t adc_edge_trigger);\n\n     hrtim_adc_edgetrigger_t getAdcEdgeTrigger(hrtim_tu_number_t pwmX);\n\n     void setAdcDecimation(hrtim_tu_number_t pwmX, uint32_t decimation);\n\n     void disablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     void setPeriodEvntRep(hrtim_tu_t PWM_tu, uint32_t repetition);\n\n     uint32_t getPeriodEvntRep(hrtim_tu_t PWM_tu);\n\n     void configurePeriodEvnt(hrtim_tu_t PWM_tu, uint32_t repetition, hrtim_callback_t callback);\n\n     void enablePeriodEvnt(hrtim_tu_t PWM_tu);\n\n     uint32_t getPeriodUs(hrtim_tu_number_t pwmX);\n\n     void setFrequency(uint32_t frequency_update);\n};\n\n#endif // PWMHAL_H_\n</code></pre>"},{"location":"powerAPI/TimerHAL_8cpp/","title":"File TimerHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * timer4   = = DEVICE_DT_GET(TIMER4_DEVICE)"},{"location":"powerAPI/TimerHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/TimerHAL_8cpp/#variable-timer4","title":"variable timer4","text":"<pre><code>const struct device* timer4;\n</code></pre> <p>Date:</p> <p>2023 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.cpp</code></p>"},{"location":"powerAPI/TimerHAL_8cpp_source/","title":"File TimerHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current file header\n#include \"TimerHAL.h\"\n\n\nstatic const struct device* timer4 = DEVICE_DT_GET(TIMER4_DEVICE);\n\nbool TimerHAL::timer4init    = false;\nbool TimerHAL::timer4started = false;\n\n\nvoid TimerHAL::timer4Initialize()\n{\n    if (device_is_ready(timer4) == true)\n    {\n        // Configure timer\n        struct timer_config_t timer_cfg =\n        {\n            .timer_enable_irq = 0,\n            .timer_enable_encoder = 1,\n            .timer_enc_pin_mode = pull_up\n\n        };\n        timer_config(timer4, &amp;timer_cfg);\n        timer4init = true;\n    }\n}\n\nvoid TimerHAL::startLogTimer4IncrementalEncoder()\n{\n    if (timer4init == false)\n    {\n        timer4Initialize();\n    }\n\n    if (timer4started == false)\n    {\n        if (device_is_ready(timer4) == true)\n        {\n            timer_start(timer4);\n            timer4started = true;\n        }\n    }\n}\n\nuint32_t TimerHAL::getTimer4IncrementalEncoderValue()\n{\n    if (timer4started == true)\n    {\n        return timer_get_count(timer4);\n    }\n    else\n    {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"powerAPI/TimerHAL_8h/","title":"File TimerHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TimerHAL_8h/#classes","title":"Classes","text":"Type Name class TimerHAL Handles timer 4 for the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/TimerHAL.h</code></p>"},{"location":"powerAPI/TimerHAL_8h_source/","title":"File TimerHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; TimerHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TIMERHAL_H_\n#define TIMERHAL_H_\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// ARM lib\n#include &lt;arm_math.h&gt;\n\n// OwnTech API\n#include \"timer.h\"\n\n\n\n\nclass TimerHAL\n{\npublic:\n\n    void startLogTimer4IncrementalEncoder();\n\n    uint32_t getTimer4IncrementalEncoderValue();\n\n\n\nprivate:\n\n    void timer4Initialize();\n\n    // Variables\n    static bool timer4init;\n    static bool timer4started;\n\n\n};\n\n\n\n#endif // TIMERHAL_H_\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/","title":"File UartHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name char buf_req bool command_flag   = = false const struct device * uart_dev   = = DEVICE_DT_GET(DT_NODELABEL(usart1))"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void _uart_usart1_process_input (const struct device * dev, void * user_data)"},{"location":"powerAPI/UartHAL_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#variable-buf_req","title":"variable buf_req","text":"<pre><code>char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-command_flag","title":"variable command_flag","text":"<pre><code>bool command_flag;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#variable-uart_dev","title":"variable uart_dev","text":"<pre><code>const struct device* uart_dev;\n</code></pre>"},{"location":"powerAPI/UartHAL_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/UartHAL_8cpp/#function-_uart_usart1_process_input","title":"function _uart_usart1_process_input","text":"<pre><code>static void _uart_usart1_process_input (\n    const struct device * dev,\n    void * user_data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.cpp</code></p>"},{"location":"powerAPI/UartHAL_8cpp_source/","title":"File UartHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// STM 32 LL\n#include &lt;stm32_ll_lpuart.h&gt;\n\n// Zephyr\n#include &lt;zephyr/drivers/uart.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n// Current file header\n#include \"UartHAL.h\"\n\n\n// USART 1 defines\n\n#define CONFIG_OWNTECH_SERIAL_TX_BUF_SIZE 5\n#define CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE 5\n#define USART1_DEVICE DT_PROP(DT_NODELABEL(usart1), label)\n\nstatic const struct device* uart_dev = DEVICE_DT_GET(DT_NODELABEL(usart1));\nstatic char buf_req[CONFIG_OWNTECH_SERIAL_RX_BUF_SIZE];\nstatic bool command_flag = false;\n\n\n// USART 1 private functions\n\nstatic void _uart_usart1_process_input(const struct device *dev, void* user_data)\n{\n    uint8_t c;\n\n    if (!uart_irq_update(uart_dev)) {\n        printk(\"no data \\n\");\n        return;\n    }\n\n    while (uart_irq_rx_ready(uart_dev) &amp;&amp; command_flag == false) {\n        uart_fifo_read(uart_dev, &amp;c, 1);\n        printk(\"received %c \\n\",c);\n        buf_req[0] = c;\n        command_flag = true;\n    }\n}\n\n// USART 1 public functions\n\nvoid UartHAL::usart1Init()\n{\n    const struct uart_config usart1_config =\n    {\n        .baudrate  = 9600,\n        .parity    = UART_CFG_PARITY_NONE,\n        .stop_bits = UART_CFG_STOP_BITS_1,\n        .data_bits = UART_CFG_DATA_BITS_8,\n        .flow_ctrl = UART_CFG_FLOW_CTRL_NONE\n    };\n\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_configure(uart_dev, &amp;usart1_config);\n        uart_irq_callback_user_data_set(uart_dev, _uart_usart1_process_input, NULL);\n        uart_irq_rx_enable(uart_dev);\n    }\n}\n\nchar UartHAL::usart1ReadChar()\n{\n    if (command_flag){\n        command_flag = false;\n        return buf_req[0];\n    } else {\n        return 'x';     // returns an x to signal there is no command waiting to be treated\n    }\n}\n\nvoid UartHAL::usart1WriteChar(char data)\n{\n    if (device_is_ready(uart_dev) == true)\n    {\n        uart_poll_out(uart_dev,data);\n    }\n}\n\nvoid UartHAL::usart1SwapRxTx()\n{\n    LL_LPUART_Disable(LPUART1);\n    LL_LPUART_SetTXRXSwap(LPUART1, LL_LPUART_TXRX_SWAPPED);\n    LL_LPUART_Enable(LPUART1);\n}\n</code></pre>"},{"location":"powerAPI/UartHAL_8h/","title":"File UartHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/UartHAL_8h/#classes","title":"Classes","text":"Type Name class UartHAL Handles usart 1 for the SPIN board. <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/UartHAL.h</code></p>"},{"location":"powerAPI/UartHAL_8h_source/","title":"File UartHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; UartHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef UARTHAL_H_\n#define UARTHAL_H_\n\nclass UartHAL\n{\npublic:\n    void usart1Init();\n\n    char usart1ReadChar();\n\n    void usart1WriteChar(char data);\n\n    void usart1SwapRxTx();\n\n\n};\n\n\n\n#endif // UARTHAL_H_\n</code></pre>"},{"location":"powerAPI/VersionHAL_8cpp/","title":"File VersionHAL.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; VersionHAL.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/VersionHAL_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name SpinAPI spin"},{"location":"powerAPI/VersionHAL_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/VersionHAL_8cpp/#variable-spin","title":"variable spin","text":"<pre><code>SpinAPI spin;\n</code></pre> <p>Date:</p> <p>2023</p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/VersionHAL.cpp</code></p>"},{"location":"powerAPI/VersionHAL_8cpp_source/","title":"File VersionHAL.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; VersionHAL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Current file header\n#include \"SpinAPI.h\"\n#include \"VersionHAL.h\"\n\nSpinAPI spin;\n\n// Static class member\nboard_version_t VersionHAL::board_version = nucleo_G474RE;\n\n\nvoid VersionHAL::setBoardVersion(board_version_t hardware_version)\n{\n    VersionHAL::board_version = board_version;\n\n    if (hardware_version == O2_v_1_1_2 || hardware_version == O2_v_0_9)\n    {\n        spin.uart.usart1SwapRxTx();\n    }else if(hardware_version == SPIN_v_0_1){\n        spin.uart.usart1SwapRxTx();\n    }else if(hardware_version == SPIN_v_0_9 || hardware_version == TWIST_v_1_1_2){\n    }else if(hardware_version == SPIN_v_1_0){\n    }else if(hardware_version == nucleo_G474RE){\n    }\n\n}\n\nboard_version_t VersionHAL::getBoardVersion()\n{\n    return board_version;\n}\n</code></pre>"},{"location":"powerAPI/VersionHAL_8h/","title":"File VersionHAL.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; VersionHAL.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/VersionHAL_8h/#classes","title":"Classes","text":"Type Name class VersionHAL Handles the versioning for the spin board."},{"location":"powerAPI/VersionHAL_8h/#public-types","title":"Public Types","text":"Type Name enum board_version_t"},{"location":"powerAPI/VersionHAL_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/VersionHAL_8h/#enum-board_version_t","title":"enum board_version_t","text":"<pre><code>enum board_version_t {\n    nucleo_G474RE,\n    O2_v_0_9,\n    O2_v_1_1_2,\n    SPIN_v_0_1,\n    SPIN_v_0_9,\n    SPIN_v_1_0,\n    TWIST_v_1_1_2,\n    TWIST_v_1_1_3,\n    TWIST_v_1_1_4\n};\n</code></pre> <p>Hardware version. See https://gitlab.laas.fr/owntech/1leg/-/wikis/Releases for the list and specificities of versions. </p> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/VersionHAL.h</code></p>"},{"location":"powerAPI/VersionHAL_8h_source/","title":"File VersionHAL.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; VersionHAL.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef VERSIONHAL_H_\n#define VERSIONHAL_H_\n\n\n\n\ntypedef enum\n{\n    nucleo_G474RE,\n    O2_v_0_9,\n    O2_v_1_1_2,\n    SPIN_v_0_1,\n    SPIN_v_0_9,\n    SPIN_v_1_0,\n    TWIST_v_1_1_2,\n    TWIST_v_1_1_3,\n    TWIST_v_1_1_4\n} board_version_t;\n\n\n\nclass VersionHAL\n{\npublic:\n\n    void setBoardVersion(board_version_t board_version);\n\n\n    board_version_t getBoardVersion();\n\n\nprivate:\n\n    static board_version_t board_version;\n\n\n};\n\n\n\n#endif // VERSIONHAL_H_\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/","title":"File hardware_auto_configuration.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const struct device * cdc_acm_console   = = DEVICE_DT_GET(CDC_ACM_DEVICE) const struct device * dac2   = = DEVICE_DT_GET(DAC2_DEVICE)This file automatically performs some hardware configuration using Zephyr macros. Configuration done in this file is low-level peripheral configuration required for OwnTech board to operate, do not mess with it unless you are absolutely sure of what you're doing. This file does not contain any public function."},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions","title":"Public Functions","text":"Type Name K_WORK_DEFINE (reboot_bootloader_work, reboot_bootloader_task)  SYS_INIT (_vrefbuf_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_dac2_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEVICE)  SYS_INIT (_console_init, APPLICATION, 89)  SYS_INIT (_img_validation, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  SYS_INIT (_register_cdc_rate_callback, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY)  void _cdc_rate_callback (const struct device * dev, uint32_t rate)  void reboot_bootloader_task (struct k_work * work)"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name int _console_init ()  int _dac2_init ()  int _img_validation ()  int _register_cdc_rate_callback ()  int _vrefbuf_init ()"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-cdc_acm_console","title":"variable cdc_acm_console","text":"<pre><code>const struct device* cdc_acm_console;\n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#variable-dac2","title":"variable dac2","text":"<p>This file automatically performs some hardware configuration using Zephyr macros. Configuration done in this file is low-level peripheral configuration required for OwnTech board to operate, do not mess with it unless you are absolutely sure of what you're doing. This file does not contain any public function. <pre><code>const struct device* dac2;\n</code></pre></p> <p>Date:</p> <p>2024 </p> <p>Author:</p> <p>Cl\u00e9ment Foucher clement.foucher@laas.fr </p> <p>Author:</p> <p>Jean Alinei jean.alinei@laas.fr </p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-k_work_define","title":"function K_WORK_DEFINE","text":"<pre><code>K_WORK_DEFINE (\n    reboot_bootloader_work,\n    reboot_bootloader_task\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _vrefbuf_init,\n    PRE_KERNEL_1,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_1","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _dac2_init,\n    PRE_KERNEL_2,\n    CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_2","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _console_init,\n    APPLICATION,\n    89\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_3","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _img_validation,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-sys_init_4","title":"function SYS_INIT","text":"<pre><code>SYS_INIT (\n    _register_cdc_rate_callback,\n    APPLICATION,\n    CONFIG_APPLICATION_INIT_PRIORITY\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_cdc_rate_callback","title":"function _cdc_rate_callback","text":"<pre><code>void _cdc_rate_callback (\n    const struct device * dev,\n    uint32_t rate\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-reboot_bootloader_task","title":"function reboot_bootloader_task","text":"<pre><code>void reboot_bootloader_task (\n    struct k_work * work\n) \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_console_init","title":"function _console_init","text":"<pre><code>static int _console_init () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_dac2_init","title":"function _dac2_init","text":"<pre><code>static int _dac2_init () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_img_validation","title":"function _img_validation","text":"<pre><code>static int _img_validation () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_register_cdc_rate_callback","title":"function _register_cdc_rate_callback","text":"<pre><code>static int _register_cdc_rate_callback () \n</code></pre>"},{"location":"powerAPI/hardware__auto__configuration_8cpp/#function-_vrefbuf_init","title":"function _vrefbuf_init","text":"<pre><code>static int _vrefbuf_init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_spin_api/zephyr/src/hardware_auto_configuration.cpp</code></p>"},{"location":"powerAPI/hardware__auto__configuration_8cpp_source/","title":"File hardware_auto_configuration.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_spin_api &gt; zephyr &gt; src &gt; hardware_auto_configuration.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/console/console.h&gt;\n\n// STM32 LL\n#include &lt;stm32_ll_bus.h&gt;\n#include &lt;stm32_ll_system.h&gt;\n\n// Owntech driver\n#include \"dac.h\"\n\nstatic const struct device* dac2 = DEVICE_DT_GET(DAC2_DEVICE);\n\n// Functions to be run\n\nstatic int _vrefbuf_init()\n{\n    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);\n    LL_VREFBUF_SetVoltageScaling(LL_VREFBUF_VOLTAGE_SCALE0);\n    LL_VREFBUF_DisableHIZ();\n    LL_VREFBUF_Enable();\n\n    return 0;\n}\n\nstatic int _dac2_init()\n{\n    if (device_is_ready(dac2) == true)\n    {\n        dac_set_const_value(dac2, 1, 2048U);\n        dac_pin_configure(dac2, 1, dac_pin_external);\n        dac_start(dac2, 1);\n    }\n\n    return 0;\n}\n\nstatic int _console_init()\n{\n    console_init();\n\n    return 0;\n}\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/dfu/mcuboot.h&gt;\nstatic int _img_validation()\n{\n    if (boot_is_img_confirmed() == false)\n    {\n        int rc = boot_write_img_confirmed();\n        if (rc != 0)\n        {\n            printk(\"Failed to confirm image\");\n        }\n    }\n\n    return 0;\n}\n#endif // CONFIG_BOOTLOADER_MCUBOOT\n\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; defined(CONFIG_USB_CDC_ACM)\n#include &lt;zephyr/retention/bootmode.h&gt;\n#include &lt;zephyr/sys/reboot.h&gt;\nvoid reboot_bootloader_task(struct k_work* work)\n{\n    bootmode_set(BOOT_MODE_TYPE_BOOTLOADER);\n    sys_reboot(SYS_REBOOT_WARM);\n}\n\nK_WORK_DEFINE(reboot_bootloader_work, reboot_bootloader_task);\nvoid _cdc_rate_callback(const struct device* dev, uint32_t rate)\n{\n    if (rate == 1200)\n    {\n        k_work_submit(&amp;reboot_bootloader_work);\n    }\n}\n\n#include &lt;zephyr/drivers/uart/cdc_acm.h&gt;\n#define CDC_ACM_DEVICE DT_NODELABEL(cdc_acm_uart0)\nstatic const struct device* cdc_acm_console = DEVICE_DT_GET(CDC_ACM_DEVICE);\nstatic int _register_cdc_rate_callback()\n{\n    cdc_acm_dte_rate_callback_set(cdc_acm_console, _cdc_rate_callback);\n\n    return 0;\n}\n#endif // CONFIG_RETENTION_BOOT_MODE &amp;&amp; CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp; CONFIG_USB_CDC_ACM\n\n// Zephyr macros to automatically run above functions\n\nSYS_INIT(_vrefbuf_init,\n         PRE_KERNEL_1, // To be run in the first init phase\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\nSYS_INIT(_dac2_init,\n         PRE_KERNEL_2, // To be run in the second init phase (depends on DAC driver initialization)\n         CONFIG_KERNEL_INIT_PRIORITY_DEVICE\n        );\n\nSYS_INIT(_console_init,\n         APPLICATION,\n         89\n        );\n\n#ifdef CONFIG_BOOTLOADER_MCUBOOT\nSYS_INIT(_img_validation,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif // CONFIG_BOOTLOADER_MCUBOOT\n\n#if defined(CONFIG_RETENTION_BOOT_MODE) &amp;&amp; defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT) &amp;&amp; defined(CONFIG_USB_CDC_ACM)\nSYS_INIT(_register_cdc_rate_callback,\n         APPLICATION,\n         CONFIG_APPLICATION_INIT_PRIORITY\n        );\n#endif // CONFIG_RETENTION_BOOT_MODE &amp;&amp; CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT &amp;&amp; CONFIG_USB_CDC_ACM\n</code></pre>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/","title":"Dir docs/core/zephyr/modules/owntech_task_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api</p>"},{"location":"powerAPI/dir_a6ca33c2a6633efd563e2ff2336e2b96/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/</code></p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr</p>"},{"location":"powerAPI/dir_930c8fa1e893c2939a58a9ccd4e9adcb/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/</code></p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/","title":"Dir docs/core/zephyr/modules/owntech_task_api/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_2b522af08cf9fc57ee593ce08ec33342/#files","title":"Files","text":"Type Name file TaskAPI.cpp file TaskAPI.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/</code></p>"},{"location":"powerAPI/TaskAPI_8cpp/","title":"File TaskAPI.cpp","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8cpp/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.cpp</code></p>"},{"location":"powerAPI/TaskAPI_8cpp_source/","title":"File TaskAPI.cpp","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n// OwnTech Power API\n#include \"../src/uninterruptible_synchronous_task.hpp\"\n#include \"../src/asynchronous_tasks.hpp\"\n\n\n// Current class header\n#include \"TaskAPI.h\"\n\n\n// Static variables\n\nconst int TaskAPI::DEFAULT_PRIORITY = 5;\n\n\n// Public object to interact with the class\n\nTaskAPI task;\n\n\n// Public API\n\n// Non-interruptible control task\n\nint8_t TaskAPI::createCritical(task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source)\n{\n    scheduling_set_uninterruptible_synchronous_task_interrupt_source(int_source);\n    return scheduling_define_uninterruptible_synchronous_task(periodic_task, task_period_us);\n}\n\nvoid TaskAPI::startCritical(bool manage_data_acquisition)\n{\n    scheduling_start_uninterruptible_synchronous_task(manage_data_acquisition);\n}\n\nvoid TaskAPI::stopCritical()\n{\n    scheduling_stop_uninterruptible_synchronous_task();\n}\n\n\n// Asynchronous tasks\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\nint8_t TaskAPI::createBackground(task_function_t routine)\n{\n    return scheduling_define_asynchronous_task(routine);\n}\n\nvoid TaskAPI::startBackground(uint8_t task_number)\n{\n    scheduling_start_asynchronous_task(task_number);\n}\n\nvoid TaskAPI::stopBackground(uint8_t task_number)\n{\n    scheduling_stop_asynchronous_task(task_number);\n}\n\n// Suspend asynchronous tasks\n\nvoid TaskAPI::suspendBackgroundMs(uint32_t duration_ms)\n{\n    k_sleep(K_MSEC(duration_ms));\n}\n\nvoid TaskAPI::suspendBackgroundUs(uint32_t duration_us)\n{\n    k_sleep(K_USEC(duration_us));\n}\n\n#endif // CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/","title":"File TaskAPI.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/TaskAPI_8h/#classes","title":"Classes","text":"Type Name class TaskAPI"},{"location":"powerAPI/TaskAPI_8h/#public-types","title":"Public Types","text":"Type Name enum scheduling_interrupt_source_t typedef void(* task_function_t"},{"location":"powerAPI/TaskAPI_8h/#public-attributes","title":"Public Attributes","text":"Type Name TaskAPI task"},{"location":"powerAPI/TaskAPI_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#enum-scheduling_interrupt_source_t","title":"enum scheduling_interrupt_source_t","text":"<pre><code>enum scheduling_interrupt_source_t {\n    source_uninitialized,\n    source_hrtim,\n    source_tim6\n};\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/#typedef-task_function_t","title":"typedef task_function_t","text":"<pre><code>typedef void(* task_function_t) ();\n</code></pre>"},{"location":"powerAPI/TaskAPI_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"powerAPI/TaskAPI_8h/#variable-task","title":"variable task","text":"<pre><code>TaskAPI task;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_task_api/zephyr/public_api/TaskAPI.h</code></p>"},{"location":"powerAPI/TaskAPI_8h_source/","title":"File TaskAPI.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_task_api &gt; zephyr &gt; public_api &gt; TaskAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2022-2023 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TASKAPI_H_\n#define TASKAPI_H_\n\n\n// Stdlib\n#include &lt;stdint.h&gt;\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n\n\n// Public types\n\ntypedef void (*task_function_t)();\n\ntypedef enum { source_uninitialized, source_hrtim, source_tim6 } scheduling_interrupt_source_t;\n\n\n// Static class definition\n\nclass TaskAPI\n{\npublic:\n    int8_t createCritical(task_function_t periodic_task, uint32_t task_period_us, scheduling_interrupt_source_t int_source = source_hrtim);\n\n    void startCritical(bool manage_data_acquisition = true);\n\n    void stopCritical();\n\n\n#ifdef CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\n    int8_t createBackground(task_function_t routine);\n\n    void startBackground(uint8_t task_number);\n\n    void stopBackground(uint8_t task_number);\n\n    void suspendBackgroundMs(uint32_t duration_ms);\n\n    void suspendBackgroundUs(uint32_t duration_us);\n\n#endif // CONFIG_OWNTECH_TASK_ENABLE_ASYNCHRONOUS_TASKS\n\nprivate:\n    static const int DEFAULT_PRIORITY;\n\n};\n\n\n// Public object to interact with the class\n\nextern TaskAPI task;\n\n\n#endif // TASKAPI_H_\n</code></pre>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver</p>"},{"location":"powerAPI/dir_2bcefd02aa22d158a7fee7f57088a2fe/#directories","title":"Directories","text":"Type Name dir zephyr <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/</code></p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr</p>"},{"location":"powerAPI/dir_62a68ad86a1f2ceff5c536793b75d59b/#directories","title":"Directories","text":"Type Name dir public_api <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/</code></p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/","title":"Dir docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api</p>"},{"location":"powerAPI/dir_7b157175519ef7e5ecaa80a64fe5f6a3/#files","title":"Files","text":"Type Name file timer.h <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/</code></p>"},{"location":"powerAPI/timer_8h/","title":"File timer.h","text":"<p>FileList &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the source code of this file</p>"},{"location":"powerAPI/timer_8h/#classes","title":"Classes","text":"Type Name struct timer_config_t struct timer_driver_api"},{"location":"powerAPI/timer_8h/#public-types","title":"Public Types","text":"Type Name enum pin_mode_t typedef void(* timer_api_config typedef uint32_t(* timer_api_get_count typedef void(* timer_api_start typedef void(* timer_api_stop typedef void(* timer_callback_t"},{"location":"powerAPI/timer_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name void timer_config (const struct device * dev, const struct timer_config_t * config)  uint32_t timer_get_count (const struct device * dev)  void timer_start (const struct device * dev)  void timer_stop (const struct device * dev)"},{"location":"powerAPI/timer_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"powerAPI/timer_8h/#enum-pin_mode_t","title":"enum pin_mode_t","text":"<pre><code>enum pin_mode_t {\n    no_pull,\n    pull_up,\n    pull_down\n};\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_config","title":"typedef timer_api_config","text":"<pre><code>typedef void(* timer_api_config) (const struct device *dev, const struct timer_config_t *config);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_get_count","title":"typedef timer_api_get_count","text":"<pre><code>typedef uint32_t(* timer_api_get_count) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_start","title":"typedef timer_api_start","text":"<pre><code>typedef void(* timer_api_start) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_api_stop","title":"typedef timer_api_stop","text":"<pre><code>typedef void(* timer_api_stop) (const struct device *dev);\n</code></pre>"},{"location":"powerAPI/timer_8h/#typedef-timer_callback_t","title":"typedef timer_callback_t","text":"<pre><code>typedef void(* timer_callback_t) ();\n</code></pre>"},{"location":"powerAPI/timer_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"powerAPI/timer_8h/#function-timer_config","title":"function timer_config","text":"<pre><code>static inline void timer_config (\n    const struct device * dev,\n    const struct timer_config_t * config\n) \n</code></pre> <p>Configure the timer dev using given configuration structure config.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> <li><code>config</code> Configuration holding the timer configuration. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_get_count","title":"function timer_get_count","text":"<pre><code>static inline uint32_t timer_get_count (\n    const struct device * dev\n) \n</code></pre> <p>Get the current timer counter value.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>Returns:</p> <p>Current value of the timer internal counter. </p>"},{"location":"powerAPI/timer_8h/#function-timer_start","title":"function timer_start","text":"<pre><code>static inline void timer_start (\n    const struct device * dev\n) \n</code></pre> <p>Start the timer dev. If timer is configured to provide a perdiodic interrupt, it will also enable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul>"},{"location":"powerAPI/timer_8h/#function-timer_stop","title":"function timer_stop","text":"<pre><code>static inline void timer_stop (\n    const struct device * dev\n) \n</code></pre> <p>Stop the timer dev. If timer is configured to provide a perdiodic interrupt, it will also disable it.</p> <p>Parameters:</p> <ul> <li><code>dev</code> Zephyr device representing the timer. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/core/zephyr/modules/owntech_timer_driver/zephyr/public_api/timer.h</code></p>"},{"location":"powerAPI/timer_8h_source/","title":"File timer.h","text":"<p>File List &gt; core &gt; zephyr &gt; modules &gt; owntech_timer_driver &gt; zephyr &gt; public_api &gt; timer.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2021-2022 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGPL-2.1\n */\n\n#ifndef TIMER_H_\n#define TIMER_H_\n\n\n// Zephyr\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// Public devices names\n\n#define TIMER4_DEVICE DT_NODELABEL(timers4)\n#define TIMER6_DEVICE DT_NODELABEL(timers6)\n#define TIMER7_DEVICE DT_NODELABEL(timers7)\n\n\n// Configuration structure\n\ntypedef void (*timer_callback_t)();\n\ntypedef enum\n{\n    no_pull,\n    pull_up,\n    pull_down\n} pin_mode_t;\n\nstruct timer_config_t\n{\n    uint32_t         timer_enable_irq     : 1;\n    uint32_t         timer_enable_encoder : 1;\n    timer_callback_t timer_irq_callback;\n    uint32_t         timer_irq_t_usec;\n    pin_mode_t       timer_enc_pin_mode;\n};\n\n\n// API\n\ntypedef void     (*timer_api_config)   (const struct device* dev, const struct timer_config_t* config);\ntypedef void     (*timer_api_start)    (const struct device* dev);\ntypedef void     (*timer_api_stop)     (const struct device* dev);\ntypedef uint32_t (*timer_api_get_count)(const struct device* dev);\n\n__subsystem struct timer_driver_api\n{\n    timer_api_config    config;\n    timer_api_start     start;\n    timer_api_stop      stop;\n    timer_api_get_count get_count;\n};\n\n\nstatic inline void timer_config(const struct device* dev, const struct timer_config_t* config)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;config(dev, config);\n}\n\nstatic inline void timer_start(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;start(dev);\n}\n\nstatic inline void timer_stop(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    api-&gt;stop(dev);\n}\n\nstatic inline uint32_t timer_get_count(const struct device* dev)\n{\n    const struct timer_driver_api* api = (const struct timer_driver_api*)(dev-&gt;api);\n\n    return api-&gt;get_count(dev);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // TIMER_H_\n</code></pre>"},{"location":"powerAPI/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"powerAPI/classes/","title":"Class Index","text":""},{"location":"powerAPI/classes/#a","title":"a","text":"<ul> <li>adc_hrtim_conf_t</li> <li>AdcHAL</li> <li>AnalogCommunication</li> </ul>"},{"location":"powerAPI/classes/#c","title":"c","text":"<ul> <li>CanCommunication</li> <li>CommunicationAPI</li> <li>comp_usage_conf_t</li> <li>CompHAL</li> </ul>"},{"location":"powerAPI/classes/#d","title":"d","text":"<ul> <li>dac_driver_api</li> <li>dac_function_config_t</li> <li>DacHAL</li> <li>DataAPI</li> </ul>"},{"location":"powerAPI/classes/#g","title":"g","text":"<ul> <li>gpio_conf_t</li> <li>GpioHAL</li> </ul>"},{"location":"powerAPI/classes/#l","title":"l","text":"<ul> <li>LedHAL</li> </ul>"},{"location":"powerAPI/classes/#n","title":"n","text":"<ul> <li>NgndHAL</li> </ul>"},{"location":"powerAPI/classes/#p","title":"p","text":"<ul> <li>phase_shift_conf_t</li> <li>pwm_conf_t</li> <li>PwmHAL</li> </ul>"},{"location":"powerAPI/classes/#r","title":"r","text":"<ul> <li>Rs485Communication</li> </ul>"},{"location":"powerAPI/classes/#s","title":"s","text":"<ul> <li>safety</li> <li>SpinAPI</li> <li>switch_conv_conf_t</li> <li>SyncCommunication</li> </ul>"},{"location":"powerAPI/classes/#t","title":"t","text":"<ul> <li>TaskAPI</li> <li>timer_config_t</li> <li>timer_driver_api</li> <li>timer_hrtim_t</li> <li>TimerHAL</li> <li>TwistAPI</li> </ul>"},{"location":"powerAPI/classes/#u","title":"u","text":"<ul> <li>UartHAL</li> </ul>"},{"location":"powerAPI/classes/#v","title":"v","text":"<ul> <li>VersionHAL</li> </ul>"},{"location":"powerAPI/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AdcHAL Handles the ADC for the spin board. </li> <li>class AnalogCommunication </li> <li>class CanCommunication </li> <li>class CommunicationAPI </li> <li>class CompHAL Handles comparator 1 and 3 of the SPIN board. </li> <li>class DacHAL </li> <li>class DataAPI </li> <li>class GpioHAL </li> <li>class LedHAL </li> <li>class NgndHAL </li> <li>class PwmHAL Handles all pwm signals for the spin board. </li> <li>class Rs485Communication </li> <li>class SpinAPI Contains all the elements linked to peripherals of the spin board. </li> <li>class SyncCommunication </li> <li>class TaskAPI </li> <li>class TimerHAL Handles timer 4 for the SPIN board. </li> <li>class TwistAPI </li> <li>class UartHAL Handles usart 1 for the SPIN board. </li> <li>class VersionHAL Handles the versioning for the spin board. </li> <li>class safety </li> <li>struct adc_hrtim_conf_t Structure containing information to setup adc events, adc source links and adc triggers. </li> <li>struct comp_usage_conf_t Structure containing the status of the usage of comparators and their values. </li> <li>struct dac_driver_api </li> <li>struct dac_function_config_t </li> <li>struct gpio_conf_t Structure containing all the information of the gpio linked to a given timing unit. </li> <li>struct phase_shift_conf_t Structure containing all the data regarding phase shifting for a given timing unit. </li> <li>struct pwm_conf_t Structure containing all the data regarding the pwm of a given timing unit. </li> <li>struct switch_conv_conf_t Structure describing the switching convention of a given timing unit. </li> <li>struct timer_config_t </li> <li>struct timer_driver_api </li> <li>struct timer_hrtim_t Timinig unit configuration - aggregates all the structures. </li> </ul>"},{"location":"powerAPI/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"powerAPI/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"powerAPI/class_members/","title":"Class Members","text":""},{"location":"powerAPI/class_members/#a","title":"a","text":"<ul> <li>adcInitialized (AdcHAL)</li> <li>analog (CommunicationAPI)</li> <li>adc (SpinAPI)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#b","title":"b","text":"<ul> <li>board_version (VersionHAL)</li> </ul>"},{"location":"powerAPI/class_members/#c","title":"c","text":"<ul> <li>configureDiscontinuousMode (AdcHAL)</li> <li>configureTriggerSource (AdcHAL)</li> <li>can (CommunicationAPI)</li> <li>currentModeInit (DacHAL)</li> <li>channels_ranks (DataAPI)</li> <li>convert (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>comp (SpinAPI)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> <li>connectAllCapacitor (TwistAPI)</li> <li>connectLegCapacitor (TwistAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#d","title":"d","text":"<ul> <li>disableChannel (AdcHAL)</li> <li>dispatch_method (DataAPI)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>dac (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>disconnectAllCapacitor (TwistAPI)</li> <li>disconnectLegCapacitor (TwistAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>duty_cycle (pwm_conf_t)</li> <li>disableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_members/#e","title":"e","text":"<ul> <li>enableChannel (AdcHAL, DataAPI)</li> <li>enableDma (AdcHAL)</li> <li>enableCan (CanCommunication)</li> <li>enableAcquisition (DataAPI)</li> <li>enableShieldChannel (DataAPI)</li> <li>enableTwistDefaultChannels (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>external_trigger (pwm_conf_t)</li> <li>enableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_members/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#g","title":"g","text":"<ul> <li>getEnabledChannelsCount (AdcHAL)</li> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getDispatchMethod (DataAPI)</li> <li>getLatest (DataAPI)</li> <li>getRawValues (DataAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriod (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>gpio (SpinAPI)</li> <li>getTimer4IncrementalEncoderValue (TimerHAL)</li> <li>getBoardVersion (VersionHAL)</li> <li>getChannelError (safety)</li> <li>getChannelReaction (safety)</li> <li>getChannelThresholdMax (safety)</li> <li>getChannelThresholdMin (safety)</li> <li>getChannelWatch (safety)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#i","title":"i","text":"<ul> <li>initializeAllAdcs (AdcHAL)</li> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>is_started (DataAPI)</li> <li>initFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>initAllBoost (TwistAPI)</li> <li>initAllBuck (TwistAPI)</li> <li>initAllMode (TwistAPI)</li> <li>initLegBoost (TwistAPI)</li> <li>initLegBuck (TwistAPI)</li> <li>initLegMode (TwistAPI)</li> <li>init_shield (safety)</li> </ul>"},{"location":"powerAPI/class_members/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_members/#m","title":"m","text":"<ul> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#n","title":"n","text":"<ul> <li>ngnd (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_members/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#p","title":"p","text":"<ul> <li>peek (DataAPI)</li> <li>peekChannel (DataAPI)</li> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>period (pwm_conf_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>retrieveParametersFromMemory (DataAPI)</li> <li>retrieveStoredConversionType (DataAPI)</li> <li>retrieveStoredParameterValue (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>retrieveThreshold (safety)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#s","title":"s","text":"<ul> <li>startAllAdcs (AdcHAL)</li> <li>stopAllAdcs (AdcHAL)</li> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>sync (CommunicationAPI)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setDispatchMethod (DataAPI)</li> <li>setParameters (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>setTwistChannelsUserCalibrationFactors (DataAPI)</li> <li>start (DataAPI, dac_driver_api, timer_driver_api)</li> <li>started (DataAPI)</li> <li>storeParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setDeadTime (PwmHAL)</li> <li>setDutyCycle (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setPhaseShift (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogTimer4IncrementalEncoder (TimerHAL)</li> <li>setAllAdcDecim (TwistAPI)</li> <li>setAllDeadTime (TwistAPI)</li> <li>setAllDutyCycle (TwistAPI)</li> <li>setAllPhaseShift (TwistAPI)</li> <li>setAllSlopeCompensation (TwistAPI)</li> <li>setAllTriggerValue (TwistAPI)</li> <li>setLegAdcDecim (TwistAPI)</li> <li>setLegDeadTime (TwistAPI)</li> <li>setLegDutyCycle (TwistAPI)</li> <li>setLegPhaseShift (TwistAPI)</li> <li>setLegSlopeCompensation (TwistAPI)</li> <li>setLegTriggerValue (TwistAPI)</li> <li>setVersion (TwistAPI)</li> <li>spinNumberToTu (TwistAPI)</li> <li>startAll (TwistAPI)</li> <li>startLeg (TwistAPI)</li> <li>stopAll (TwistAPI)</li> <li>stopLeg (TwistAPI)</li> <li>setBoardVersion (VersionHAL)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>stop (dac_driver_api, timer_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>setChannelReaction (safety)</li> <li>setChannelThresholdMax (safety)</li> <li>setChannelThresholdMin (safety)</li> <li>setChannelWatch (safety)</li> <li>storeThreshold (safety)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_members/#t","title":"t","text":"<ul> <li>triggerSoftwareConversion (AdcHAL)</li> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL, NgndHAL)</li> <li>turnOn (LedHAL, NgndHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>timer (SpinAPI)</li> <li>timer4Initialize (TimerHAL)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>twist_init (TwistAPI)</li> <li>twist_version (TwistAPI)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_members/#u","title":"u","text":"<ul> <li>uart (SpinAPI)</li> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> <li>unsetChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_members/#v","title":"v","text":"<ul> <li>version (SpinAPI)</li> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_members/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/","title":"Class Member Functions","text":""},{"location":"powerAPI/class_member_functions/#c","title":"c","text":"<ul> <li>configureDiscontinuousMode (AdcHAL)</li> <li>configureTriggerSource (AdcHAL)</li> <li>currentModeInit (DacHAL)</li> <li>convert (DataAPI)</li> <li>configurePin (GpioHAL)</li> <li>configurePeriodEvnt (PwmHAL)</li> <li>configure (Rs485Communication)</li> <li>configureCustom (Rs485Communication)</li> <li>createBackground (TaskAPI)</li> <li>createCritical (TaskAPI)</li> <li>connectAllCapacitor (TwistAPI)</li> <li>connectLegCapacitor (TwistAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#d","title":"d","text":"<ul> <li>disableChannel (AdcHAL)</li> <li>disableAdcTrigger (PwmHAL)</li> <li>disablePeriodEvnt (PwmHAL)</li> <li>disconnectAllCapacitor (TwistAPI)</li> <li>disconnectLegCapacitor (TwistAPI)</li> <li>disableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#e","title":"e","text":"<ul> <li>enableChannel (AdcHAL, DataAPI)</li> <li>enableDma (AdcHAL)</li> <li>enableCan (CanCommunication)</li> <li>enableAcquisition (DataAPI)</li> <li>enableShieldChannel (DataAPI)</li> <li>enableTwistDefaultChannels (DataAPI)</li> <li>enableAdcTrigger (PwmHAL)</li> <li>enablePeriodEvnt (PwmHAL)</li> <li>enableSafetyApi (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#g","title":"g","text":"<ul> <li>getEnabledChannelsCount (AdcHAL)</li> <li>getAnalogCommValue (AnalogCommunication)</li> <li>getBroadcastPeriod (CanCommunication)</li> <li>getCanNodeAddr (CanCommunication)</li> <li>getControlPeriod (CanCommunication)</li> <li>getCtrlEnable (CanCommunication)</li> <li>getCtrlReference (CanCommunication)</li> <li>getChannelLatest (DataAPI)</li> <li>getChannelNumber (DataAPI)</li> <li>getChannelRank (DataAPI)</li> <li>getChannelRawValues (DataAPI)</li> <li>getDispatchMethod (DataAPI)</li> <li>getLatest (DataAPI)</li> <li>getRawValues (DataAPI)</li> <li>getGpioDevice (GpioHAL)</li> <li>getPinNumber (GpioHAL)</li> <li>getAdcEdgeTrigger (PwmHAL)</li> <li>getAdcTrigger (PwmHAL)</li> <li>getEev (PwmHAL)</li> <li>getMode (PwmHAL)</li> <li>getModulation (PwmHAL)</li> <li>getPeriod (PwmHAL)</li> <li>getPeriodEvntRep (PwmHAL)</li> <li>getPeriodUs (PwmHAL)</li> <li>getSwitchConvention (PwmHAL)</li> <li>getTimer4IncrementalEncoderValue (TimerHAL)</li> <li>getBoardVersion (VersionHAL)</li> <li>getChannelError (safety)</li> <li>getChannelReaction (safety)</li> <li>getChannelThresholdMax (safety)</li> <li>getChannelThresholdMin (safety)</li> <li>getChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#i","title":"i","text":"<ul> <li>initializeAllAdcs (AdcHAL)</li> <li>init (AnalogCommunication)</li> <li>initialize (CompHAL, LedHAL)</li> <li>initConstValue (DacHAL)</li> <li>initFrequency (PwmHAL)</li> <li>initUnit (PwmHAL)</li> <li>initMaster (SyncCommunication)</li> <li>initSlave (SyncCommunication)</li> <li>initAllBoost (TwistAPI)</li> <li>initAllBuck (TwistAPI)</li> <li>initAllMode (TwistAPI)</li> <li>initLegBoost (TwistAPI)</li> <li>initLegBuck (TwistAPI)</li> <li>initLegMode (TwistAPI)</li> <li>init_shield (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#p","title":"p","text":"<ul> <li>peek (DataAPI)</li> <li>peekChannel (DataAPI)</li> </ul>"},{"location":"powerAPI/class_member_functions/#r","title":"r","text":"<ul> <li>retrieveParametersFromMemory (DataAPI)</li> <li>retrieveStoredConversionType (DataAPI)</li> <li>retrieveStoredParameterValue (DataAPI)</li> <li>readPin (GpioHAL)</li> <li>resetPin (GpioHAL)</li> <li>retrieveThreshold (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#s","title":"s","text":"<ul> <li>startAllAdcs (AdcHAL)</li> <li>stopAllAdcs (AdcHAL)</li> <li>setAnalogCommValue (AnalogCommunication)</li> <li>setBroadcastPeriod (CanCommunication)</li> <li>setCanNodeAddr (CanCommunication)</li> <li>setControlPeriod (CanCommunication)</li> <li>setCtrlEnable (CanCommunication)</li> <li>setCtrlReference (CanCommunication)</li> <li>setConstValue (DacHAL)</li> <li>slopeCompensation (DacHAL)</li> <li>setDispatchMethod (DataAPI)</li> <li>setParameters (DataAPI)</li> <li>setRepetitionsBetweenDispatches (DataAPI)</li> <li>setTwistChannelsUserCalibrationFactors (DataAPI)</li> <li>start (DataAPI)</li> <li>started (DataAPI)</li> <li>storeParametersInMemory (DataAPI)</li> <li>setPin (GpioHAL)</li> <li>setAdcDecimation (PwmHAL)</li> <li>setAdcEdgeTrigger (PwmHAL)</li> <li>setAdcTrigger (PwmHAL)</li> <li>setAdcTriggerInstant (PwmHAL)</li> <li>setAdcTriggerPostScaler (PwmHAL)</li> <li>setDeadTime (PwmHAL)</li> <li>setDutyCycle (PwmHAL)</li> <li>setEev (PwmHAL)</li> <li>setFrequency (PwmHAL)</li> <li>setMode (PwmHAL)</li> <li>setModulation (PwmHAL)</li> <li>setPeriodEvntRep (PwmHAL)</li> <li>setPhaseShift (PwmHAL)</li> <li>setSwitchConvention (PwmHAL)</li> <li>startDualOutput (PwmHAL)</li> <li>startSingleOutput (PwmHAL)</li> <li>stopDualOutput (PwmHAL)</li> <li>stopSingleOutput (PwmHAL)</li> <li>startTransmission (Rs485Communication)</li> <li>startBackground (TaskAPI)</li> <li>startCritical (TaskAPI)</li> <li>stopBackground (TaskAPI)</li> <li>stopCritical (TaskAPI)</li> <li>suspendBackgroundMs (TaskAPI)</li> <li>suspendBackgroundUs (TaskAPI)</li> <li>startLogTimer4IncrementalEncoder (TimerHAL)</li> <li>setAllAdcDecim (TwistAPI)</li> <li>setAllDeadTime (TwistAPI)</li> <li>setAllDutyCycle (TwistAPI)</li> <li>setAllPhaseShift (TwistAPI)</li> <li>setAllSlopeCompensation (TwistAPI)</li> <li>setAllTriggerValue (TwistAPI)</li> <li>setLegAdcDecim (TwistAPI)</li> <li>setLegDeadTime (TwistAPI)</li> <li>setLegDutyCycle (TwistAPI)</li> <li>setLegPhaseShift (TwistAPI)</li> <li>setLegSlopeCompensation (TwistAPI)</li> <li>setLegTriggerValue (TwistAPI)</li> <li>setVersion (TwistAPI)</li> <li>spinNumberToTu (TwistAPI)</li> <li>startAll (TwistAPI)</li> <li>startLeg (TwistAPI)</li> <li>stopAll (TwistAPI)</li> <li>stopLeg (TwistAPI)</li> <li>setBoardVersion (VersionHAL)</li> <li>setChannelReaction (safety)</li> <li>setChannelThresholdMax (safety)</li> <li>setChannelThresholdMin (safety)</li> <li>setChannelWatch (safety)</li> <li>storeThreshold (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#t","title":"t","text":"<ul> <li>triggerSoftwareConversion (AdcHAL)</li> <li>triggerAcquisition (DataAPI)</li> <li>togglePin (GpioHAL)</li> <li>toggle (LedHAL)</li> <li>turnOff (LedHAL, NgndHAL)</li> <li>turnOn (LedHAL, NgndHAL)</li> <li>turnOffCommunication (Rs485Communication)</li> <li>turnOnCommunication (Rs485Communication)</li> <li>timer4Initialize (TimerHAL)</li> </ul>"},{"location":"powerAPI/class_member_functions/#u","title":"u","text":"<ul> <li>usart1Init (UartHAL)</li> <li>usart1ReadChar (UartHAL)</li> <li>usart1SwapRxTx (UartHAL)</li> <li>usart1WriteChar (UartHAL)</li> <li>unsetChannelWatch (safety)</li> </ul>"},{"location":"powerAPI/class_member_functions/#w","title":"w","text":"<ul> <li>writePin (GpioHAL)</li> </ul>"},{"location":"powerAPI/class_member_variables/","title":"Class Member Variables","text":""},{"location":"powerAPI/class_member_variables/#a","title":"a","text":"<ul> <li>adcInitialized (AdcHAL)</li> <li>analog (CommunicationAPI)</li> <li>adc (SpinAPI)</li> <li>adc_event (adc_hrtim_conf_t)</li> <li>adc_rollover (adc_hrtim_conf_t)</li> <li>adc_source (adc_hrtim_conf_t)</li> <li>adc_trigger (adc_hrtim_conf_t)</li> <li>adc_hrtim (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#b","title":"b","text":"<ul> <li>board_version (VersionHAL)</li> </ul>"},{"location":"powerAPI/class_member_variables/#c","title":"c","text":"<ul> <li>can (CommunicationAPI)</li> <li>channels_ranks (DataAPI)</li> <li>current_rank (DataAPI)</li> <li>comp (SpinAPI)</li> <li>cmp1 (comp_usage_conf_t)</li> <li>cmp1_value (comp_usage_conf_t)</li> <li>cmp2 (comp_usage_conf_t)</li> <li>cmp2_value (comp_usage_conf_t)</li> <li>cmp3 (comp_usage_conf_t)</li> <li>cmp3_value (comp_usage_conf_t)</li> <li>cmp4 (comp_usage_conf_t)</li> <li>cmp4_value (comp_usage_conf_t)</li> <li>compare_tu (phase_shift_conf_t)</li> <li>ckpsc (pwm_conf_t)</li> <li>convention (switch_conv_conf_t)</li> <li>config (timer_driver_api)</li> <li>comp_usage (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#d","title":"d","text":"<ul> <li>dispatch_method (DataAPI)</li> <li>dac (SpinAPI)</li> <li>DEFAULT_PRIORITY (TaskAPI)</li> <li>dac_function (dac_function_config_t)</li> <li>duty_cycle (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#e","title":"e","text":"<ul> <li>external_trigger (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#f","title":"f","text":"<ul> <li>fn_upd_reset (dac_driver_api)</li> <li>fn_upd_step (dac_driver_api)</li> <li>fall_dead_time (pwm_conf_t)</li> <li>frequency (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (SpinAPI)</li> <li>get_count (timer_driver_api)</li> <li>gpio_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#i","title":"i","text":"<ul> <li>is_started (DataAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#l","title":"l","text":"<ul> <li>ledInitialized (LedHAL)</li> <li>led (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#m","title":"m","text":"<ul> <li>modulation (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#n","title":"n","text":"<ul> <li>ngnd (SpinAPI)</li> </ul>"},{"location":"powerAPI/class_member_variables/#o","title":"o","text":"<ul> <li>OUT_H (gpio_conf_t)</li> <li>OUT_L (gpio_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#p","title":"p","text":"<ul> <li>pwm (SpinAPI)</li> <li>pinconfigure (dac_driver_api)</li> <li>polarity (dac_function_config_t)</li> <li>period (pwm_conf_t)</li> <li>pwm_mode (pwm_conf_t)</li> <li>pwm_tu (pwm_conf_t)</li> <li>phase_shift (timer_hrtim_t)</li> <li>pwm_conf (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#r","title":"r","text":"<ul> <li>rs485 (CommunicationAPI)</li> <li>repetition_count_between_dispatches (DataAPI)</li> <li>reset_data (dac_function_config_t)</li> <li>reset_trigger_source (dac_function_config_t)</li> <li>reset_trig (phase_shift_conf_t)</li> <li>rise_dead_time (pwm_conf_t)</li> <li>reset_H (switch_conv_conf_t)</li> <li>reset_L (switch_conv_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#s","title":"s","text":"<ul> <li>sync (CommunicationAPI)</li> <li>setconstvalue (dac_driver_api)</li> <li>setfunction (dac_driver_api)</li> <li>start (dac_driver_api, timer_driver_api)</li> <li>stop (dac_driver_api, timer_driver_api)</li> <li>step_data (dac_function_config_t)</li> <li>step_trigger_source (dac_function_config_t)</li> <li>switch_H (gpio_conf_t)</li> <li>switch_L (gpio_conf_t)</li> <li>set_H (switch_conv_conf_t)</li> <li>set_L (switch_conv_conf_t)</li> <li>switch_conv (timer_hrtim_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#t","title":"t","text":"<ul> <li>timer (SpinAPI)</li> <li>timer4init (TimerHAL)</li> <li>timer4started (TimerHAL)</li> <li>twist_init (TwistAPI)</li> <li>twist_version (TwistAPI)</li> <li>tu_gpio_CLK (gpio_conf_t)</li> <li>timer_enable_encoder (timer_config_t)</li> <li>timer_enable_irq (timer_config_t)</li> <li>timer_enc_pin_mode (timer_config_t)</li> <li>timer_irq_callback (timer_config_t)</li> <li>timer_irq_t_usec (timer_config_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#u","title":"u","text":"<ul> <li>uart (SpinAPI)</li> <li>unit (gpio_conf_t)</li> <li>unit_on (pwm_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_variables/#v","title":"v","text":"<ul> <li>version (SpinAPI)</li> <li>value (phase_shift_conf_t)</li> </ul>"},{"location":"powerAPI/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"powerAPI/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"powerAPI/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"powerAPI/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"powerAPI/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"powerAPI/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"powerAPI/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"powerAPI/functions/","title":"Functions","text":""},{"location":"powerAPI/functions/#a","title":"a","text":"<ul> <li>adc_add_channel (adc.c, adc.h)</li> <li>adc_configure_discontinuous_mode (adc.c, adc.h)</li> <li>adc_configure_trigger_source (adc.c, adc.h)</li> <li>adc_configure_use_dma (adc.c, adc.h)</li> <li>adc_get_enabled_channels_count (adc.c, adc.h)</li> <li>adc_remove_channel (adc.c, adc.h)</li> <li>adc_start (adc.c, adc.h)</li> <li>adc_stop (adc.c, adc.h)</li> <li>adc_trigger_software_conversion (adc.c, adc.h)</li> </ul>"},{"location":"powerAPI/functions/#c","title":"c","text":"<ul> <li>can_isotp_thread (thingset_isotp.cpp)</li> <li>CAN_MSGQ_DEFINE (thingset_pub_sub.cpp)</li> <li>can_pub_isr (thingset_pub_sub.cpp)</li> <li>can_pub_send (thingset_pub_sub.cpp)</li> <li>can_pubsub_thread (thingset_pub_sub.cpp)</li> <li>comparator1_init (comparator.c, comparator.h)</li> <li>comparator3_init (comparator.c, comparator.h)</li> </ul>"},{"location":"powerAPI/functions/#d","title":"d","text":"<ul> <li>dma_channel_init_rx (Rs485.cpp, Rs485.h)</li> <li>dma_channel_init_tx (Rs485.cpp, Rs485.h)</li> <li>dataObjectsUpdateMeasures (data_objects.cpp, data_objects.h)</li> <li>dac_function_update_reset (dac.h)</li> <li>dac_function_update_step (dac.h)</li> <li>dac_pin_configure (dac.h)</li> <li>dac_set_const_value (dac.h)</li> <li>dac_set_function (dac.h)</li> <li>dac_start (dac.h)</li> <li>dac_stop (dac.h)</li> <li>data_dispatch_do_full_dispatch (data_api_internal.h)</li> <li>DualDAC_init (hrtim.h)</li> </ul>"},{"location":"powerAPI/functions/#h","title":"h","text":"<ul> <li>hrtim_PeriodicEvent_GetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_SetRep (hrtim.h)</li> <li>hrtim_PeriodicEvent_configure (hrtim.h)</li> <li>hrtim_PeriodicEvent_dis (hrtim.h)</li> <li>hrtim_PeriodicEvent_en (hrtim.h)</li> <li>hrtim_adc_rollover_get (hrtim.h)</li> <li>hrtim_adc_rollover_set (hrtim.h)</li> <li>hrtim_adc_triger_get (hrtim.h)</li> <li>hrtim_adc_triger_set (hrtim.h)</li> <li>hrtim_adc_trigger_dis (hrtim.h)</li> <li>hrtim_adc_trigger_en (hrtim.h)</li> <li>hrtim_adc_trigger_set_postscaler (hrtim.h)</li> <li>hrtim_change_frequency (hrtim.h)</li> <li>hrtim_cmpl_pwm_out1 (hrtim.h)</li> <li>hrtim_cmpl_pwm_out2 (hrtim.h)</li> <li>hrtim_cnt_dis (hrtim.h)</li> <li>hrtim_cnt_en (hrtim.h)</li> <li>hrtim_dt_init (hrtim.h)</li> <li>hrtim_dt_set (hrtim.h)</li> <li>hrtim_duty_cycle_set (hrtim.h)</li> <li>hrtim_eev_get (hrtim.h)</li> <li>hrtim_eev_set (hrtim.h)</li> <li>hrtim_frequency_set (hrtim.h)</li> <li>hrtim_get_apb2_clock (hrtim.h)</li> <li>hrtim_get_modulation (hrtim.h)</li> <li>hrtim_get_status (hrtim.h)</li> <li>hrtim_get_switch_convention (hrtim.h)</li> <li>hrtim_init_default_all (hrtim.h)</li> <li>hrtim_master_cmp_set (hrtim.h)</li> <li>hrtim_out_dis (hrtim.h)</li> <li>hrtim_out_dis_single (hrtim.h)</li> <li>hrtim_out_en (hrtim.h)</li> <li>hrtim_out_en_single (hrtim.h)</li> <li>hrtim_period_Master_get (hrtim.h)</li> <li>hrtim_period_Master_get_us (hrtim.h)</li> <li>hrtim_period_get (hrtim.h)</li> <li>hrtim_period_get_us (hrtim.h)</li> <li>hrtim_phase_shift_set (hrtim.h)</li> <li>hrtim_pwm_mode_get (hrtim.h)</li> <li>hrtim_pwm_mode_set (hrtim.h)</li> <li>hrtim_rst_evt_dis (hrtim.h)</li> <li>hrtim_rst_evt_en (hrtim.h)</li> <li>hrtim_set_modulation (hrtim.h)</li> <li>hrtim_set_switch_convention (hrtim.h)</li> <li>hrtim_tu_cmp_set (hrtim.h)</li> <li>hrtim_tu_gpio_init (hrtim.h)</li> <li>hrtim_tu_init (hrtim.h)</li> </ul>"},{"location":"powerAPI/functions/#i","title":"i","text":"<ul> <li>init_DEmode (Rs485.cpp, Rs485.h)</li> <li>init_usrBaudrate (Rs485.cpp, Rs485.h)</li> <li>init_usrBuffer (Rs485.cpp, Rs485.h)</li> <li>init_usrDataSize (Rs485.cpp, Rs485.h)</li> <li>init_usrFunc (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#k","title":"k","text":"<ul> <li>K_THREAD_DEFINE (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>K_WORK_DEFINE (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#n","title":"n","text":"<ul> <li>nvs_storage_clear_all_stored_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_current_version (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_get_version_in_nvs (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_retrieve_data (nvs_storage.c, nvs_storage.h)</li> <li>nvs_storage_store_data (nvs_storage.c, nvs_storage.h)</li> <li>ngnd_set (ngnd.h)</li> </ul>"},{"location":"powerAPI/functions/#o","title":"o","text":"<ul> <li>oversamp_set (Rs485.cpp, Rs485.h)</li> </ul>"},{"location":"powerAPI/functions/#r","title":"r","text":"<ul> <li>reboot_bootloader_task (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#s","title":"s","text":"<ul> <li>serial_init (Rs485.cpp, Rs485.h)</li> <li>serial_start (Rs485.cpp, Rs485.h)</li> <li>serial_stop (Rs485.cpp, Rs485.h)</li> <li>serial_tx_on (Rs485.cpp, Rs485.h)</li> <li>send_complete_cb (thingset_isotp.cpp)</li> <li>send_ts_can_pub_message (thingset_pub_sub.cpp)</li> <li>safety_task (safety_internal.h)</li> <li>SYS_INIT (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/functions/#t","title":"t","text":"<ul> <li>ts (data_objects.cpp)</li> <li>timer_config (timer.h)</li> <li>timer_get_count (timer.h)</li> <li>timer_start (timer.h)</li> <li>timer_stop (timer.h)</li> </ul>"},{"location":"powerAPI/functions/#u","title":"u","text":"<ul> <li>update_ts_data_nodes (thingset_pub_sub.cpp)</li> </ul>"},{"location":"powerAPI/functions/#_","title":"_","text":"<ul> <li>_dma_callback_rx (Rs485.cpp)</li> <li>_dma_callback_tx (Rs485.cpp)</li> <li>_nvs_storage_init (nvs_storage.c)</li> <li>_nvs_storage_store_version (nvs_storage.c)</li> <li>_uart_usart1_process_input (UartHAL.cpp)</li> <li>_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_console_init (hardware_auto_configuration.cpp)</li> <li>_dac2_init (hardware_auto_configuration.cpp)</li> <li>_img_validation (hardware_auto_configuration.cpp)</li> <li>_register_cdc_rate_callback (hardware_auto_configuration.cpp)</li> <li>_vrefbuf_init (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"powerAPI/variables/","title":"Variables","text":""},{"location":"powerAPI/variables/#a","title":"a","text":"<ul> <li>adc_discontinuous_mode (adc.c)</li> <li>adc_trigger_sources (adc.c)</li> <li>adc_ev_src_t (adc.h)</li> <li>ADC_COUNT (DataAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#b","title":"b","text":"<ul> <li>broadcast_time (CanCommunication.cpp, thingset_pub_sub.cpp)</li> <li>baud (Rs485.cpp)</li> <li>buf_req (UartHAL.cpp)</li> <li>board_version_t (VersionHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#c","title":"c","text":"<ul> <li>communication (CommunicationAPI.cpp, CommunicationAPI.h)</li> <li>control_time (CanCommunication.cpp, thingset_pub_sub.cpp)</li> <li>can_node_addr (data_objects.cpp, data_objects.h, thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>ctrl_enable (data_objects.cpp, data_objects.h)</li> <li>can_dev (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>ctrl_filter (thingset_pub_sub.cpp)</li> <li>CHANNELS_PER_ADC (DataAPI.h)</li> <li>channel_t (DataAPI.h)</li> <li>current_storage_version (nvs_storage.c)</li> <li>command_flag (UartHAL.cpp)</li> <li>cdc_acm_console (hardware_auto_configuration.cpp)</li> </ul>"},{"location":"powerAPI/variables/#d","title":"d","text":"<ul> <li>dma1 (Rs485.cpp)</li> <li>dma_buffer_size (Rs485.cpp)</li> <li>dma_callbackRXfunc_t (Rs485.h)</li> <li>data_objects (data_objects.cpp)</li> <li>device_id (data_objects.cpp)</li> <li>device_type (data_objects.cpp)</li> <li>dac_api_fn_upd_reset (dac.h)</li> <li>dac_api_fn_upd_step (dac.h)</li> <li>dac_api_pinconfigure (dac.h)</li> <li>dac_api_setconstvalue (dac.h)</li> <li>dac_api_setfunction (dac.h)</li> <li>dac_api_start (dac.h)</li> <li>dac_api_stop (dac.h)</li> <li>dac_function_t (dac.h)</li> <li>dac_pin_config_t (dac.h)</li> <li>dac_polarity_t (dac.h)</li> <li>dac_trigger_t (dac.h)</li> <li>data (DataAPI.cpp, DataAPI.h)</li> <li>DATA_IS_MISSING (DataAPI.h)</li> <li>DATA_IS_OK (DataAPI.h)</li> <li>DATA_IS_OLD (DataAPI.h)</li> <li>DispatchMethod_t (DataAPI.h)</li> <li>dac1 (DacHAL.cpp)</li> <li>dac2 (DacHAL.cpp, hardware_auto_configuration.cpp)</li> <li>dac3 (DacHAL.cpp)</li> </ul>"},{"location":"powerAPI/variables/#e","title":"e","text":"<ul> <li>enable_dma (adc.c)</li> <li>enabled_channels (adc.c)</li> <li>enabled_channels_count (adc.c)</li> <li>evt (Rs485.cpp)</li> </ul>"},{"location":"powerAPI/variables/#f","title":"f","text":"<ul> <li>firmware_version (data_objects.cpp)</li> <li>fc_opts (thingset_isotp.cpp)</li> <li>fs (nvs_storage.c)</li> </ul>"},{"location":"powerAPI/variables/#g","title":"g","text":"<ul> <li>GPIO_A (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_B (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_C (GpioHAL.cpp, GpioHAL.h)</li> <li>GPIO_D (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#h","title":"h","text":"<ul> <li>hardware_version (data_objects.cpp)</li> <li>HRTIM_CHANNELS (hrtim_enum.h)</li> <li>hrtim_adc_edgetrigger_t (hrtim_enum.h)</li> <li>hrtim_adc_event_t (hrtim_enum.h)</li> <li>hrtim_adc_source_t (hrtim_enum.h)</li> <li>hrtim_adc_t (hrtim_enum.h)</li> <li>hrtim_adc_trigger_t (hrtim_enum.h)</li> <li>hrtim_callback_t (hrtim_enum.h)</li> <li>hrtim_cmp_t (hrtim_enum.h)</li> <li>hrtim_cnt_t (hrtim_enum.h)</li> <li>hrtim_comp_usage_t (hrtim_enum.h)</li> <li>hrtim_external_trigger_t (hrtim_enum.h)</li> <li>hrtim_gpio_clock_number_t (hrtim_enum.h)</li> <li>hrtim_out_t (hrtim_enum.h)</li> <li>hrtim_output_number_t (hrtim_enum.h)</li> <li>hrtim_output_reset_t (hrtim_enum.h)</li> <li>hrtim_output_set_t (hrtim_enum.h)</li> <li>hrtim_output_units_t (hrtim_enum.h)</li> <li>hrtim_pwm_mode_t (hrtim_enum.h)</li> <li>hrtim_reset_trig_t (hrtim_enum.h)</li> <li>hrtim_switch_convention_t (hrtim_enum.h)</li> <li>hrtim_tu_ON_OFF_t (hrtim_enum.h)</li> <li>hrtim_tu_number_t (hrtim_enum.h)</li> <li>hrtim_tu_t (hrtim_enum.h)</li> </ul>"},{"location":"powerAPI/variables/#i","title":"i","text":"<ul> <li>i1_low_value (data_objects.cpp)</li> <li>i2_low_value (data_objects.cpp)</li> <li>i_high_value (data_objects.cpp)</li> <li>initialized (nvs_storage.c)</li> <li>INPUT (GpioHAL.cpp, GpioHAL.h)</li> <li>INPUT_PULLUP (GpioHAL.cpp, GpioHAL.h)</li> <li>inverter_modulation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#l","title":"l","text":"<ul> <li>leg_t (TwistAPI.h)</li> <li>led_pin_spec (LedHAL.cpp)</li> <li>leg_operation_t (PwmHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#m","title":"m","text":"<ul> <li>manufacturer (data_objects.cpp)</li> </ul>"},{"location":"powerAPI/variables/#n","title":"n","text":"<ul> <li>NO_VALUE (DataAPI.h)</li> <li>nvs_category_t (nvs_storage.h)</li> <li>ngnd_switch (NgndHAL.cpp)</li> </ul>"},{"location":"powerAPI/variables/#o","title":"o","text":"<ul> <li>OUTPUT (GpioHAL.cpp, GpioHAL.h)</li> </ul>"},{"location":"powerAPI/variables/#p","title":"p","text":"<ul> <li>parameter_t (DataAPI.h)</li> <li>P0 (GpioHAL.h)</li> <li>P1 (GpioHAL.h)</li> <li>P10 (GpioHAL.h)</li> <li>P11 (GpioHAL.h)</li> <li>P12 (GpioHAL.h)</li> <li>P13 (GpioHAL.h)</li> <li>P14 (GpioHAL.h)</li> <li>P15 (GpioHAL.h)</li> <li>P2 (GpioHAL.h)</li> <li>P3 (GpioHAL.h)</li> <li>P4 (GpioHAL.h)</li> <li>P5 (GpioHAL.h)</li> <li>P6 (GpioHAL.h)</li> <li>P7 (GpioHAL.h)</li> <li>P8 (GpioHAL.h)</li> <li>P9 (GpioHAL.h)</li> <li>PA (GpioHAL.h)</li> <li>PB (GpioHAL.h)</li> <li>PC (GpioHAL.h)</li> <li>PD (GpioHAL.h)</li> <li>pin_t (GpioHAL.h)</li> <li>pin_mode_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#r","title":"r","text":"<ul> <li>rx_usart_val (Rs485.cpp)</li> <li>rs485_speed_t (Rs485Communication.h)</li> <li>reference_value (data_objects.cpp, data_objects.h)</li> <li>recv_ctx (thingset_isotp.cpp)</li> <li>rx_addr (thingset_isotp.cpp)</li> </ul>"},{"location":"powerAPI/variables/#s","title":"s","text":"<ul> <li>send_ctx (thingset_isotp.cpp)</li> <li>storage_version_in_nvs (nvs_storage.c)</li> <li>Safety (SafetyAPI.cpp, SafetyAPI.h)</li> <li>spin (SpinAPI.h, VersionHAL.cpp)</li> <li>scheduling_interrupt_source_t (TaskAPI.h)</li> </ul>"},{"location":"powerAPI/variables/#t","title":"t","text":"<ul> <li>tx_usart_val (Rs485.cpp)</li> <li>temp_value (data_objects.cpp)</li> <li>ts (thingset_isotp.cpp, thingset_pub_sub.cpp)</li> <li>tx_addr (thingset_isotp.cpp)</li> <li>tu_channel (hrtim.h)</li> <li>twist (TwistAPI.cpp, TwistAPI.h)</li> <li>twist_version_t (TwistAPI.h)</li> <li>timer4 (TimerHAL.cpp)</li> <li>task (TaskAPI.cpp, TaskAPI.h)</li> <li>task_function_t (TaskAPI.h)</li> <li>timer_api_config (timer.h)</li> <li>timer_api_get_count (timer.h)</li> <li>timer_api_start (timer.h)</li> <li>timer_api_stop (timer.h)</li> <li>timer_callback_t (timer.h)</li> </ul>"},{"location":"powerAPI/variables/#u","title":"u","text":"<ul> <li>uart_cfg (Rs485.cpp)</li> <li>uart_dev (Rs485.cpp, UartHAL.cpp)</li> <li>user_fnc (Rs485.cpp)</li> <li>usart_oversampling_t (Rs485.h)</li> </ul>"},{"location":"powerAPI/variables/#v","title":"v","text":"<ul> <li>v1_low_value (data_objects.cpp)</li> <li>v2_low_value (data_objects.cpp)</li> <li>v_high_value (data_objects.cpp)</li> </ul>"},{"location":"powerAPI/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"controlLibrary/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,... </li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class Pid Pid in a standard form taking into account saturation. </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class Pr </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RST discrete polynomial regulator taking into account saturations. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir controlLibrary <ul> <li>dir src <ul> <li>file controller.h </li> <li>file filters.h </li> <li>file fir.h </li> <li>file pid.h </li> <li>file pr.h </li> <li>file rst.h </li> <li>file transform.h </li> <li>file trigo.h </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"controlLibrary/classController/","title":"Class Controller","text":"<p>template &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;</p> <p>ClassList &gt; Controller</p> <p>Controller interface for various inherited class like pid, rst, pr,...More...</p> <ul> <li><code>#include &lt;controller.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classController/#public-functions","title":"Public Functions","text":"Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classController/#protected-attributes","title":"Protected Attributes","text":"Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classController/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Guillaume Arthaud. </p> <p>Template parameters:</p> <ul> <li><code>refs_T</code> type of the reference </li> <li><code>meas_T</code> type of the measure </li> <li><code>outputs_T</code> type of the output </li> <li><code>params_T</code> type of the parameter </li> </ul> <p>Parameters:</p> <ul> <li><code>parameters</code> structure including all parameters needs to make calculations.</li> </ul> <p>we assume that outputs_T has already an order relation implemented. </p>"},{"location":"controlLibrary/classController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classController/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Controller::calculate (\n    void\n) = 0\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p>"},{"location":"controlLibrary/classController/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<p>calculate a new command value according the argument values <pre><code>inline virtual outputs_T Controller::calculateWithReturn (\n    refs_T yref,\n    meas_T y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p>"},{"location":"controlLibrary/classController/#function-getoutput","title":"function getOutput","text":"<p>retrieve the last command value calculated. <pre><code>inline virtual outputs_T Controller::getOutput () \n</code></pre></p> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Controller::init (\n    params_T parameters\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p>"},{"location":"controlLibrary/classController/#function-reset","title":"function reset","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void Controller::reset (\n    void\n) = 0\n</code></pre></p>"},{"location":"controlLibrary/classController/#function-saturate","title":"function saturate","text":"<p>limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. <pre><code>inline virtual outputs_T Controller::saturate (\n    outputs_T u\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>u</code> should be a command value. </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classController/#function-setmeasurement","title":"function setMeasurement","text":"<p>capture a new measurement. <pre><code>inline virtual void Controller::setMeasurement (\n    meas_T measure\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>measure</code> </li> </ul>"},{"location":"controlLibrary/classController/#function-setreference","title":"function setReference","text":"<p>capture a new reference. <pre><code>inline virtual void Controller::setReference (\n    refs_T reference\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reference</code> </li> </ul>"},{"location":"controlLibrary/classController/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"controlLibrary/classController/#variable-_ts","title":"variable _Ts","text":"<pre><code>float32_t Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_Ts;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_lower_bound","title":"variable _lower_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_lower_bound;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_measure","title":"variable _measure","text":"<pre><code>meas_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_measure;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_output","title":"variable _output","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_output;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_reference","title":"variable _reference","text":"<pre><code>refs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_reference;\n</code></pre>"},{"location":"controlLibrary/classController/#variable-_upper_bound","title":"variable _upper_bound","text":"<pre><code>outputs_T Controller&lt; refs_T, meas_T, outputs_T, params_T &gt;::_upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/classFir/","title":"Class Fir","text":"<p>ClassList &gt; Fir</p> <p>a class to implement the Finite Impulse Response filter behaviour More...</p> <ul> <li><code>#include &lt;fir.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classFir/#public-functions","title":"Public Functions","text":"Type Name Fir ()  Fir (const uint8_t nc, const float32_t * coeffs)  uint8_t init (uint8_t nc, const float32_t * coeffs) method to initialize the Fir with its coefficients void reset ()  void setCoeff (uint8_t n, float32_t value)  float32_t update (float32_t new_data)  ~Fir ()"},{"location":"controlLibrary/classFir/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients</li> <li><code>*coeffs</code> pointer to array of coefficients </li> </ul>"},{"location":"controlLibrary/classFir/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classFir/#function-fir-12","title":"function Fir [1/2]","text":"<pre><code>Fir::Fir () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir-22","title":"function Fir [2/2]","text":"<pre><code>Fir::Fir (\n    const uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-init","title":"function init","text":"<p>method to initialize the Fir with its coefficients <pre><code>uint8_t Fir::init (\n    uint8_t nc,\n    const float32_t * coeffs\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>nc</code> number of coefficients </li> <li><code>coeffs</code> pointer to array of coefficients </li> </ul> <p>Returns:</p>"},{"location":"controlLibrary/classFir/#function-reset","title":"function reset","text":"<pre><code>void Fir::reset () \n</code></pre>"},{"location":"controlLibrary/classFir/#function-setcoeff","title":"function setCoeff","text":"<pre><code>void Fir::setCoeff (\n    uint8_t n,\n    float32_t value\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-update","title":"function update","text":"<pre><code>float32_t Fir::update (\n    float32_t new_data\n) \n</code></pre>"},{"location":"controlLibrary/classFir/#function-fir","title":"function ~Fir","text":"<pre><code>Fir::~Fir () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/","title":"Class LowPassFirstOrderFilter","text":"<p>ClassList &gt; LowPassFirstOrderFilter</p> <p>More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions","title":"Public Functions","text":"Type Name LowPassFirstOrderFilter (float32_t Ts, float32_t tau)  float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t tau)  void reset ()  void reset (float32_t value)"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-lowpassfirstorderfilter","title":"function LowPassFirstOrderFilter","text":"<pre><code>LowPassFirstOrderFilter::LowPassFirstOrderFilter (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t LowPassFirstOrderFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-init","title":"function init","text":"<pre><code>uint8_t LowPassFirstOrderFilter::init (\n    float32_t Ts,\n    float32_t tau\n) \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-12","title":"function reset [1/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset () \n</code></pre>"},{"location":"controlLibrary/classLowPassFirstOrderFilter/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void LowPassFirstOrderFilter::reset (\n    float32_t value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classNotchFilter/","title":"Class NotchFilter","text":"<p>ClassList &gt; NotchFilter</p>"},{"location":"controlLibrary/classNotchFilter/#public-functions","title":"Public Functions","text":"Type Name NotchFilter ()  NotchFilter (float32_t Ts, float32_t f0, float32_t bandwidth) its a band stop filter float32_t calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t f0, float32_t bandwidth) initialize the band stop filter parameters void reset ()"},{"location":"controlLibrary/classNotchFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-12","title":"function NotchFilter [1/2]","text":"<pre><code>inline NotchFilter::NotchFilter () \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-notchfilter-22","title":"function NotchFilter [2/2]","text":"<p>its a band stop filter <pre><code>NotchFilter::NotchFilter (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>float32_t NotchFilter::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classNotchFilter/#function-init","title":"function init","text":"<p>initialize the band stop filter parameters <pre><code>uint8_t NotchFilter::init (\n    float32_t Ts,\n    float32_t f0,\n    float32_t bandwidth\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time [s] </li> <li><code>f0</code> central frequency to stop in [Hz] </li> <li><code>bandwidth</code> frequency band [Hz] around f0 where gain &lt; -3dB </li> </ul>"},{"location":"controlLibrary/classNotchFilter/#function-reset","title":"function reset","text":"<pre><code>void NotchFilter::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPid/","title":"Class Pid","text":"<p>ClassList &gt; Pid</p> <p>Pid in a standard form taking into account saturation.More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPid/#public-functions","title":"Public Functions","text":"Type Name Pid ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (PidParams params) overrideinitialize the standard pid virtual void reset () overridereset internal states and the last command of the controller. void reset (float32_t output)"},{"location":"controlLibrary/classPid/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPid/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPid/#detailed-description","title":"Detailed Description","text":"<p>out = Kp * (error + 1 / Ti * error / s + 1 / (1 + Td / N * s) * Td * s * error )</p> <p>It uses backward euler integration method.</p> <p>Example of use:</p> <p>Pid mypid; PidParams params(Ts, Kp, Ti, Td, N, lower_bound, upper_bound); mypid.init(params); mypid.setMeasurement(y); mypid.setReference(yref); mypid.calculate(); mypid.getOutput(); </p>"},{"location":"controlLibrary/classPid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPid/#function-pid","title":"function Pid","text":"<pre><code>inline Pid::Pid () \n</code></pre>"},{"location":"controlLibrary/classPid/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void Pid::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPid/#function-init","title":"function init","text":"<p>initialize the standard pid <pre><code>virtual int8_t Pid::init (\n    PidParams params\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> is a PidParams structure with all the parameters of the Pid. </li> </ul> <p>Returns:</p> <p>0 if ok else -EINVAL </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPid/#function-reset-12","title":"function reset [1/2]","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void Pid::reset () override\n</code></pre></p> <p>Implements Controller::reset</p>"},{"location":"controlLibrary/classPid/#function-reset-22","title":"function reset [2/2]","text":"<pre><code>void Pid::reset (\n    float32_t output\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPidParams/","title":"Class PidParams","text":"<p>ClassList &gt; PidParams</p> <p>all parameters of a standard pid More...</p> <ul> <li><code>#include &lt;pid.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t N float32_t Td float32_t Ti float32_t Ts float32_t lower_bound float32_t upper_bound"},{"location":"controlLibrary/structPidParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Ti</code> integral time constant</li> <li><code>Td</code> derivative time constant</li> <li><code>N</code> derivative filter coefficient</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPidParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPidParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PidParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-n","title":"variable N","text":"<pre><code>float32_t PidParams::N;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-td","title":"variable Td","text":"<pre><code>float32_t PidParams::Td;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ti","title":"variable Ti","text":"<pre><code>float32_t PidParams::Ti;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PidParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PidParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPidParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PidParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/structPllDatas/","title":"Class PllDatas","text":"<p>ClassList &gt; PllDatas</p> <p>datas returned by pll calculations More...</p> <ul> <li><code>#include &lt;filters.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes","title":"Public Attributes","text":"Type Name float32_t angle float32_t error float32_t w"},{"location":"controlLibrary/structPllDatas/#detailed-description","title":"Detailed Description","text":"<p>Parameters:</p> <ul> <li><code>w</code> pulsation estimated of the tracked signal [rad/s]</li> <li><code>angle</code> of the tracked signal [rad] </li> </ul>"},{"location":"controlLibrary/structPllDatas/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPllDatas/#variable-angle","title":"variable angle","text":"<pre><code>float32_t PllDatas::angle;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-error","title":"variable error","text":"<pre><code>float32_t PllDatas::error;\n</code></pre>"},{"location":"controlLibrary/structPllDatas/#variable-w","title":"variable w","text":"<pre><code>float32_t PllDatas::w;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPllSinus/","title":"Class PllSinus","text":"<p>ClassList &gt; PllSinus</p>"},{"location":"controlLibrary/classPllSinus/#public-functions","title":"Public Functions","text":"Type Name PllSinus () a software phase lock loop on a sinusoidal signal PllSinus (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  PllDatas calculateWithReturn (float32_t signal)  uint8_t init (float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt)  void reset (float32_t f0)"},{"location":"controlLibrary/classPllSinus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPllSinus/#function-pllsinus-12","title":"function PllSinus [1/2]","text":"<p>a software phase lock loop on a sinusoidal signal <pre><code>inline PllSinus::PllSinus () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time in [s] </li> <li><code>amplitude</code> amplitude of the signal to track. </li> <li><code>f0</code> mean frequency of the signal to track </li> <li><code>rt</code> rise time of the loop in [s]. </li> </ul>"},{"location":"controlLibrary/classPllSinus/#function-pllsinus-22","title":"function PllSinus [2/2]","text":"<pre><code>PllSinus::PllSinus (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-calculatewithreturn","title":"function calculateWithReturn","text":"<pre><code>PllDatas PllSinus::calculateWithReturn (\n    float32_t signal\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-init","title":"function init","text":"<pre><code>uint8_t PllSinus::init (\n    float32_t Ts,\n    float32_t amplitude,\n    float32_t f0,\n    float32_t rt\n) \n</code></pre>"},{"location":"controlLibrary/classPllSinus/#function-reset","title":"function reset","text":"<pre><code>void PllSinus::reset (\n    float32_t f0\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/classPr/","title":"Class Pr","text":"<p>ClassList &gt; Pr</p> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classPr/#public-functions","title":"Public Functions","text":"Type Name Pr ()  virtual void calculate (void) calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . virtual int8_t init (PrParams parameters) initialize the controller. virtual void reset (void) calculate a new command value according the argument values"},{"location":"controlLibrary/classPr/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classPr/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classPr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classPr/#function-pr","title":"function Pr","text":"<pre><code>inline Pr::Pr () \n</code></pre>"},{"location":"controlLibrary/classPr/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>set_reference</code> method and a measuremnt fixed using<code>set_measurement</code> . <pre><code>virtual void Pr::calculate (\n    void\n) \n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classPr/#function-init","title":"function init","text":"<p>initialize the controller. <pre><code>virtual int8_t Pr::init (\n    PrParams parameters\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>parameters</code> </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL else. </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classPr/#function-reset","title":"function reset","text":"<p>calculate a new command value according the argument values <pre><code>virtual void Pr::reset (\n    void\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yrefs</code> reference </li> <li><code>y</code> measure </li> </ul> <p>Returns:</p> <p>new command value. </p> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/structPrParams/","title":"Class PrParams","text":"<p>ClassList &gt; PrParams</p> <p>all parameters to define the proportional resonant controller. More...</p> <ul> <li><code>#include &lt;pr.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Kp float32_t Kr float32_t Ts float32_t lower_bound float32_t phi_prime float32_t upper_bound float32_t w0"},{"location":"controlLibrary/structPrParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr</p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>Kp</code> proportional gain</li> <li><code>Kr</code> resonant gain</li> <li><code>w0</code> pulsation [rad/s]</li> <li><code>phi_prime</code> angle in rad to compensate delays</li> <li><code>lower_bound</code> min value of the output</li> <li><code>upper_bound</code> max value of the output </li> </ul>"},{"location":"controlLibrary/structPrParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structPrParams/#variable-kp","title":"variable Kp","text":"<pre><code>float32_t PrParams::Kp;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-kr","title":"variable Kr","text":"<pre><code>float32_t PrParams::Kr;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t PrParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t PrParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-phi_prime","title":"variable phi_prime","text":"<pre><code>float32_t PrParams::phi_prime;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t PrParams::upper_bound;\n</code></pre>"},{"location":"controlLibrary/structPrParams/#variable-w0","title":"variable w0","text":"<pre><code>float32_t PrParams::w0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/classRST/","title":"Class RST","text":"<p>ClassList &gt; RST</p> <p>discrete polynomial regulator taking into account saturations. More...</p> <ul> <li><code>#include &lt;rst.h&gt;</code></li> </ul> <p>Inherits the following classes: Controller</p>"},{"location":"controlLibrary/classRST/#public-functions","title":"Public Functions","text":"Type Name RST ()  virtual void calculate (void) overridecalculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual int8_t init (RstParams p) overrideinitialize the rst controller virtual void reset (void) overridereset internal states and the last command of the controller."},{"location":"controlLibrary/classRST/#public-functions-inherited-from-controller","title":"Public Functions inherited from Controller","text":"<p>See Controller</p> Type Name virtual void calculate (void) = 0calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . virtual outputs_T calculateWithReturn (refs_T yref, meas_T y) calculate a new command value according the argument values virtual outputs_T getOutput () retrieve the last command value calculated. virtual int8_t init (params_T parameters) = 0initialize the controller. virtual void reset (void) = 0reset internal states and the last command of the controller. virtual outputs_T saturate (outputs_T u) limit the argument <code>u</code> between<code>upper_bound</code> and<code>lower_bound</code> it is called by the<code>calculate</code> method. virtual void setMeasurement (meas_T measure) capture a new measurement. virtual void setReference (refs_T reference) capture a new reference."},{"location":"controlLibrary/classRST/#protected-attributes-inherited-from-controller","title":"Protected Attributes inherited from Controller","text":"<p>See Controller</p> Type Name float32_t _Ts outputs_T _lower_bound meas_T _measure outputs_T _output refs_T _reference outputs_T _upper_bound"},{"location":"controlLibrary/classRST/#detailed-description","title":"Detailed Description","text":"<p>It uses 3 Fir : * one on the measurements called R(), * one on the previous command, called S(), * and the last on the reference called T()</p> <p>It mainly allows to add some filtering action on reference or measurements. and sometimes to add some filtering poles which help stabilisation.</p> <p>some classical regulators can be implemented by its way like pid and pr. </p>"},{"location":"controlLibrary/classRST/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/classRST/#function-rst","title":"function RST","text":"<pre><code>inline RST::RST () \n</code></pre>"},{"location":"controlLibrary/classRST/#function-calculate","title":"function calculate","text":"<p>calculate a new command value according to a reference fixed using <code>setReference</code> method and a measuremnt fixed using<code>setMeasurement</code> . <pre><code>virtual void RST::calculate (\n    void\n) override\n</code></pre></p> <p>The new command value can be captured using the <code>get_output</code> method. </p> <p>Implements Controller::calculate</p>"},{"location":"controlLibrary/classRST/#function-init","title":"function init","text":"<p>initialize the rst controller <pre><code>virtual int8_t RST::init (\n    RstParams p\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> RstParams structure </li> </ul> <p>Returns:</p> <p>0 if ok -EINVAL if not </p> <p>Implements Controller::init</p>"},{"location":"controlLibrary/classRST/#function-reset","title":"function reset","text":"<p>reset internal states and the last command of the controller. <pre><code>virtual void RST::reset (\n    void\n) override\n</code></pre></p> <p>Implements Controller::reset</p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/structRstParams/","title":"Class RstParams","text":"<p>ClassList &gt; RstParams</p> <p>More...</p>"},{"location":"controlLibrary/structRstParams/#public-attributes","title":"Public Attributes","text":"Type Name float32_t Ts float32_t lower_bound uint8_t nr uint8_t ns uint8_t nt const float32_t * r const float32_t * s const float32_t * t float32_t upper_bound"},{"location":"controlLibrary/structRstParams/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>2024 </p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr Rst parameters </p> <p>Parameters:</p> <ul> <li><code>Ts</code> sample time</li> <li><code>nr</code> number of R coefficients</li> <li><code>r[]</code> array of R coefficients</li> <li><code>ns</code> number of S coefficients</li> <li><code>s[]</code> array of S coefficients</li> <li><code>nt</code> number of t coefficients</li> <li><code>t[]</code> array of T coefficients</li> <li><code>lower_bound</code> minimal value of output</li> <li><code>upper_bound</code> maximal value of output </li> </ul>"},{"location":"controlLibrary/structRstParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structRstParams/#variable-ts","title":"variable Ts","text":"<pre><code>float32_t RstParams::Ts;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>float32_t RstParams::lower_bound;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nr","title":"variable nr","text":"<pre><code>uint8_t RstParams::nr;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-ns","title":"variable ns","text":"<pre><code>uint8_t RstParams::ns;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-nt","title":"variable nt","text":"<pre><code>uint8_t RstParams::nt;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-r","title":"variable r","text":"<pre><code>const float32_t* RstParams::r;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-s","title":"variable s","text":"<pre><code>const float32_t* RstParams::s;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-t","title":"variable t","text":"<pre><code>const float32_t* RstParams::t;\n</code></pre>"},{"location":"controlLibrary/structRstParams/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>float32_t RstParams::upper_bound;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/classTransform/","title":"Class Transform","text":"<p>ClassList &gt; Transform</p> <p>static class to group methods helping translation between reference frames More...</p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/classTransform/#public-static-functions","title":"Public Static Functions","text":"Type Name clarke_t clarke (three_phase_t Xabc) transform a three_phase_t vector to aclarke_t vector. three_phase_t clarke_inverse (clarke_t Xabo) transform a clarke_t vector to athree_phase_t vector. clarke_t rotation_to_clarke (dqo_t Xdqo, float32_t theta) make a rotation which transform adqo_t vector to aclarke_t vector. dqo_t rotation_to_dqo (clarke_t Xabo, float32_t theta) make a - rotation which transform aclarke_t vector to adqo_t vector. dqo_t to_dqo (three_phase_t Xabc, float32_t theta) transform a three_phase_t vector to adqo_t vector. three_phase_t to_threephase (dqo_t Xdqo, float32_t theta) transform a dqo_t vector to athree_phase_t vector."},{"location":"controlLibrary/classTransform/#detailed-description","title":"Detailed Description","text":"<p>mainly 3 reference frames: * abc :three phase *  : clarke. * d, q, o : direct-quadrature. </p>"},{"location":"controlLibrary/classTransform/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"controlLibrary/classTransform/#function-clarke","title":"function clarke","text":"<p>transform a three_phase_t vector to aclarke_t vector. <pre><code>static clarke_t Transform::clarke (\n    three_phase_t Xabc\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-clarke_inverse","title":"function clarke_inverse","text":"<p>transform a clarke_t vector to athree_phase_t vector. <pre><code>static three_phase_t Transform::clarke_inverse (\n    clarke_t Xabo\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-rotation_to_clarke","title":"function rotation_to_clarke","text":"<p>make a rotation which transform adqo_t vector to aclarke_t vector. <pre><code>static clarke_t Transform::rotation_to_clarke (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-rotation_to_dqo","title":"function rotation_to_dqo","text":"<p>make a - rotation which transform aclarke_t vector to adqo_t vector. <pre><code>static dqo_t Transform::rotation_to_dqo (\n    clarke_t Xabo,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-to_dqo","title":"function to_dqo","text":"<p>transform a three_phase_t vector to adqo_t vector. <pre><code>static dqo_t Transform::to_dqo (\n    three_phase_t Xabc,\n    float32_t theta\n) \n</code></pre></p>"},{"location":"controlLibrary/classTransform/#function-to_threephase","title":"function to_threephase","text":"<p>transform a dqo_t vector to athree_phase_t vector. <pre><code>static three_phase_t Transform::to_threephase (\n    dqo_t Xdqo,\n    float32_t theta\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structclarke__t/","title":"Struct clarke_t","text":"<p>ClassList &gt; clarke_t</p> <p>to keep together \u03b1, \u03b2 and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structclarke__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t alpha float32_t beta float32_t o"},{"location":"controlLibrary/structclarke__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structclarke__t/#variable-alpha","title":"variable alpha","text":"<pre><code>float32_t clarke_t::alpha;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-beta","title":"variable beta","text":"<pre><code>float32_t clarke_t::beta;\n</code></pre>"},{"location":"controlLibrary/structclarke__t/#variable-o","title":"variable o","text":"<pre><code>float32_t clarke_t::o;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structdqo__t/","title":"Struct dqo_t","text":"<p>ClassList &gt; dqo_t</p> <p>to keep together d, q and o values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structdqo__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t d float32_t o float32_t q"},{"location":"controlLibrary/structdqo__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structdqo__t/#variable-d","title":"variable d","text":"<pre><code>float32_t dqo_t::d;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-o","title":"variable o","text":"<pre><code>float32_t dqo_t::o;\n</code></pre>"},{"location":"controlLibrary/structdqo__t/#variable-q","title":"variable q","text":"<pre><code>float32_t dqo_t::q;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/structthree__phase__t/","title":"Struct three_phase_t","text":"<p>ClassList &gt; three_phase_t</p> <p>to keep together a,b and c phase values. </p> <ul> <li><code>#include &lt;transform.h&gt;</code></li> </ul>"},{"location":"controlLibrary/structthree__phase__t/#public-attributes","title":"Public Attributes","text":"Type Name float32_t a float32_t b float32_t c"},{"location":"controlLibrary/structthree__phase__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/structthree__phase__t/#variable-a","title":"variable a","text":"<pre><code>float32_t three_phase_t::a;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-b","title":"variable b","text":"<pre><code>float32_t three_phase_t::b;\n</code></pre>"},{"location":"controlLibrary/structthree__phase__t/#variable-c","title":"variable c","text":"<pre><code>float32_t three_phase_t::c;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"controlLibrary/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir controlLibrary <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/","title":"Dir docs/controlLibrary","text":"<p>FileList &gt; controlLibrary</p>"},{"location":"controlLibrary/dir_78b365e62f248710669e9a6984210a4a/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/</code></p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/","title":"Dir docs/controlLibrary/src","text":"<p>FileList &gt; controlLibrary &gt; src</p>"},{"location":"controlLibrary/dir_0c7b11c8d6d0df41220cb8bbf1e252be/#files","title":"Files","text":"Type Name file controller.h file filters.h file fir.h file pid.h file pr.h file rst.h file transform.h file trigo.h <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/</code></p>"},{"location":"controlLibrary/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include &lt;zephyr/logging/log.h&gt;</code></li> </ul>"},{"location":"controlLibrary/controller_8h/#classes","title":"Classes","text":"Type Name class Controller &lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;Controller interface for various inherited class like pid, rst, pr,... <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/controller.h</code></p>"},{"location":"controlLibrary/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; controller.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include &lt;arm_math.h&gt;\n#ifndef CONTROLLER_H_\n#define CONTROLLER_H_\n#include &lt;zephyr/logging/log.h&gt;\n\ntemplate&lt;typename refs_T, typename meas_T, typename outputs_T, typename params_T&gt;\nclass Controller\n{\n    public:\n    virtual int8_t init(params_T parameters) = 0; //ref + mesure\n\n    virtual void reset(void) = 0;\n\n    virtual void calculate(void) = 0; \n    virtual outputs_T calculateWithReturn(refs_T yref, meas_T y) {\n        this-&gt;setReference(yref);\n        this-&gt;setMeasurement(y);\n        this-&gt;calculate();\n        return this-&gt;getOutput();\n    }\n\n    virtual void setReference(refs_T reference) {\n        _reference = reference;\n    }; \n\n    virtual void setMeasurement(meas_T measure) {\n        _measure = measure;\n    }; \n\n    virtual outputs_T getOutput() {\n        return _output;\n    }; \n\n    virtual outputs_T saturate(outputs_T u) {\n        if ( u &gt; _upper_bound) {\n            u = _upper_bound;\n        }\n        if (u &lt; _lower_bound) {\n            u = _lower_bound;\n        }\n        return u;\n    };\nprotected:\n    float32_t _Ts; // sample time\n    outputs_T _lower_bound;\n    outputs_T _upper_bound;\n    // template \n    refs_T _reference;\n    outputs_T _output;\n    meas_T _measure;\n\n};\n\n#endif /* !CONTROLLER_H_ */\n</code></pre>"},{"location":"controlLibrary/filters_8h/","title":"File filters.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"arm_math_types.h\"</code></li> <li><code>#include \"fir.h\"</code></li> <li><code>#include \"pid.h\"</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/filters_8h/#classes","title":"Classes","text":"Type Name class LowPassFirstOrderFilter class NotchFilter class PllDatas datas returned by pll calculations class PllSinus <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/filters.h</code></p>"},{"location":"controlLibrary/filters_8h_source/","title":"File filters.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; filters.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef FILTERS_H_\n#define FILTERS_H_\n#include \"arm_math_types.h\"\n#include \"fir.h\"\n#include \"pid.h\"\n#include \"trigo.h\" \n\nclass LowPassFirstOrderFilter {\npublic:\n    LowPassFirstOrderFilter(float32_t Ts, float32_t tau);\n    uint8_t init(float32_t Ts, float32_t tau);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\n    void reset(float32_t value);\nprivate:\n    float32_t _Ts;\n    float32_t _tau;\n    float32_t _a1;\n    float32_t _b1;\n\n    float32_t _previous_value;\n};\n\nclass NotchFilter {\npublic:\n    NotchFilter() {};\n    NotchFilter(float32_t Ts, float32_t f0, float32_t bandwidth);\n\n    uint8_t init(float32_t Ts, float32_t f0, float32_t bandwidth);\n    float32_t calculateWithReturn(float32_t signal);\n    void reset();\nprivate:\n    float32_t _Ts;\n    float32_t _f0;\n    float32_t _bandwidth;\n\n    Fir _B; // numerator of the filter\n    Fir _A; // denominator of the filter\n    float32_t _output;\n};\n\nstruct PllDatas {\n    float32_t w;\n    float32_t angle;\n    float32_t error;\n};\n\nclass PllSinus {\npublic:\n    PllSinus() {};\n    PllSinus(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    uint8_t init(float32_t Ts, float32_t amplitude, float32_t f0, float32_t rt);\n    PllDatas calculateWithReturn(float32_t signal);\n    void reset(float32_t f0);\n\nprivate:\n    float32_t _Ts;\n    float32_t _amplitude;\n    float32_t _f0;\n    float32_t _rt;\n\n    NotchFilter _notch;\n    Pid _pi;\n    float32_t _w;\n    float32_t _angle;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/fir_8h/","title":"File fir.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/fir_8h/#classes","title":"Classes","text":"Type Name class Fir a class to implement the Finite Impulse Response filter behaviour <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/fir.h</code></p>"},{"location":"controlLibrary/fir_8h_source/","title":"File fir.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; fir.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef FIR_H_\n#define FIR_H_\n#include &lt;arm_math.h&gt;\n\nclass Fir {\npublic:\n    Fir();\n    Fir(const uint8_t nc, const float32_t *coeffs);\n    uint8_t init(uint8_t nc, const float32_t *coeffs);\n    float32_t update(float32_t new_data);\n    void reset();\n    void setCoeff(uint8_t n, float32_t value);\n    ~Fir();\nprivate:\n    uint8_t nc;\n    float32_t *coeffs;\n    float32_t *datas;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pid_8h/","title":"File pid.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> </ul>"},{"location":"controlLibrary/pid_8h/#classes","title":"Classes","text":"Type Name class Pid Pid in a standard form taking into account saturation. class PidParams all parameters of a standard pid <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pid.h</code></p>"},{"location":"controlLibrary/pid_8h_source/","title":"File pid.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pid.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef PID_H_\n#define PID_H_\n#include \"controller.h\"\n\nstruct PidParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Ti;\n    float32_t Td;\n    float32_t N;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass Pid: public Controller &lt;float32_t, float32_t, float32_t, PidParams&gt; {\n\npublic:\n    Pid(){};\n\n    int8_t init(PidParams params) override; \n\n    void calculate(void) override;\n\n    void reset() override;\n\n    void reset(float32_t output);\n\nprivate:\n    float32_t _integral;\n    float32_t _Kp;\n    float32_t _Ti;\n    float32_t _Td;\n    float32_t _N;\n    float32_t _previous_f_deriv; // previous filtered derivative value\n    float32_t _previous_error;  // previous error\n\n    float32_t _inverse_Ts;\n    float32_t _inverse_Ti;\n    float32_t _inverse_Kp;\n    float32_t _b1_filter;\n    float32_t _a1_filter;\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/pr_8h/","title":"File pr.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/pr_8h/#classes","title":"Classes","text":"Type Name class Pr class PrParams all parameters to define the proportional resonant controller. <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/pr.h</code></p>"},{"location":"controlLibrary/pr_8h_source/","title":"File pr.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; pr.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include \"controller.h\"\n#include \"fir.h\"\n\nstruct PrParams {\n    float32_t Ts;\n    float32_t Kp;\n    float32_t Kr;\n    float32_t w0;\n    float32_t phi_prime;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\nclass Pr: public Controller &lt;float32_t, float32_t, float32_t, PrParams&gt; {\n\npublic:\n    Pr() {};\n\n    int8_t init(PrParams p);\n\n    void calculate(void);\n\n    void reset(void);\n\nprivate:\n    float32_t _Ts;\n    float32_t _Kp;\n    float32_t _Kr;\n    float32_t _inverse_Kr;\n    Fir _B; // numerator of the resonator\n    Fir _A; // denominator of the resonator\n    float32_t _resonant; // resonator output\n};\n</code></pre>"},{"location":"controlLibrary/rst_8h/","title":"File rst.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"fir.h\"</code></li> </ul>"},{"location":"controlLibrary/rst_8h/#classes","title":"Classes","text":"Type Name class RST discrete polynomial regulator taking into account saturations. class RstParams <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/rst.h</code></p>"},{"location":"controlLibrary/rst_8h_source/","title":"File rst.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; rst.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#ifndef RST_H_\n#define RST_H_\n#include \"controller.h\"\n#include \"fir.h\" \n\nstruct RstParams {\n    float32_t Ts;\n    uint8_t nr;\n    const float32_t *r;\n    uint8_t ns;\n    const float32_t *s;\n    uint8_t nt;\n    const float32_t *t;\n    float32_t lower_bound;\n    float32_t upper_bound;\n};\n\n\nclass RST: public Controller&lt;float32_t, float32_t, float32_t, RstParams&gt; {\npublic:\n    RST() {};\n\n    int8_t init(RstParams p) override;\n\n    void calculate(void) override;\n\n    using Controller&lt;float32_t, float32_t, float32_t, RstParams&gt;::calculate;\n\n    void reset(void) override;\n\nprivate:\n    Fir _R;\n    Fir _Sp;\n    Fir _T;\n    float32_t _inv_s0;\n};\n\n#endif\n</code></pre>"},{"location":"controlLibrary/transform_8h/","title":"File transform.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> <li><code>#include \"trigo.h\"</code></li> </ul>"},{"location":"controlLibrary/transform_8h/#classes","title":"Classes","text":"Type Name class Transform static class to group methods helping translation between reference frames struct clarke_t to keep together \u03b1, \u03b2 and o values. struct dqo_t to keep together d, q and o values. struct three_phase_t to keep together a,b and c phase values."},{"location":"controlLibrary/transform_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t SQRT3_DIV_2   = = 0.8660254F const float32_t SQRT3_INVERSE   = = 0.57735026F"},{"location":"controlLibrary/transform_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/transform_8h/#variable-sqrt3_div_2","title":"variable SQRT3_DIV_2","text":"<pre><code>const float32_t SQRT3_DIV_2;\n</code></pre>"},{"location":"controlLibrary/transform_8h/#variable-sqrt3_inverse","title":"variable SQRT3_INVERSE","text":"<pre><code>const float32_t SQRT3_INVERSE;\n</code></pre> <p>Date:</p> <p>2024</p> <p>Author:</p> <p>R\u00e9gis Ruelland regis.ruelland@laas.fr </p> <p>Author:</p> <p>Luiz Villa luiz.villa@laas.fr </p> <p>Author:</p> <p>Ayoub Farah Hassan ayoub.farah-hassan@laas.fr </p> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/transform.h</code></p>"},{"location":"controlLibrary/transform_8h_source/","title":"File transform.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; transform.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n#ifndef TRANSFORM_H_\n#define TRANSFORM_H_\n#include &lt;arm_math.h&gt;\n#include \"trigo.h\"\n\nconst float32_t SQRT3_INVERSE  = 0.57735026F;\nconst float32_t SQRT3_DIV_2    = 0.8660254F;\n\n\nstruct three_phase_t {\n    float32_t a;\n    float32_t b;\n    float32_t c;\n\n};\n\nstruct clarke_t {\n    float32_t alpha;\n    float32_t beta;\n    float32_t o;\n};\n\nstruct dqo_t {\n    float32_t d;\n    float32_t q;\n    float32_t o;\n};\n\nclass Transform\n{\npublic:\n    static dqo_t rotation_to_dqo(clarke_t Xabo, float32_t theta);\n    static clarke_t rotation_to_clarke(dqo_t Xdqo, float32_t theta);\n    static clarke_t clarke(three_phase_t Xabc);\n    static three_phase_t clarke_inverse(clarke_t Xabo);\n    static dqo_t to_dqo(three_phase_t Xabc, float32_t theta);\n    static three_phase_t to_threephase(dqo_t Xdqo, float32_t theta);\n};\n#endif\n</code></pre>"},{"location":"controlLibrary/trigo_8h/","title":"File trigo.h","text":"<p>FileList &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arm_math.h&gt;</code></li> </ul>"},{"location":"controlLibrary/trigo_8h/#public-attributes","title":"Public Attributes","text":"Type Name const float32_t INV_MODULO_RES const float32_t MODULO_RES const uint32_t MODULO_SIZE"},{"location":"controlLibrary/trigo_8h/#public-functions","title":"Public Functions","text":"Type Name float32_t ot_cos (float32_t x)  float32_t ot_modulo_2pi (float32_t theta)  float32_t ot_sin (float32_t x)"},{"location":"controlLibrary/trigo_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"controlLibrary/trigo_8h/#variable-inv_modulo_res","title":"variable INV_MODULO_RES","text":"<pre><code>const float32_t INV_MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_res","title":"variable MODULO_RES","text":"<pre><code>const float32_t MODULO_RES;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#variable-modulo_size","title":"variable MODULO_SIZE","text":"<pre><code>const uint32_t MODULO_SIZE;\n</code></pre>"},{"location":"controlLibrary/trigo_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"controlLibrary/trigo_8h/#function-ot_cos","title":"function ot_cos","text":"<pre><code>float32_t ot_cos (\n    float32_t x\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_modulo_2pi","title":"function ot_modulo_2pi","text":"<pre><code>float32_t ot_modulo_2pi (\n    float32_t theta\n) \n</code></pre>"},{"location":"controlLibrary/trigo_8h/#function-ot_sin","title":"function ot_sin","text":"<pre><code>float32_t ot_sin (\n    float32_t x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/controlLibrary/src/trigo.h</code></p>"},{"location":"controlLibrary/trigo_8h_source/","title":"File trigo.h","text":"<p>File List &gt; controlLibrary &gt; src &gt; trigo.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * Copyright (c) 2024 LAAS-CNRS\n *\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n *\n * SPDX-License-Identifier: LGLPV2.1\n */\n\n#include &lt;arm_math.h&gt;\nextern const uint32_t MODULO_SIZE;     \nextern const float32_t INV_MODULO_RES;\nextern const float32_t MODULO_RES; \n\n// TODO: use CORDIC ?\n#ifdef CORDIC \n#include \"stm32g4xx_ll_cordic.h\"\n#endif\n\n\nfloat32_t ot_sin(float32_t x);\nfloat32_t ot_cos(float32_t x);\nfloat32_t ot_modulo_2pi(float32_t theta);\n</code></pre>"},{"location":"controlLibrary/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"controlLibrary/classes/","title":"Class Index","text":""},{"location":"controlLibrary/classes/#c","title":"c","text":"<ul> <li>clarke_t</li> <li>Controller</li> </ul>"},{"location":"controlLibrary/classes/#d","title":"d","text":"<ul> <li>dqo_t</li> </ul>"},{"location":"controlLibrary/classes/#f","title":"f","text":"<ul> <li>Fir</li> </ul>"},{"location":"controlLibrary/classes/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter</li> </ul>"},{"location":"controlLibrary/classes/#n","title":"n","text":"<ul> <li>NotchFilter</li> </ul>"},{"location":"controlLibrary/classes/#p","title":"p","text":"<ul> <li>Pid</li> <li>PidParams</li> <li>PllDatas</li> <li>PllSinus</li> <li>Pr</li> <li>PrParams</li> </ul>"},{"location":"controlLibrary/classes/#r","title":"r","text":"<ul> <li>RST</li> <li>RstParams</li> </ul>"},{"location":"controlLibrary/classes/#t","title":"t","text":"<ul> <li>three_phase_t</li> <li>Transform</li> </ul>"},{"location":"controlLibrary/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class Controller Controller interface for various inherited class like pid, rst, pr,...</li> <li>class Fir a class to implement the Finite Impulse Response filter behaviour </li> <li>class LowPassFirstOrderFilter </li> <li>class NotchFilter </li> <li>class PidParams all parameters of a standard pid </li> <li>class PllDatas datas returned by pll calculations </li> <li>class PllSinus </li> <li>class PrParams all parameters to define the proportional resonant controller. </li> <li>class RstParams </li> <li>class Transform static class to group methods helping translation between reference frames </li> <li>struct clarke_t to keep together \u03b1, \u03b2 and o values. </li> <li>struct dqo_t to keep together d, q and o values. </li> <li>struct three_phase_t to keep together a,b and c phase values. </li> </ul>"},{"location":"controlLibrary/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"controlLibrary/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"controlLibrary/class_members/","title":"Class Members","text":""},{"location":"controlLibrary/class_members/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>coeffs (Fir)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_members/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_members/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_members/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_members/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>NotchFilter (NotchFilter)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_members/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>r (RstParams)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_members/#u","title":"u","text":"<ul> <li>update (Fir)</li> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_members/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_members/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_members/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/","title":"Class Member Functions","text":""},{"location":"controlLibrary/class_member_functions/#c","title":"c","text":"<ul> <li>calculate (Controller, Pid, Pr, RST)</li> <li>calculateWithReturn (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus)</li> <li>clarke (Transform)</li> <li>clarke_inverse (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#f","title":"f","text":"<ul> <li>Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#g","title":"g","text":"<ul> <li>getOutput (Controller)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#i","title":"i","text":"<ul> <li>init (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#l","title":"l","text":"<ul> <li>LowPassFirstOrderFilter (LowPassFirstOrderFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#n","title":"n","text":"<ul> <li>NotchFilter (NotchFilter)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#p","title":"p","text":"<ul> <li>Pid (Pid)</li> <li>PllSinus (PllSinus)</li> <li>Pr (Pr)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#r","title":"r","text":"<ul> <li>reset (Controller, Fir, LowPassFirstOrderFilter, NotchFilter, Pid, PllSinus, Pr, RST)</li> <li>RST (RST)</li> <li>rotation_to_clarke (Transform)</li> <li>rotation_to_dqo (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#s","title":"s","text":"<ul> <li>saturate (Controller)</li> <li>setMeasurement (Controller)</li> <li>setReference (Controller)</li> <li>setCoeff (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#t","title":"t","text":"<ul> <li>to_dqo (Transform)</li> <li>to_threephase (Transform)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#u","title":"u","text":"<ul> <li>update (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_functions/#_1","title":"~","text":"<ul> <li>~Fir (Fir)</li> </ul>"},{"location":"controlLibrary/class_member_variables/","title":"Class Member Variables","text":""},{"location":"controlLibrary/class_member_variables/#a","title":"a","text":"<ul> <li>angle (PllDatas)</li> <li>alpha (clarke_t)</li> <li>a (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#b","title":"b","text":"<ul> <li>beta (clarke_t)</li> <li>b (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#c","title":"c","text":"<ul> <li>coeffs (Fir)</li> <li>c (three_phase_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#d","title":"d","text":"<ul> <li>datas (Fir)</li> <li>d (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#e","title":"e","text":"<ul> <li>error (PllDatas)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#k","title":"k","text":"<ul> <li>Kp (PidParams, PrParams)</li> <li>Kr (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#l","title":"l","text":"<ul> <li>lower_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#n","title":"n","text":"<ul> <li>nc (Fir)</li> <li>N (PidParams)</li> <li>nr (RstParams)</li> <li>ns (RstParams)</li> <li>nt (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#o","title":"o","text":"<ul> <li>o (clarke_t, dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#p","title":"p","text":"<ul> <li>phi_prime (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#q","title":"q","text":"<ul> <li>q (dqo_t)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#r","title":"r","text":"<ul> <li>r (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#s","title":"s","text":"<ul> <li>s (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#t","title":"t","text":"<ul> <li>Td (PidParams)</li> <li>Ti (PidParams)</li> <li>Ts (PidParams, PrParams, RstParams)</li> <li>t (RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#u","title":"u","text":"<ul> <li>upper_bound (PidParams, PrParams, RstParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#w","title":"w","text":"<ul> <li>w (PllDatas)</li> <li>w0 (PrParams)</li> </ul>"},{"location":"controlLibrary/class_member_variables/#_","title":"_","text":"<ul> <li>_Ts (Controller, LowPassFirstOrderFilter, NotchFilter, PllSinus, Pr)</li> <li>_lower_bound (Controller)</li> <li>_measure (Controller)</li> <li>_output (Controller, NotchFilter)</li> <li>_reference (Controller)</li> <li>_upper_bound (Controller)</li> <li>_a1 (LowPassFirstOrderFilter)</li> <li>_b1 (LowPassFirstOrderFilter)</li> <li>_previous_value (LowPassFirstOrderFilter)</li> <li>_tau (LowPassFirstOrderFilter)</li> <li>_A (NotchFilter, Pr)</li> <li>_B (NotchFilter, Pr)</li> <li>_bandwidth (NotchFilter)</li> <li>_f0 (NotchFilter, PllSinus)</li> <li>_Kp (Pid, Pr)</li> <li>_N (Pid)</li> <li>_Td (Pid)</li> <li>_Ti (Pid)</li> <li>_a1_filter (Pid)</li> <li>_b1_filter (Pid)</li> <li>_integral (Pid)</li> <li>_inverse_Kp (Pid)</li> <li>_inverse_Ti (Pid)</li> <li>_inverse_Ts (Pid)</li> <li>_previous_error (Pid)</li> <li>_previous_f_deriv (Pid)</li> <li>_amplitude (PllSinus)</li> <li>_angle (PllSinus)</li> <li>_notch (PllSinus)</li> <li>_pi (PllSinus)</li> <li>_rt (PllSinus)</li> <li>_w (PllSinus)</li> <li>_Kr (Pr)</li> <li>_inverse_Kr (Pr)</li> <li>_resonant (Pr)</li> <li>_R (RST)</li> <li>_Sp (RST)</li> <li>_T (RST)</li> <li>_inv_s0 (RST)</li> </ul>"},{"location":"controlLibrary/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"controlLibrary/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"controlLibrary/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"controlLibrary/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"controlLibrary/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"controlLibrary/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"controlLibrary/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"controlLibrary/functions/","title":"Functions","text":""},{"location":"controlLibrary/functions/#o","title":"o","text":"<ul> <li>ot_cos (trigo.h)</li> <li>ot_modulo_2pi (trigo.h)</li> <li>ot_sin (trigo.h)</li> </ul>"},{"location":"controlLibrary/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"controlLibrary/variables/","title":"Variables","text":""},{"location":"controlLibrary/variables/#i","title":"i","text":"<ul> <li>INV_MODULO_RES (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#m","title":"m","text":"<ul> <li>MODULO_RES (trigo.h)</li> <li>MODULO_SIZE (trigo.h)</li> </ul>"},{"location":"controlLibrary/variables/#s","title":"s","text":"<ul> <li>SQRT3_DIV_2 (transform.h)</li> <li>SQRT3_INVERSE (transform.h)</li> </ul>"},{"location":"controlLibrary/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}